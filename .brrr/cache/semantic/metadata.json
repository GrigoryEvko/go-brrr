{
  "version": 2,
  "units": [
    {
      "name": "main",
      "qualified_name": "build.rs::main",
      "file": "build.rs",
      "line": 5,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn main() -> Result<(), Box<dyn std::error::Error>>",
      "docstring": "",
      "calls": [
        "cmd_diagnostics",
        "cmd_search",
        "cmd_imports",
        "cmd_dead",
        "cmd_tree"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:0",
      "dependencies": "",
      "code_preview": "fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Rerun build if proto files change\n    println!(\"cargo:rerun-if-changed=proto/tei.proto\");\n\n    // Compile the TEI proto file with tonic-build 0.12 API\n    tonic_build::configure()\n        .build_server(false) // Only need client stubs\n        .build_client(true)\n        .compile(&[\"proto/tei.proto\"], &[\"proto/\"])?;\n\n    Ok(())\n}\n",
      "semantic_tags": [
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 107
    },
    {
      "name": "(DFGInfo) backward_slice",
      "qualified_name": "src/dfg/types.rs::(DFGInfo) backward_slice",
      "file": "src/dfg/types.rs",
      "line": 49,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DFGInfo) backward_slice(&self, target_line: usize) -> Vec<usize>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn backward_slice(&self, target_line: usize) -> Vec<usize> {\n        let mut result = HashSet::new();\n        let mut frontier = VecDeque::new();\n        frontier.push_back(target_line);\n\n        while let Some(line) = frontier.pop_front() {\n            if result.insert(line) {\n                // Find all edges that flow into this line\n                for edge in &self.edges {\n                    if edge.to_line == line && !result.contains(&edge.from_line) {\n                        frontier.push_back(edge.from_line);\n                    }\n                }\n            }\n        }\n\n        let mut lines: Vec<_> = result.into_iter().collect();\n        lines.sort();\n        lines\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 139
    },
    {
      "name": "(DFGInfo) forward_slice",
      "qualified_name": "src/dfg/types.rs::(DFGInfo) forward_slice",
      "file": "src/dfg/types.rs",
      "line": 71,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DFGInfo) forward_slice(&self, source_line: usize) -> Vec<usize>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn forward_slice(&self, source_line: usize) -> Vec<usize> {\n        let mut result = HashSet::new();\n        let mut frontier = VecDeque::new();\n        frontier.push_back(source_line);\n\n        while let Some(line) = frontier.pop_front() {\n            if result.insert(line) {\n                // Find all edges that flow from this line\n                for edge in &self.edges {\n                    if edge.from_line == line && !result.contains(&edge.to_line) {\n                        frontier.push_back(edge.to_line);\n                    }\n                }\n            }\n        }\n\n        let mut lines: Vec<_> = result.into_iter().collect();\n        lines.sort();\n        lines\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 139
    },
    {
      "name": "(DFGInfo) variables",
      "qualified_name": "src/dfg/types.rs::(DFGInfo) variables",
      "file": "src/dfg/types.rs",
      "line": 93,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DFGInfo) variables(&self) -> Vec<&str>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn variables(&self) -> Vec<&str> {\n        let mut vars: Vec<_> = self.definitions.keys().map(|s| s.as_str()).collect();\n        vars.sort();\n        vars.dedup();\n        vars\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 52
    },
    {
      "name": "DataflowEdge",
      "qualified_name": "src/dfg/types.rs::DataflowEdge",
      "file": "src/dfg/types.rs",
      "line": 23,
      "language": "rust",
      "unit_type": "class",
      "signature": "class DataflowEdge",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct DataflowEdge {\n    /// Variable name\n    pub variable: String,\n    /// Source line (where data comes from)\n    pub from_line: usize,\n    /// Target line (where data flows to)\n    pub to_line: usize,\n    /// Kind of data flow\n    pub kind: DataflowKind,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 67
    },
    {
      "name": "DFGInfo",
      "qualified_name": "src/dfg/types.rs::DFGInfo",
      "file": "src/dfg/types.rs",
      "line": 36,
      "language": "rust",
      "unit_type": "class",
      "signature": "class DFGInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct DFGInfo {\n    /// Function name\n    pub function_name: String,\n    /// All data flow edges\n    pub edges: Vec<DataflowEdge>,\n    /// Where each variable is defined\n    pub definitions: HashMap<String, Vec<usize>>,\n    /// Where each variable is used\n    pub uses: HashMap<String, Vec<usize>>,\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 71
    },
    {
      "name": "code_structure",
      "qualified_name": "src/ast/structure.rs::code_structure",
      "file": "src/ast/structure.rs",
      "line": 39,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn code_structure(path: &str, lang_filter: Option<&str>, max_results: usize) -> Result<CodeStructure>",
      "docstring": "",
      "calls": [
        "extract_file"
      ],
      "called_by": [
        "test_function_summary_has_signature",
        "test_code_structure_typescript_only",
        "test_code_structure_python_only",
        "test_code_structure_all_languages",
        "test_code_structure_max_results"
      ],
      "cfg_summary": "complexity:7, blocks:17",
      "dfg_summary": "vars:44, def-use chains:33",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "pub fn code_structure(\n    path: &str,\n    lang_filter: Option<&str>,\n    max_results: usize,\n) -> Result<CodeStructure> {\n    let root_path = Path::new(path);\n    let registry = LanguageRegistry::global();\n\n    // Validate root path exists\n    if !root_path.exists() {\n        return Err(TldrError::Io(std::io::Error::new(\n            std::io::ErrorKind::NotFound,\n            format!(\"Path not found: {}\", path),\n        )));\n    }\n\n    // Collect all source files respecting .gitignore and .tldrignore\n    let files: Vec<_> = WalkBuilder::new(root_path)\n        .add_custom_ignore_filename(\".tldrignore\")\n        .hidden(true) // Skip hidden files by default\n        .build()\n        .filter_map(|entry| entry.ok())\n        .filter(|e| e.path().is_file())\n        .filter(|e| {\n            // Filter by language if specified\n            if let Some(lang_name) = lang_filter {\n                registry\n                    .detect_language(e.path())\n                    .map(|l| l.name() == lang_name)\n                    .unwrap_or(false)\n            } else {\n                // Include all supported languages\n                registry.detect_language(e.path()).is_some()\n            }\n        })\n        .collect();\n\n    let file_count = files.len();\n    debug!(\"Found {} source files to analyze\", file_count);\n\n    // Extract AST info from all files in parallel using rayon\n    // Store (relative_path, ModuleInfo) pairs\n    let results: Vec<(String, ModuleInfo)> = files\n        .par_iter()\n        .filter_map(|entry| {\n            let file_path = entry.path();\n            match AstExtractor::extract_file(file_path) {\n                Ok(module) => {\n                    // Compute relative path for cleaner output\n                    let rel_path = file_path\n                        .strip_prefix(root_path)\n                        .unwrap_or(file_path)\n                        .display()\n                        .to_string();\n                    Some((rel_path, module))\n                }\n                Err(e) => {\n                    // Log extraction failures but don't fail the whole operation\n                    warn!(\n                        file = %file_path.display(),\n                        error = %e,\n                        \"Failed to extract AST from file\"\n                    );\n                    None\n                }\n            }\n        })\n        .collect();\n\n    debug!(\n        \"Successfully extracted AST from {} of {} files\",\n        results.len(),\n        file_count\n    );\n\n    // Aggregate all functions and classes with relative paths\n    let mut functions = Vec::new();\n    let mut classes = Vec::new();\n\n    for (rel_path, module) in results {\n        // Collect top-level functions\n        for func in module.functions {\n            functions.push(FunctionSummary {\n                name: func.name.clone(),\n                file: rel_path.clone(),\n                line: func.line_number,\n                signature: func.signature(),\n            });\n        }\n\n        // Collect classes (structs, interfaces, etc.)\n        for class in module.classes {\n            classes.push(ClassSummary {\n                name: class.name,\n                file: rel_path.clone(),\n                line: class.line_number,\n                method_count: class.methods.len(),\n            });\n        }\n    }\n\n    // Apply result limit if specified (0 = unlimited)\n    if max_results > 0 {\n        functions.truncate(max_results);\n        classes.truncate(max_results);\n    }\n\n    Ok(CodeStructure {\n        path: path.to_string(),\n        file_count,\n        functions,\n        classes,\n    })\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "logging",
        "error_handling",
        "async_ops",
        "iteration",
        "config",
        "transform",
        "cache"
      ],
      "complexity": {
        "depth": 6,
        "branches": 7,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 716
    },
    {
      "name": "extract_file",
      "qualified_name": "src/ast/structure.rs::extract_file",
      "file": "src/ast/structure.rs",
      "line": 170,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_file(file_path: &str) -> Result<ModuleInfo>",
      "docstring": "",
      "calls": [
        "extract_file",
        "extract_module",
        "extract_file"
      ],
      "called_by": [
        "test_extract_typescript_functions",
        "test_extract_file_nonexistent",
        "test_unsupported_language",
        "test_decorated_python_function",
        "find_class"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:2",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "pub fn extract_file(file_path: &str) -> Result<ModuleInfo> {\n    let path = Path::new(file_path);\n    AstExtractor::extract_file(path)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 36
    },
    {
      "name": "create_test_project",
      "qualified_name": "src/ast/structure.rs::create_test_project",
      "file": "src/ast/structure.rs",
      "line": 182,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_test_project() -> TempDir",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [
        "test_code_structure_unlimited_results",
        "test_code_structure_relative_paths",
        "test_class_summary_has_method_count",
        "test_scan_config",
        "test_scan_language"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:9",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn create_test_project() -> TempDir {\n        let dir = TempDir::new().expect(\"Failed to create temp dir\");\n\n        // Create Python files\n        let py_content = r#\"\ndef hello(name: str) -> str:\n    \"\"\"Say hello to someone.\"\"\"\n    return f\"Hello, {name}!\"\n\nclass Greeter:\n    \"\"\"A greeting class.\"\"\"\n\n    def greet(self, name: str) -> str:\n        return hello(name)\n\"#;\n        fs::write(dir.path().join(\"main.py\"), py_content).unwrap();\n        fs::write(dir.path().join(\"utils.py\"), \"def helper(): pass\").unwrap();\n\n        // Create a subdirectory with more files\n        let sub_dir = dir.path().join(\"lib\");\n        fs::create_dir(&sub_dir).unwrap();\n        fs::write(sub_dir.join(\"core.py\"), \"def core_func(): pass\").unwrap();\n\n        // Create TypeScript file\n        let ts_content = r#\"\nfunction greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nclass Service {\n    process(): void {}\n}\n\"#;\n        fs::write(dir.path().join(\"app.ts\"), ts_content).unwrap();\n\n        dir\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 251
    },
    {
      "name": "test_code_structure_all_languages",
      "qualified_name": "src/ast/structure.rs::test_code_structure_all_languages",
      "file": "src/ast/structure.rs",
      "line": 221,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_code_structure_all_languages()",
      "docstring": "",
      "calls": [
        "code_structure",
        "create_test_project"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:4",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_code_structure_all_languages() {\n        let dir = create_test_project();\n        let result = code_structure(dir.path().to_str().unwrap(), None, 100).unwrap();\n\n        // Should find files from both Python and TypeScript\n        assert!(result.file_count >= 3);\n        assert!(!result.functions.is_empty());\n        assert!(!result.classes.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 81
    },
    {
      "name": "test_code_structure_python_only",
      "qualified_name": "src/ast/structure.rs::test_code_structure_python_only",
      "file": "src/ast/structure.rs",
      "line": 232,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_code_structure_python_only()",
      "docstring": "",
      "calls": [
        "code_structure",
        "create_test_project"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:7",
      "dfg_summary": "vars:11, def-use chains:4",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_code_structure_python_only() {\n        let dir = create_test_project();\n        let result = code_structure(dir.path().to_str().unwrap(), Some(\"python\"), 100).unwrap();\n\n        // Should only find Python files\n        assert!(result.file_count >= 3);\n\n        // All files should be .py\n        for func in &result.functions {\n            assert!(\n                func.file.ends_with(\".py\"),\n                \"Expected .py file: {}\",\n                func.file\n            );\n        }\n        for class in &result.classes {\n            assert!(\n                class.file.ends_with(\".py\"),\n                \"Expected .py file: {}\",\n                class.file\n            );\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 143
    },
    {
      "name": "test_code_structure_typescript_only",
      "qualified_name": "src/ast/structure.rs::test_code_structure_typescript_only",
      "file": "src/ast/structure.rs",
      "line": 257,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_code_structure_typescript_only()",
      "docstring": "",
      "calls": [
        "code_structure",
        "create_test_project"
      ],
      "called_by": [],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:10, def-use chains:3",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_code_structure_typescript_only() {\n        let dir = create_test_project();\n        let result = code_structure(dir.path().to_str().unwrap(), Some(\"typescript\"), 100).unwrap();\n\n        // Should find the TypeScript file\n        assert!(result.file_count >= 1);\n\n        // All files should be .ts\n        for func in &result.functions {\n            assert!(\n                func.file.ends_with(\".ts\"),\n                \"Expected .ts file: {}\",\n                func.file\n            );\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 108
    },
    {
      "name": "test_code_structure_max_results",
      "qualified_name": "src/ast/structure.rs::test_code_structure_max_results",
      "file": "src/ast/structure.rs",
      "line": 275,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_code_structure_max_results()",
      "docstring": "",
      "calls": [
        "code_structure",
        "create_test_project"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:3",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_code_structure_max_results() {\n        let dir = create_test_project();\n        let result = code_structure(dir.path().to_str().unwrap(), None, 2).unwrap();\n\n        // Should limit results\n        assert!(result.functions.len() <= 2);\n        assert!(result.classes.len() <= 2);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 68
    },
    {
      "name": "test_code_structure_unlimited_results",
      "qualified_name": "src/ast/structure.rs::test_code_structure_unlimited_results",
      "file": "src/ast/structure.rs",
      "line": 285,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_code_structure_unlimited_results()",
      "docstring": "",
      "calls": [
        "create_test_project",
        "code_structure"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:2",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_code_structure_unlimited_results() {\n        let dir = create_test_project();\n        let result = code_structure(dir.path().to_str().unwrap(), None, 0).unwrap();\n\n        // max_results=0 means unlimited - should return all\n        assert!(result.functions.len() > 2);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 65
    },
    {
      "name": "test_code_structure_relative_paths",
      "qualified_name": "src/ast/structure.rs::test_code_structure_relative_paths",
      "file": "src/ast/structure.rs",
      "line": 294,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_code_structure_relative_paths()",
      "docstring": "",
      "calls": [
        "create_test_project",
        "code_structure"
      ],
      "called_by": [],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:10, def-use chains:2",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_code_structure_relative_paths() {\n        let dir = create_test_project();\n        let result = code_structure(dir.path().to_str().unwrap(), Some(\"python\"), 100).unwrap();\n\n        // File paths should be relative, not absolute\n        for func in &result.functions {\n            assert!(\n                !func.file.starts_with('/') && !func.file.contains(\"tmp\"),\n                \"Expected relative path, got: {}\",\n                func.file\n            );\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 100
    },
    {
      "name": "test_code_structure_nested_directory",
      "qualified_name": "src/ast/structure.rs::test_code_structure_nested_directory",
      "file": "src/ast/structure.rs",
      "line": 309,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_code_structure_nested_directory()",
      "docstring": "",
      "calls": [
        "code_structure",
        "create_test_project"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:3",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_code_structure_nested_directory() {\n        let dir = create_test_project();\n        let result = code_structure(dir.path().to_str().unwrap(), Some(\"python\"), 100).unwrap();\n\n        // Should find function in nested lib/core.py\n        let has_nested = result.functions.iter().any(|f| f.file.contains(\"lib\"));\n        assert!(has_nested, \"Should find functions in nested directories\");\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 88
    },
    {
      "name": "test_code_structure_nonexistent_path",
      "qualified_name": "src/ast/structure.rs::test_code_structure_nonexistent_path",
      "file": "src/ast/structure.rs",
      "line": 319,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_code_structure_nonexistent_path()",
      "docstring": "",
      "calls": [
        "code_structure"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:1",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_code_structure_nonexistent_path() {\n        let result = code_structure(\"/nonexistent/path/that/does/not/exist\", None, 100);\n        assert!(result.is_err());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 44
    },
    {
      "name": "test_code_structure_empty_directory",
      "qualified_name": "src/ast/structure.rs::test_code_structure_empty_directory",
      "file": "src/ast/structure.rs",
      "line": 325,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_code_structure_empty_directory()",
      "docstring": "",
      "calls": [
        "code_structure"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:4",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_code_structure_empty_directory() {\n        let dir = TempDir::new().unwrap();\n        let result = code_structure(dir.path().to_str().unwrap(), None, 100).unwrap();\n\n        assert_eq!(result.file_count, 0);\n        assert!(result.functions.is_empty());\n        assert!(result.classes.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 72
    },
    {
      "name": "test_extract_file_python",
      "qualified_name": "src/ast/structure.rs::test_extract_file_python",
      "file": "src/ast/structure.rs",
      "line": 335,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_file_python()",
      "docstring": "",
      "calls": [
        "create_test_project",
        "extract_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:18, def-use chains:9",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_extract_file_python() {\n        let dir = create_test_project();\n        let file_path = dir.path().join(\"main.py\");\n        let result = extract_file(file_path.to_str().unwrap()).unwrap();\n\n        assert_eq!(result.language, \"python\");\n        assert!(!result.functions.is_empty());\n        assert!(!result.classes.is_empty());\n\n        // Check specific function\n        let hello = result.functions.iter().find(|f| f.name == \"hello\");\n        assert!(hello.is_some());\n        let hello = hello.unwrap();\n        assert_eq!(hello.return_type, Some(\"str\".to_string()));\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 127
    },
    {
      "name": "test_extract_file_nonexistent",
      "qualified_name": "src/ast/structure.rs::test_extract_file_nonexistent",
      "file": "src/ast/structure.rs",
      "line": 352,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_file_nonexistent()",
      "docstring": "",
      "calls": [
        "extract_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:1",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_extract_file_nonexistent() {\n        let result = extract_file(\"/nonexistent/file.py\");\n        assert!(result.is_err());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 30
    },
    {
      "name": "test_function_summary_has_signature",
      "qualified_name": "src/ast/structure.rs::test_function_summary_has_signature",
      "file": "src/ast/structure.rs",
      "line": 358,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_function_summary_has_signature()",
      "docstring": "",
      "calls": [
        "code_structure",
        "create_test_project"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:10, def-use chains:2",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_function_summary_has_signature() {\n        let dir = create_test_project();\n        let result = code_structure(dir.path().to_str().unwrap(), Some(\"python\"), 100).unwrap();\n\n        // All functions should have non-empty signatures\n        for func in &result.functions {\n            assert!(!func.signature.is_empty());\n            // Python signatures should contain 'def'\n            if func.file.ends_with(\".py\") {\n                assert!(\n                    func.signature.contains(\"def\"),\n                    \"Python sig: {}\",\n                    func.signature\n                );\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 117
    },
    {
      "name": "test_class_summary_has_method_count",
      "qualified_name": "src/ast/structure.rs::test_class_summary_has_method_count",
      "file": "src/ast/structure.rs",
      "line": 377,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_class_summary_has_method_count()",
      "docstring": "",
      "calls": [
        "create_test_project",
        "code_structure"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:4",
      "dependencies": "std::path, ignore, rayon::prelude, tracing, crate::ast::extractor",
      "code_preview": "    fn test_class_summary_has_method_count() {\n        let dir = create_test_project();\n        let result = code_structure(dir.path().to_str().unwrap(), Some(\"python\"), 100).unwrap();\n\n        // Find the Greeter class\n        let greeter = result.classes.iter().find(|c| c.name == \"Greeter\");\n        assert!(greeter.is_some());\n        assert!(greeter.unwrap().method_count >= 1);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 94
    },
    {
      "name": "extract",
      "qualified_name": "src/cfg/mod.rs::extract",
      "file": "src/cfg/mod.rs",
      "line": 57,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract(file: &str, function: &str) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "get_slice",
        "get_dfg",
        "cmd_dfg",
        "get_cfg",
        "get_forward_slice_result"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:1",
      "dependencies": "builder, render, types, types, builder",
      "code_preview": "pub fn extract(file: &str, function: &str) -> Result<CFGInfo> {\n    CfgBuilder::extract_from_file(file, function)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 33
    },
    {
      "name": "trait Language",
      "qualified_name": "src/lang/traits.rs::trait Language",
      "file": "src/lang/traits.rs",
      "line": 18,
      "language": "rust",
      "unit_type": "class",
      "signature": "class trait Language",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "pub trait Language: Send + Sync {\n    /// Language identifier (e.g., \"python\", \"typescript\").\n    fn name(&self) -> &'static str;\n\n    /// File extensions for this language (e.g., &[\".py\", \".pyi\"]).\n    fn extensions(&self) -> &[&'static str];\n\n    /// Get a configured tree-sitter parser for this language.\n    fn parser(&self) -> Result<Parser>;\n\n    /// Extract function information from an AST node.\n    fn extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>;\n\n    /// Extract class information from an AST node.\n    fn extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo>;\n\n    /// Extract all imports from a parsed tree.\n    fn extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo>;\n\n    /// Tree-sitter query pattern for function definitions.\n    fn function_query(&self) -> &'static str;\n\n    /// Tree-sitter query pattern for class definitions.\n    fn class_query(&self) -> &'static str;\n\n    /// Tree-sitter query pattern for call expressions.\n    fn call_query(&self) -> &'static str;\n\n    /// Build control flow graph for a function.\n    fn build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo>;\n\n    /// Build data flow graph for a function.\n    fn build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo>;\n}\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration",
        "config",
        "database"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 7
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 328
    },
    {
      "name": "name",
      "qualified_name": "src/lang/traits.rs::trait Language.name",
      "file": "src/lang/traits.rs",
      "line": 20,
      "language": "rust",
      "unit_type": "method",
      "signature": "fn name()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "    fn name(&self) -> &'static str;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 11
    },
    {
      "name": "extensions",
      "qualified_name": "src/lang/traits.rs::trait Language.extensions",
      "file": "src/lang/traits.rs",
      "line": 23,
      "language": "rust",
      "unit_type": "method",
      "signature": "fn extensions()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "    fn extensions(&self) -> &[&'static str];\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 13
    },
    {
      "name": "parser",
      "qualified_name": "src/lang/traits.rs::trait Language.parser",
      "file": "src/lang/traits.rs",
      "line": 26,
      "language": "rust",
      "unit_type": "method",
      "signature": "fn parser()",
      "docstring": "",
      "calls": [
        "new",
        "new"
      ],
      "called_by": [
        "parse_java",
        "parse_c",
        "parse_rust",
        "parse_go"
      ],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "    fn parser(&self) -> Result<Parser>;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 11
    },
    {
      "name": "extract_function",
      "qualified_name": "src/lang/traits.rs::trait Language.extract_function",
      "file": "src/lang/traits.rs",
      "line": 29,
      "language": "rust",
      "unit_type": "method",
      "signature": "fn extract_function()",
      "docstring": "",
      "calls": [
        "extract_constructor",
        "extract_param_list",
        "new",
        "get_doc_comment",
        "find_jsdoc"
      ],
      "called_by": [
        "test_extract_generic_function",
        "test_extract_method_with_params",
        "test_extract_simple_method",
        "test_extract_method",
        "Language.extract_class"
      ],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "    fn extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>;\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 23
    },
    {
      "name": "extract_class",
      "qualified_name": "src/lang/traits.rs::trait Language.extract_class",
      "file": "src/lang/traits.rs",
      "line": 32,
      "language": "rust",
      "unit_type": "method",
      "signature": "fn extract_class()",
      "docstring": "",
      "calls": [
        "node_text",
        "get_text",
        "extract_decorators",
        "extract_type_params",
        "extract_methods_from_body"
      ],
      "called_by": [
        "test_extract_enum",
        "test_extract_impl_block",
        "test_extract_class",
        "test_extract_class_with_inheritance",
        "test_extract_class"
      ],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "    fn extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo>;\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 22
    },
    {
      "name": "extract_imports",
      "qualified_name": "src/lang/traits.rs::trait Language.extract_imports",
      "file": "src/lang/traits.rs",
      "line": 35,
      "language": "rust",
      "unit_type": "method",
      "signature": "fn extract_imports()",
      "docstring": "",
      "calls": [
        "new",
        "extract_include",
        "extract_import",
        "extract_imports",
        "extract_single_import"
      ],
      "called_by": [
        "test_extract_imports",
        "test_extract_imports",
        "test_extract_imports",
        "extract_imports",
        "test_extract_python_imports"
      ],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "    fn extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo>;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 25
    },
    {
      "name": "function_query",
      "qualified_name": "src/lang/traits.rs::trait Language.function_query",
      "file": "src/lang/traits.rs",
      "line": 38,
      "language": "rust",
      "unit_type": "method",
      "signature": "fn function_query()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "    fn function_query(&self) -> &'static str;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 12
    },
    {
      "name": "class_query",
      "qualified_name": "src/lang/traits.rs::trait Language.class_query",
      "file": "src/lang/traits.rs",
      "line": 41,
      "language": "rust",
      "unit_type": "method",
      "signature": "fn class_query()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "    fn class_query(&self) -> &'static str;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 12
    },
    {
      "name": "call_query",
      "qualified_name": "src/lang/traits.rs::trait Language.call_query",
      "file": "src/lang/traits.rs",
      "line": 44,
      "language": "rust",
      "unit_type": "method",
      "signature": "fn call_query()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "    fn call_query(&self) -> &'static str;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 12
    },
    {
      "name": "build_cfg",
      "qualified_name": "src/lang/traits.rs::trait Language.build_cfg",
      "file": "src/lang/traits.rs",
      "line": 47,
      "language": "rust",
      "unit_type": "method",
      "signature": "fn build_cfg()",
      "docstring": "",
      "calls": [
        "child_by_field",
        "node_text",
        "new",
        "build_rust_cfg",
        "build"
      ],
      "called_by": [
        "test_build_cfg",
        "test_build_simple_cfg",
        "test_build_cfg",
        "test_build_simple_cfg",
        "test_build_cfg_with_if"
      ],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "    fn build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo>;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 23
    },
    {
      "name": "build_dfg",
      "qualified_name": "src/lang/traits.rs::trait Language.build_dfg",
      "file": "src/lang/traits.rs",
      "line": 50,
      "language": "rust",
      "unit_type": "method",
      "signature": "fn build_dfg()",
      "docstring": "",
      "calls": [
        "build",
        "build_c_dfg",
        "build",
        "child_by_field",
        "new"
      ],
      "called_by": [
        "test_build_dfg",
        "test_build_dfg",
        "test_build_dfg",
        "test_build_simple_dfg"
      ],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types, crate::error",
      "code_preview": "    fn build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo>;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 25
    },
    {
      "name": "bench_ast_extraction",
      "qualified_name": "benches/ast_parsing.rs::bench_ast_extraction",
      "file": "benches/ast_parsing.rs",
      "line": 9,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn bench_ast_extraction(c: &mut Criterion)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:1",
      "dependencies": "criterion, std::path",
      "code_preview": "fn bench_ast_extraction(c: &mut Criterion) {\n    // Placeholder benchmark - to be implemented with real test files\n    c.bench_function(\"ast_placeholder\", |b| b.iter(|| black_box(1 + 1)));\n}\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 48
    },
    {
      "name": "(LanguageRegistry) global",
      "qualified_name": "src/lang/registry.rs::(LanguageRegistry) global",
      "file": "src/lang/registry.rs",
      "line": 23,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (LanguageRegistry) global() -> &'static Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, std::sync, crate::lang::traits, crate::lang",
      "code_preview": "    pub fn global() -> &'static Self {\n        REGISTRY.get_or_init(Self::new)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 22
    },
    {
      "name": "(LanguageRegistry) new",
      "qualified_name": "src/lang/registry.rs::(LanguageRegistry) new",
      "file": "src/lang/registry.rs",
      "line": 28,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (LanguageRegistry) new() -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, std::sync, crate::lang::traits, crate::lang",
      "code_preview": "    fn new() -> Self {\n        let mut registry = Self {\n            by_name: HashMap::new(),\n            by_ext: HashMap::new(),\n        };\n\n        // Register all languages\n        registry.register(Box::new(python::Python));\n        registry.register(Box::new(typescript::TypeScript));\n        registry.register(Box::new(go::Go));\n        registry.register(Box::new(rust_lang::Rust));\n        registry.register(Box::new(java::Java));\n        registry.register(Box::new(c::C));\n\n        registry\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 109
    },
    {
      "name": "(LanguageRegistry) register",
      "qualified_name": "src/lang/registry.rs::(LanguageRegistry) register",
      "file": "src/lang/registry.rs",
      "line": 46,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (LanguageRegistry) register(&mut self, lang: BoxedLanguage)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, std::sync, crate::lang::traits, crate::lang",
      "code_preview": "    fn register(&mut self, lang: BoxedLanguage) {\n        let name = lang.name();\n        for ext in lang.extensions() {\n            self.by_ext.insert(*ext, name);\n        }\n        self.by_name.insert(name, lang);\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 52
    },
    {
      "name": "(LanguageRegistry) get_by_name",
      "qualified_name": "src/lang/registry.rs::(LanguageRegistry) get_by_name",
      "file": "src/lang/registry.rs",
      "line": 55,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (LanguageRegistry) get_by_name(&self, name: &str) -> Option<&dyn Language>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, std::sync, crate::lang::traits, crate::lang",
      "code_preview": "    pub fn get_by_name(&self, name: &str) -> Option<&dyn Language> {\n        self.by_name.get(name).map(|b| b.as_ref())\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 38
    },
    {
      "name": "(LanguageRegistry) get_by_extension",
      "qualified_name": "src/lang/registry.rs::(LanguageRegistry) get_by_extension",
      "file": "src/lang/registry.rs",
      "line": 60,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (LanguageRegistry) get_by_extension(&self, ext: &str) -> Option<&dyn Language>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, std::sync, crate::lang::traits, crate::lang",
      "code_preview": "    pub fn get_by_extension(&self, ext: &str) -> Option<&dyn Language> {\n        self.by_ext.get(ext).and_then(|name| self.get_by_name(name))\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 41
    },
    {
      "name": "(LanguageRegistry) detect_language",
      "qualified_name": "src/lang/registry.rs::(LanguageRegistry) detect_language",
      "file": "src/lang/registry.rs",
      "line": 65,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (LanguageRegistry) detect_language(&self, path: &Path) -> Option<&dyn Language>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, std::sync, crate::lang::traits, crate::lang",
      "code_preview": "    pub fn detect_language(&self, path: &Path) -> Option<&dyn Language> {\n        path.extension()\n            .and_then(|e| e.to_str())\n            .map(|ext| format!(\".{}\", ext))\n            .and_then(|ext| self.get_by_extension(&ext))\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 63
    },
    {
      "name": "(LanguageRegistry) supported_languages",
      "qualified_name": "src/lang/registry.rs::(LanguageRegistry) supported_languages",
      "file": "src/lang/registry.rs",
      "line": 73,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (LanguageRegistry) supported_languages(&self) -> Vec<&'static str>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, std::sync, crate::lang::traits, crate::lang",
      "code_preview": "    pub fn supported_languages(&self) -> Vec<&'static str> {\n        self.by_name.keys().copied().collect()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 29
    },
    {
      "name": "LanguageRegistry",
      "qualified_name": "src/lang/registry.rs::LanguageRegistry",
      "file": "src/lang/registry.rs",
      "line": 16,
      "language": "rust",
      "unit_type": "class",
      "signature": "class LanguageRegistry",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, std::path, std::sync, crate::lang::traits, crate::lang",
      "code_preview": "pub struct LanguageRegistry {\n    by_name: HashMap<&'static str, BoxedLanguage>,\n    by_ext: HashMap<&'static str, &'static str>,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 34
    },
    {
      "name": "(CfgBuilder) extract_from_file",
      "qualified_name": "src/cfg/builder.rs::(CfgBuilder) extract_from_file",
      "file": "src/cfg/builder.rs",
      "line": 51,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CfgBuilder) extract_from_file(file: &str, function: &str) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    pub fn extract_from_file(file: &str, function: &str) -> Result<CFGInfo> {\n        let path = Path::new(file);\n        let registry = LanguageRegistry::global();\n\n        // Detect language from file extension\n        let lang = registry.detect_language(path).ok_or_else(|| {\n            TldrError::UnsupportedLanguage(\n                path.extension()\n                    .and_then(|e| e.to_str())\n                    .unwrap_or(\"unknown\")\n                    .to_string(),\n            )\n        })?;\n\n        // Read and parse the file\n        let source = std::fs::read(path)?;\n        let mut parser = lang.parser()?;\n        let tree = parser\n            .parse(&source, None)\n            .ok_or_else(|| TldrError::Parse {\n                file: file.to_string(),\n                message: \"Failed to parse file\".to_string(),\n            })?;\n\n        // Build a query to find the function by name\n        let function_node = Self::find_function_node(&tree, &source, lang, function)?;\n\n        // Delegate to language-specific CFG builder\n        lang.build_cfg(function_node, &source)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 231
    },
    {
      "name": "(CfgBuilder) find_function_node",
      "qualified_name": "src/cfg/builder.rs::(CfgBuilder) find_function_node",
      "file": "src/cfg/builder.rs",
      "line": 86,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CfgBuilder) find_function_node(tree: &'a tree_sitter::Tree, source: &'a [u8], lang: &dyn crate::lang::Language, function_name: &str) -> Result<tree_sitter::Node<'a>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn find_function_node<'a>(\n        tree: &'a tree_sitter::Tree,\n        source: &'a [u8],\n        lang: &dyn crate::lang::Language,\n        function_name: &str,\n    ) -> Result<tree_sitter::Node<'a>> {\n        let query_str = lang.function_query();\n        let ts_lang = tree.language();\n\n        let query = Query::new(&ts_lang, query_str).map_err(|e| {\n            TldrError::TreeSitter(format!(\"Invalid function query for {}: {}\", lang.name(), e))\n        })?;\n\n        let mut cursor = QueryCursor::new();\n        let mut matches = cursor.matches(&query, tree.root_node(), source);\n\n        // Find capture indices\n        let function_capture_idx = query.capture_index_for_name(\"function\");\n        let name_capture_idx = query.capture_index_for_name(\"name\");\n\n        // Track seen ranges to avoid duplicates (e.g., decorated functions)\n        let mut seen_ranges: Vec<(usize, usize)> = Vec::new();\n\n        while let Some(match_) = matches.next() {\n            // Get the function node\n            let func_node = if let Some(idx) = function_capture_idx {\n                match_\n                    .captures\n                    .iter()\n                    .find(|c| c.index == idx)\n                    .map(|c| c.node)\n            } else {\n                match_.captures.first().map(|c| c.node)\n            };\n\n            // Get the name node\n            let name_node = if let Some(idx) = name_capture_idx {\n                match_\n                    .captures\n                    .iter()\n                    .find(|c| c.index == idx)\n                    .map(|c| c.node)\n            } else {\n                None\n            };\n\n            if let (Some(func_node), Some(name_node)) = (func_node, name_node) {\n                // Skip if we've already processed this range\n                let start = func_node.start_byte();\n                let end = func_node.end_byte();\n\n                let overlaps = seen_ranges\n                    .iter()\n                    .any(|(s, e)| (start <= *s && end >= *e) || (*s <= start && *e >= end));\n\n                if overlaps {\n                    continue;\n                }\n                seen_ranges.push((start, end));\n\n                // Check if name matches\n                let name =\n                    std::str::from_utf8(&source[name_node.start_byte()..name_node.end_byte()])\n                        .unwrap_or(\"\");\n\n                if name == function_name {\n                    // For decorated functions, we need to find the inner function_definition\n                    return Ok(Self::unwrap_decorated_function(func_node));\n                }\n            }\n        }\n\n        // Function not found - search in class methods\n        Self::find_method_node(tree, source, lang, function_name)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 6,
        "branches": 9,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 573
    },
    {
      "name": "(CfgBuilder) unwrap_decorated_function",
      "qualified_name": "src/cfg/builder.rs::(CfgBuilder) unwrap_decorated_function",
      "file": "src/cfg/builder.rs",
      "line": 166,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CfgBuilder) unwrap_decorated_function(node: tree_sitter::Node) -> tree_sitter::Node",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn unwrap_decorated_function(node: tree_sitter::Node) -> tree_sitter::Node {\n        if node.kind() == \"decorated_definition\" {\n            // Find the function_definition inside\n            let mut cursor = node.walk();\n            for child in node.children(&mut cursor) {\n                if child.kind() == \"function_definition\" {\n                    return child;\n                }\n            }\n        }\n        node\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 86
    },
    {
      "name": "(CfgBuilder) find_method_node",
      "qualified_name": "src/cfg/builder.rs::(CfgBuilder) find_method_node",
      "file": "src/cfg/builder.rs",
      "line": 180,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CfgBuilder) find_method_node(tree: &'a tree_sitter::Tree, source: &'a [u8], lang: &dyn crate::lang::Language, method_name: &str) -> Result<tree_sitter::Node<'a>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn find_method_node<'a>(\n        tree: &'a tree_sitter::Tree,\n        source: &'a [u8],\n        lang: &dyn crate::lang::Language,\n        method_name: &str,\n    ) -> Result<tree_sitter::Node<'a>> {\n        let class_query_str = lang.class_query();\n        let ts_lang = tree.language();\n\n        let query = Query::new(&ts_lang, class_query_str).map_err(|e| {\n            TldrError::TreeSitter(format!(\"Invalid class query for {}: {}\", lang.name(), e))\n        })?;\n\n        let mut cursor = QueryCursor::new();\n        let mut matches = cursor.matches(&query, tree.root_node(), source);\n\n        let class_capture_idx = query.capture_index_for_name(\"class\");\n\n        while let Some(match_) = matches.next() {\n            let class_node = if let Some(idx) = class_capture_idx {\n                match_\n                    .captures\n                    .iter()\n                    .find(|c| c.index == idx)\n                    .map(|c| c.node)\n            } else {\n                match_.captures.first().map(|c| c.node)\n            };\n\n            if let Some(class_node) = class_node {\n                // Search for method inside class body\n                if let Some(method_node) =\n                    Self::find_method_in_class(class_node, source, method_name)\n                {\n                    return Ok(method_node);\n                }\n            }\n        }\n\n        Err(TldrError::FunctionNotFound(format!(\n            \"Function '{}' not found in file\",\n            method_name\n        )))\n    }\n",
      "semantic_tags": [
        "database",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 324
    },
    {
      "name": "(CfgBuilder) find_method_in_class",
      "qualified_name": "src/cfg/builder.rs::(CfgBuilder) find_method_in_class",
      "file": "src/cfg/builder.rs",
      "line": 226,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CfgBuilder) find_method_in_class(class_node: tree_sitter::Node<'a>, source: &[u8], method_name: &str) -> Option<tree_sitter::Node<'a>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn find_method_in_class<'a>(\n        class_node: tree_sitter::Node<'a>,\n        source: &[u8],\n        method_name: &str,\n    ) -> Option<tree_sitter::Node<'a>> {\n        // Find the class body (block in Python, class_body in other languages)\n        let body_node = Self::find_class_body(class_node)?;\n\n        let mut cursor = body_node.walk();\n        for child in body_node.children(&mut cursor) {\n            match child.kind() {\n                \"function_definition\" | \"method_definition\" | \"method_declaration\" => {\n                    if let Some(name) = Self::extract_function_name(child, source) {\n                        if name == method_name {\n                            return Some(child);\n                        }\n                    }\n                }\n                \"decorated_definition\" => {\n                    // Look for function inside decorated definition\n                    let mut inner_cursor = child.walk();\n                    for inner in child.children(&mut inner_cursor) {\n                        if inner.kind() == \"function_definition\" {\n                            if let Some(name) = Self::extract_function_name(inner, source) {\n                                if name == method_name {\n                                    return Some(inner);\n                                }\n                            }\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 9,
        "branches": 6,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 259
    },
    {
      "name": "(CfgBuilder) find_class_body",
      "qualified_name": "src/cfg/builder.rs::(CfgBuilder) find_class_body",
      "file": "src/cfg/builder.rs",
      "line": 265,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CfgBuilder) find_class_body(class_node: tree_sitter::Node) -> Option<tree_sitter::Node>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn find_class_body(class_node: tree_sitter::Node) -> Option<tree_sitter::Node> {\n        let mut cursor = class_node.walk();\n        for child in class_node.children(&mut cursor) {\n            match child.kind() {\n                \"block\" | \"class_body\" | \"declaration_list\" => {\n                    return Some(child);\n                }\n                _ => {}\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 87
    },
    {
      "name": "(CfgBuilder) extract_function_name",
      "qualified_name": "src/cfg/builder.rs::(CfgBuilder) extract_function_name",
      "file": "src/cfg/builder.rs",
      "line": 279,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CfgBuilder) extract_function_name(node: tree_sitter::Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn extract_function_name(node: tree_sitter::Node, source: &[u8]) -> Option<String> {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"identifier\" | \"property_identifier\" | \"field_identifier\" => {\n                    return std::str::from_utf8(&source[child.start_byte()..child.end_byte()])\n                        .ok()\n                        .map(|s| s.to_string());\n                }\n                \"name\" => {\n                    // Some languages wrap the name in a \"name\" node\n                    let mut inner = child.walk();\n                    for inner_child in child.children(&mut inner) {\n                        if inner_child.kind() == \"identifier\" {\n                            return std::str::from_utf8(\n                                &source[inner_child.start_byte()..inner_child.end_byte()],\n                            )\n                            .ok()\n                            .map(|s| s.to_string());\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 8,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 212
    },
    {
      "name": "(CfgBuilder) extract_from_source",
      "qualified_name": "src/cfg/builder.rs::(CfgBuilder) extract_from_source",
      "file": "src/cfg/builder.rs",
      "line": 319,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CfgBuilder) extract_from_source(source: &str, language: &str, function: &str) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    pub fn extract_from_source(source: &str, language: &str, function: &str) -> Result<CFGInfo> {\n        let registry = LanguageRegistry::global();\n        let lang = registry\n            .get_by_name(language)\n            .ok_or_else(|| TldrError::UnsupportedLanguage(language.to_string()))?;\n\n        let source_bytes = source.as_bytes();\n        let mut parser = lang.parser()?;\n        let tree = parser\n            .parse(source_bytes, None)\n            .ok_or_else(|| TldrError::Parse {\n                file: \"<string>\".to_string(),\n                message: \"Failed to parse source\".to_string(),\n            })?;\n\n        let function_node = Self::find_function_node(&tree, source_bytes, lang, function)?;\n        lang.build_cfg(function_node, source_bytes)\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 166
    },
    {
      "name": "create_temp_file",
      "qualified_name": "src/cfg/builder.rs::create_temp_file",
      "file": "src/cfg/builder.rs",
      "line": 345,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_temp_file(content: &str, extension: &str) -> NamedTempFile",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_extract_python_functions",
        "test_decorated_python_class",
        "test_lookup_pattern",
        "test_extract_python_imports",
        "test_extract_python_classes"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:4",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn create_temp_file(content: &str, extension: &str) -> NamedTempFile {\n        let mut file = tempfile::Builder::new()\n            .suffix(extension)\n            .tempfile()\n            .unwrap();\n        file.write_all(content.as_bytes()).unwrap();\n        file\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 60
    },
    {
      "name": "test_extract_simple_function_cfg",
      "qualified_name": "src/cfg/builder.rs::test_extract_simple_function_cfg",
      "file": "src/cfg/builder.rs",
      "line": 355,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_simple_function_cfg()",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "extract_from_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:8",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_extract_simple_function_cfg() {\n        let source = r#\"\ndef example(x):\n    if x > 0:\n        return True\n    return False\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let cfg = CfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"example\");\n\n        assert!(cfg.is_ok());\n        let cfg = cfg.unwrap();\n        assert_eq!(cfg.function_name, \"example\");\n        assert!(!cfg.blocks.is_empty());\n        assert!(!cfg.edges.is_empty());\n        assert!(!cfg.exits.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 126
    },
    {
      "name": "test_extract_function_with_loop",
      "qualified_name": "src/cfg/builder.rs::test_extract_function_with_loop",
      "file": "src/cfg/builder.rs",
      "line": 374,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_function_with_loop()",
      "docstring": "",
      "calls": [
        "extract_from_file",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:7",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_extract_function_with_loop() {\n        let source = r#\"\ndef sum_list(items):\n    total = 0\n    for item in items:\n        total += item\n    return total\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let cfg = CfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"sum_list\");\n\n        assert!(cfg.is_ok());\n        let cfg = cfg.unwrap();\n        assert_eq!(cfg.function_name, \"sum_list\");\n\n        // Should have edges for loop\n        let has_iterate_edge = cfg.edges.iter().any(|e| {\n            e.label\n                .as_ref()\n                .map(|l| l.contains(\"iterate\"))\n                .unwrap_or(false)\n        });\n        assert!(has_iterate_edge);\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 167
    },
    {
      "name": "test_extract_function_with_try_except",
      "qualified_name": "src/cfg/builder.rs::test_extract_function_with_try_except",
      "file": "src/cfg/builder.rs",
      "line": 400,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_function_with_try_except()",
      "docstring": "",
      "calls": [
        "extract_from_file",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:7",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_extract_function_with_try_except() {\n        let source = r#\"\ndef safe_divide(a, b):\n    try:\n        result = a / b\n    except ZeroDivisionError:\n        result = 0\n    return result\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let cfg = CfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"safe_divide\");\n\n        assert!(cfg.is_ok());\n        let cfg = cfg.unwrap();\n        assert_eq!(cfg.function_name, \"safe_divide\");\n\n        // Should have exception edge\n        let has_exception_edge = cfg.edges.iter().any(|e| {\n            e.label\n                .as_ref()\n                .map(|l| l.contains(\"exception\"))\n                .unwrap_or(false)\n        });\n        assert!(has_exception_edge);\n    }\n",
      "semantic_tags": [
        "validation",
        "error_handling",
        "iteration",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 175
    },
    {
      "name": "test_extract_decorated_function",
      "qualified_name": "src/cfg/builder.rs::test_extract_decorated_function",
      "file": "src/cfg/builder.rs",
      "line": 427,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_decorated_function()",
      "docstring": "",
      "calls": [
        "extract_from_file",
        "extract_from_file",
        "parse_python",
        "create_temp_file",
        "extract_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:5",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_extract_decorated_function() {\n        let source = r#\"\n@staticmethod\ndef my_static_method(x):\n    return x * 2\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let cfg = CfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"my_static_method\");\n\n        assert!(cfg.is_ok());\n        let cfg = cfg.unwrap();\n        assert_eq!(cfg.function_name, \"my_static_method\");\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 99
    },
    {
      "name": "test_extract_class_method",
      "qualified_name": "src/cfg/builder.rs::test_extract_class_method",
      "file": "src/cfg/builder.rs",
      "line": 442,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_class_method()",
      "docstring": "",
      "calls": [
        "extract_from_file",
        "create_temp_file",
        "extract_from_file",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:5",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_extract_class_method() {\n        let source = r#\"\nclass Calculator:\n    def add(self, a, b):\n        return a + b\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let cfg = CfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"add\");\n\n        assert!(cfg.is_ok());\n        let cfg = cfg.unwrap();\n        assert_eq!(cfg.function_name, \"add\");\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 96
    },
    {
      "name": "test_function_not_found",
      "qualified_name": "src/cfg/builder.rs::test_function_not_found",
      "file": "src/cfg/builder.rs",
      "line": 457,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_function_not_found()",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "extract_from_file",
        "create_temp_file",
        "extract_from_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:4",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_function_not_found() {\n        let source = r#\"\ndef existing_function():\n    pass\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let cfg = CfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"nonexistent\");\n\n        assert!(cfg.is_err());\n        assert!(matches!(cfg, Err(TldrError::FunctionNotFound(_))));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 84
    },
    {
      "name": "test_extract_from_source",
      "qualified_name": "src/cfg/builder.rs::test_extract_from_source",
      "file": "src/cfg/builder.rs",
      "line": 470,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_from_source()",
      "docstring": "",
      "calls": [
        "extract_from_source",
        "extract_from_source",
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:4",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_extract_from_source() {\n        let source = r#\"\ndef multiply(a, b):\n    return a * b\n\"#;\n        let cfg = CfgBuilder::extract_from_source(source, \"python\", \"multiply\");\n\n        assert!(cfg.is_ok());\n        let cfg = cfg.unwrap();\n        assert_eq!(cfg.function_name, \"multiply\");\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 75
    },
    {
      "name": "test_mermaid_output",
      "qualified_name": "src/cfg/builder.rs::test_mermaid_output",
      "file": "src/cfg/builder.rs",
      "line": 483,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_mermaid_output()",
      "docstring": "",
      "calls": [
        "extract_from_source",
        "sample_cfg",
        "to_mermaid",
        "to_mermaid"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:4",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_mermaid_output() {\n        use crate::cfg::render::to_mermaid;\n\n        let source = r#\"\ndef conditional(x):\n    if x > 0:\n        return \"positive\"\n    else:\n        return \"non-positive\"\n\"#;\n        let cfg = CfgBuilder::extract_from_source(source, \"python\", \"conditional\").unwrap();\n        let mermaid = to_mermaid(&cfg);\n\n        assert!(mermaid.contains(\"flowchart TD\"));\n        assert!(mermaid.contains(\"B0\")); // Should have at least entry block\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 120
    },
    {
      "name": "test_cyclomatic_complexity",
      "qualified_name": "src/cfg/builder.rs::test_cyclomatic_complexity",
      "file": "src/cfg/builder.rs",
      "line": 501,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_cyclomatic_complexity()",
      "docstring": "",
      "calls": [
        "extract_from_source",
        "parse_rust",
        "build_cfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:6",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_cyclomatic_complexity() {\n        // Simple function: complexity = 1\n        let simple_source = r#\"\ndef simple():\n    return 42\n\"#;\n        let simple_cfg =\n            CfgBuilder::extract_from_source(simple_source, \"python\", \"simple\").unwrap();\n        let simple_complexity = simple_cfg.cyclomatic_complexity();\n\n        // Function with if: complexity >= 2\n        let if_source = r#\"\ndef with_if(x):\n    if x > 0:\n        return 1\n    return 0\n\"#;\n        let if_cfg = CfgBuilder::extract_from_source(if_source, \"python\", \"with_if\").unwrap();\n        let if_complexity = if_cfg.cyclomatic_complexity();\n\n        assert!(if_complexity >= simple_complexity);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 172
    },
    {
      "name": "test_unsupported_language",
      "qualified_name": "src/cfg/builder.rs::test_unsupported_language",
      "file": "src/cfg/builder.rs",
      "line": 525,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_unsupported_language()",
      "docstring": "",
      "calls": [
        "extract_file",
        "create_temp_file",
        "extract_from_file",
        "create_temp_file",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:2",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_unsupported_language() {\n        let file = create_temp_file(\"content\", \".xyz\");\n        let result = CfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"func\");\n\n        assert!(matches!(result, Err(TldrError::UnsupportedLanguage(_))));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 61
    },
    {
      "name": "test_while_loop_cfg",
      "qualified_name": "src/cfg/builder.rs::test_while_loop_cfg",
      "file": "src/cfg/builder.rs",
      "line": 533,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_while_loop_cfg()",
      "docstring": "",
      "calls": [
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:3",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_while_loop_cfg() {\n        let source = r#\"\ndef countdown(n):\n    while n > 0:\n        n -= 1\n    return n\n\"#;\n        let cfg = CfgBuilder::extract_from_source(source, \"python\", \"countdown\").unwrap();\n\n        // Should have back edge for loop\n        let has_next_edge = cfg.edges.iter().any(|e| {\n            e.label\n                .as_ref()\n                .map(|l| l.contains(\"next\"))\n                .unwrap_or(false)\n        });\n        assert!(has_next_edge);\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 121
    },
    {
      "name": "test_match_statement_cfg",
      "qualified_name": "src/cfg/builder.rs::test_match_statement_cfg",
      "file": "src/cfg/builder.rs",
      "line": 553,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_match_statement_cfg()",
      "docstring": "",
      "calls": [
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:5",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_match_statement_cfg() {\n        let source = r#\"\ndef process_command(cmd):\n    match cmd:\n        case \"start\":\n            return 1\n        case \"stop\":\n            return 0\n        case _:\n            return -1\n\"#;\n        let cfg = CfgBuilder::extract_from_source(source, \"python\", \"process_command\").unwrap();\n\n        // Match statement with 3 cases should produce multiple blocks and edges\n        // The exact structure depends on tree-sitter-python version and match support\n        assert!(\n            cfg.blocks.len() >= 2,\n            \"Expected at least 2 blocks for match statement with cases, got {}\",\n            cfg.blocks.len()\n        );\n        assert!(\n            cfg.edges.len() >= 1,\n            \"Expected at least 1 edge for match statement, got {}\",\n            cfg.edges.len()\n        );\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 7,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 180
    },
    {
      "name": "test_break_continue_cfg",
      "qualified_name": "src/cfg/builder.rs::test_break_continue_cfg",
      "file": "src/cfg/builder.rs",
      "line": 581,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_break_continue_cfg()",
      "docstring": "",
      "calls": [
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:5",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "    fn test_break_continue_cfg() {\n        let source = r#\"\ndef find_first(items, target):\n    for item in items:\n        if item == target:\n            break\n        if item < 0:\n            continue\n    return item\n\"#;\n        let cfg = CfgBuilder::extract_from_source(source, \"python\", \"find_first\").unwrap();\n\n        // Should have break edge\n        let has_break = cfg.edges.iter().any(|e| {\n            e.label\n                .as_ref()\n                .map(|l| l.contains(\"break\"))\n                .unwrap_or(false)\n        });\n        assert!(has_break);\n\n        // Should have continue edge\n        let has_continue = cfg.edges.iter().any(|e| {\n            e.label\n                .as_ref()\n                .map(|l| l.contains(\"continue\"))\n                .unwrap_or(false)\n        });\n        assert!(has_continue);\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 187
    },
    {
      "name": "CfgBuilder",
      "qualified_name": "src/cfg/builder.rs::CfgBuilder",
      "file": "src/cfg/builder.rs",
      "line": 22,
      "language": "rust",
      "unit_type": "class",
      "signature": "class CfgBuilder",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::cfg::types, crate::error",
      "code_preview": "pub struct CfgBuilder;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 0,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 6
    },
    {
      "name": "(UnitKind) as_str",
      "qualified_name": "src/semantic/types.rs::(UnitKind) as_str",
      "file": "src/semantic/types.rs",
      "line": 121,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (UnitKind) as_str(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn as_str(&self) -> &'static str {\n        match self {\n            Self::Function => \"function\",\n            Self::Method => \"method\",\n            Self::Class => \"class\",\n            Self::Module => \"module\",\n            Self::Chunk => \"chunk\",\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 61
    },
    {
      "name": "(UnitKind) fmt",
      "qualified_name": "src/semantic/types.rs::(UnitKind) fmt",
      "file": "src/semantic/types.rs",
      "line": 133,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (UnitKind) fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 38
    },
    {
      "name": "(CodeComplexity) empty",
      "qualified_name": "src/semantic/types.rs::(CodeComplexity) empty",
      "file": "src/semantic/types.rs",
      "line": 152,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CodeComplexity) empty() -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn empty() -> Self {\n        Self::default()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 15
    },
    {
      "name": "(CodeComplexity) is_complex",
      "qualified_name": "src/semantic/types.rs::(CodeComplexity) is_complex",
      "file": "src/semantic/types.rs",
      "line": 158,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CodeComplexity) is_complex(&self) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn is_complex(&self) -> bool {\n        self.depth > 3 || self.branches > 5 || self.loops > 2\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 34
    },
    {
      "name": "(CodeComplexity) describe",
      "qualified_name": "src/semantic/types.rs::(CodeComplexity) describe",
      "file": "src/semantic/types.rs",
      "line": 164,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CodeComplexity) describe(&self) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn describe(&self) -> Option<String> {\n        let mut parts = Vec::new();\n        if self.depth > 3 {\n            parts.push(\"deep nesting\");\n        }\n        if self.branches > 5 {\n            parts.push(\"many branches\");\n        }\n        if self.loops > 2 {\n            parts.push(\"multiple loops\");\n        }\n        if parts.is_empty() {\n            None\n        } else {\n            Some(parts.join(\", \"))\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 5,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 98
    },
    {
      "name": "default_chunk_total",
      "qualified_name": "src/semantic/types.rs::default_chunk_total",
      "file": "src/semantic/types.rs",
      "line": 264,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn default_chunk_total() -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:1, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "fn default_chunk_total() -> usize {\n    1\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 13
    },
    {
      "name": "(EmbeddingUnit) new",
      "qualified_name": "src/semantic/types.rs::(EmbeddingUnit) new",
      "file": "src/semantic/types.rs",
      "line": 271,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (EmbeddingUnit) new(file: impl Into<String>, name: impl Into<String>, kind: UnitKind, code: impl Into<String>, start_line: usize, language: impl Into<String>) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn new(\n        file: impl Into<String>,\n        name: impl Into<String>,\n        kind: UnitKind,\n        code: impl Into<String>,\n        start_line: usize,\n        language: impl Into<String>,\n    ) -> Self {\n        let name = name.into();\n        let file = file.into();\n        let code = code.into();\n\n        Self {\n            id: format!(\"{}::{}\", file, name),\n            file,\n            name,\n            kind,\n            code,\n            signature: String::new(),\n            docstring: None,\n            start_line,\n            end_line: start_line,\n            token_count: 0,\n            semantic_tags: Vec::new(),\n            parent: None,\n            language: language.into(),\n            calls: Vec::new(),\n            called_by: Vec::new(),\n            cfg_summary: String::new(),\n            dfg_summary: String::new(),\n            dependencies: String::new(),\n            complexity: CodeComplexity::default(),\n            chunk_index: 0,\n            chunk_total: 1,\n        }\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 214
    },
    {
      "name": "(EmbeddingUnit) is_chunk",
      "qualified_name": "src/semantic/types.rs::(EmbeddingUnit) is_chunk",
      "file": "src/semantic/types.rs",
      "line": 310,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (EmbeddingUnit) is_chunk(&self) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn is_chunk(&self) -> bool {\n        self.chunk_total > 1\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 21
    },
    {
      "name": "(EmbeddingUnit) needs_chunking",
      "qualified_name": "src/semantic/types.rs::(EmbeddingUnit) needs_chunking",
      "file": "src/semantic/types.rs",
      "line": 316,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (EmbeddingUnit) needs_chunking(&self) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn needs_chunking(&self) -> bool {\n        self.token_count > MAX_EMBEDDING_TOKENS\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 27
    },
    {
      "name": "(EmbeddingUnit) qualified_name",
      "qualified_name": "src/semantic/types.rs::(EmbeddingUnit) qualified_name",
      "file": "src/semantic/types.rs",
      "line": 322,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (EmbeddingUnit) qualified_name(&self) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn qualified_name(&self) -> String {\n        match &self.parent {\n            Some(parent) if self.kind == UnitKind::Method => {\n                format!(\"{}::{}.{}\", self.file, parent, self.name)\n            }\n            _ => format!(\"{}::{}\", self.file, self.name),\n        }\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 66
    },
    {
      "name": "(EmbeddingUnit) to_map",
      "qualified_name": "src/semantic/types.rs::(EmbeddingUnit) to_map",
      "file": "src/semantic/types.rs",
      "line": 333,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (EmbeddingUnit) to_map(&self) -> HashMap<String, serde_json::Value>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn to_map(&self) -> HashMap<String, serde_json::Value> {\n        serde_json::to_value(self)\n            .ok()\n            .and_then(|v| v.as_object().cloned())\n            .map(|m| m.into_iter().collect())\n            .unwrap_or_default()\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 64
    },
    {
      "name": "(SearchResult) new",
      "qualified_name": "src/semantic/types.rs::(SearchResult) new",
      "file": "src/semantic/types.rs",
      "line": 359,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (SearchResult) new(unit: EmbeddingUnit, score: f32) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn new(unit: EmbeddingUnit, score: f32) -> Self {\n        Self {\n            unit,\n            score,\n            highlights: Vec::new(),\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 39
    },
    {
      "name": "(SearchResult) with_highlights",
      "qualified_name": "src/semantic/types.rs::(SearchResult) with_highlights",
      "file": "src/semantic/types.rs",
      "line": 369,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (SearchResult) with_highlights(unit: EmbeddingUnit, score: f32, highlights: Vec<String>) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn with_highlights(unit: EmbeddingUnit, score: f32, highlights: Vec<String>) -> Self {\n        Self {\n            unit,\n            score,\n            highlights,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 42
    },
    {
      "name": "(ChunkInfo) new",
      "qualified_name": "src/semantic/types.rs::(ChunkInfo) new",
      "file": "src/semantic/types.rs",
      "line": 392,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ChunkInfo) new(text: String, start_char: usize, end_char: usize) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    pub fn new(text: String, start_char: usize, end_char: usize) -> Self {\n        Self {\n            text,\n            start_char,\n            end_char,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 39
    },
    {
      "name": "test_unit_kind_as_str",
      "qualified_name": "src/semantic/types.rs::test_unit_kind_as_str",
      "file": "src/semantic/types.rs",
      "line": 410,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_unit_kind_as_str()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    fn test_unit_kind_as_str() {\n        assert_eq!(UnitKind::Function.as_str(), \"function\");\n        assert_eq!(UnitKind::Method.as_str(), \"method\");\n        assert_eq!(UnitKind::Class.as_str(), \"class\");\n        assert_eq!(UnitKind::Module.as_str(), \"module\");\n        assert_eq!(UnitKind::Chunk.as_str(), \"chunk\");\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 81
    },
    {
      "name": "test_unit_kind_display",
      "qualified_name": "src/semantic/types.rs::test_unit_kind_display",
      "file": "src/semantic/types.rs",
      "line": 419,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_unit_kind_display()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    fn test_unit_kind_display() {\n        assert_eq!(format!(\"{}\", UnitKind::Function), \"function\");\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 24
    },
    {
      "name": "test_code_complexity_describe",
      "qualified_name": "src/semantic/types.rs::test_code_complexity_describe",
      "file": "src/semantic/types.rs",
      "line": 424,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_code_complexity_describe()",
      "docstring": "",
      "calls": [
        "describe"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:5",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    fn test_code_complexity_describe() {\n        let simple = CodeComplexity {\n            depth: 2,\n            branches: 3,\n            loops: 1,\n        };\n        assert!(simple.describe().is_none());\n\n        let complex = CodeComplexity {\n            depth: 5,\n            branches: 10,\n            loops: 4,\n        };\n        let desc = complex.describe().unwrap();\n        assert!(desc.contains(\"deep nesting\"));\n        assert!(desc.contains(\"many branches\"));\n        assert!(desc.contains(\"multiple loops\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 114
    },
    {
      "name": "test_embedding_unit_new",
      "qualified_name": "src/semantic/types.rs::test_embedding_unit_new",
      "file": "src/semantic/types.rs",
      "line": 444,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_embedding_unit_new()",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:7",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    fn test_embedding_unit_new() {\n        let unit = EmbeddingUnit::new(\n            \"src/main.py\",\n            \"process_data\",\n            UnitKind::Function,\n            \"def process_data(): pass\",\n            10,\n            \"python\",\n        );\n\n        assert_eq!(unit.id, \"src/main.py::process_data\");\n        assert_eq!(unit.file, \"src/main.py\");\n        assert_eq!(unit.name, \"process_data\");\n        assert_eq!(unit.kind, UnitKind::Function);\n        assert_eq!(unit.start_line, 10);\n        assert_eq!(unit.language, \"python\");\n        assert!(!unit.is_chunk());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 136
    },
    {
      "name": "test_embedding_unit_qualified_name",
      "qualified_name": "src/semantic/types.rs::test_embedding_unit_qualified_name",
      "file": "src/semantic/types.rs",
      "line": 464,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_embedding_unit_qualified_name()",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:1",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    fn test_embedding_unit_qualified_name() {\n        let mut unit = EmbeddingUnit::new(\n            \"src/model.py\",\n            \"save\",\n            UnitKind::Method,\n            \"def save(self): pass\",\n            20,\n            \"python\",\n        );\n        unit.parent = Some(\"User\".to_string());\n\n        assert_eq!(unit.qualified_name(), \"src/model.py::User.save\");\n    }\n",
      "semantic_tags": [
        "crud",
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 86
    },
    {
      "name": "test_embedding_unit_is_chunk",
      "qualified_name": "src/semantic/types.rs::test_embedding_unit_is_chunk",
      "file": "src/semantic/types.rs",
      "line": 479,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_embedding_unit_is_chunk()",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:1",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    fn test_embedding_unit_is_chunk() {\n        let mut unit = EmbeddingUnit::new(\n            \"src/large.py\",\n            \"big_function[1/3]\",\n            UnitKind::Chunk,\n            \"# chunk 1\",\n            1,\n            \"python\",\n        );\n        unit.chunk_index = 0;\n        unit.chunk_total = 3;\n\n        assert!(unit.is_chunk());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 83
    },
    {
      "name": "test_search_result",
      "qualified_name": "src/semantic/types.rs::test_search_result",
      "file": "src/semantic/types.rs",
      "line": 495,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_search_result()",
      "docstring": "",
      "calls": [
        "new",
        "with_highlights"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:17, def-use chains:5",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    fn test_search_result() {\n        let unit = EmbeddingUnit::new(\n            \"test.py\",\n            \"test_fn\",\n            UnitKind::Function,\n            \"def test_fn(): pass\",\n            1,\n            \"python\",\n        );\n        let result = SearchResult::new(unit.clone(), 0.95);\n\n        assert_eq!(result.score, 0.95);\n        assert!(result.highlights.is_empty());\n\n        let result_with_highlights =\n            SearchResult::with_highlights(unit, 0.95, vec![\"highlighted text\".to_string()]);\n        assert_eq!(result_with_highlights.highlights.len(), 1);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 137
    },
    {
      "name": "test_semantic_patterns_defined",
      "qualified_name": "src/semantic/types.rs::test_semantic_patterns_defined",
      "file": "src/semantic/types.rs",
      "line": 515,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_semantic_patterns_defined()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:4",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    fn test_semantic_patterns_defined() {\n        assert!(!SEMANTIC_PATTERNS.is_empty());\n\n        // Check some key patterns exist\n        let pattern_names: Vec<_> = SEMANTIC_PATTERNS.iter().map(|p| p.name).collect();\n        assert!(pattern_names.contains(&\"crud\"));\n        assert!(pattern_names.contains(&\"validation\"));\n        assert!(pattern_names.contains(&\"error_handling\"));\n        assert!(pattern_names.contains(&\"async_ops\"));\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 100
    },
    {
      "name": "test_constants",
      "qualified_name": "src/semantic/types.rs::test_constants",
      "file": "src/semantic/types.rs",
      "line": 527,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_constants()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:0",
      "dependencies": "serde, std::collections, super",
      "code_preview": "    fn test_constants() {\n        assert!(MAX_EMBEDDING_TOKENS > 0);\n        assert!(MAX_CODE_PREVIEW_TOKENS < MAX_EMBEDDING_TOKENS);\n        assert!(CHUNK_OVERLAP_TOKENS < MAX_CODE_PREVIEW_TOKENS);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 56
    },
    {
      "name": "SemanticPattern",
      "qualified_name": "src/semantic/types.rs::SemanticPattern",
      "file": "src/semantic/types.rs",
      "line": 30,
      "language": "rust",
      "unit_type": "class",
      "signature": "class SemanticPattern",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections, super",
      "code_preview": "pub struct SemanticPattern {\n    /// Pattern category name (e.g., \"crud\", \"validation\")\n    pub name: &'static str,\n    /// Regex pattern to match\n    pub pattern: &'static str,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 44
    },
    {
      "name": "CodeComplexity",
      "qualified_name": "src/semantic/types.rs::CodeComplexity",
      "file": "src/semantic/types.rs",
      "line": 140,
      "language": "rust",
      "unit_type": "class",
      "signature": "class CodeComplexity",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections, super",
      "code_preview": "pub struct CodeComplexity {\n    /// Maximum nesting depth\n    pub depth: usize,\n    /// Number of branch statements (if, elif, else, case, switch, match)\n    pub branches: usize,\n    /// Number of loop statements (for, while, loop)\n    pub loops: usize,\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 6,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 63
    },
    {
      "name": "EmbeddingUnit",
      "qualified_name": "src/semantic/types.rs::EmbeddingUnit",
      "file": "src/semantic/types.rs",
      "line": 188,
      "language": "rust",
      "unit_type": "class",
      "signature": "class EmbeddingUnit",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections, super",
      "code_preview": "pub struct EmbeddingUnit {\n    /// Unique identifier (typically file::qualified_name or file::name#chunkN)\n    pub id: String,\n\n    /// Source file path (relative to project root)\n    pub file: String,\n\n    /// Simple name (function/class/method name)\n    pub name: String,\n\n    /// Kind of code unit\n    pub kind: UnitKind,\n\n    /// Full code content (may be truncated for large units)\n    pub code: String,\n\n    /// Function/method signature or class declaration\n    pub signature: String,\n\n    /// Docstring or documentation comment\n    pub docstring: Option<String>,\n\n    /// Starting line number (1-indexed)\n    pub start_line: usize,\n\n    /// Ending line number (1-indexed)\n    pub end_line: usize,\n\n    /// Token count for this unit's code\n    pub token_count: usize,\n\n    /// Semantic tags detected from code patterns\n    pub semantic_tags: Vec<String>,\n\n    /// Parent unit name (for chunks and methods)\n    pub parent: Option<String>,\n\n    // ==========================================================================\n    // Extended metadata from TLDR layers\n    // ==========================================================================\n    /// L1: Programming language\n    pub language: String,\n\n    /// L2: Functions this unit calls\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub calls: Vec<String>,\n\n    /// L2: Functions that call this unit\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub called_by: Vec<String>,\n\n    /// L3: CFG summary (complexity, block count)\n    #[serde(default, skip_serializing_if = \"String::is_empty\")]\n    pub cfg_summary: String,\n\n    /// L4: DFG summary (variable count, def-use chains)\n    #[serde(default, skip_serializing_if = \"String::is_empty\")]\n    pub dfg_summary: String,\n\n    /// L5: Dependencies (imported modules)\n    #[serde(default, skip_serializing_if = \"String::is_empty\")]\n    pub dependencies: String,\n\n    /// Code complexity metrics\n    #[serde(default)]\n    pub complexity: CodeComplexity,\n\n    /// Chunk index (0-indexed, for chunked units)\n    #[serde(default)]\n    pub chunk_index: usize,\n\n    /// Total number of chunks (1 for non-chunked units)\n    #[serde(default = \"default_chunk_total\")]\n    pub chunk_total: usize,\n}\n",
      "semantic_tags": [
        "auth",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 5
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 505
    },
    {
      "name": "SearchResult",
      "qualified_name": "src/semantic/types.rs::SearchResult",
      "file": "src/semantic/types.rs",
      "line": 344,
      "language": "rust",
      "unit_type": "class",
      "signature": "class SearchResult",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections, super",
      "code_preview": "pub struct SearchResult {\n    /// The matching code unit\n    pub unit: EmbeddingUnit,\n\n    /// Similarity score (0.0 to 1.0, higher is better)\n    pub score: f32,\n\n    /// Highlighted portions of code that matched (optional)\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub highlights: Vec<String>,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 82
    },
    {
      "name": "ChunkInfo",
      "qualified_name": "src/semantic/types.rs::ChunkInfo",
      "file": "src/semantic/types.rs",
      "line": 380,
      "language": "rust",
      "unit_type": "class",
      "signature": "class ChunkInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections, super",
      "code_preview": "pub struct ChunkInfo {\n    /// Chunk text content\n    pub text: String,\n    /// Start character offset in original code\n    pub start_char: usize,\n    /// End character offset in original code\n    pub end_char: usize,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 50
    },
    {
      "name": "test_vector_index_types_exported",
      "qualified_name": "src/embedding/mod.rs::test_vector_index_types_exported",
      "file": "src/embedding/mod.rs",
      "line": 84,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_vector_index_types_exported()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:0",
      "dependencies": "index, tei_client, tei_client, index, super",
      "code_preview": "    fn test_vector_index_types_exported() {\n        // Verify public types are accessible\n        fn _assert_types() {\n            let _: Option<VectorIndex> = None;\n            let _: Option<IndexConfig> = None;\n            let _: Metric = Metric::InnerProduct;\n            let _: Quantization = Quantization::F32;\n        }\n    }\n",
      "semantic_tags": [
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 73
    },
    {
      "name": "test_utility_functions_exported",
      "qualified_name": "src/embedding/mod.rs::test_utility_functions_exported",
      "file": "src/embedding/mod.rs",
      "line": 95,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_utility_functions_exported() -> Vec<f32>;\n            let _ = normalize_vector as fn(&[f32])",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:0",
      "dependencies": "index, tei_client, tei_client, index, super",
      "code_preview": "    fn test_utility_functions_exported() {\n        // Verify public functions are accessible\n        fn _assert_functions() {\n            let _ = distances_to_scores as fn(&[f32]) -> Vec<f32>;\n            let _ = normalize_vector as fn(&[f32]) -> Vec<f32>;\n            let _ = is_normalized as fn(&[f32], f32) -> bool;\n        }\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 91
    },
    {
      "name": "get_tree",
      "qualified_name": "src/lib.rs::get_tree",
      "file": "src/lib.rs",
      "line": 163,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_tree(path: &str, ext_filter: Option<&str>) -> Result<FileTreeEntry>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:2",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn get_tree(path: &str, ext_filter: Option<&str>) -> Result<FileTreeEntry> {\n    ast::file_tree(path, ext_filter)\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 34
    },
    {
      "name": "get_structure",
      "qualified_name": "src/lib.rs::get_structure",
      "file": "src/lib.rs",
      "line": 207,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_structure(path: &str, lang_filter: Option<&str>, max_results: usize) -> Result<CodeStructure>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:3",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn get_structure(\n    path: &str,\n    lang_filter: Option<&str>,\n    max_results: usize,\n) -> Result<CodeStructure> {\n    ast::code_structure(path, lang_filter, max_results)\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 47
    },
    {
      "name": "extract_file",
      "qualified_name": "src/lib.rs::extract_file",
      "file": "src/lib.rs",
      "line": 261,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_file(file_path: &str) -> Result<ModuleInfo>",
      "docstring": "",
      "calls": [
        "extract_file",
        "extract_module",
        "extract_file"
      ],
      "called_by": [
        "test_extract_typescript_functions",
        "test_extract_file_nonexistent",
        "test_unsupported_language",
        "test_decorated_python_function",
        "find_class"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:1",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn extract_file(file_path: &str) -> Result<ModuleInfo> {\n    ast::extract_file(file_path)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 26
    },
    {
      "name": "get_context",
      "qualified_name": "src/lib.rs::get_context",
      "file": "src/lib.rs",
      "line": 306,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_context(project: &str, entry_point: &str, depth: usize) -> Result<serde_json::Value>",
      "docstring": "",
      "calls": [
        "build",
        "get_context"
      ],
      "called_by": [
        "get_context",
        "cmd_context"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:3",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn get_context(project: &str, entry_point: &str, depth: usize) -> Result<serde_json::Value> {\n    callgraph::get_context(project, entry_point, depth)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 42
    },
    {
      "name": "get_cfg",
      "qualified_name": "src/lib.rs::get_cfg",
      "file": "src/lib.rs",
      "line": 353,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_cfg(file: &str, function: &str) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [
        "extract"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:1",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn get_cfg(file: &str, function: &str) -> Result<CFGInfo> {\n    cfg::extract(file, function)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 30
    },
    {
      "name": "get_dfg",
      "qualified_name": "src/lib.rs::get_dfg",
      "file": "src/lib.rs",
      "line": 396,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_dfg(file: &str, function: &str) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [
        "extract"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:1",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn get_dfg(file: &str, function: &str) -> Result<DFGInfo> {\n    dfg::extract(file, function)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 33
    },
    {
      "name": "get_slice",
      "qualified_name": "src/lib.rs::get_slice",
      "file": "src/lib.rs",
      "line": 436,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_slice(file: &str, function: &str, line: usize) -> Result<Vec<usize>>",
      "docstring": "",
      "calls": [
        "extract",
        "get_slice"
      ],
      "called_by": [
        "cmd_slice",
        "get_slice"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:2",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn get_slice(file: &str, function: &str, line: usize) -> Result<Vec<usize>> {\n    dfg::get_slice(file, function, line)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 37
    },
    {
      "name": "build_callgraph",
      "qualified_name": "src/lib.rs::build_callgraph",
      "file": "src/lib.rs",
      "line": 480,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn build_callgraph(path: &str) -> Result<CallGraph>",
      "docstring": "",
      "calls": [
        "build"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:1",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn build_callgraph(path: &str) -> Result<CallGraph> {\n    callgraph::build(path)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 25
    },
    {
      "name": "get_impact",
      "qualified_name": "src/lib.rs::get_impact",
      "file": "src/lib.rs",
      "line": 524,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_impact(path: &str, function: &str, depth: usize) -> Result<Vec<FunctionRef>>",
      "docstring": "",
      "calls": [
        "impact"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn get_impact(path: &str, function: &str, depth: usize) -> Result<Vec<FunctionRef>> {\n    callgraph::impact(path, function, depth)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 39
    },
    {
      "name": "find_dead_code",
      "qualified_name": "src/lib.rs::find_dead_code",
      "file": "src/lib.rs",
      "line": 568,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn find_dead_code(path: &str) -> Result<Vec<FunctionRef>>",
      "docstring": "",
      "calls": [
        "dead_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:1",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn find_dead_code(path: &str) -> Result<Vec<FunctionRef>> {\n    callgraph::dead_code(path)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 27
    },
    {
      "name": "warm_callgraph",
      "qualified_name": "src/lib.rs::warm_callgraph",
      "file": "src/lib.rs",
      "line": 598,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn warm_callgraph(path: &str, langs: Option<&[String]>) -> Result<()>",
      "docstring": "",
      "calls": [
        "warm"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:2",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn warm_callgraph(path: &str, langs: Option<&[String]>) -> Result<()> {\n    callgraph::warm(path, langs)\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 32
    },
    {
      "name": "extract_semantic_units",
      "qualified_name": "src/lib.rs::extract_semantic_units",
      "file": "src/lib.rs",
      "line": 641,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_semantic_units(path: &str, lang: &str) -> Result<Vec<EmbeddingUnit>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:2",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn extract_semantic_units(path: &str, lang: &str) -> Result<Vec<EmbeddingUnit>> {\n    semantic::extract_units(path, lang)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 35
    },
    {
      "name": "extract_file_units",
      "qualified_name": "src/lib.rs::extract_file_units",
      "file": "src/lib.rs",
      "line": 674,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_file_units(file_path: &str) -> Result<Vec<EmbeddingUnit>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:1",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn extract_file_units(file_path: &str) -> Result<Vec<EmbeddingUnit>> {\n    semantic::extract_units_from_file(file_path)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 31
    },
    {
      "name": "build_embedding_text",
      "qualified_name": "src/lib.rs::build_embedding_text",
      "file": "src/lib.rs",
      "line": 704,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn build_embedding_text(unit: &EmbeddingUnit) -> String",
      "docstring": "",
      "calls": [
        "truncate_to_tokens",
        "build_embedding_text",
        "parse_identifier_to_words"
      ],
      "called_by": [
        "test_build_embedding_text",
        "build_embedding_text"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:1",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn build_embedding_text(unit: &EmbeddingUnit) -> String {\n    semantic::build_embedding_text(unit)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 24
    },
    {
      "name": "count_tokens",
      "qualified_name": "src/lib.rs::count_tokens",
      "file": "src/lib.rs",
      "line": 729,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn count_tokens(text: &str) -> usize",
      "docstring": "",
      "calls": [
        "estimate_tokens",
        "count_tokens",
        "tokenize",
        "estimate_tokens"
      ],
      "called_by": [
        "test_count_tokens_code",
        "enrich_unit",
        "fits_in_tokens",
        "truncate_to_tokens",
        "count_tokens"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:1",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "pub fn count_tokens(text: &str) -> usize {\n    semantic::count_tokens(text)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 20
    },
    {
      "name": "test_public_api_types_exported",
      "qualified_name": "src/lib.rs::test_public_api_types_exported",
      "file": "src/lib.rs",
      "line": 742,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_public_api_types_exported()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "    fn test_public_api_types_exported() {\n        // Verify that all public types are accessible\n        fn _assert_types() {\n            let _: Option<FileTreeEntry> = None;\n            let _: Option<CodeStructure> = None;\n            let _: Option<ModuleInfo> = None;\n            let _: Option<FunctionInfo> = None;\n            let _: Option<ClassInfo> = None;\n            let _: Option<ImportInfo> = None;\n            let _: Option<CFGInfo> = None;\n            let _: Option<CFGBlock> = None;\n            let _: Option<CFGEdge> = None;\n            let _: Option<BlockId> = None;\n            let _: Option<DFGInfo> = None;\n            let _: Option<DataflowEdge> = None;\n            let _: Option<DataflowKind> = None;\n            let _: Option<CallGraph> = None;\n            let _: Option<CallEdge> = None;\n            let _: Option<FunctionRef> = None;\n            let _: Option<TldrError> = None;\n            // Semantic types\n            let _: Option<EmbeddingUnit> = None;\n            let _: Option<SearchResult> = None;\n            let _: Option<UnitKind> = None;\n            let _: Option<CodeComplexity> = None;\n            let _: Option<ChunkInfo> = None;\n        }\n    }\n",
      "semantic_tags": [
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 278
    },
    {
      "name": "test_public_api_functions_exist",
      "qualified_name": "src/lib.rs::test_public_api_functions_exist",
      "file": "src/lib.rs",
      "line": 772,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_public_api_functions_exist() -> Result<FileTreeEntry>;\n            let _ = get_structure as fn(&str, Option<&str>, usize)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:18, def-use chains:0",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "    fn test_public_api_functions_exist() {\n        // Verify that all public API functions are callable\n        // (compilation test - doesn't actually run them)\n        fn _assert_functions() {\n            let _ = get_tree as fn(&str, Option<&str>) -> Result<FileTreeEntry>;\n            let _ = get_structure as fn(&str, Option<&str>, usize) -> Result<CodeStructure>;\n            let _ = extract_file as fn(&str) -> Result<ModuleInfo>;\n            let _ = get_context as fn(&str, &str, usize) -> Result<serde_json::Value>;\n            let _ = get_cfg as fn(&str, &str) -> Result<CFGInfo>;\n            let _ = get_dfg as fn(&str, &str) -> Result<DFGInfo>;\n            let _ = get_slice as fn(&str, &str, usize) -> Result<Vec<usize>>;\n            let _ = build_callgraph as fn(&str) -> Result<CallGraph>;\n            let _ = get_impact as fn(&str, &str, usize) -> Result<Vec<FunctionRef>>;\n            let _ = find_dead_code as fn(&str) -> Result<Vec<FunctionRef>>;\n            let _ = warm_callgraph as fn(&str, Option<&[String]>) -> Result<()>;\n            // Semantic API functions\n            let _ = extract_semantic_units as fn(&str, &str) -> Result<Vec<EmbeddingUnit>>;\n            let _ = extract_file_units as fn(&str) -> Result<Vec<EmbeddingUnit>>;\n            let _ = build_embedding_text as fn(&EmbeddingUnit) -> String;\n            let _ = count_tokens as fn(&str) -> usize;\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 357
    },
    {
      "name": "test_semantic_constants_exported",
      "qualified_name": "src/lib.rs::test_semantic_constants_exported",
      "file": "src/lib.rs",
      "line": 796,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_semantic_constants_exported()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:0",
      "dependencies": "ast, callgraph, cfg, dfg, embedding",
      "code_preview": "    fn test_semantic_constants_exported() {\n        // Verify semantic constants are accessible\n        assert!(MAX_EMBEDDING_TOKENS > 0);\n        assert!(MAX_CODE_PREVIEW_TOKENS > 0);\n        assert!(CHUNK_OVERLAP_TOKENS > 0);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 60
    },
    {
      "name": "(CFGInfo) cyclomatic_complexity",
      "qualified_name": "src/cfg/types.rs::(CFGInfo) cyclomatic_complexity",
      "file": "src/cfg/types.rs",
      "line": 65,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CFGInfo) cyclomatic_complexity(&self) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn cyclomatic_complexity(&self) -> usize {\n        let edges = self.edges.len();\n        let nodes = self.blocks.len();\n        edges.saturating_sub(nodes) + 2\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 43
    },
    {
      "name": "(CFGInfo) successors",
      "qualified_name": "src/cfg/types.rs::(CFGInfo) successors",
      "file": "src/cfg/types.rs",
      "line": 72,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CFGInfo) successors(&self, block_id: BlockId) -> Vec<BlockId>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn successors(&self, block_id: BlockId) -> Vec<BlockId> {\n        self.edges\n            .iter()\n            .filter(|e| e.from == block_id)\n            .map(|e| e.to)\n            .collect()\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 54
    },
    {
      "name": "(CFGInfo) predecessors",
      "qualified_name": "src/cfg/types.rs::(CFGInfo) predecessors",
      "file": "src/cfg/types.rs",
      "line": 81,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CFGInfo) predecessors(&self, block_id: BlockId) -> Vec<BlockId>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn predecessors(&self, block_id: BlockId) -> Vec<BlockId> {\n        self.edges\n            .iter()\n            .filter(|e| e.to == block_id)\n            .map(|e| e.from)\n            .collect()\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 54
    },
    {
      "name": "BlockId",
      "qualified_name": "src/cfg/types.rs::BlockId",
      "file": "src/cfg/types.rs",
      "line": 8,
      "language": "rust",
      "unit_type": "class",
      "signature": "class BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct BlockId(pub usize);\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 0,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 7
    },
    {
      "name": "CFGBlock",
      "qualified_name": "src/cfg/types.rs::CFGBlock",
      "file": "src/cfg/types.rs",
      "line": 12,
      "language": "rust",
      "unit_type": "class",
      "signature": "class CFGBlock",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct CFGBlock {\n    /// Unique block identifier\n    pub id: BlockId,\n    /// Human-readable label\n    pub label: String,\n    /// Statements in this block\n    pub statements: Vec<String>,\n    /// Starting line number\n    pub start_line: usize,\n    /// Ending line number\n    pub end_line: usize,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 71
    },
    {
      "name": "CFGEdge",
      "qualified_name": "src/cfg/types.rs::CFGEdge",
      "file": "src/cfg/types.rs",
      "line": 27,
      "language": "rust",
      "unit_type": "class",
      "signature": "class CFGEdge",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct CFGEdge {\n    /// Source block\n    pub from: BlockId,\n    /// Target block\n    pub to: BlockId,\n    /// Edge label (e.g., \"true\", \"false\", \"exception\")\n    pub label: Option<String>,\n}\n",
      "semantic_tags": [
        "config",
        "error_handling"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 54
    },
    {
      "name": "CFGInfo",
      "qualified_name": "src/cfg/types.rs::CFGInfo",
      "file": "src/cfg/types.rs",
      "line": 38,
      "language": "rust",
      "unit_type": "class",
      "signature": "class CFGInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct CFGInfo {\n    /// Function name\n    pub function_name: String,\n    /// All blocks indexed by ID\n    pub blocks: HashMap<BlockId, CFGBlock>,\n    /// All edges\n    pub edges: Vec<CFGEdge>,\n    /// Entry block\n    pub entry: BlockId,\n    /// Exit blocks\n    pub exits: Vec<BlockId>,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 76
    },
    {
      "name": "main",
      "qualified_name": "examples/test_java.rs::main",
      "file": "examples/test_java.rs",
      "line": 6,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn main()",
      "docstring": "",
      "calls": [
        "cmd_diagnostics",
        "cmd_search",
        "cmd_imports",
        "cmd_dead",
        "cmd_tree"
      ],
      "called_by": [],
      "cfg_summary": "complexity:7, blocks:16",
      "dfg_summary": "vars:26, def-use chains:13",
      "dependencies": "llm_tldr::lang::java, llm_tldr::lang::traits",
      "code_preview": "fn main() {\n    let java = Java;\n\n    // Test parsing\n    let mut parser = java.parser().expect(\"Failed to create parser\");\n\n    let code = r#\"\nimport java.util.List;\nimport static java.lang.Math.PI;\n\n/**\n * User class with documentation.\n */\n@Entity\npublic class User extends BaseEntity implements Serializable {\n    private String name;\n\n    /**\n     * Constructor.\n     */\n    public User(String name) {\n        this.name = name;\n    }\n\n    /**\n     * Get name.\n     */\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    public static <T> List<T> process(List<T> items, int count) {\n        return items;\n    }\n}\n\"#;\n\n    let tree = parser.parse(code, None).expect(\"Failed to parse\");\n    let root = tree.root_node();\n\n    println!(\"=== Java Language Support Test ===\\n\");\n\n    // Test import extraction\n    let imports = java.extract_imports(&tree, code.as_bytes());\n    println!(\"Imports found: {}\", imports.len());\n    for imp in &imports {\n        println!(\n            \"  - {}{}\",\n            imp.module,\n            if imp.is_from { \" (static)\" } else { \"\" }\n        );\n    }\n\n    // Test class and method extraction\n    for child in root.children(&mut root.walk()) {\n        if child.kind() == \"class_declaration\" {\n            if let Some(class) = java.extract_class(child, code.as_bytes()) {\n                println!(\"\\nClass: {}\", class.name);\n                println!(\"  Bases: {:?}\", class.bases);\n                println!(\"  Decorators: {:?}\", class.decorators);\n                if let Some(doc) = &class.docstring {\n                    println!(\"  Doc: {}\", doc.lines().next().unwrap_or(\"\"));\n                }\n                println!(\"  Methods:\");\n                for method in &class.methods {\n                    println!(\"    - {} ({})\", method.name, method.signature());\n                    println!(\"      Decorators: {:?}\", method.decorators);\n                }\n            }\n        }\n    }\n\n    println!(\"\\n=== Test Passed ===\");\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "iteration",
        "test",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 5,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 424
    },
    {
      "name": "extract",
      "qualified_name": "src/dfg/mod.rs::extract",
      "file": "src/dfg/mod.rs",
      "line": 43,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract(file: &str, function: &str) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "get_slice",
        "get_dfg",
        "cmd_dfg",
        "get_cfg",
        "get_forward_slice_result"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:1",
      "dependencies": "builder, slice, types, types, builder",
      "code_preview": "pub fn extract(file: &str, function: &str) -> Result<DFGInfo> {\n    DfgBuilder::extract_from_file(file, function)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 34
    },
    {
      "name": "get_slice",
      "qualified_name": "src/dfg/mod.rs::get_slice",
      "file": "src/dfg/mod.rs",
      "line": 50,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_slice(file: &str, function: &str, line: usize) -> Result<Vec<usize>>",
      "docstring": "",
      "calls": [
        "extract",
        "get_slice"
      ],
      "called_by": [
        "cmd_slice",
        "get_slice"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "builder, slice, types, types, builder",
      "code_preview": "pub fn get_slice(file: &str, function: &str, line: usize) -> Result<Vec<usize>> {\n    let dfg = extract(file, function)?;\n    Ok(dfg.backward_slice(line))\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 43
    },
    {
      "name": "get_slice_result",
      "qualified_name": "src/dfg/mod.rs::get_slice_result",
      "file": "src/dfg/mod.rs",
      "line": 56,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_slice_result(file: &str, function: &str, line: usize) -> Result<SliceResult>",
      "docstring": "",
      "calls": [
        "extract",
        "backward_slice"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:4",
      "dependencies": "builder, slice, types, types, builder",
      "code_preview": "pub fn get_slice_result(file: &str, function: &str, line: usize) -> Result<SliceResult> {\n    let dfg = extract(file, function)?;\n    let criteria = SliceCriteria::at_line(line);\n    Ok(backward_slice(&dfg, &criteria))\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 60
    },
    {
      "name": "get_forward_slice",
      "qualified_name": "src/dfg/mod.rs::get_forward_slice",
      "file": "src/dfg/mod.rs",
      "line": 63,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_forward_slice(file: &str, function: &str, line: usize) -> Result<Vec<usize>>",
      "docstring": "",
      "calls": [
        "extract"
      ],
      "called_by": [
        "cmd_slice"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "builder, slice, types, types, builder",
      "code_preview": "pub fn get_forward_slice(file: &str, function: &str, line: usize) -> Result<Vec<usize>> {\n    let dfg = extract(file, function)?;\n    Ok(dfg.forward_slice(line))\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 44
    },
    {
      "name": "get_forward_slice_result",
      "qualified_name": "src/dfg/mod.rs::get_forward_slice_result",
      "file": "src/dfg/mod.rs",
      "line": 69,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_forward_slice_result(file: &str, function: &str, line: usize) -> Result<SliceResult>",
      "docstring": "",
      "calls": [
        "forward_slice",
        "extract"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:4",
      "dependencies": "builder, slice, types, types, builder",
      "code_preview": "pub fn get_forward_slice_result(file: &str, function: &str, line: usize) -> Result<SliceResult> {\n    let dfg = extract(file, function)?;\n    let criteria = SliceCriteria::at_line(line);\n    Ok(forward_slice(&dfg, &criteria))\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 61
    },
    {
      "name": "test_public_types_exported",
      "qualified_name": "src/semantic/mod.rs::test_public_types_exported",
      "file": "src/semantic/mod.rs",
      "line": 129,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_public_types_exported()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "chunker, extractor, types, types, types",
      "code_preview": "    fn test_public_types_exported() {\n        // Verify all public types are accessible\n        fn _assert_types() {\n            let _: Option<EmbeddingUnit> = None;\n            let _: Option<SearchResult> = None;\n            let _: Option<UnitKind> = None;\n            let _: Option<CodeComplexity> = None;\n            let _: Option<ChunkInfo> = None;\n            let _: Option<SemanticPattern> = None;\n        }\n    }\n",
      "semantic_tags": [
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 97
    },
    {
      "name": "test_constants_exported",
      "qualified_name": "src/semantic/mod.rs::test_constants_exported",
      "file": "src/semantic/mod.rs",
      "line": 142,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_constants_exported()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:0",
      "dependencies": "chunker, extractor, types, types, types",
      "code_preview": "    fn test_constants_exported() {\n        assert!(MAX_EMBEDDING_TOKENS > 0);\n        assert!(MAX_CODE_PREVIEW_TOKENS > 0);\n        assert!(CHUNK_OVERLAP_TOKENS > 0);\n        assert!(!SEMANTIC_PATTERNS.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 63
    },
    {
      "name": "test_functions_exported",
      "qualified_name": "src/semantic/mod.rs::test_functions_exported",
      "file": "src/semantic/mod.rs",
      "line": 150,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_functions_exported() -> crate::error::Result<Vec<EmbeddingUnit>>;\n            let _ = extract_units_from_file as fn(&str)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:0",
      "dependencies": "chunker, extractor, types, types, types",
      "code_preview": "    fn test_functions_exported() {\n        // Verify all public functions are callable\n        fn _assert_functions() {\n            let _ = extract_units as fn(&str, &str) -> crate::error::Result<Vec<EmbeddingUnit>>;\n            let _ = extract_units_from_file as fn(&str) -> crate::error::Result<Vec<EmbeddingUnit>>;\n            let _ = count_tokens as fn(&str) -> usize;\n            let _ = truncate_to_tokens as fn(&str, usize) -> String;\n            let _ = detect_semantic_patterns as fn(&str) -> Vec<String>;\n            let _ = detect_code_complexity as fn(&str) -> CodeComplexity;\n            let _ = split_into_chunks as fn(&str, usize, usize) -> Vec<ChunkInfo>;\n            let _ = chunk_unit as fn(&EmbeddingUnit) -> Vec<EmbeddingUnit>;\n            let _ = enrich_unit as fn(&mut EmbeddingUnit);\n            let _ = build_embedding_text as fn(&EmbeddingUnit) -> String;\n            let _ = parse_identifier_to_words as fn(&str) -> String;\n        }\n    }\n",
      "semantic_tags": [
        "validation",
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 234
    },
    {
      "name": "test_chunker_functions_exported",
      "qualified_name": "src/semantic/mod.rs::test_chunker_functions_exported",
      "file": "src/semantic/mod.rs",
      "line": 168,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunker_functions_exported() -> Vec<Chunk>;\n            let _ = chunk_code_default as fn(&str)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:0",
      "dependencies": "chunker, extractor, types, types, types",
      "code_preview": "    fn test_chunker_functions_exported() {\n        // Verify chunker functions are callable\n        fn _assert_chunker() {\n            let _ = chunk_code as fn(&str, usize) -> Vec<Chunk>;\n            let _ = chunk_code_default as fn(&str) -> Vec<Chunk>;\n            let _ = chunk_code_with_overlap as fn(&str, usize, usize) -> Vec<Chunk>;\n            let _ = needs_chunking as fn(&str, usize) -> bool;\n        }\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 105
    },
    {
      "name": "test_chunk_type_exported",
      "qualified_name": "src/semantic/mod.rs::test_chunk_type_exported",
      "file": "src/semantic/mod.rs",
      "line": 179,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_type_exported()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "chunker, extractor, types, types, types",
      "code_preview": "    fn test_chunk_type_exported() {\n        // Verify Chunk type is accessible\n        fn _assert_chunk_type() {\n            let _: Option<Chunk> = None;\n        }\n    }\n",
      "semantic_tags": [
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 39
    },
    {
      "name": "(FunctionRef) matches",
      "qualified_name": "src/callgraph/types.rs::(FunctionRef) matches",
      "file": "src/callgraph/types.rs",
      "line": 19,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionRef) matches(&self, other: &FunctionRef) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn matches(&self, other: &FunctionRef) -> bool {\n        if !self.file.is_empty() && !other.file.is_empty() && self.file != other.file {\n            return false;\n        }\n        self.name == other.name\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 53
    },
    {
      "name": "(CallGraph) build_indexes",
      "qualified_name": "src/callgraph/types.rs::(CallGraph) build_indexes",
      "file": "src/callgraph/types.rs",
      "line": 55,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CallGraph) build_indexes(&mut self)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn build_indexes(&mut self) {\n        self.callers.clear();\n        self.callees.clear();\n\n        for edge in &self.edges {\n            self.callers\n                .entry(edge.callee.clone())\n                .or_default()\n                .insert(edge.caller.clone());\n            self.callees\n                .entry(edge.caller.clone())\n                .or_default()\n                .insert(edge.callee.clone());\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 88
    },
    {
      "name": "(CallGraph) impact",
      "qualified_name": "src/callgraph/types.rs::(CallGraph) impact",
      "file": "src/callgraph/types.rs",
      "line": 72,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CallGraph) impact(&self, target: &FunctionRef, depth: usize) -> HashSet<FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn impact(&self, target: &FunctionRef, depth: usize) -> HashSet<FunctionRef> {\n        let mut result = HashSet::new();\n        let mut frontier: Vec<_> = self\n            .callers\n            .iter()\n            .filter(|(k, _)| k.matches(target))\n            .flat_map(|(_, callers)| callers.iter().cloned())\n            .collect();\n        let mut visited = HashSet::new();\n\n        for _ in 0..depth {\n            let mut next_frontier = Vec::new();\n            for func in frontier {\n                if visited.insert(func.clone()) {\n                    result.insert(func.clone());\n                    if let Some(callers) = self.callers.get(&func) {\n                        for caller in callers {\n                            next_frontier.push(caller.clone());\n                        }\n                    }\n                }\n            }\n            frontier = next_frontier;\n        }\n\n        result\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 7,
        "branches": 2,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 186
    },
    {
      "name": "(CallGraph) get_callees",
      "qualified_name": "src/callgraph/types.rs::(CallGraph) get_callees",
      "file": "src/callgraph/types.rs",
      "line": 101,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CallGraph) get_callees(&self, source: &FunctionRef, depth: usize) -> HashSet<FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn get_callees(&self, source: &FunctionRef, depth: usize) -> HashSet<FunctionRef> {\n        let mut result = HashSet::new();\n        let mut frontier: Vec<_> = self\n            .callees\n            .iter()\n            .filter(|(k, _)| k.matches(source))\n            .flat_map(|(_, callees)| callees.iter().cloned())\n            .collect();\n        let mut visited = HashSet::new();\n\n        for _ in 0..depth {\n            let mut next_frontier = Vec::new();\n            for func in frontier {\n                if visited.insert(func.clone()) {\n                    result.insert(func.clone());\n                    if let Some(callees) = self.callees.get(&func) {\n                        for callee in callees {\n                            next_frontier.push(callee.clone());\n                        }\n                    }\n                }\n            }\n            frontier = next_frontier;\n        }\n\n        result\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 7,
        "branches": 2,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 195
    },
    {
      "name": "(CallGraph) dead_code",
      "qualified_name": "src/callgraph/types.rs::(CallGraph) dead_code",
      "file": "src/callgraph/types.rs",
      "line": 130,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CallGraph) dead_code(&self, entry_points: &[FunctionRef]) -> HashSet<FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn dead_code(&self, entry_points: &[FunctionRef]) -> HashSet<FunctionRef> {\n        let mut reachable = HashSet::new();\n        let mut frontier: Vec<_> = entry_points.iter().cloned().collect();\n\n        while let Some(func) = frontier.pop() {\n            if reachable.insert(func.clone()) {\n                if let Some(callees) = self.callees.get(&func) {\n                    frontier.extend(callees.iter().cloned());\n                }\n            }\n        }\n\n        // All functions minus reachable\n        let all_funcs: HashSet<_> = self\n            .edges\n            .iter()\n            .flat_map(|e| [e.caller.clone(), e.callee.clone()])\n            .collect();\n\n        all_funcs.difference(&reachable).cloned().collect()\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 166
    },
    {
      "name": "(CallGraph) all_functions",
      "qualified_name": "src/callgraph/types.rs::(CallGraph) all_functions",
      "file": "src/callgraph/types.rs",
      "line": 153,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (CallGraph) all_functions(&self) -> HashSet<FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn all_functions(&self) -> HashSet<FunctionRef> {\n        self.edges\n            .iter()\n            .flat_map(|e| [e.caller.clone(), e.callee.clone()])\n            .collect()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 47
    },
    {
      "name": "FunctionRef",
      "qualified_name": "src/callgraph/types.rs::FunctionRef",
      "file": "src/callgraph/types.rs",
      "line": 8,
      "language": "rust",
      "unit_type": "class",
      "signature": "class FunctionRef",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct FunctionRef {\n    /// File containing the function\n    pub file: String,\n    /// Function name\n    pub name: String,\n    /// Fully qualified name (e.g., \"module.Class.method\")\n    pub qualified_name: Option<String>,\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 52
    },
    {
      "name": "CallEdge",
      "qualified_name": "src/callgraph/types.rs::CallEdge",
      "file": "src/callgraph/types.rs",
      "line": 29,
      "language": "rust",
      "unit_type": "class",
      "signature": "class CallEdge",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct CallEdge {\n    /// Calling function\n    pub caller: FunctionRef,\n    /// Called function\n    pub callee: FunctionRef,\n    /// Line number of the call\n    pub call_line: usize,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 45
    },
    {
      "name": "CallGraph",
      "qualified_name": "src/callgraph/types.rs::CallGraph",
      "file": "src/callgraph/types.rs",
      "line": 40,
      "language": "rust",
      "unit_type": "class",
      "signature": "class CallGraph",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct CallGraph {\n    /// All call edges\n    pub edges: Vec<CallEdge>,\n\n    /// Index: callee -> callers (who calls this?)\n    #[serde(skip)]\n    pub callers: HashMap<FunctionRef, HashSet<FunctionRef>>,\n\n    /// Index: caller -> callees (what does this call?)\n    #[serde(skip)]\n    pub callees: HashMap<FunctionRef, HashSet<FunctionRef>>,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 88
    },
    {
      "name": "(FunctionInfo) signature",
      "qualified_name": "src/ast/types.rs::(FunctionInfo) signature",
      "file": "src/ast/types.rs",
      "line": 35,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionInfo) signature(&self) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "serde, std::collections",
      "code_preview": "    pub fn signature(&self) -> String {\n        let async_prefix = if self.is_async { \"async \" } else { \"\" };\n        let params = self.params.join(\", \");\n\n        match self.language.as_str() {\n            \"python\" => {\n                let ret = self\n                    .return_type\n                    .as_ref()\n                    .map(|r| format!(\" -> {}\", r))\n                    .unwrap_or_default();\n                format!(\"{}def {}({}){}\", async_prefix, self.name, params, ret)\n            }\n            \"rust\" => {\n                let ret = self\n                    .return_type\n                    .as_ref()\n                    .map(|r| format!(\" -> {}\", r))\n                    .unwrap_or_default();\n                format!(\"{}fn {}({}){}\", async_prefix, self.name, params, ret)\n            }\n            \"go\" => {\n                let ret = self\n                    .return_type\n                    .as_ref()\n                    .map(|r| format!(\" {}\", r))\n                    .unwrap_or_default();\n                format!(\"func {}({}){}\", self.name, params, ret)\n            }\n            \"typescript\" | \"javascript\" => {\n                let ret = self\n                    .return_type\n                    .as_ref()\n                    .map(|r| format!(\": {}\", r))\n                    .unwrap_or_default();\n                format!(\"{}function {}({}){}\", async_prefix, self.name, params, ret)\n            }\n            \"java\" => {\n                let ret = self.return_type.as_deref().unwrap_or(\"void\");\n                format!(\"{} {}({})\", ret, self.name, params)\n            }\n            \"c\" => {\n                let ret = self.return_type.as_deref().unwrap_or(\"void\");\n                format!(\"{} {}({})\", ret, self.name, params)\n            }\n            _ => format!(\"fn {}({})\", self.name, params),\n        }\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "async_ops",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 382
    },
    {
      "name": "FunctionInfo",
      "qualified_name": "src/ast/types.rs::FunctionInfo",
      "file": "src/ast/types.rs",
      "line": 10,
      "language": "rust",
      "unit_type": "class",
      "signature": "class FunctionInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct FunctionInfo {\n    /// Function name\n    pub name: String,\n    /// Parameter names (with optional type annotations)\n    pub params: Vec<String>,\n    /// Return type annotation if present\n    pub return_type: Option<String>,\n    /// Docstring or doc comment\n    pub docstring: Option<String>,\n    /// Whether this is a method (has self/this)\n    pub is_method: bool,\n    /// Whether this is an async function\n    pub is_async: bool,\n    /// Decorators/attributes applied\n    pub decorators: Vec<String>,\n    /// Starting line number (1-indexed)\n    pub line_number: usize,\n    /// Ending line number (1-indexed)\n    pub end_line_number: Option<usize>,\n    /// Source language\n    pub language: String,\n}\n",
      "semantic_tags": [
        "async_ops",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 164
    },
    {
      "name": "ClassInfo",
      "qualified_name": "src/ast/types.rs::ClassInfo",
      "file": "src/ast/types.rs",
      "line": 87,
      "language": "rust",
      "unit_type": "class",
      "signature": "class ClassInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct ClassInfo {\n    /// Class name\n    pub name: String,\n    /// Base classes / implemented interfaces\n    pub bases: Vec<String>,\n    /// Docstring or doc comment\n    pub docstring: Option<String>,\n    /// Methods defined in this class\n    pub methods: Vec<FunctionInfo>,\n    /// Decorators/attributes applied\n    pub decorators: Vec<String>,\n    /// Starting line number (1-indexed)\n    pub line_number: usize,\n    /// Ending line number (1-indexed)\n    pub end_line_number: Option<usize>,\n    /// Source language\n    pub language: String,\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 127
    },
    {
      "name": "ImportInfo",
      "qualified_name": "src/ast/types.rs::ImportInfo",
      "file": "src/ast/types.rs",
      "line": 108,
      "language": "rust",
      "unit_type": "class",
      "signature": "class ImportInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct ImportInfo {\n    /// Module being imported\n    pub module: String,\n    /// Specific names imported (empty for `import module`)\n    pub names: Vec<String>,\n    /// Aliases (original_name -> alias)\n    pub aliases: HashMap<String, String>,\n    /// Whether this is a `from X import Y` style\n    pub is_from: bool,\n    /// Relative import level (0 for absolute)\n    pub level: usize,\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 93
    },
    {
      "name": "ModuleInfo",
      "qualified_name": "src/ast/types.rs::ModuleInfo",
      "file": "src/ast/types.rs",
      "line": 123,
      "language": "rust",
      "unit_type": "class",
      "signature": "class ModuleInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct ModuleInfo {\n    /// File path\n    pub path: String,\n    /// Detected language\n    pub language: String,\n    /// Top-level functions\n    pub functions: Vec<FunctionInfo>,\n    /// Classes/structs\n    pub classes: Vec<ClassInfo>,\n    /// Import statements\n    pub imports: Vec<ImportInfo>,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 72
    },
    {
      "name": "FileTreeEntry",
      "qualified_name": "src/ast/types.rs::FileTreeEntry",
      "file": "src/ast/types.rs",
      "line": 138,
      "language": "rust",
      "unit_type": "class",
      "signature": "class FileTreeEntry",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct FileTreeEntry {\n    /// File or directory name\n    pub name: String,\n    /// Full path\n    pub path: String,\n    /// Whether this is a directory\n    pub is_dir: bool,\n    /// Children (for directories)\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub children: Vec<FileTreeEntry>,\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 78
    },
    {
      "name": "CodeStructure",
      "qualified_name": "src/ast/types.rs::CodeStructure",
      "file": "src/ast/types.rs",
      "line": 152,
      "language": "rust",
      "unit_type": "class",
      "signature": "class CodeStructure",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct CodeStructure {\n    /// Path analyzed\n    pub path: String,\n    /// Functions found\n    pub functions: Vec<FunctionSummary>,\n    /// Classes found\n    pub classes: Vec<ClassSummary>,\n    /// Total files analyzed\n    pub file_count: usize,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 57
    },
    {
      "name": "FunctionSummary",
      "qualified_name": "src/ast/types.rs::FunctionSummary",
      "file": "src/ast/types.rs",
      "line": 165,
      "language": "rust",
      "unit_type": "class",
      "signature": "class FunctionSummary",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct FunctionSummary {\n    pub name: String,\n    pub file: String,\n    pub line: usize,\n    pub signature: String,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 30
    },
    {
      "name": "ClassSummary",
      "qualified_name": "src/ast/types.rs::ClassSummary",
      "file": "src/ast/types.rs",
      "line": 174,
      "language": "rust",
      "unit_type": "class",
      "signature": "class ClassSummary",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "serde, std::collections",
      "code_preview": "pub struct ClassSummary {\n    pub name: String,\n    pub file: String,\n    pub line: usize,\n    pub method_count: usize,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 31
    },
    {
      "name": "file_tree",
      "qualified_name": "src/ast/tree.rs::file_tree",
      "file": "src/ast/tree.rs",
      "line": 63,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn file_tree(path: &str, ext_filter: Option<&str>) -> Result<FileTreeEntry>",
      "docstring": "",
      "calls": [
        "build_tree_from_map"
      ],
      "called_by": [
        "test_sorting_dirs_first",
        "test_file_tree_no_filter",
        "test_file_tree_with_extension_filter",
        "test_tree_structure_is_hierarchical"
      ],
      "cfg_summary": "complexity:10, blocks:22",
      "dfg_summary": "vars:37, def-use chains:31",
      "dependencies": "std::collections, std::path, ignore, crate::ast::types, crate::error",
      "code_preview": "pub fn file_tree(path: &str, ext_filter: Option<&str>) -> Result<FileTreeEntry> {\n    let root_path = Path::new(path)\n        .canonicalize()\n        .map_err(|e| crate::error::TldrError::Io(e))?;\n\n    // Phase 1: Collect all paths allowed by gitignore/tldrignore using the walker.\n    // This is efficient because the ignore crate handles all pattern matching.\n    let walker = WalkBuilder::new(&root_path)\n        .add_custom_ignore_filename(\".tldrignore\")\n        .hidden(false) // Don't skip hidden by default (we filter manually)\n        .build();\n\n    // Collect paths and build parent->children mapping in one pass\n    let mut children_map: HashMap<PathBuf, Vec<PathBuf>> = HashMap::new();\n    let mut is_dir_set: HashSet<PathBuf> = HashSet::new();\n\n    for result in walker {\n        let entry = match result {\n            Ok(e) => e,\n            Err(_) => continue,\n        };\n\n        let entry_path = entry.path().to_path_buf();\n\n        // Skip root itself (we'll handle it as the return value)\n        if entry_path == root_path {\n            is_dir_set.insert(entry_path);\n            continue;\n        }\n\n        // Get relative path for filtering\n        let rel_path = match entry_path.strip_prefix(&root_path) {\n            Ok(p) => p,\n            Err(_) => continue,\n        };\n\n        // Skip default directories\n        if rel_path\n            .components()\n            .any(|c| DEFAULT_SKIP_DIRS.contains(&c.as_os_str().to_str().unwrap_or(\"\")))\n        {\n            continue;\n        }\n\n        // Skip hidden files/directories (those starting with '.')\n        if rel_path.components().any(|c| {\n            c.as_os_str()\n                .to_str()\n                .map(|s| s.starts_with('.'))\n                .unwrap_or(false)\n        }) {\n            continue;\n        }\n\n        let is_directory = entry_path.is_dir();\n\n        // For files, apply extension filter\n        if !is_directory {\n            if let Some(ext) = ext_filter {\n                let matches = entry_path\n                    .extension()\n                    .and_then(|e| e.to_str())\n                    .map(|e| format!(\".{}\", e) == ext)\n                    .unwrap_or(false);\n                if !matches {\n                    continue;\n                }\n            }\n        }\n\n        // Track directory status\n        if is_directory {\n            is_dir_set.insert(entry_path.clone());\n        }\n\n        // Add to parent's children list\n        if let Some(parent) = entry_path.parent() {\n            children_map\n                .entry(parent.to_path_buf())\n                .or_default()\n                .push(entry_path);\n        }\n    }\n\n    // Phase 2: Build the tree recursively from the children map.\n    // This handles the \"prune empty directories\" logic for extension filtering.\n    let tree = build_tree_from_map(\n        &root_path,\n        &root_path,\n        &mut children_map,\n        &is_dir_set,\n        ext_filter.is_some(),\n    );\n\n    match tree {\n        Some(t) => Ok(t),\n        None => {\n            // Return empty root if nothing matches filter\n            Ok(FileTreeEntry {\n                name: root_path\n                    .file_name()\n                    .and_then(|n| n.to_str())\n                    .unwrap_or(\".\")\n                    .to_string(),\n                path: path.to_string(),\n                is_dir: true,\n                children: vec![],\n            })\n        }\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "logging",
        "error_handling",
        "api_endpoint",
        "iteration",
        "config",
        "test",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 12,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 728
    },
    {
      "name": "build_tree_from_map",
      "qualified_name": "src/ast/tree.rs::build_tree_from_map",
      "file": "src/ast/tree.rs",
      "line": 179,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn build_tree_from_map(path: &Path, root: &Path, children_map: &mut HashMap<PathBuf, Vec<PathBuf>>, is_dir_set: &HashSet<PathBuf>, has_filter: bool) -> Option<FileTreeEntry>",
      "docstring": "",
      "calls": [
        "build_tree_from_map"
      ],
      "called_by": [
        "build_tree_from_map",
        "file_tree"
      ],
      "cfg_summary": "complexity:6, blocks:13",
      "dfg_summary": "vars:27, def-use chains:31",
      "dependencies": "std::collections, std::path, ignore, crate::ast::types, crate::error",
      "code_preview": "fn build_tree_from_map(\n    path: &Path,\n    root: &Path,\n    children_map: &mut HashMap<PathBuf, Vec<PathBuf>>,\n    is_dir_set: &HashSet<PathBuf>,\n    has_filter: bool,\n) -> Option<FileTreeEntry> {\n    let is_directory = is_dir_set.contains(path);\n\n    // For files, just return the entry\n    if !is_directory {\n        let name = path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .unwrap_or(\"\")\n            .to_string();\n\n        let rel_path = path\n            .strip_prefix(root)\n            .map(|p| p.display().to_string())\n            .unwrap_or_default();\n\n        return Some(FileTreeEntry {\n            name,\n            path: rel_path,\n            is_dir: false,\n            children: vec![],\n        });\n    }\n\n    // For directories, recursively process children\n    let child_paths = children_map.remove(path).unwrap_or_default();\n    let mut children: Vec<FileTreeEntry> = Vec::with_capacity(child_paths.len());\n\n    for child_path in child_paths {\n        if let Some(child_entry) =\n            build_tree_from_map(&child_path, root, children_map, is_dir_set, has_filter)\n        {\n            children.push(child_entry);\n        }\n    }\n\n    // Sort: directories first, then alphabetically by name (case-insensitive)\n    children.sort_by(|a, b| match (a.is_dir, b.is_dir) {\n        (true, false) => std::cmp::Ordering::Less,\n        (false, true) => std::cmp::Ordering::Greater,\n        _ => a.name.to_lowercase().cmp(&b.name.to_lowercase()),\n    });\n\n    // Prune empty directories when filter is active (matches Python behavior)\n    if has_filter && children.is_empty() && path != root {\n        return None;\n    }\n\n    let name = path\n        .file_name()\n        .and_then(|n| n.to_str())\n        .unwrap_or(\".\")\n        .to_string();\n\n    let rel_path = if path == root {\n        path.display().to_string()\n    } else {\n        path.strip_prefix(root)\n            .map(|p| p.display().to_string())\n            .unwrap_or_default()\n    };\n\n    Some(FileTreeEntry {\n        name,\n        path: rel_path,\n        is_dir: true,\n        children,\n    })\n}\n",
      "semantic_tags": [
        "crud",
        "async_ops",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 7,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 497
    },
    {
      "name": "create_test_tree",
      "qualified_name": "src/ast/tree.rs::create_test_tree",
      "file": "src/ast/tree.rs",
      "line": 262,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_test_tree() -> TempDir",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_file_tree_with_extension_filter",
        "test_tree_structure_is_hierarchical",
        "test_sorting_dirs_first",
        "test_file_tree_no_filter"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:13",
      "dependencies": "std::collections, std::path, ignore, crate::ast::types, crate::error",
      "code_preview": "    fn create_test_tree() -> TempDir {\n        let temp_dir = TempDir::new().unwrap();\n        let root = temp_dir.path();\n\n        // Create directory structure:\n        // root/\n        //   src/\n        //     main.py\n        //     utils.py\n        //   tests/\n        //     test_main.py\n        //   docs/\n        //     README.md\n        //   .hidden/\n        //     secret.py\n        //   node_modules/\n        //     package/\n        //       index.js\n\n        fs::create_dir_all(root.join(\"src\")).unwrap();\n        fs::create_dir_all(root.join(\"tests\")).unwrap();\n        fs::create_dir_all(root.join(\"docs\")).unwrap();\n        fs::create_dir_all(root.join(\".hidden\")).unwrap();\n        fs::create_dir_all(root.join(\"node_modules/package\")).unwrap();\n\n        File::create(root.join(\"src/main.py\"))\n            .unwrap()\n            .write_all(b\"print('hello')\")\n            .unwrap();\n        File::create(root.join(\"src/utils.py\"))\n            .unwrap()\n            .write_all(b\"# utils\")\n            .unwrap();\n        File::create(root.join(\"tests/test_main.py\"))\n            .unwrap()\n            .write_all(b\"# tests\")\n            .unwrap();\n        File::create(root.join(\"docs/README.md\"))\n            .unwrap()\n            .write_all(b\"# README\")\n            .unwrap();\n        File::create(root.join(\".hidden/secret.py\"))\n            .unwrap()\n            .write_all(b\"# secret\")\n            .unwrap();\n        File::create(root.join(\"node_modules/package/index.js\"))\n            .unwrap()\n            .write_all(b\"// index\")\n            .unwrap();\n\n        temp_dir\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "logging"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 352
    },
    {
      "name": "test_file_tree_no_filter",
      "qualified_name": "src/ast/tree.rs::test_file_tree_no_filter",
      "file": "src/ast/tree.rs",
      "line": 316,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_file_tree_no_filter()",
      "docstring": "",
      "calls": [
        "file_tree",
        "create_test_tree"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:9",
      "dependencies": "std::collections, std::path, ignore, crate::ast::types, crate::error",
      "code_preview": "    fn test_file_tree_no_filter() {\n        let temp_dir = create_test_tree();\n        let tree = file_tree(temp_dir.path().to_str().unwrap(), None).unwrap();\n\n        assert!(tree.is_dir);\n        assert!(!tree.children.is_empty());\n\n        // Should have src, tests, docs but NOT .hidden or node_modules\n        let child_names: Vec<&str> = tree.children.iter().map(|c| c.name.as_str()).collect();\n        assert!(child_names.contains(&\"src\"));\n        assert!(child_names.contains(&\"tests\"));\n        assert!(child_names.contains(&\"docs\"));\n        assert!(!child_names.contains(&\".hidden\"));\n        assert!(!child_names.contains(&\"node_modules\"));\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 150
    },
    {
      "name": "test_file_tree_with_extension_filter",
      "qualified_name": "src/ast/tree.rs::test_file_tree_with_extension_filter",
      "file": "src/ast/tree.rs",
      "line": 333,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_file_tree_with_extension_filter()",
      "docstring": "",
      "calls": [
        "file_tree",
        "create_test_tree"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:6",
      "dependencies": "std::collections, std::path, ignore, crate::ast::types, crate::error",
      "code_preview": "    fn test_file_tree_with_extension_filter() {\n        let temp_dir = create_test_tree();\n        let tree = file_tree(temp_dir.path().to_str().unwrap(), Some(\".py\")).unwrap();\n\n        assert!(tree.is_dir);\n\n        // Should have src and tests (contain .py files) but NOT docs (only .md)\n        let child_names: Vec<&str> = tree.children.iter().map(|c| c.name.as_str()).collect();\n        assert!(child_names.contains(&\"src\"));\n        assert!(child_names.contains(&\"tests\"));\n        assert!(!child_names.contains(&\"docs\")); // Pruned because no .py files\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 135
    },
    {
      "name": "test_tree_structure_is_hierarchical",
      "qualified_name": "src/ast/tree.rs::test_tree_structure_is_hierarchical",
      "file": "src/ast/tree.rs",
      "line": 347,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_tree_structure_is_hierarchical()",
      "docstring": "",
      "calls": [
        "file_tree",
        "create_test_tree"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:7",
      "dependencies": "std::collections, std::path, ignore, crate::ast::types, crate::error",
      "code_preview": "    fn test_tree_structure_is_hierarchical() {\n        let temp_dir = create_test_tree();\n        let tree = file_tree(temp_dir.path().to_str().unwrap(), None).unwrap();\n\n        // Find src directory\n        let src_dir = tree.children.iter().find(|c| c.name == \"src\").unwrap();\n        assert!(src_dir.is_dir);\n        assert!(!src_dir.children.is_empty());\n\n        // src should contain main.py and utils.py\n        let src_files: Vec<&str> = src_dir.children.iter().map(|c| c.name.as_str()).collect();\n        assert!(src_files.contains(&\"main.py\"));\n        assert!(src_files.contains(&\"utils.py\"));\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 144
    },
    {
      "name": "test_sorting_dirs_first",
      "qualified_name": "src/ast/tree.rs::test_sorting_dirs_first",
      "file": "src/ast/tree.rs",
      "line": 363,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_sorting_dirs_first()",
      "docstring": "",
      "calls": [
        "file_tree",
        "create_test_tree"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:7",
      "dependencies": "std::collections, std::path, ignore, crate::ast::types, crate::error",
      "code_preview": "    fn test_sorting_dirs_first() {\n        let temp_dir = create_test_tree();\n\n        // Add a file at root level\n        File::create(temp_dir.path().join(\"setup.py\"))\n            .unwrap()\n            .write_all(b\"# setup\")\n            .unwrap();\n\n        let tree = file_tree(temp_dir.path().to_str().unwrap(), None).unwrap();\n\n        // Directories should come before files\n        let first_file_idx = tree\n            .children\n            .iter()\n            .position(|c| !c.is_dir)\n            .unwrap_or(tree.children.len());\n        let last_dir_idx = tree.children.iter().rposition(|c| c.is_dir).unwrap_or(0);\n\n        assert!(\n            last_dir_idx < first_file_idx,\n            \"Directories should come before files\"\n        );\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "validation",
        "test"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 167
    },
    {
      "name": "normalize_path",
      "qualified_name": "src/util/path.rs::normalize_path",
      "file": "src/util/path.rs",
      "line": 33,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn normalize_path(path: &Path) -> PathBuf",
      "docstring": "",
      "calls": [],
      "called_by": [
        "get_project_root",
        "relative_to",
        "test_normalize_path_relative"
      ],
      "cfg_summary": "complexity:5, blocks:10",
      "dfg_summary": "vars:15, def-use chains:11",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "pub fn normalize_path(path: &Path) -> PathBuf {\n    // Try canonicalization first (resolves symlinks and relative components)\n    if let Ok(canonical) = path.canonicalize() {\n        return canonical;\n    }\n\n    // Fallback: manually clean the path without requiring existence\n    let mut result = PathBuf::new();\n    let is_absolute = path.is_absolute();\n\n    for component in path.components() {\n        match component {\n            std::path::Component::CurDir => {\n                // Skip \".\" components\n            }\n            std::path::Component::ParentDir => {\n                // Pop last component for \"..\"\n                result.pop();\n            }\n            _ => {\n                result.push(component);\n            }\n        }\n    }\n\n    // Ensure absolute paths stay absolute\n    if is_absolute && !result.is_absolute() {\n        if let Ok(cwd) = std::env::current_dir() {\n            return cwd.join(result);\n        }\n    }\n\n    result\n}\n",
      "semantic_tags": [
        "validation",
        "error_handling",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 4,
        "branches": 4,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 201
    },
    {
      "name": "relative_to",
      "qualified_name": "src/util/path.rs::relative_to",
      "file": "src/util/path.rs",
      "line": 95,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn relative_to(target: &Path, base: &Path) -> PathBuf",
      "docstring": "",
      "calls": [
        "normalize_path"
      ],
      "called_by": [
        "test_relative_to_not_under_base",
        "test_relative_to_simple"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:8, def-use chains:5",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "pub fn relative_to(target: &Path, base: &Path) -> PathBuf {\n    // Normalize both paths for consistent comparison\n    let target_norm = normalize_path(target);\n    let base_norm = normalize_path(base);\n\n    // Try strip_prefix for simple case\n    if let Ok(relative) = target_norm.strip_prefix(&base_norm) {\n        return relative.to_path_buf();\n    }\n\n    // Paths don't share a prefix, return target as-is\n    target.to_path_buf()\n}\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "error_handling"
      ],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 100
    },
    {
      "name": "is_source_file",
      "qualified_name": "src/util/path.rs::is_source_file",
      "file": "src/util/path.rs",
      "line": 134,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_source_file(path: &Path) -> bool",
      "docstring": "",
      "calls": [
        "detect_language"
      ],
      "called_by": [],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "pub fn is_source_file(path: &Path) -> bool {\n    // Must be a file (or at least have a file-like name)\n    if path.is_dir() {\n        return false;\n    }\n\n    // Check extension against language registry\n    let registry = LanguageRegistry::global();\n    registry.detect_language(path).is_some()\n}\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 69
    },
    {
      "name": "get_project_root",
      "qualified_name": "src/util/path.rs::get_project_root",
      "file": "src/util/path.rs",
      "line": 201,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_project_root(path: &Path) -> Option<PathBuf>",
      "docstring": "",
      "calls": [
        "normalize_path"
      ],
      "called_by": [
        "test_get_project_root_with_git",
        "test_get_project_root_not_found",
        "test_get_project_root_with_cargo"
      ],
      "cfg_summary": "complexity:6, blocks:14",
      "dfg_summary": "vars:10, def-use chains:8",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "pub fn get_project_root(path: &Path) -> Option<PathBuf> {\n    // Normalize the starting path\n    let start = normalize_path(path);\n\n    // If it's a file, start from its parent directory\n    let mut current = if start.is_file() {\n        start.parent()?.to_path_buf()\n    } else {\n        start\n    };\n\n    // Walk up the directory tree\n    loop {\n        // Check for any project marker\n        for marker in PROJECT_MARKERS {\n            if current.join(marker).exists() {\n                return Some(current);\n            }\n        }\n\n        // Move to parent directory\n        match current.parent() {\n            Some(parent) => {\n                if parent == current {\n                    // Reached root without finding markers\n                    break;\n                }\n                current = parent.to_path_buf();\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "config",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 5,
        "branches": 5,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 179
    },
    {
      "name": "detect_language",
      "qualified_name": "src/util/path.rs::detect_language",
      "file": "src/util/path.rs",
      "line": 250,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn detect_language(path: &Path) -> Option<&'static str>",
      "docstring": "",
      "calls": [
        "get_by_extension",
        "detect_language"
      ],
      "called_by": [
        "detect_language",
        "is_source_file"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:2",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "pub fn detect_language(path: &Path) -> Option<&'static str> {\n    let registry = LanguageRegistry::global();\n    registry.detect_language(path).map(|lang| lang.name())\n}\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 40
    },
    {
      "name": "test_normalize_path_relative",
      "qualified_name": "src/util/path.rs::test_normalize_path_relative",
      "file": "src/util/path.rs",
      "line": 266,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_normalize_path_relative()",
      "docstring": "",
      "calls": [
        "normalize_path"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:3",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "    fn test_normalize_path_relative() {\n        let path = Path::new(\"./src/../src/main.rs\");\n        let normalized = normalize_path(path);\n        // Should remove . and .. components\n        assert!(!normalized.to_string_lossy().contains(\"./\"));\n        assert!(!normalized.to_string_lossy().contains(\"..\"));\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 67
    },
    {
      "name": "test_relative_to_simple",
      "qualified_name": "src/util/path.rs::test_relative_to_simple",
      "file": "src/util/path.rs",
      "line": 275,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_relative_to_simple()",
      "docstring": "",
      "calls": [
        "relative_to"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "    fn test_relative_to_simple() {\n        let target = Path::new(\"/home/user/project/src/main.rs\");\n        let base = Path::new(\"/home/user/project\");\n        let rel = relative_to(target, base);\n        assert_eq!(rel, Path::new(\"src/main.rs\"));\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 61
    },
    {
      "name": "test_relative_to_not_under_base",
      "qualified_name": "src/util/path.rs::test_relative_to_not_under_base",
      "file": "src/util/path.rs",
      "line": 283,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_relative_to_not_under_base()",
      "docstring": "",
      "calls": [
        "relative_to"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "    fn test_relative_to_not_under_base() {\n        let target = Path::new(\"/other/path/file.rs\");\n        let base = Path::new(\"/home/user/project\");\n        let rel = relative_to(target, base);\n        // Should return original path when not relative\n        assert_eq!(rel, Path::new(\"/other/path/file.rs\"));\n    }\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 72
    },
    {
      "name": "test_is_source_file",
      "qualified_name": "src/util/path.rs::test_is_source_file",
      "file": "src/util/path.rs",
      "line": 292,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_is_source_file()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:0",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "    fn test_is_source_file() {\n        assert!(is_source_file(Path::new(\"main.py\")));\n        assert!(is_source_file(Path::new(\"app.ts\")));\n        assert!(is_source_file(Path::new(\"lib.rs\")));\n        assert!(is_source_file(Path::new(\"Main.java\")));\n        assert!(is_source_file(Path::new(\"main.go\")));\n        assert!(is_source_file(Path::new(\"util.c\")));\n\n        assert!(!is_source_file(Path::new(\"readme.md\")));\n        assert!(!is_source_file(Path::new(\"config.json\")));\n        assert!(!is_source_file(Path::new(\"data.xml\")));\n        assert!(!is_source_file(Path::new(\"image.png\")));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 145
    },
    {
      "name": "test_get_project_root_with_git",
      "qualified_name": "src/util/path.rs::test_get_project_root_with_git",
      "file": "src/util/path.rs",
      "line": 307,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_get_project_root_with_git()",
      "docstring": "",
      "calls": [
        "get_project_root"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:17, def-use chains:9",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "    fn test_get_project_root_with_git() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_dir = temp_dir.path().join(\"project\");\n        let src_dir = project_dir.join(\"src\");\n        fs::create_dir_all(&src_dir).unwrap();\n        fs::create_dir(project_dir.join(\".git\")).unwrap();\n\n        let file_path = src_dir.join(\"main.rs\");\n        fs::write(&file_path, \"fn main() {}\").unwrap();\n\n        let root = get_project_root(&file_path);\n        assert!(root.is_some());\n        assert_eq!(root.unwrap().file_name().unwrap(), \"project\");\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 134
    },
    {
      "name": "test_get_project_root_with_cargo",
      "qualified_name": "src/util/path.rs::test_get_project_root_with_cargo",
      "file": "src/util/path.rs",
      "line": 323,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_get_project_root_with_cargo()",
      "docstring": "",
      "calls": [
        "get_project_root"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:6",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "    fn test_get_project_root_with_cargo() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_dir = temp_dir.path().join(\"rust_project\");\n        fs::create_dir_all(&project_dir).unwrap();\n        fs::write(project_dir.join(\"Cargo.toml\"), \"[package]\\nname = \\\"test\\\"\").unwrap();\n\n        let root = get_project_root(&project_dir);\n        assert!(root.is_some());\n        assert_eq!(root.unwrap().file_name().unwrap(), \"rust_project\");\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 109
    },
    {
      "name": "test_get_project_root_not_found",
      "qualified_name": "src/util/path.rs::test_get_project_root_not_found",
      "file": "src/util/path.rs",
      "line": 335,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_get_project_root_not_found()",
      "docstring": "",
      "calls": [
        "get_project_root"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:17, def-use chains:8",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "    fn test_get_project_root_not_found() {\n        let temp_dir = TempDir::new().unwrap();\n        let orphan_dir = temp_dir.path().join(\"no_markers\");\n        fs::create_dir_all(&orphan_dir).unwrap();\n\n        // Create a file but no project markers\n        let file_path = orphan_dir.join(\"orphan.rs\");\n        fs::write(&file_path, \"fn main() {}\").unwrap();\n\n        // Note: This might find markers in parent directories on real systems\n        // For isolation, we test with the temp dir root\n        let root = get_project_root(temp_dir.path());\n        // Should be None since temp dir has no markers\n        assert!(root.is_none() || root.as_ref().map(|p| p != temp_dir.path()).unwrap_or(true));\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 167
    },
    {
      "name": "test_detect_language",
      "qualified_name": "src/util/path.rs::test_detect_language",
      "file": "src/util/path.rs",
      "line": 352,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_detect_language()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:0",
      "dependencies": "std::path, crate::lang, super, std, tempfile",
      "code_preview": "    fn test_detect_language() {\n        assert_eq!(detect_language(Path::new(\"main.py\")), Some(\"python\"));\n        assert_eq!(detect_language(Path::new(\"app.ts\")), Some(\"typescript\"));\n        assert_eq!(detect_language(Path::new(\"lib.rs\")), Some(\"rust\"));\n        assert_eq!(detect_language(Path::new(\"main.go\")), Some(\"go\"));\n        assert_eq!(detect_language(Path::new(\"Main.java\")), Some(\"java\"));\n        assert_eq!(detect_language(Path::new(\"util.c\")), Some(\"c\"));\n\n        assert_eq!(detect_language(Path::new(\"readme.md\")), None);\n        assert_eq!(detect_language(Path::new(\"config.json\")), None);\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 142
    },
    {
      "name": "build",
      "qualified_name": "src/callgraph/mod.rs::build",
      "file": "src/callgraph/mod.rs",
      "line": 46,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn build(path: &str) -> Result<CallGraph>",
      "docstring": "",
      "calls": [
        "new",
        "process_block",
        "compute_def_use_chains",
        "extract_params",
        "visit_node"
      ],
      "called_by": [
        "test_build_index_python",
        "test_class_indexed_for_constructors",
        "test_build_index_typescript",
        "Language.build_dfg",
        "build_dfg"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:6",
      "dependencies": "dead, impact, indexer, resolver, scanner",
      "code_preview": "pub fn build(path: &str) -> Result<CallGraph> {\n    let scanner = scanner::ProjectScanner::new(path)?;\n    let files = scanner.scan_files()?;\n    let index = indexer::FunctionIndex::build(&files)?;\n    let graph = resolver::resolve_calls(&files, &index)?;\n    Ok(graph)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 67
    },
    {
      "name": "impact",
      "qualified_name": "src/callgraph/mod.rs::impact",
      "file": "src/callgraph/mod.rs",
      "line": 58,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn impact(path: &str, function: &str, depth: usize) -> Result<Vec<FunctionRef>>",
      "docstring": "",
      "calls": [
        "analyze_impact",
        "matches",
        "build"
      ],
      "called_by": [
        "cmd_impact",
        "get_impact"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:5",
      "dependencies": "dead, impact, indexer, resolver, scanner",
      "code_preview": "pub fn impact(path: &str, function: &str, depth: usize) -> Result<Vec<FunctionRef>> {\n    let graph = build(path)?;\n    let config = ImpactConfig::new().with_depth(depth);\n    let result = analyze_impact(&graph, function, config);\n\n    // Convert CallerInfo back to FunctionRef for backward compatibility\n    Ok(result\n        .callers\n        .into_iter()\n        .map(|c| FunctionRef {\n            file: c.file,\n            name: c.name,\n            qualified_name: c.qualified_name,\n        })\n        .collect())\n}\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 123
    },
    {
      "name": "impact_full",
      "qualified_name": "src/callgraph/mod.rs::impact_full",
      "file": "src/callgraph/mod.rs",
      "line": 85,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn impact_full(path: &str, function: &str, config: ImpactConfig) -> Result<ImpactResult>",
      "docstring": "",
      "calls": [
        "analyze_impact",
        "build"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:3",
      "dependencies": "dead, impact, indexer, resolver, scanner",
      "code_preview": "pub fn impact_full(path: &str, function: &str, config: ImpactConfig) -> Result<ImpactResult> {\n    let graph = build(path)?;\n    Ok(analyze_impact(&graph, function, config))\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 48
    },
    {
      "name": "dead_code",
      "qualified_name": "src/callgraph/mod.rs::dead_code",
      "file": "src/callgraph/mod.rs",
      "line": 95,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn dead_code(path: &str) -> Result<Vec<FunctionRef>>",
      "docstring": "",
      "calls": [
        "analyze_dead_code_full"
      ],
      "called_by": [
        "find_dead_code",
        "cmd_dead"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:2",
      "dependencies": "dead, impact, indexer, resolver, scanner",
      "code_preview": "pub fn dead_code(path: &str) -> Result<Vec<FunctionRef>> {\n    let result = analyze_dead_code_full(path, DeadCodeConfig::default())?;\n\n    // Convert DeadFunction back to FunctionRef for backward compatibility\n    Ok(result\n        .dead_functions\n        .into_iter()\n        .map(|d| FunctionRef {\n            file: d.file,\n            name: d.name,\n            qualified_name: d.qualified_name,\n        })\n        .collect())\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 98
    },
    {
      "name": "analyze_dead_code_full",
      "qualified_name": "src/callgraph/mod.rs::analyze_dead_code_full",
      "file": "src/callgraph/mod.rs",
      "line": 119,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn analyze_dead_code_full(path: &str, config: DeadCodeConfig) -> Result<DeadCodeResult>",
      "docstring": "",
      "calls": [
        "analyze_dead_code_with_config",
        "build"
      ],
      "called_by": [
        "dead_code"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:4",
      "dependencies": "dead, impact, indexer, resolver, scanner",
      "code_preview": "pub fn analyze_dead_code_full(path: &str, config: DeadCodeConfig) -> Result<DeadCodeResult> {\n    let mut graph = build(path)?;\n    graph.build_indexes();\n    Ok(dead::analyze_dead_code_with_config(&graph, &config))\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 54
    },
    {
      "name": "warm",
      "qualified_name": "src/callgraph/mod.rs::warm",
      "file": "src/callgraph/mod.rs",
      "line": 126,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn warm(path: &str, _langs: Option<&[String]>) -> Result<()>",
      "docstring": "",
      "calls": [
        "build"
      ],
      "called_by": [
        "cmd_warm",
        "warm_callgraph"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:1",
      "dependencies": "dead, impact, indexer, resolver, scanner",
      "code_preview": "pub fn warm(path: &str, _langs: Option<&[String]>) -> Result<()> {\n    // Build and cache the call graph\n    let _graph = build(path)?;\n    // TODO: Persist to cache\n    Ok(())\n}\n",
      "semantic_tags": [
        "crud",
        "cache",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 50
    },
    {
      "name": "get_context",
      "qualified_name": "src/callgraph/mod.rs::get_context",
      "file": "src/callgraph/mod.rs",
      "line": 134,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_context(project: &str, entry_point: &str, depth: usize) -> Result<serde_json::Value>",
      "docstring": "",
      "calls": [
        "build",
        "get_context"
      ],
      "called_by": [
        "get_context",
        "cmd_context"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:20, def-use chains:9",
      "dependencies": "dead, impact, indexer, resolver, scanner",
      "code_preview": "pub fn get_context(project: &str, entry_point: &str, depth: usize) -> Result<serde_json::Value> {\n    let graph = build(project)?;\n    let target = FunctionRef {\n        file: String::new(),\n        name: entry_point.to_string(),\n        qualified_name: None,\n    };\n\n    let callees = graph.get_callees(&target, depth);\n\n    Ok(serde_json::json!({\n        \"entry_point\": entry_point,\n        \"depth\": depth,\n        \"functions\": callees.iter().map(|f| &f.name).collect::<Vec<_>>(),\n        \"count\": callees.len()\n    }))\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 136
    },
    {
      "name": "(SliceCriteria) at_line",
      "qualified_name": "src/dfg/slice.rs::(SliceCriteria) at_line",
      "file": "src/dfg/slice.rs",
      "line": 30,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (SliceCriteria) at_line(line: usize) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    pub fn at_line(line: usize) -> Self {\n        Self {\n            line,\n            variable: None,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 27
    },
    {
      "name": "(SliceCriteria) at_line_variable",
      "qualified_name": "src/dfg/slice.rs::(SliceCriteria) at_line_variable",
      "file": "src/dfg/slice.rs",
      "line": 39,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (SliceCriteria) at_line_variable(line: usize, variable: impl Into<String>) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    pub fn at_line_variable(line: usize, variable: impl Into<String>) -> Self {\n        Self {\n            line,\n            variable: Some(variable.into()),\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 36
    },
    {
      "name": "(SliceResult) contains_line",
      "qualified_name": "src/dfg/slice.rs::(SliceResult) contains_line",
      "file": "src/dfg/slice.rs",
      "line": 98,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (SliceResult) contains_line(&self, line: usize) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    pub fn contains_line(&self, line: usize) -> bool {\n        self.lines.binary_search(&line).is_ok()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 28
    },
    {
      "name": "(SliceResult) line_range",
      "qualified_name": "src/dfg/slice.rs::(SliceResult) line_range",
      "file": "src/dfg/slice.rs",
      "line": 103,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (SliceResult) line_range(&self) -> Option<(usize, usize)>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    pub fn line_range(&self) -> Option<(usize, usize)> {\n        if self.lines.is_empty() {\n            None\n        } else {\n            Some((self.lines[0], *self.lines.last().unwrap()))\n        }\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 50
    },
    {
      "name": "(SliceResult) is_empty",
      "qualified_name": "src/dfg/slice.rs::(SliceResult) is_empty",
      "file": "src/dfg/slice.rs",
      "line": 113,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (SliceResult) is_empty(&self) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    pub fn is_empty(&self) -> bool {\n        self.lines.is_empty()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 19
    },
    {
      "name": "backward_slice",
      "qualified_name": "src/dfg/slice.rs::backward_slice",
      "file": "src/dfg/slice.rs",
      "line": 140,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn backward_slice(dfg: &DFGInfo, criteria: &SliceCriteria) -> SliceResult",
      "docstring": "",
      "calls": [
        "collect_slice_variables",
        "compute_function_line_range",
        "count_edges_in_slice",
        "backward_slice_variable_impl",
        "backward_slice_all"
      ],
      "called_by": [
        "test_empty_dfg_slice",
        "test_slice_result_line_range",
        "test_slice_with_variable_filter_criteria",
        "bidirectional_slice",
        "test_backward_slice_from_return"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:17, def-use chains:22",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "pub fn backward_slice(dfg: &DFGInfo, criteria: &SliceCriteria) -> SliceResult {\n    let lines = if let Some(ref var) = criteria.variable {\n        backward_slice_variable_impl(dfg, criteria.line, var)\n    } else {\n        backward_slice_all(dfg, criteria.line)\n    };\n\n    // Collect variables involved in the slice\n    let variables = collect_slice_variables(dfg, &lines);\n\n    // Compute metrics\n    let function_line_range = compute_function_line_range(dfg);\n    let total_lines = function_line_range\n        .map(|(min, max)| max - min + 1)\n        .unwrap_or(1);\n    let edges_traversed = count_edges_in_slice(dfg, &lines);\n\n    let metrics = SliceMetrics {\n        slice_size: lines.len(),\n        edges_traversed,\n        slice_ratio: lines.len() as f64 / total_lines as f64,\n        variable_count: variables.len(),\n    };\n\n    SliceResult {\n        function_name: dfg.function_name.clone(),\n        target_line: criteria.line,\n        direction: \"backward\".to_string(),\n        lines,\n        variables,\n        variable_filter: criteria.variable.clone(),\n        metrics,\n    }\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 252
    },
    {
      "name": "forward_slice",
      "qualified_name": "src/dfg/slice.rs::forward_slice",
      "file": "src/dfg/slice.rs",
      "line": 197,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn forward_slice(dfg: &DFGInfo, criteria: &SliceCriteria) -> SliceResult",
      "docstring": "",
      "calls": [
        "compute_function_line_range",
        "forward_slice_all",
        "forward_slice_variable_impl",
        "collect_slice_variables",
        "count_edges_in_slice"
      ],
      "called_by": [
        "get_forward_slice_result",
        "test_forward_slice_from_middle",
        "test_forward_slice_from_start",
        "bidirectional_slice"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:17, def-use chains:22",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "pub fn forward_slice(dfg: &DFGInfo, criteria: &SliceCriteria) -> SliceResult {\n    let lines = if let Some(ref var) = criteria.variable {\n        forward_slice_variable_impl(dfg, criteria.line, var)\n    } else {\n        forward_slice_all(dfg, criteria.line)\n    };\n\n    // Collect variables involved in the slice\n    let variables = collect_slice_variables(dfg, &lines);\n\n    // Compute metrics\n    let function_line_range = compute_function_line_range(dfg);\n    let total_lines = function_line_range\n        .map(|(min, max)| max - min + 1)\n        .unwrap_or(1);\n    let edges_traversed = count_edges_in_slice(dfg, &lines);\n\n    let metrics = SliceMetrics {\n        slice_size: lines.len(),\n        edges_traversed,\n        slice_ratio: lines.len() as f64 / total_lines as f64,\n        variable_count: variables.len(),\n    };\n\n    SliceResult {\n        function_name: dfg.function_name.clone(),\n        target_line: criteria.line,\n        direction: \"forward\".to_string(),\n        lines,\n        variables,\n        variable_filter: criteria.variable.clone(),\n        metrics,\n    }\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 252
    },
    {
      "name": "backward_slice_variable",
      "qualified_name": "src/dfg/slice.rs::backward_slice_variable",
      "file": "src/dfg/slice.rs",
      "line": 244,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn backward_slice_variable(dfg: &DFGInfo, line: usize, variable: &str) -> Vec<usize>",
      "docstring": "",
      "calls": [
        "backward_slice_variable_impl"
      ],
      "called_by": [
        "test_backward_slice_variable_specific"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "pub fn backward_slice_variable(dfg: &DFGInfo, line: usize, variable: &str) -> Vec<usize> {\n    backward_slice_variable_impl(dfg, line, variable)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 40
    },
    {
      "name": "forward_slice_variable",
      "qualified_name": "src/dfg/slice.rs::forward_slice_variable",
      "file": "src/dfg/slice.rs",
      "line": 260,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn forward_slice_variable(dfg: &DFGInfo, line: usize, variable: &str) -> Vec<usize>",
      "docstring": "",
      "calls": [
        "forward_slice_variable_impl"
      ],
      "called_by": [
        "test_forward_slice_variable_specific"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "pub fn forward_slice_variable(dfg: &DFGInfo, line: usize, variable: &str) -> Vec<usize> {\n    forward_slice_variable_impl(dfg, line, variable)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 40
    },
    {
      "name": "bidirectional_slice",
      "qualified_name": "src/dfg/slice.rs::bidirectional_slice",
      "file": "src/dfg/slice.rs",
      "line": 275,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn bidirectional_slice(dfg: &DFGInfo, criteria: &SliceCriteria) -> (SliceResult, SliceResult)",
      "docstring": "",
      "calls": [
        "backward_slice",
        "forward_slice"
      ],
      "called_by": [
        "test_bidirectional_slice"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:6",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "pub fn bidirectional_slice(dfg: &DFGInfo, criteria: &SliceCriteria) -> (SliceResult, SliceResult) {\n    let backward = backward_slice(dfg, criteria);\n    let forward = forward_slice(dfg, criteria);\n    (backward, forward)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 57
    },
    {
      "name": "chop",
      "qualified_name": "src/dfg/slice.rs::chop",
      "file": "src/dfg/slice.rs",
      "line": 297,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn chop(dfg: &DFGInfo, source_line: usize, target_line: usize) -> Vec<usize>",
      "docstring": "",
      "calls": [
        "backward_slice_all",
        "forward_slice_all"
      ],
      "called_by": [
        "test_chop_narrower",
        "test_chop"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:8",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "pub fn chop(dfg: &DFGInfo, source_line: usize, target_line: usize) -> Vec<usize> {\n    let forward_set: HashSet<usize> = forward_slice_all(dfg, source_line).into_iter().collect();\n\n    let backward_set: HashSet<usize> = backward_slice_all(dfg, target_line).into_iter().collect();\n\n    let mut result: Vec<usize> = forward_set.intersection(&backward_set).copied().collect();\n\n    result.sort_unstable();\n    result\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 103
    },
    {
      "name": "backward_slice_all",
      "qualified_name": "src/dfg/slice.rs::backward_slice_all",
      "file": "src/dfg/slice.rs",
      "line": 313,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn backward_slice_all(dfg: &DFGInfo, target_line: usize) -> Vec<usize>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "chop",
        "backward_slice"
      ],
      "cfg_summary": "complexity:7, blocks:16",
      "dfg_summary": "vars:15, def-use chains:12",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "fn backward_slice_all(dfg: &DFGInfo, target_line: usize) -> Vec<usize> {\n    // Build reverse adjacency: to_line -> [(from_line, edge)]\n    let mut incoming: HashMap<usize, Vec<usize>> = HashMap::new();\n    for edge in &dfg.edges {\n        incoming\n            .entry(edge.to_line)\n            .or_default()\n            .push(edge.from_line);\n    }\n\n    // BFS backward\n    let mut result = HashSet::new();\n    let mut frontier = VecDeque::new();\n    frontier.push_back(target_line);\n\n    while let Some(line) = frontier.pop_front() {\n        if result.insert(line) {\n            if let Some(sources) = incoming.get(&line) {\n                for &source in sources {\n                    if !result.contains(&source) {\n                        frontier.push_back(source);\n                    }\n                }\n            }\n        }\n    }\n\n    let mut lines: Vec<_> = result.into_iter().collect();\n    lines.sort_unstable();\n    lines\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 3,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 207
    },
    {
      "name": "backward_slice_variable_impl",
      "qualified_name": "src/dfg/slice.rs::backward_slice_variable_impl",
      "file": "src/dfg/slice.rs",
      "line": 346,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn backward_slice_variable_impl(dfg: &DFGInfo, target_line: usize, variable: &str) -> Vec<usize>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "backward_slice_variable",
        "backward_slice"
      ],
      "cfg_summary": "complexity:8, blocks:18",
      "dfg_summary": "vars:16, def-use chains:13",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "fn backward_slice_variable_impl(dfg: &DFGInfo, target_line: usize, variable: &str) -> Vec<usize> {\n    // Build reverse adjacency for specific variable: to_line -> [from_line]\n    let mut incoming: HashMap<usize, Vec<usize>> = HashMap::new();\n    for edge in &dfg.edges {\n        if edge.variable == variable {\n            incoming\n                .entry(edge.to_line)\n                .or_default()\n                .push(edge.from_line);\n        }\n    }\n\n    // BFS backward\n    let mut result = HashSet::new();\n    let mut frontier = VecDeque::new();\n    frontier.push_back(target_line);\n\n    while let Some(line) = frontier.pop_front() {\n        if result.insert(line) {\n            if let Some(sources) = incoming.get(&line) {\n                for &source in sources {\n                    if !result.contains(&source) {\n                        frontier.push_back(source);\n                    }\n                }\n            }\n        }\n    }\n\n    let mut lines: Vec<_> = result.into_iter().collect();\n    lines.sort_unstable();\n    lines\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 4,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 223
    },
    {
      "name": "forward_slice_all",
      "qualified_name": "src/dfg/slice.rs::forward_slice_all",
      "file": "src/dfg/slice.rs",
      "line": 381,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn forward_slice_all(dfg: &DFGInfo, source_line: usize) -> Vec<usize>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "chop",
        "forward_slice"
      ],
      "cfg_summary": "complexity:7, blocks:16",
      "dfg_summary": "vars:15, def-use chains:12",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "fn forward_slice_all(dfg: &DFGInfo, source_line: usize) -> Vec<usize> {\n    // Build forward adjacency: from_line -> [to_line]\n    let mut outgoing: HashMap<usize, Vec<usize>> = HashMap::new();\n    for edge in &dfg.edges {\n        outgoing\n            .entry(edge.from_line)\n            .or_default()\n            .push(edge.to_line);\n    }\n\n    // BFS forward\n    let mut result = HashSet::new();\n    let mut frontier = VecDeque::new();\n    frontier.push_back(source_line);\n\n    while let Some(line) = frontier.pop_front() {\n        if result.insert(line) {\n            if let Some(targets) = outgoing.get(&line) {\n                for &target in targets {\n                    if !result.contains(&target) {\n                        frontier.push_back(target);\n                    }\n                }\n            }\n        }\n    }\n\n    let mut lines: Vec<_> = result.into_iter().collect();\n    lines.sort_unstable();\n    lines\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 3,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 204
    },
    {
      "name": "forward_slice_variable_impl",
      "qualified_name": "src/dfg/slice.rs::forward_slice_variable_impl",
      "file": "src/dfg/slice.rs",
      "line": 414,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn forward_slice_variable_impl(dfg: &DFGInfo, source_line: usize, variable: &str) -> Vec<usize>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "forward_slice",
        "forward_slice_variable"
      ],
      "cfg_summary": "complexity:8, blocks:18",
      "dfg_summary": "vars:16, def-use chains:13",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "fn forward_slice_variable_impl(dfg: &DFGInfo, source_line: usize, variable: &str) -> Vec<usize> {\n    // Build forward adjacency for specific variable: from_line -> [to_line]\n    let mut outgoing: HashMap<usize, Vec<usize>> = HashMap::new();\n    for edge in &dfg.edges {\n        if edge.variable == variable {\n            outgoing\n                .entry(edge.from_line)\n                .or_default()\n                .push(edge.to_line);\n        }\n    }\n\n    // BFS forward\n    let mut result = HashSet::new();\n    let mut frontier = VecDeque::new();\n    frontier.push_back(source_line);\n\n    while let Some(line) = frontier.pop_front() {\n        if result.insert(line) {\n            if let Some(targets) = outgoing.get(&line) {\n                for &target in targets {\n                    if !result.contains(&target) {\n                        frontier.push_back(target);\n                    }\n                }\n            }\n        }\n    }\n\n    let mut lines: Vec<_> = result.into_iter().collect();\n    lines.sort_unstable();\n    lines\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 4,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 222
    },
    {
      "name": "collect_slice_variables",
      "qualified_name": "src/dfg/slice.rs::collect_slice_variables",
      "file": "src/dfg/slice.rs",
      "line": 453,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_slice_variables(dfg: &DFGInfo, lines: &[usize]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "backward_slice",
        "forward_slice"
      ],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:10, def-use chains:8",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "fn collect_slice_variables(dfg: &DFGInfo, lines: &[usize]) -> Vec<String> {\n    let line_set: HashSet<usize> = lines.iter().copied().collect();\n\n    let mut variables: HashSet<&str> = HashSet::new();\n    for edge in &dfg.edges {\n        if line_set.contains(&edge.from_line) || line_set.contains(&edge.to_line) {\n            variables.insert(&edge.variable);\n        }\n    }\n\n    let mut result: Vec<String> = variables.into_iter().map(String::from).collect();\n    result.sort_unstable();\n    result\n}\n",
      "semantic_tags": [
        "crud",
        "transform",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 123
    },
    {
      "name": "count_edges_in_slice",
      "qualified_name": "src/dfg/slice.rs::count_edges_in_slice",
      "file": "src/dfg/slice.rs",
      "line": 469,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn count_edges_in_slice(dfg: &DFGInfo, lines: &[usize]) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [
        "backward_slice",
        "forward_slice"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:4",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "fn count_edges_in_slice(dfg: &DFGInfo, lines: &[usize]) -> usize {\n    let line_set: HashSet<usize> = lines.iter().copied().collect();\n\n    dfg.edges\n        .iter()\n        .filter(|e| line_set.contains(&e.from_line) || line_set.contains(&e.to_line))\n        .count()\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 75
    },
    {
      "name": "compute_function_line_range",
      "qualified_name": "src/dfg/slice.rs::compute_function_line_range",
      "file": "src/dfg/slice.rs",
      "line": 479,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn compute_function_line_range(dfg: &DFGInfo) -> Option<(usize, usize)>",
      "docstring": "",
      "calls": [
        "is_empty"
      ],
      "called_by": [
        "backward_slice",
        "forward_slice"
      ],
      "cfg_summary": "complexity:4, blocks:9",
      "dfg_summary": "vars:9, def-use chains:8",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "fn compute_function_line_range(dfg: &DFGInfo) -> Option<(usize, usize)> {\n    if dfg.edges.is_empty() {\n        return None;\n    }\n\n    let mut min_line = usize::MAX;\n    let mut max_line = 0;\n\n    for edge in &dfg.edges {\n        min_line = min_line.min(edge.from_line).min(edge.to_line);\n        max_line = max_line.max(edge.from_line).max(edge.to_line);\n    }\n\n    if min_line <= max_line {\n        Some((min_line, max_line))\n    } else {\n        None\n    }\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 125
    },
    {
      "name": "create_test_dfg",
      "qualified_name": "src/dfg/slice.rs::create_test_dfg",
      "file": "src/dfg/slice.rs",
      "line": 517,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_test_dfg() -> DFGInfo",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_chop_narrower",
        "test_backward_slice_from_middle",
        "test_slice_result_contains_line",
        "test_forward_slice_from_start",
        "test_slice_with_variable_filter_criteria"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:0",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn create_test_dfg() -> DFGInfo {\n        DFGInfo {\n            function_name: \"test_func\".to_string(),\n            edges: vec![\n                // x flows: 1 -> 2, 1 -> 4\n                DataflowEdge {\n                    variable: \"x\".to_string(),\n                    from_line: 1,\n                    to_line: 2,\n                    kind: DataflowKind::Definition,\n                },\n                DataflowEdge {\n                    variable: \"x\".to_string(),\n                    from_line: 1,\n                    to_line: 4,\n                    kind: DataflowKind::Use,\n                },\n                // y flows: 2 -> 3\n                DataflowEdge {\n                    variable: \"y\".to_string(),\n                    from_line: 2,\n                    to_line: 3,\n                    kind: DataflowKind::Definition,\n                },\n                // z flows: 3 -> 4\n                DataflowEdge {\n                    variable: \"z\".to_string(),\n                    from_line: 3,\n                    to_line: 4,\n                    kind: DataflowKind::Definition,\n                },\n                // w flows: 4 -> 5\n                DataflowEdge {\n                    variable: \"w\".to_string(),\n                    from_line: 4,\n                    to_line: 5,\n                    kind: DataflowKind::Definition,\n                },\n            ],\n            definitions: [\n                (\"x\".to_string(), vec![1]),\n                (\"y\".to_string(), vec![2]),\n                (\"z\".to_string(), vec![3]),\n                (\"w\".to_string(), vec![4]),\n            ]\n            .into_iter()\n            .collect(),\n            uses: [\n                (\"x\".to_string(), vec![2, 4]),\n                (\"y\".to_string(), vec![3]),\n                (\"z\".to_string(), vec![4]),\n                (\"w\".to_string(), vec![5]),\n            ]\n            .into_iter()\n            .collect(),\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 5,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 405
    },
    {
      "name": "test_backward_slice_from_return",
      "qualified_name": "src/dfg/slice.rs::test_backward_slice_from_return",
      "file": "src/dfg/slice.rs",
      "line": 576,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_backward_slice_from_return() -> 4 (w defined)",
      "docstring": "",
      "calls": [
        "backward_slice",
        "at_line",
        "create_test_dfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:5",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_backward_slice_from_return() {\n        let dfg = create_test_dfg();\n        let criteria = SliceCriteria::at_line(5);\n        let result = backward_slice(&dfg, &criteria);\n\n        // Backward from line 5 (return w) should include:\n        // 5 -> 4 (w defined) -> 3 (z defined) -> 2 (y defined) -> 1 (x defined)\n        // Also 4 uses x directly from 1\n        assert_eq!(result.lines, vec![1, 2, 3, 4, 5]);\n        assert_eq!(result.direction, \"backward\");\n        assert_eq!(result.target_line, 5);\n    }\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 149
    },
    {
      "name": "test_backward_slice_from_middle",
      "qualified_name": "src/dfg/slice.rs::test_backward_slice_from_middle",
      "file": "src/dfg/slice.rs",
      "line": 590,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_backward_slice_from_middle() -> 2 (y defined)",
      "docstring": "",
      "calls": [
        "at_line",
        "create_test_dfg",
        "backward_slice"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:3",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_backward_slice_from_middle() {\n        let dfg = create_test_dfg();\n        let criteria = SliceCriteria::at_line(3);\n        let result = backward_slice(&dfg, &criteria);\n\n        // Backward from line 3 (z = y * 2) should include:\n        // 3 -> 2 (y defined) -> 1 (x defined)\n        assert_eq!(result.lines, vec![1, 2, 3]);\n    }\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 100
    },
    {
      "name": "test_forward_slice_from_start",
      "qualified_name": "src/dfg/slice.rs::test_forward_slice_from_start",
      "file": "src/dfg/slice.rs",
      "line": 601,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_forward_slice_from_start() -> 2",
      "docstring": "",
      "calls": [
        "create_test_dfg",
        "at_line",
        "forward_slice"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:4",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_forward_slice_from_start() {\n        let dfg = create_test_dfg();\n        let criteria = SliceCriteria::at_line(1);\n        let result = forward_slice(&dfg, &criteria);\n\n        // Forward from line 1 (x = input) should reach everything\n        // 1 -> 2 -> 3 -> 4 -> 5\n        // 1 -> 4 -> 5\n        assert_eq!(result.lines, vec![1, 2, 3, 4, 5]);\n        assert_eq!(result.direction, \"forward\");\n    }\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 123
    },
    {
      "name": "test_forward_slice_from_middle",
      "qualified_name": "src/dfg/slice.rs::test_forward_slice_from_middle",
      "file": "src/dfg/slice.rs",
      "line": 614,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_forward_slice_from_middle() -> 4",
      "docstring": "",
      "calls": [
        "forward_slice",
        "at_line",
        "create_test_dfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:3",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_forward_slice_from_middle() {\n        let dfg = create_test_dfg();\n        let criteria = SliceCriteria::at_line(3);\n        let result = forward_slice(&dfg, &criteria);\n\n        // Forward from line 3 (z = y * 2):\n        // 3 -> 4 -> 5\n        assert_eq!(result.lines, vec![3, 4, 5]);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 89
    },
    {
      "name": "test_backward_slice_variable_specific",
      "qualified_name": "src/dfg/slice.rs::test_backward_slice_variable_specific",
      "file": "src/dfg/slice.rs",
      "line": 625,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_backward_slice_variable_specific()",
      "docstring": "",
      "calls": [
        "backward_slice_variable",
        "create_test_dfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:2",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_backward_slice_variable_specific() {\n        let dfg = create_test_dfg();\n        let result = backward_slice_variable(&dfg, 4, \"x\");\n\n        // Backward from line 4 following only x:\n        // 4 <- 1 (x defined at 1, used at 4)\n        assert_eq!(result, vec![1, 4]);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 82
    },
    {
      "name": "test_forward_slice_variable_specific",
      "qualified_name": "src/dfg/slice.rs::test_forward_slice_variable_specific",
      "file": "src/dfg/slice.rs",
      "line": 635,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_forward_slice_variable_specific() -> 3 (y used at 3)\n        assert_eq!(result, vec![2, 3]);\n    }",
      "docstring": "",
      "calls": [
        "forward_slice_variable",
        "create_test_dfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:2",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_forward_slice_variable_specific() {\n        let dfg = create_test_dfg();\n        let result = forward_slice_variable(&dfg, 2, \"y\");\n\n        // Forward from line 2 following only y:\n        // 2 -> 3 (y used at 3)\n        assert_eq!(result, vec![2, 3]);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 76
    },
    {
      "name": "test_chop",
      "qualified_name": "src/dfg/slice.rs::test_chop",
      "file": "src/dfg/slice.rs",
      "line": 645,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chop()",
      "docstring": "",
      "calls": [
        "create_test_dfg",
        "chop"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:2",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_chop() {\n        let dfg = create_test_dfg();\n        let result = chop(&dfg, 1, 5);\n\n        // Chop from 1 to 5 = forward(1) intersect backward(5)\n        // Both should be {1,2,3,4,5}\n        assert_eq!(result, vec![1, 2, 3, 4, 5]);\n    }\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 91
    },
    {
      "name": "test_chop_narrower",
      "qualified_name": "src/dfg/slice.rs::test_chop_narrower",
      "file": "src/dfg/slice.rs",
      "line": 655,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chop_narrower()",
      "docstring": "",
      "calls": [
        "create_test_dfg",
        "chop"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:2",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_chop_narrower() {\n        let dfg = create_test_dfg();\n        let result = chop(&dfg, 2, 4);\n\n        // forward(2) = {2, 3, 4, 5}\n        // backward(4) = {1, 2, 3, 4}\n        // intersection = {2, 3, 4}\n        assert_eq!(result, vec![2, 3, 4]);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 104
    },
    {
      "name": "test_bidirectional_slice",
      "qualified_name": "src/dfg/slice.rs::test_bidirectional_slice",
      "file": "src/dfg/slice.rs",
      "line": 666,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_bidirectional_slice()",
      "docstring": "",
      "calls": [
        "at_line",
        "bidirectional_slice",
        "create_test_dfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:4",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_bidirectional_slice() {\n        let dfg = create_test_dfg();\n        let criteria = SliceCriteria::at_line(3);\n        let (backward, forward) = bidirectional_slice(&dfg, &criteria);\n\n        assert_eq!(backward.lines, vec![1, 2, 3]);\n        assert_eq!(forward.lines, vec![3, 4, 5]);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 84
    },
    {
      "name": "test_slice_metrics",
      "qualified_name": "src/dfg/slice.rs::test_slice_metrics",
      "file": "src/dfg/slice.rs",
      "line": 676,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_slice_metrics()",
      "docstring": "",
      "calls": [
        "backward_slice",
        "at_line",
        "create_test_dfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:5",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_slice_metrics() {\n        let dfg = create_test_dfg();\n        let criteria = SliceCriteria::at_line(5);\n        let result = backward_slice(&dfg, &criteria);\n\n        assert_eq!(result.metrics.slice_size, 5);\n        assert!(result.metrics.slice_ratio > 0.0);\n        assert!(result.metrics.slice_ratio <= 1.0);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 82
    },
    {
      "name": "test_slice_result_contains_line",
      "qualified_name": "src/dfg/slice.rs::test_slice_result_contains_line",
      "file": "src/dfg/slice.rs",
      "line": 687,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_slice_result_contains_line()",
      "docstring": "",
      "calls": [
        "create_test_dfg",
        "at_line",
        "backward_slice"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:7",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_slice_result_contains_line() {\n        let dfg = create_test_dfg();\n        let criteria = SliceCriteria::at_line(3);\n        let result = backward_slice(&dfg, &criteria);\n\n        assert!(result.contains_line(1));\n        assert!(result.contains_line(2));\n        assert!(result.contains_line(3));\n        assert!(!result.contains_line(4));\n        assert!(!result.contains_line(5));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 93
    },
    {
      "name": "test_slice_result_line_range",
      "qualified_name": "src/dfg/slice.rs::test_slice_result_line_range",
      "file": "src/dfg/slice.rs",
      "line": 700,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_slice_result_line_range()",
      "docstring": "",
      "calls": [
        "backward_slice",
        "at_line",
        "create_test_dfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:3",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_slice_result_line_range() {\n        let dfg = create_test_dfg();\n        let criteria = SliceCriteria::at_line(3);\n        let result = backward_slice(&dfg, &criteria);\n\n        assert_eq!(result.line_range(), Some((1, 3)));\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 61
    },
    {
      "name": "test_empty_dfg_slice",
      "qualified_name": "src/dfg/slice.rs::test_empty_dfg_slice",
      "file": "src/dfg/slice.rs",
      "line": 709,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_empty_dfg_slice()",
      "docstring": "",
      "calls": [
        "backward_slice",
        "at_line"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:4",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_empty_dfg_slice() {\n        let dfg = DFGInfo {\n            function_name: \"empty\".to_string(),\n            edges: vec![],\n            definitions: Default::default(),\n            uses: Default::default(),\n        };\n\n        let criteria = SliceCriteria::at_line(1);\n        let result = backward_slice(&dfg, &criteria);\n\n        // Should still include the target line itself\n        assert_eq!(result.lines, vec![1]);\n        assert!(result.variables.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 106
    },
    {
      "name": "test_slice_with_variable_filter_criteria",
      "qualified_name": "src/dfg/slice.rs::test_slice_with_variable_filter_criteria",
      "file": "src/dfg/slice.rs",
      "line": 726,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_slice_with_variable_filter_criteria()",
      "docstring": "",
      "calls": [
        "backward_slice",
        "create_test_dfg",
        "at_line_variable"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:4",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "    fn test_slice_with_variable_filter_criteria() {\n        let dfg = create_test_dfg();\n        let criteria = SliceCriteria::at_line_variable(4, \"x\");\n        let result = backward_slice(&dfg, &criteria);\n\n        // Only following x edges from line 4\n        assert_eq!(result.lines, vec![1, 4]);\n        assert_eq!(result.variable_filter, Some(\"x\".to_string()));\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 91
    },
    {
      "name": "SliceCriteria",
      "qualified_name": "src/dfg/slice.rs::SliceCriteria",
      "file": "src/dfg/slice.rs",
      "line": 18,
      "language": "rust",
      "unit_type": "class",
      "signature": "class SliceCriteria",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "pub struct SliceCriteria {\n    /// Target line number (1-indexed, matching source code)\n    pub line: usize,\n    /// Optional: specific variable to track.\n    /// When None, all data flow edges are followed.\n    /// When Some(var), only edges for that variable are followed.\n    pub variable: Option<String>,\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 68
    },
    {
      "name": "SliceResult",
      "qualified_name": "src/dfg/slice.rs::SliceResult",
      "file": "src/dfg/slice.rs",
      "line": 52,
      "language": "rust",
      "unit_type": "class",
      "signature": "class SliceResult",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "pub struct SliceResult {\n    /// Function name where slicing was performed.\n    pub function_name: String,\n\n    /// Target/source line of the slice criterion.\n    pub target_line: usize,\n\n    /// Direction of the slice (\"backward\" or \"forward\").\n    pub direction: String,\n\n    /// Lines in the slice (sorted ascending).\n    /// These are all lines that either affect (backward) or are\n    /// affected by (forward) the target line.\n    pub lines: Vec<usize>,\n\n    /// Variables involved in the slice.\n    /// Unique set of variable names found along the data flow paths.\n    pub variables: Vec<String>,\n\n    /// If slicing was restricted to a specific variable.\n    pub variable_filter: Option<String>,\n\n    /// Metrics about the slice computation.\n    pub metrics: SliceMetrics,\n}\n",
      "semantic_tags": [
        "crud",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 167
    },
    {
      "name": "SliceMetrics",
      "qualified_name": "src/dfg/slice.rs::SliceMetrics",
      "file": "src/dfg/slice.rs",
      "line": 80,
      "language": "rust",
      "unit_type": "class",
      "signature": "class SliceMetrics",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, crate::dfg::types, super, crate::dfg::types",
      "code_preview": "pub struct SliceMetrics {\n    /// Total number of lines in the slice.\n    pub slice_size: usize,\n\n    /// Number of edges traversed during computation.\n    pub edges_traversed: usize,\n\n    /// Slice ratio: slice_size / total_function_lines.\n    /// Lower is better (more focused slice).\n    pub slice_ratio: f64,\n\n    /// Number of unique variables in the slice.\n    pub variable_count: usize,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 90
    },
    {
      "name": "(FileMetadata) from_path",
      "qualified_name": "src/callgraph/scanner.rs::(FileMetadata) from_path",
      "file": "src/callgraph/scanner.rs",
      "line": 46,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FileMetadata) from_path(path: PathBuf, registry: &LanguageRegistry) -> Option<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn from_path(path: PathBuf, registry: &LanguageRegistry) -> Option<Self> {\n        let metadata = fs::metadata(&path).ok()?;\n\n        // Skip directories (should not happen with WalkBuilder, but safety check)\n        if !metadata.is_file() {\n            return None;\n        }\n\n        let language = registry\n            .detect_language(&path)\n            .map(|l| l.name().to_string());\n\n        Some(Self {\n            path,\n            size: metadata.len(),\n            modified: metadata.modified().ok(),\n            language,\n        })\n    }\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "config",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 116
    },
    {
      "name": "(ScanConfig) for_language",
      "qualified_name": "src/callgraph/scanner.rs::(ScanConfig) for_language",
      "file": "src/callgraph/scanner.rs",
      "line": 90,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ScanConfig) for_language(lang: &str) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn for_language(lang: &str) -> Self {\n        Self {\n            language: Some(lang.to_string()),\n            ..Default::default()\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 34
    },
    {
      "name": "(ScanConfig) for_extensions",
      "qualified_name": "src/callgraph/scanner.rs::(ScanConfig) for_extensions",
      "file": "src/callgraph/scanner.rs",
      "line": 98,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ScanConfig) for_extensions(exts: &[&str]) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn for_extensions(exts: &[&str]) -> Self {\n        Self {\n            extensions: exts.iter().map(|s| (*s).to_string()).collect(),\n            ..Default::default()\n        }\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 47
    },
    {
      "name": "(ScanConfig) with_includes",
      "qualified_name": "src/callgraph/scanner.rs::(ScanConfig) with_includes",
      "file": "src/callgraph/scanner.rs",
      "line": 106,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ScanConfig) with_includes(mut self, patterns: &[&str]) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn with_includes(mut self, patterns: &[&str]) -> Self {\n        self.include_patterns = patterns.iter().map(|s| (*s).to_string()).collect();\n        self\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 43
    },
    {
      "name": "(ScanConfig) with_excludes",
      "qualified_name": "src/callgraph/scanner.rs::(ScanConfig) with_excludes",
      "file": "src/callgraph/scanner.rs",
      "line": 112,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ScanConfig) with_excludes(mut self, patterns: &[&str]) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn with_excludes(mut self, patterns: &[&str]) -> Self {\n        self.exclude_patterns = patterns.iter().map(|s| (*s).to_string()).collect();\n        self\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 43
    },
    {
      "name": "(ScanConfig) with_metadata",
      "qualified_name": "src/callgraph/scanner.rs::(ScanConfig) with_metadata",
      "file": "src/callgraph/scanner.rs",
      "line": 118,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ScanConfig) with_metadata(mut self) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn with_metadata(mut self) -> Self {\n        self.collect_metadata = true;\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 23
    },
    {
      "name": "(ScanConfig) with_max_depth",
      "qualified_name": "src/callgraph/scanner.rs::(ScanConfig) with_max_depth",
      "file": "src/callgraph/scanner.rs",
      "line": 124,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ScanConfig) with_max_depth(mut self, depth: usize) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn with_max_depth(mut self, depth: usize) -> Self {\n        self.max_depth = Some(depth);\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 29
    },
    {
      "name": "(ScanResult) new",
      "qualified_name": "src/callgraph/scanner.rs::(ScanResult) new",
      "file": "src/callgraph/scanner.rs",
      "line": 144,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ScanResult) new() -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn new() -> Self {\n        Self {\n            files: Vec::new(),\n            metadata: Vec::new(),\n            total_bytes: 0,\n            by_language: std::collections::HashMap::new(),\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 47
    },
    {
      "name": "(ScanResult) add_file",
      "qualified_name": "src/callgraph/scanner.rs::(ScanResult) add_file",
      "file": "src/callgraph/scanner.rs",
      "line": 153,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ScanResult) add_file(&mut self, path: PathBuf)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn add_file(&mut self, path: PathBuf) {\n        self.files.push(path);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 22
    },
    {
      "name": "(ScanResult) add_metadata",
      "qualified_name": "src/callgraph/scanner.rs::(ScanResult) add_metadata",
      "file": "src/callgraph/scanner.rs",
      "line": 157,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ScanResult) add_metadata(&mut self, meta: FileMetadata)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn add_metadata(&mut self, meta: FileMetadata) {\n        self.total_bytes += meta.size;\n        if let Some(ref lang) = meta.language {\n            *self.by_language.entry(lang.clone()).or_insert(0) += 1;\n        }\n        self.metadata.push(meta);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 61
    },
    {
      "name": "(ProjectScanner) new",
      "qualified_name": "src/callgraph/scanner.rs::(ProjectScanner) new",
      "file": "src/callgraph/scanner.rs",
      "line": 200,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ProjectScanner) new(path: &str) -> Result<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn new(path: &str) -> Result<Self> {\n        let root = PathBuf::from(path);\n\n        if !root.exists() {\n            return Err(TldrError::Io(std::io::Error::new(\n                std::io::ErrorKind::NotFound,\n                format!(\"Project root does not exist: {}\", path),\n            )));\n        }\n\n        if !root.is_dir() {\n            return Err(TldrError::Io(std::io::Error::new(\n                std::io::ErrorKind::InvalidInput,\n                format!(\"Project root is not a directory: {}\", path),\n            )));\n        }\n\n        Ok(Self { root })\n    }\n",
      "semantic_tags": [
        "validation",
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 135
    },
    {
      "name": "(ProjectScanner) root",
      "qualified_name": "src/callgraph/scanner.rs::(ProjectScanner) root",
      "file": "src/callgraph/scanner.rs",
      "line": 221,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ProjectScanner) root(&self) -> &Path",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn root(&self) -> &Path {\n        &self.root\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 18
    },
    {
      "name": "(ProjectScanner) scan_files",
      "qualified_name": "src/callgraph/scanner.rs::(ProjectScanner) scan_files",
      "file": "src/callgraph/scanner.rs",
      "line": 229,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ProjectScanner) scan_files(&self) -> Result<Vec<PathBuf>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn scan_files(&self) -> Result<Vec<PathBuf>> {\n        let registry = LanguageRegistry::global();\n\n        let files: Vec<_> = self\n            .build_walker(None)?\n            .filter_map(|entry| entry.ok())\n            .filter(|e| e.path().is_file())\n            .filter(|e| registry.detect_language(e.path()).is_some())\n            .map(|e| e.path().to_path_buf())\n            .collect();\n\n        Ok(files)\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 101
    },
    {
      "name": "(ProjectScanner) scan_language",
      "qualified_name": "src/callgraph/scanner.rs::(ProjectScanner) scan_language",
      "file": "src/callgraph/scanner.rs",
      "line": 252,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ProjectScanner) scan_language(&self, lang_name: &str) -> Result<Vec<PathBuf>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn scan_language(&self, lang_name: &str) -> Result<Vec<PathBuf>> {\n        let registry = LanguageRegistry::global();\n\n        // Validate language exists\n        if registry.get_by_name(lang_name).is_none() {\n            return Err(TldrError::UnsupportedLanguage(lang_name.to_string()));\n        }\n\n        let files: Vec<_> = self\n            .build_walker(None)?\n            .filter_map(|entry| entry.ok())\n            .filter(|e| e.path().is_file())\n            .filter(|e| {\n                registry\n                    .detect_language(e.path())\n                    .is_some_and(|l| l.name() == lang_name)\n            })\n            .map(|e| e.path().to_path_buf())\n            .collect();\n\n        Ok(files)\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 161
    },
    {
      "name": "(ProjectScanner) scan_extensions",
      "qualified_name": "src/callgraph/scanner.rs::(ProjectScanner) scan_extensions",
      "file": "src/callgraph/scanner.rs",
      "line": 280,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ProjectScanner) scan_extensions(&self, extensions: &[&str]) -> Result<Vec<PathBuf>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn scan_extensions(&self, extensions: &[&str]) -> Result<Vec<PathBuf>> {\n        let ext_set: std::collections::HashSet<_> = extensions.iter().copied().collect();\n\n        let files: Vec<_> = self\n            .build_walker(None)?\n            .filter_map(|entry| entry.ok())\n            .filter(|e| e.path().is_file())\n            .filter(|e| {\n                e.path()\n                    .extension()\n                    .and_then(|ext| ext.to_str())\n                    .map(|ext| {\n                        let with_dot = format!(\".{}\", ext);\n                        ext_set.contains(with_dot.as_str()) || ext_set.contains(ext)\n                    })\n                    .unwrap_or(false)\n            })\n            .map(|e| e.path().to_path_buf())\n            .collect();\n\n        Ok(files)\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 173
    },
    {
      "name": "(ProjectScanner) scan_with_config",
      "qualified_name": "src/callgraph/scanner.rs::(ProjectScanner) scan_with_config",
      "file": "src/callgraph/scanner.rs",
      "line": 310,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ProjectScanner) scan_with_config(&self, config: &ScanConfig) -> Result<ScanResult>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn scan_with_config(&self, config: &ScanConfig) -> Result<ScanResult> {\n        let registry = LanguageRegistry::global();\n\n        // Validate language if specified\n        if let Some(ref lang) = config.language {\n            if registry.get_by_name(lang).is_none() {\n                return Err(TldrError::UnsupportedLanguage(lang.clone()));\n            }\n        }\n\n        // Build extension set for filtering\n        let ext_set: std::collections::HashSet<String> = config\n            .extensions\n            .iter()\n            .map(|e| {\n                if e.starts_with('.') {\n                    e.clone()\n                } else {\n                    format!(\".{}\", e)\n                }\n            })\n            .collect();\n\n        // Collect initial file list\n        let walker = self.build_walker_with_config(config)?;\n        let entries: Vec<_> = walker\n            .filter_map(|entry| entry.ok())\n            .filter(|e| e.path().is_file())\n            .collect();\n\n        // Apply language and extension filters\n        let filtered: Vec<_> = entries\n            .into_iter()\n            .filter(|e| {\n                let path = e.path();\n\n                // Language filter\n                if let Some(ref lang) = config.language {\n                    let detected = registry.detect_language(path);\n                    if !detected.is_some_and(|l| l.name() == lang) {\n                        return false;\n                    }\n                }\n\n                // Extension filter (only if extensions specified)\n                if !ext_set.is_empty() {\n                    let has_ext = path\n                        .extension()\n                        .and_then(|ext| ext.to_str())\n                        .map(|ext| ext_set.contains(&format!(\".{}\", ext)))\n                        .unwrap_or(false);\n                    if !has_ext {\n                        return false;\n                    }\n                }\n\n                // If no language or extension filter, check if file is supported\n                if config.language.is_none() && ext_set.is_empty() {\n                    return registry.detect_language(path).is_some();\n                }\n\n                true\n            })\n            .map(|e| e.path().to_path_buf())\n            .collect();\n\n        // Collect metadata if requested\n        let mut result = ScanResult::new();\n\n        if config.collect_metadata {\n            let use_parallel = config.parallel && filtered.len() >= MIN_FILES_FOR_PARALLEL;\n\n            if use_parallel {\n                // Parallel metadata collection\n                let metadata: Vec<_> = filtered\n                    .par_iter()\n                    .filter_map(|path| FileMetadata::from_path(path.clone(), registry))\n                    .collect();\n\n                for meta in metadata {\n                    result.add_file(meta.path.clone());\n                    result.add_metadata(meta);\n                }\n            } else {\n                // Sequential metadata collection\n                for path in filtered {\n                    if let Some(meta) = FileMetadata::from_path(path.clone(), registry) {\n                        result.add_file(meta.path.clone());\n                        result.add_metadata(meta);\n                    } else {\n                        result.add_file(path);\n                    }\n                }\n            }\n        } else {\n            result.files = filtered;\n        }\n\n        Ok(result)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 6,
        "branches": 19,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 621
    },
    {
      "name": "(ProjectScanner) scan_with_metadata",
      "qualified_name": "src/callgraph/scanner.rs::(ProjectScanner) scan_with_metadata",
      "file": "src/callgraph/scanner.rs",
      "line": 417,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ProjectScanner) scan_with_metadata(&self) -> Result<Vec<FileMetadata>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn scan_with_metadata(&self) -> Result<Vec<FileMetadata>> {\n        let config = ScanConfig {\n            collect_metadata: true,\n            parallel: true,\n            ..Default::default()\n        };\n\n        Ok(self.scan_with_config(&config)?.metadata)\n    }\n",
      "semantic_tags": [
        "async_ops",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 55
    },
    {
      "name": "(ProjectScanner) scan_language_with_metadata",
      "qualified_name": "src/callgraph/scanner.rs::(ProjectScanner) scan_language_with_metadata",
      "file": "src/callgraph/scanner.rs",
      "line": 428,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ProjectScanner) scan_language_with_metadata(&self, lang_name: &str) -> Result<Vec<FileMetadata>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn scan_language_with_metadata(&self, lang_name: &str) -> Result<Vec<FileMetadata>> {\n        let config = ScanConfig {\n            language: Some(lang_name.to_string()),\n            collect_metadata: true,\n            parallel: true,\n            ..Default::default()\n        };\n\n        Ok(self.scan_with_config(&config)?.metadata)\n    }\n",
      "semantic_tags": [
        "async_ops",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 71
    },
    {
      "name": "(ProjectScanner) build_walker",
      "qualified_name": "src/callgraph/scanner.rs::(ProjectScanner) build_walker",
      "file": "src/callgraph/scanner.rs",
      "line": 440,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ProjectScanner) build_walker(&self, max_depth: Option<usize>) -> Result<impl Iterator<Item = std::result::Result<ignore::DirEntry, ignore::Error>>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn build_walker(\n        &self,\n        max_depth: Option<usize>,\n    ) -> Result<impl Iterator<Item = std::result::Result<ignore::DirEntry, ignore::Error>>> {\n        let mut builder = WalkBuilder::new(&self.root);\n\n        // Respect standard ignore files\n        builder\n            .hidden(true) // Skip hidden files/dirs\n            .parents(true) // Respect .gitignore in parent dirs\n            .git_ignore(true) // Respect .gitignore\n            .git_global(true) // Respect global gitignore\n            .git_exclude(true) // Respect .git/info/exclude\n            .add_custom_ignore_filename(\".tldrignore\");\n\n        if let Some(depth) = max_depth {\n            builder.max_depth(Some(depth));\n        }\n\n        // Add common exclude patterns\n        let mut overrides = OverrideBuilder::new(&self.root);\n        // Standard directories to always skip\n        let _ = overrides.add(\"!**/node_modules/**\");\n        let _ = overrides.add(\"!**/__pycache__/**\");\n        let _ = overrides.add(\"!**/.venv/**\");\n        let _ = overrides.add(\"!**/venv/**\");\n        let _ = overrides.add(\"!**/target/debug/**\");\n        let _ = overrides.add(\"!**/target/release/**\");\n        let _ = overrides.add(\"!**/.git/**\");\n        let _ = overrides.add(\"!**/dist/**\");\n        let _ = overrides.add(\"!**/build/**\");\n        let _ = overrides.add(\"!**/*.min.js\");\n        let _ = overrides.add(\"!**/*.min.css\");\n\n        if let Ok(built) = overrides.build() {\n            builder.overrides(built);\n        }\n\n        Ok(builder.build())\n    }\n",
      "semantic_tags": [
        "crud",
        "config",
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 354
    },
    {
      "name": "(ProjectScanner) build_walker_with_config",
      "qualified_name": "src/callgraph/scanner.rs::(ProjectScanner) build_walker_with_config",
      "file": "src/callgraph/scanner.rs",
      "line": 482,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ProjectScanner) build_walker_with_config(&self, config: &ScanConfig) -> Result<impl Iterator<Item = std::result::Result<ignore::DirEntry, ignore::Error>>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn build_walker_with_config(\n        &self,\n        config: &ScanConfig,\n    ) -> Result<impl Iterator<Item = std::result::Result<ignore::DirEntry, ignore::Error>>> {\n        let mut builder = WalkBuilder::new(&self.root);\n\n        // Base settings\n        builder\n            .hidden(true)\n            .parents(true)\n            .git_ignore(true)\n            .git_global(true)\n            .git_exclude(true)\n            .follow_links(config.follow_symlinks)\n            .add_custom_ignore_filename(\".tldrignore\");\n\n        if let Some(depth) = config.max_depth {\n            builder.max_depth(Some(depth));\n        }\n\n        // Build overrides from config patterns\n        let mut overrides = OverrideBuilder::new(&self.root);\n\n        // Standard excludes (always applied)\n        let _ = overrides.add(\"!**/node_modules/**\");\n        let _ = overrides.add(\"!**/__pycache__/**\");\n        let _ = overrides.add(\"!**/.venv/**\");\n        let _ = overrides.add(\"!**/venv/**\");\n        let _ = overrides.add(\"!**/target/debug/**\");\n        let _ = overrides.add(\"!**/target/release/**\");\n        let _ = overrides.add(\"!**/.git/**\");\n\n        // User-specified excludes\n        for pattern in &config.exclude_patterns {\n            let exclude = if pattern.starts_with('!') {\n                pattern.clone()\n            } else {\n                format!(\"!{}\", pattern)\n            };\n            let _ = overrides.add(&exclude);\n        }\n\n        // User-specified includes (if any)\n        for pattern in &config.include_patterns {\n            let _ = overrides.add(pattern);\n        }\n\n        if let Ok(built) = overrides.build() {\n            builder.overrides(built);\n        }\n\n        // Enable parallel directory traversal for large projects\n        if config.parallel {\n            builder.threads(0); // Use all available CPUs\n        } else {\n            builder.threads(1);\n        }\n\n        Ok(builder.build())\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "logging",
        "error_handling",
        "async_ops",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 7,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 409
    },
    {
      "name": "(ProjectScanner) estimate_file_count",
      "qualified_name": "src/callgraph/scanner.rs::(ProjectScanner) estimate_file_count",
      "file": "src/callgraph/scanner.rs",
      "line": 546,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ProjectScanner) estimate_file_count(&self) -> Result<usize>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    pub fn estimate_file_count(&self) -> Result<usize> {\n        let count = self\n            .build_walker(Some(1))?\n            .filter_map(|e| e.ok())\n            .filter(|e| e.path().is_file())\n            .count();\n\n        // Rough estimate: assume similar file count per directory\n        let dir_count = self\n            .build_walker(None)?\n            .filter_map(|e| e.ok())\n            .filter(|e| e.path().is_dir())\n            .count();\n\n        Ok(count * dir_count.max(1))\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 120
    },
    {
      "name": "create_test_project",
      "qualified_name": "src/callgraph/scanner.rs::create_test_project",
      "file": "src/callgraph/scanner.rs",
      "line": 570,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_test_project() -> TempDir",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [
        "test_code_structure_unlimited_results",
        "test_code_structure_relative_paths",
        "test_class_summary_has_method_count",
        "test_scan_config",
        "test_scan_language"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:11",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn create_test_project() -> TempDir {\n        let dir = TempDir::new().unwrap();\n        let root = dir.path();\n\n        // Create some test files\n        File::create(root.join(\"main.py\")).unwrap();\n        File::create(root.join(\"lib.py\")).unwrap();\n        File::create(root.join(\"utils.rs\")).unwrap();\n        File::create(root.join(\"app.ts\")).unwrap();\n\n        // Create subdirectory\n        std::fs::create_dir(root.join(\"src\")).unwrap();\n        File::create(root.join(\"src/module.py\")).unwrap();\n        File::create(root.join(\"src/helper.rs\")).unwrap();\n\n        // Create ignored directory\n        std::fs::create_dir(root.join(\"node_modules\")).unwrap();\n        File::create(root.join(\"node_modules/dep.js\")).unwrap();\n\n        dir\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 170
    },
    {
      "name": "test_scan_files",
      "qualified_name": "src/callgraph/scanner.rs::test_scan_files",
      "file": "src/callgraph/scanner.rs",
      "line": 593,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_scan_files()",
      "docstring": "",
      "calls": [
        "create_test_project",
        "scan_files",
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:6",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn test_scan_files() {\n        let dir = create_test_project();\n        let scanner = ProjectScanner::new(dir.path().to_str().unwrap()).unwrap();\n\n        let files = scanner.scan_files().unwrap();\n\n        // Should find Python, Rust, TypeScript files but not node_modules\n        assert!(files.iter().any(|p| p.ends_with(\"main.py\")));\n        assert!(files.iter().any(|p| p.ends_with(\"utils.rs\")));\n        assert!(files.iter().any(|p| p.ends_with(\"app.ts\")));\n        assert!(!files\n            .iter()\n            .any(|p| p.to_str().unwrap().contains(\"node_modules\")));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 138
    },
    {
      "name": "test_scan_language",
      "qualified_name": "src/callgraph/scanner.rs::test_scan_language",
      "file": "src/callgraph/scanner.rs",
      "line": 609,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_scan_language()",
      "docstring": "",
      "calls": [
        "create_test_project",
        "scan_language",
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:4",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn test_scan_language() {\n        let dir = create_test_project();\n        let scanner = ProjectScanner::new(dir.path().to_str().unwrap()).unwrap();\n\n        let py_files = scanner.scan_language(\"python\").unwrap();\n\n        assert_eq!(py_files.len(), 3); // main.py, lib.py, src/module.py\n        assert!(py_files.iter().all(|p| p.extension().unwrap() == \"py\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 90
    },
    {
      "name": "test_scan_extensions",
      "qualified_name": "src/callgraph/scanner.rs::test_scan_extensions",
      "file": "src/callgraph/scanner.rs",
      "line": 620,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_scan_extensions()",
      "docstring": "",
      "calls": [
        "scan_extensions",
        "new",
        "create_test_project"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:3",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn test_scan_extensions() {\n        let dir = create_test_project();\n        let scanner = ProjectScanner::new(dir.path().to_str().unwrap()).unwrap();\n\n        let rs_files = scanner.scan_extensions(&[\".rs\"]).unwrap();\n\n        assert_eq!(rs_files.len(), 2); // utils.rs, src/helper.rs\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 68
    },
    {
      "name": "test_scan_with_metadata",
      "qualified_name": "src/callgraph/scanner.rs::test_scan_with_metadata",
      "file": "src/callgraph/scanner.rs",
      "line": 630,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_scan_with_metadata()",
      "docstring": "",
      "calls": [
        "scan_with_metadata",
        "create_test_project",
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:4",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn test_scan_with_metadata() {\n        let dir = create_test_project();\n        let scanner = ProjectScanner::new(dir.path().to_str().unwrap()).unwrap();\n\n        let metadata = scanner.scan_with_metadata().unwrap();\n\n        assert!(!metadata.is_empty());\n        // All files should have language detected\n        assert!(metadata.iter().all(|m| m.language.is_some()));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 79
    },
    {
      "name": "test_scan_config",
      "qualified_name": "src/callgraph/scanner.rs::test_scan_config",
      "file": "src/callgraph/scanner.rs",
      "line": 642,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_scan_config()",
      "docstring": "",
      "calls": [
        "scan_with_config",
        "create_test_project",
        "with_excludes",
        "new",
        "for_language"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:5",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn test_scan_config() {\n        let dir = create_test_project();\n        let scanner = ProjectScanner::new(dir.path().to_str().unwrap()).unwrap();\n\n        let config = ScanConfig::for_language(\"python\")\n            .with_excludes(&[\"**/src/**\"])\n            .with_metadata();\n\n        let result = scanner.scan_with_config(&config).unwrap();\n\n        // Should only find root-level Python files\n        assert_eq!(result.files.len(), 2); // main.py, lib.py\n        assert!(result.by_language.contains_key(\"python\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 116
    },
    {
      "name": "test_unsupported_language_error",
      "qualified_name": "src/callgraph/scanner.rs::test_unsupported_language_error",
      "file": "src/callgraph/scanner.rs",
      "line": 658,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_unsupported_language_error()",
      "docstring": "",
      "calls": [
        "new",
        "create_test_project",
        "scan_language"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:3",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn test_unsupported_language_error() {\n        let dir = create_test_project();\n        let scanner = ProjectScanner::new(dir.path().to_str().unwrap()).unwrap();\n\n        let result = scanner.scan_language(\"brainfuck\");\n\n        assert!(matches!(result, Err(TldrError::UnsupportedLanguage(_))));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 64
    },
    {
      "name": "test_nonexistent_path_error",
      "qualified_name": "src/callgraph/scanner.rs::test_nonexistent_path_error",
      "file": "src/callgraph/scanner.rs",
      "line": 668,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_nonexistent_path_error()",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:1",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "    fn test_nonexistent_path_error() {\n        let result = ProjectScanner::new(\"/nonexistent/path/12345\");\n\n        assert!(matches!(result, Err(TldrError::Io(_))));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 45
    },
    {
      "name": "FileMetadata",
      "qualified_name": "src/callgraph/scanner.rs::FileMetadata",
      "file": "src/callgraph/scanner.rs",
      "line": 33,
      "language": "rust",
      "unit_type": "class",
      "signature": "class FileMetadata",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "pub struct FileMetadata {\n    /// Absolute path to the file.\n    pub path: PathBuf,\n    /// File size in bytes.\n    pub size: u64,\n    /// Modification time (None if unavailable).\n    pub modified: Option<SystemTime>,\n    /// Detected language name (e.g., \"python\", \"typescript\").\n    pub language: Option<String>,\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 75
    },
    {
      "name": "ScanConfig",
      "qualified_name": "src/callgraph/scanner.rs::ScanConfig",
      "file": "src/callgraph/scanner.rs",
      "line": 69,
      "language": "rust",
      "unit_type": "class",
      "signature": "class ScanConfig",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "pub struct ScanConfig {\n    /// Filter by specific language (e.g., \"python\").\n    pub language: Option<String>,\n    /// Filter by file extensions (e.g., [\".py\", \".pyi\"]).\n    pub extensions: Vec<String>,\n    /// Glob patterns to include (e.g., [\"src/**/*.rs\"]).\n    pub include_patterns: Vec<String>,\n    /// Glob patterns to exclude (e.g., [\"**/test/**\"]).\n    pub exclude_patterns: Vec<String>,\n    /// Whether to follow symbolic links (default: false).\n    pub follow_symlinks: bool,\n    /// Maximum directory depth (None for unlimited).\n    pub max_depth: Option<usize>,\n    /// Whether to collect file metadata (default: false for faster scanning).\n    pub collect_metadata: bool,\n    /// Whether to use parallel scanning (default: true for large projects).\n    pub parallel: bool,\n}\n",
      "semantic_tags": [
        "async_ops",
        "iteration",
        "config",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 183
    },
    {
      "name": "ScanResult",
      "qualified_name": "src/callgraph/scanner.rs::ScanResult",
      "file": "src/callgraph/scanner.rs",
      "line": 132,
      "language": "rust",
      "unit_type": "class",
      "signature": "class ScanResult",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "pub struct ScanResult {\n    /// All matching file paths.\n    pub files: Vec<PathBuf>,\n    /// File metadata (only populated if `collect_metadata` was true).\n    pub metadata: Vec<FileMetadata>,\n    /// Total bytes scanned.\n    pub total_bytes: u64,\n    /// Number of files by language.\n    pub by_language: std::collections::HashMap<String, usize>,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 81
    },
    {
      "name": "ProjectScanner",
      "qualified_name": "src/callgraph/scanner.rs::ProjectScanner",
      "file": "src/callgraph/scanner.rs",
      "line": 190,
      "language": "rust",
      "unit_type": "class",
      "signature": "class ProjectScanner",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std, std::path, std::time, ignore::overrides, ignore",
      "code_preview": "pub struct ProjectScanner {\n    root: PathBuf,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 12
    },
    {
      "name": "(FunctionDef) matches_name",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionDef) matches_name",
      "file": "src/callgraph/indexer.rs",
      "line": 37,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionDef) matches_name(&self, name: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn matches_name(&self, name: &str) -> bool {\n        self.func_ref.name == name\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 26
    },
    {
      "name": "(FunctionDef) matches_qualified",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionDef) matches_qualified",
      "file": "src/callgraph/indexer.rs",
      "line": 44,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionDef) matches_qualified(&self, pattern: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn matches_qualified(&self, pattern: &str) -> bool {\n        if let Some(ref qname) = self.func_ref.qualified_name {\n            // Exact match\n            if qname == pattern {\n                return true;\n            }\n            // Suffix match (allows partial qualification)\n            if qname.ends_with(pattern) {\n                let prefix_end = qname.len() - pattern.len();\n                // Ensure we match at a boundary (after . or # or /)\n                if prefix_end == 0 {\n                    return true;\n                }\n                let boundary = qname.chars().nth(prefix_end - 1);\n                return matches!(boundary, Some('.') | Some('#') | Some('/') | Some(':'));\n            }\n        }\n        false\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 5,
        "branches": 7,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 156
    },
    {
      "name": "(FunctionIndex) build",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) build",
      "file": "src/callgraph/indexer.rs",
      "line": 129,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) build(files: &[PathBuf]) -> Result<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn build(files: &[PathBuf]) -> Result<Self> {\n        Self::build_with_root(files, None)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 27
    },
    {
      "name": "(FunctionIndex) build_with_root",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) build_with_root",
      "file": "src/callgraph/indexer.rs",
      "line": 141,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) build_with_root(files: &[PathBuf], root: Option<&Path>) -> Result<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn build_with_root(files: &[PathBuf], root: Option<&Path>) -> Result<Self> {\n        let mut index = Self::default();\n\n        // Extract functions in parallel\n        let results: Vec<FileExtraction> = files\n            .par_iter()\n            .filter_map(|path| {\n                match extract_functions_from_file(path, root) {\n                    Ok(extraction) => Some(extraction),\n                    Err(_) => {\n                        // Parse errors are expected for some files\n                        None\n                    }\n                }\n            })\n            .collect();\n\n        // Track parse errors (files that didn't produce results)\n        let successful_files = results.len();\n        index.stats.parse_errors = files.len().saturating_sub(successful_files);\n        index.stats.files_processed = successful_files;\n\n        // Merge results into index\n        for extraction in results {\n            for func_def in extraction.functions {\n                index.insert(func_def);\n            }\n        }\n\n        Ok(index)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "iteration",
        "config",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 6,
        "branches": 1,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 197
    },
    {
      "name": "(FunctionIndex) insert",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) insert",
      "file": "src/callgraph/indexer.rs",
      "line": 174,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) insert(&mut self, func_def: FunctionDef)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn insert(&mut self, func_def: FunctionDef) {\n        let name = func_def.func_ref.name.clone();\n        let file = func_def.func_ref.file.clone();\n\n        // Update statistics\n        if func_def.is_method {\n            self.stats.methods_indexed += 1;\n        } else {\n            self.stats.functions_indexed += 1;\n        }\n\n        // Index by simple name\n        self.by_name\n            .entry(name)\n            .or_default()\n            .push(func_def.func_ref.clone());\n\n        // Index by qualified name\n        if let Some(ref qname) = func_def.func_ref.qualified_name {\n            self.by_qualified\n                .insert(qname.clone(), func_def.func_ref.clone());\n            self.definitions.insert(qname.clone(), func_def.clone());\n        }\n\n        // Index by file\n        self.by_file\n            .entry(file)\n            .or_default()\n            .push(func_def.func_ref);\n    }\n",
      "semantic_tags": [
        "crud",
        "database"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 194
    },
    {
      "name": "(FunctionIndex) lookup",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) lookup",
      "file": "src/callgraph/indexer.rs",
      "line": 216,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) lookup(&self, name: &str) -> Vec<&FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn lookup(&self, name: &str) -> Vec<&FunctionRef> {\n        self.by_name\n            .get(name)\n            .map(|v| v.iter().collect())\n            .unwrap_or_default()\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 48
    },
    {
      "name": "(FunctionIndex) lookup_qualified",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) lookup_qualified",
      "file": "src/callgraph/indexer.rs",
      "line": 230,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) lookup_qualified(&self, qname: &str) -> Option<&FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn lookup_qualified(&self, qname: &str) -> Option<&FunctionRef> {\n        self.by_qualified.get(qname)\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 33
    },
    {
      "name": "(FunctionIndex) lookup_in_file",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) lookup_in_file",
      "file": "src/callgraph/indexer.rs",
      "line": 244,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) lookup_in_file(&self, file: &str, name: &str) -> Option<&FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn lookup_in_file(&self, file: &str, name: &str) -> Option<&FunctionRef> {\n        self.by_file\n            .get(file)\n            .and_then(|funcs| funcs.iter().find(|f| f.name == name))\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 57
    },
    {
      "name": "(FunctionIndex) lookup_method",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) lookup_method",
      "file": "src/callgraph/indexer.rs",
      "line": 261,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) lookup_method(&self, class_name: &str, method_name: &str) -> Vec<&FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn lookup_method(&self, class_name: &str, method_name: &str) -> Vec<&FunctionRef> {\n        self.definitions\n            .values()\n            .filter(|def| {\n                def.is_method\n                    && def.class_name.as_deref() == Some(class_name)\n                    && def.func_ref.name == method_name\n            })\n            .map(|def| &def.func_ref)\n            .collect()\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 91
    },
    {
      "name": "(FunctionIndex) get_definition",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) get_definition",
      "file": "src/callgraph/indexer.rs",
      "line": 280,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) get_definition(&self, qname: &str) -> Option<&FunctionDef>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn get_definition(&self, qname: &str) -> Option<&FunctionDef> {\n        self.definitions.get(qname)\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 31
    },
    {
      "name": "(FunctionIndex) lookup_pattern",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) lookup_pattern",
      "file": "src/callgraph/indexer.rs",
      "line": 293,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) lookup_pattern(&self, pattern: &str) -> Vec<&FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn lookup_pattern(&self, pattern: &str) -> Vec<&FunctionRef> {\n        // First try exact qualified match\n        if let Some(func) = self.by_qualified.get(pattern) {\n            return vec![func];\n        }\n\n        // Try suffix matching\n        self.definitions\n            .values()\n            .filter(|def| def.matches_qualified(pattern))\n            .map(|def| &def.func_ref)\n            .collect()\n    }\n",
      "semantic_tags": [
        "crud",
        "error_handling",
        "api_endpoint",
        "iteration",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 95
    },
    {
      "name": "(FunctionIndex) all_functions",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) all_functions",
      "file": "src/callgraph/indexer.rs",
      "line": 308,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) all_functions(&self) -> impl Iterator<Item = &FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn all_functions(&self) -> impl Iterator<Item = &FunctionRef> {\n        self.by_qualified.values()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 27
    },
    {
      "name": "(FunctionIndex) len",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) len",
      "file": "src/callgraph/indexer.rs",
      "line": 313,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) len(&self) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn len(&self) -> usize {\n        self.by_qualified.len()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 19
    },
    {
      "name": "(FunctionIndex) is_empty",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) is_empty",
      "file": "src/callgraph/indexer.rs",
      "line": 318,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) is_empty(&self) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn is_empty(&self) -> bool {\n        self.by_qualified.is_empty()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 21
    },
    {
      "name": "(FunctionIndex) files",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) files",
      "file": "src/callgraph/indexer.rs",
      "line": 323,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) files(&self) -> impl Iterator<Item = &String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn files(&self) -> impl Iterator<Item = &String> {\n        self.by_file.keys()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 24
    },
    {
      "name": "(FunctionIndex) contains",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) contains",
      "file": "src/callgraph/indexer.rs",
      "line": 328,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) contains(&self, name: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn contains(&self, name: &str) -> bool {\n        self.by_name.contains_key(name)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 25
    },
    {
      "name": "(FunctionIndex) statistics",
      "qualified_name": "src/callgraph/indexer.rs::(FunctionIndex) statistics",
      "file": "src/callgraph/indexer.rs",
      "line": 333,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (FunctionIndex) statistics(&self) -> &IndexStats",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    pub fn statistics(&self) -> &IndexStats {\n        &self.stats\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 19
    },
    {
      "name": "extract_functions_from_file",
      "qualified_name": "src/callgraph/indexer.rs::extract_functions_from_file",
      "file": "src/callgraph/indexer.rs",
      "line": 342,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_functions_from_file(path: &PathBuf, root: Option<&Path>) -> Result<FileExtraction>",
      "docstring": "",
      "calls": [
        "build_qualified_name",
        "contains",
        "compute_module_name"
      ],
      "called_by": [
        "build_with_root",
        "FunctionIndex.build_with_root"
      ],
      "cfg_summary": "complexity:6, blocks:15",
      "dfg_summary": "vars:24, def-use chains:33",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "fn extract_functions_from_file(path: &PathBuf, root: Option<&Path>) -> Result<FileExtraction> {\n    let module_info = AstExtractor::extract_file(path)?;\n\n    // Compute relative path for qualified names\n    let rel_path = if let Some(root) = root {\n        path.strip_prefix(root)\n            .map(|p| p.to_path_buf())\n            .unwrap_or_else(|_| path.clone())\n    } else {\n        path.clone()\n    };\n\n    let file_str = path.display().to_string();\n    let mut functions = Vec::new();\n\n    // Compute module name from path\n    let module_name = compute_module_name(&rel_path, &module_info.language);\n\n    // First, collect all method line numbers from classes to avoid duplicates.\n    // The function_query in some languages (like Python) matches methods inside\n    // classes, causing them to appear in both module_info.functions AND\n    // module_info.classes[].methods. We prioritize class methods since they\n    // have proper class context.\n    let method_lines: std::collections::HashSet<usize> = module_info\n        .classes\n        .iter()\n        .flat_map(|c| c.methods.iter().map(|m| m.line_number))\n        .collect();\n\n    // Extract top-level functions (skip those that are actually class methods)\n    for func in &module_info.functions {\n        // Skip if this function is actually a method we'll index from a class\n        if method_lines.contains(&func.line_number) {\n            continue;\n        }\n\n        let qname = build_qualified_name(&module_name, None, &func.name, &module_info.language);\n\n        functions.push(FunctionDef {\n            func_ref: FunctionRef {\n                file: file_str.clone(),\n                name: func.name.clone(),\n                qualified_name: Some(qname),\n            },\n            is_method: func.is_method,\n            class_name: None,\n            line_number: func.line_number,\n            language: module_info.language.clone(),\n        });\n    }\n\n    // Extract class methods\n    for class in &module_info.classes {\n        for method in &class.methods {\n            let qname = build_qualified_name(\n                &module_name,\n                Some(&class.name),\n                &method.name,\n                &module_info.language,\n            );\n\n            functions.push(FunctionDef {\n                func_ref: FunctionRef {\n                    file: file_str.clone(),\n                    name: method.name.clone(),\n                    qualified_name: Some(qname),\n                },\n                is_method: true,\n                class_name: Some(class.name.clone()),\n                line_number: method.line_number,\n                language: module_info.language.clone(),\n            });\n        }\n\n        // Also index the class itself (for constructor calls)\n        let class_qname =\n            build_qualified_name(&module_name, None, &class.name, &module_info.language);\n\n        functions.push(FunctionDef {\n            func_ref: FunctionRef {\n                file: file_str.clone(),\n                name: class.name.clone(),\n                qualified_name: Some(class_qname),\n            },\n            is_method: false,\n            class_name: None,\n            line_number: class.line_number,\n            language: module_info.language.clone(),\n        });\n    }\n\n    Ok(FileExtraction { functions })\n}\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 5
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 653
    },
    {
      "name": "compute_module_name",
      "qualified_name": "src/callgraph/indexer.rs::compute_module_name",
      "file": "src/callgraph/indexer.rs",
      "line": 442,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn compute_module_name(path: &Path, language: &str) -> String",
      "docstring": "",
      "calls": [
        "is_empty"
      ],
      "called_by": [
        "test_compute_module_name_rust",
        "test_compute_module_name_python",
        "extract_functions_from_file",
        "test_compute_module_name_typescript"
      ],
      "cfg_summary": "complexity:5, blocks:13",
      "dfg_summary": "vars:10, def-use chains:23",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "fn compute_module_name(path: &Path, language: &str) -> String {\n    let stem = path\n        .file_stem()\n        .and_then(|s| s.to_str())\n        .unwrap_or(\"unknown\");\n\n    let parent_parts: Vec<&str> = path\n        .parent()\n        .map(|p| p.iter().filter_map(|c| c.to_str()).collect())\n        .unwrap_or_default();\n\n    match language {\n        \"python\" => {\n            if parent_parts.is_empty() {\n                stem.to_string()\n            } else {\n                format!(\"{}.{}\", parent_parts.join(\".\"), stem)\n            }\n        }\n        \"typescript\" | \"javascript\" => {\n            if parent_parts.is_empty() {\n                stem.to_string()\n            } else {\n                format!(\"{}/{}\", parent_parts.join(\"/\"), stem)\n            }\n        }\n        \"go\" => {\n            // Go uses the package name, which is the directory name\n            parent_parts.last().copied().unwrap_or(stem).to_string()\n        }\n        \"rust\" => {\n            if parent_parts.is_empty() {\n                stem.to_string()\n            } else {\n                format!(\"{}::{}\", parent_parts.join(\"::\"), stem)\n            }\n        }\n        \"java\" => {\n            // Java uses package.ClassName\n            if parent_parts.is_empty() {\n                stem.to_string()\n            } else {\n                format!(\"{}.{}\", parent_parts.join(\".\"), stem)\n            }\n        }\n        \"c\" => {\n            // C doesn't have namespaces, use file stem\n            stem.to_string()\n        }\n        _ => stem.to_string(),\n    }\n}\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 9,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 336
    },
    {
      "name": "build_qualified_name",
      "qualified_name": "src/callgraph/indexer.rs::build_qualified_name",
      "file": "src/callgraph/indexer.rs",
      "line": 502,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn build_qualified_name(module: &str, class: Option<&str>, name: &str, language: &str) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [
        "extract_functions_from_file",
        "test_build_qualified_name_python",
        "test_build_qualified_name_rust",
        "test_build_qualified_name_typescript"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:28",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "fn build_qualified_name(module: &str, class: Option<&str>, name: &str, language: &str) -> String {\n    match language {\n        \"python\" | \"java\" => match class {\n            Some(c) => format!(\"{}.{}.{}\", module, c, name),\n            None => format!(\"{}.{}\", module, name),\n        },\n        \"typescript\" | \"javascript\" => match class {\n            Some(c) => format!(\"{}#{}.{}\", module, c, name),\n            None => format!(\"{}#{}\", module, name),\n        },\n        \"go\" => match class {\n            Some(c) => format!(\"{}.{}.{}\", module, c, name),\n            None => format!(\"{}.{}\", module, name),\n        },\n        \"rust\" => match class {\n            Some(c) => format!(\"{}::{}::{}\", module, c, name),\n            None => format!(\"{}::{}\", module, name),\n        },\n        \"c\" => {\n            // C doesn't have classes, just prefix with file name\n            format!(\"{}::{}\", module, name)\n        }\n        _ => match class {\n            Some(c) => format!(\"{}.{}.{}\", module, c, name),\n            None => format!(\"{}.{}\", module, name),\n        },\n    }\n}\n",
      "semantic_tags": [
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 6,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 264
    },
    {
      "name": "create_temp_file",
      "qualified_name": "src/callgraph/indexer.rs::create_temp_file",
      "file": "src/callgraph/indexer.rs",
      "line": 537,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_temp_file(dir: &TempDir, name: &str, content: &str) -> PathBuf",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_extract_python_functions",
        "test_decorated_python_class",
        "test_lookup_pattern",
        "test_extract_python_imports",
        "test_extract_python_classes"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:13, def-use chains:7",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn create_temp_file(dir: &TempDir, name: &str, content: &str) -> PathBuf {\n        let path = dir.path().join(name);\n        if let Some(parent) = path.parent() {\n            std::fs::create_dir_all(parent).unwrap();\n        }\n        let mut file = std::fs::File::create(&path).unwrap();\n        file.write_all(content.as_bytes()).unwrap();\n        path\n    }\n",
      "semantic_tags": [
        "crud",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 92
    },
    {
      "name": "test_build_index_python",
      "qualified_name": "src/callgraph/indexer.rs::test_build_index_python",
      "file": "src/callgraph/indexer.rs",
      "line": 548,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_index_python()",
      "docstring": "",
      "calls": [
        "build",
        "lookup",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:16, def-use chains:9",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_build_index_python() {\n        let dir = TempDir::new().unwrap();\n\n        let content = r#\"\ndef standalone():\n    pass\n\nclass MyClass:\n    def method(self):\n        pass\n\nasync def async_func():\n    pass\n\"#;\n        let file = create_temp_file(&dir, \"module.py\", content);\n\n        let index = FunctionIndex::build(&[file]).unwrap();\n\n        // Check statistics\n        assert!(index.stats.files_processed >= 1);\n        assert!(index.len() >= 3); // standalone, method, async_func, MyClass\n\n        // Lookup by simple name\n        let funcs = index.lookup(\"standalone\");\n        assert!(!funcs.is_empty());\n\n        let methods = index.lookup(\"method\");\n        assert!(!methods.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "async_ops",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 163
    },
    {
      "name": "test_build_index_typescript",
      "qualified_name": "src/callgraph/indexer.rs::test_build_index_typescript",
      "file": "src/callgraph/indexer.rs",
      "line": 579,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_index_typescript()",
      "docstring": "",
      "calls": [
        "build",
        "create_temp_file",
        "lookup"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:6",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_build_index_typescript() {\n        let dir = TempDir::new().unwrap();\n\n        let content = r#\"\nfunction greet(name: string): void {\n    console.log(name);\n}\n\nclass Service {\n    handle(): void {}\n}\n\nconst arrow = () => {};\n\"#;\n        let file = create_temp_file(&dir, \"api.ts\", content);\n\n        let index = FunctionIndex::build(&[file]).unwrap();\n\n        // Check we found functions\n        assert!(!index.is_empty());\n\n        let greet = index.lookup(\"greet\");\n        assert!(!greet.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "logging"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 124
    },
    {
      "name": "test_lookup_qualified",
      "qualified_name": "src/callgraph/indexer.rs::test_lookup_qualified",
      "file": "src/callgraph/indexer.rs",
      "line": 605,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_lookup_qualified()",
      "docstring": "",
      "calls": [
        "lookup_qualified",
        "create_temp_file",
        "build_with_root"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:6",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_lookup_qualified() {\n        let dir = TempDir::new().unwrap();\n\n        let content = r#\"\nclass Controller:\n    def handle(self):\n        pass\n\"#;\n        let file = create_temp_file(&dir, \"web.py\", content);\n\n        let index = FunctionIndex::build_with_root(&[file], Some(dir.path())).unwrap();\n\n        // Should be able to look up with qualified name\n        let result = index.lookup_qualified(\"web.Controller.handle\");\n        assert!(result.is_some());\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "api_endpoint"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 109
    },
    {
      "name": "test_lookup_in_file",
      "qualified_name": "src/callgraph/indexer.rs::test_lookup_in_file",
      "file": "src/callgraph/indexer.rs",
      "line": 623,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_lookup_in_file()",
      "docstring": "",
      "calls": [
        "build",
        "create_temp_file",
        "lookup_in_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:16, def-use chains:8",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_lookup_in_file() {\n        let dir = TempDir::new().unwrap();\n\n        let content = r#\"\ndef helper():\n    pass\n\ndef main():\n    helper()\n\"#;\n        let file = create_temp_file(&dir, \"script.py\", content);\n        let file_str = file.display().to_string();\n\n        let index = FunctionIndex::build(&[file]).unwrap();\n\n        let result = index.lookup_in_file(&file_str, \"helper\");\n        assert!(result.is_some());\n        assert_eq!(result.unwrap().name, \"helper\");\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 117
    },
    {
      "name": "test_lookup_method",
      "qualified_name": "src/callgraph/indexer.rs::test_lookup_method",
      "file": "src/callgraph/indexer.rs",
      "line": 644,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_lookup_method()",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "lookup_method",
        "lookup",
        "build"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:9",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_lookup_method() {\n        let dir = TempDir::new().unwrap();\n\n        let content = r#\"\nclass Service:\n    def process(self):\n        pass\n\nclass Handler:\n    def process(self):\n        pass\n\"#;\n        let file = create_temp_file(&dir, \"handlers.py\", content);\n\n        let index = FunctionIndex::build(&[file]).unwrap();\n\n        // Both classes have 'process', lookup should find both\n        let all_process = index.lookup(\"process\");\n        assert_eq!(all_process.len(), 2);\n\n        // Lookup specific class method\n        let service_process = index.lookup_method(\"Service\", \"process\");\n        assert_eq!(service_process.len(), 1);\n\n        let handler_process = index.lookup_method(\"Handler\", \"process\");\n        assert_eq!(handler_process.len(), 1);\n    }\n",
      "semantic_tags": [
        "test",
        "api_endpoint"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 172
    },
    {
      "name": "test_multiple_files_same_function_name",
      "qualified_name": "src/callgraph/indexer.rs::test_multiple_files_same_function_name",
      "file": "src/callgraph/indexer.rs",
      "line": 673,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_multiple_files_same_function_name()",
      "docstring": "",
      "calls": [
        "lookup",
        "create_temp_file",
        "build"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:8",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_multiple_files_same_function_name() {\n        let dir = TempDir::new().unwrap();\n\n        let content1 = \"def helper(): pass\";\n        let content2 = \"def helper(): pass\";\n\n        let file1 = create_temp_file(&dir, \"module1.py\", content1);\n        let file2 = create_temp_file(&dir, \"module2.py\", content2);\n\n        let index = FunctionIndex::build(&[file1, file2]).unwrap();\n\n        // Should find both functions with same name\n        let helpers = index.lookup(\"helper\");\n        assert_eq!(helpers.len(), 2);\n    }\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 130
    },
    {
      "name": "test_lookup_pattern",
      "qualified_name": "src/callgraph/indexer.rs::test_lookup_pattern",
      "file": "src/callgraph/indexer.rs",
      "line": 690,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_lookup_pattern()",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "build_with_root",
        "lookup_pattern"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:6",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_lookup_pattern() {\n        let dir = TempDir::new().unwrap();\n\n        let content = r#\"\nclass Database:\n    def connect(self):\n        pass\n\"#;\n        let file = create_temp_file(&dir, \"db.py\", content);\n\n        let index = FunctionIndex::build_with_root(&[file], Some(dir.path())).unwrap();\n\n        // Partial pattern should match\n        let result = index.lookup_pattern(\"Database.connect\");\n        assert!(!result.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 102
    },
    {
      "name": "test_compute_module_name_python",
      "qualified_name": "src/callgraph/indexer.rs::test_compute_module_name_python",
      "file": "src/callgraph/indexer.rs",
      "line": 708,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_compute_module_name_python()",
      "docstring": "",
      "calls": [
        "compute_module_name"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_compute_module_name_python() {\n        let path = Path::new(\"pkg/subpkg/module.py\");\n        let module = compute_module_name(path, \"python\");\n        assert_eq!(module, \"pkg.subpkg.module\");\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 49
    },
    {
      "name": "test_compute_module_name_typescript",
      "qualified_name": "src/callgraph/indexer.rs::test_compute_module_name_typescript",
      "file": "src/callgraph/indexer.rs",
      "line": 715,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_compute_module_name_typescript()",
      "docstring": "",
      "calls": [
        "compute_module_name"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_compute_module_name_typescript() {\n        let path = Path::new(\"src/utils/helpers.ts\");\n        let module = compute_module_name(path, \"typescript\");\n        assert_eq!(module, \"src/utils/helpers\");\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 48
    },
    {
      "name": "test_compute_module_name_rust",
      "qualified_name": "src/callgraph/indexer.rs::test_compute_module_name_rust",
      "file": "src/callgraph/indexer.rs",
      "line": 722,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_compute_module_name_rust()",
      "docstring": "",
      "calls": [
        "compute_module_name"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_compute_module_name_rust() {\n        let path = Path::new(\"src/lib/parser.rs\");\n        let module = compute_module_name(path, \"rust\");\n        assert_eq!(module, \"src::lib::parser\");\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 50
    },
    {
      "name": "test_build_qualified_name_python",
      "qualified_name": "src/callgraph/indexer.rs::test_build_qualified_name_python",
      "file": "src/callgraph/indexer.rs",
      "line": 729,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_qualified_name_python()",
      "docstring": "",
      "calls": [
        "build_qualified_name"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_build_qualified_name_python() {\n        let qname = build_qualified_name(\"module\", Some(\"Class\"), \"method\", \"python\");\n        assert_eq!(qname, \"module.Class.method\");\n\n        let qname = build_qualified_name(\"module\", None, \"func\", \"python\");\n        assert_eq!(qname, \"module.func\");\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 77
    },
    {
      "name": "test_build_qualified_name_typescript",
      "qualified_name": "src/callgraph/indexer.rs::test_build_qualified_name_typescript",
      "file": "src/callgraph/indexer.rs",
      "line": 738,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_qualified_name_typescript()",
      "docstring": "",
      "calls": [
        "build_qualified_name"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_build_qualified_name_typescript() {\n        let qname = build_qualified_name(\"utils\", Some(\"Helper\"), \"run\", \"typescript\");\n        assert_eq!(qname, \"utils#Helper.run\");\n\n        let qname = build_qualified_name(\"utils\", None, \"parse\", \"typescript\");\n        assert_eq!(qname, \"utils#parse\");\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 80
    },
    {
      "name": "test_build_qualified_name_rust",
      "qualified_name": "src/callgraph/indexer.rs::test_build_qualified_name_rust",
      "file": "src/callgraph/indexer.rs",
      "line": 747,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_qualified_name_rust()",
      "docstring": "",
      "calls": [
        "build_qualified_name"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_build_qualified_name_rust() {\n        let qname = build_qualified_name(\"parser\", Some(\"Lexer\"), \"tokenize\", \"rust\");\n        assert_eq!(qname, \"parser::Lexer::tokenize\");\n\n        let qname = build_qualified_name(\"utils\", None, \"helper\", \"rust\");\n        assert_eq!(qname, \"utils::helper\");\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 83
    },
    {
      "name": "test_function_def_matches_qualified",
      "qualified_name": "src/callgraph/indexer.rs::test_function_def_matches_qualified",
      "file": "src/callgraph/indexer.rs",
      "line": 756,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_function_def_matches_qualified()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:5",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_function_def_matches_qualified() {\n        let def = FunctionDef {\n            func_ref: FunctionRef {\n                file: \"test.py\".to_string(),\n                name: \"method\".to_string(),\n                qualified_name: Some(\"pkg.module.Class.method\".to_string()),\n            },\n            is_method: true,\n            class_name: Some(\"Class\".to_string()),\n            line_number: 10,\n            language: \"python\".to_string(),\n        };\n\n        // Exact match\n        assert!(def.matches_qualified(\"pkg.module.Class.method\"));\n\n        // Suffix match\n        assert!(def.matches_qualified(\"Class.method\"));\n        assert!(def.matches_qualified(\"module.Class.method\"));\n\n        // Non-match\n        assert!(!def.matches_qualified(\"other.method\"));\n        assert!(!def.matches_qualified(\"ss.method\")); // Partial word match should fail\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "error_handling"
      ],
      "complexity": {
        "depth": 4,
        "branches": 4,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 180
    },
    {
      "name": "test_empty_index",
      "qualified_name": "src/callgraph/indexer.rs::test_empty_index",
      "file": "src/callgraph/indexer.rs",
      "line": 782,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_empty_index()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:4",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_empty_index() {\n        let index = FunctionIndex::default();\n\n        assert!(index.is_empty());\n        assert_eq!(index.len(), 0);\n        assert!(index.lookup(\"anything\").is_empty());\n        assert!(index.lookup_qualified(\"any.thing\").is_none());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 61
    },
    {
      "name": "test_class_indexed_for_constructors",
      "qualified_name": "src/callgraph/indexer.rs::test_class_indexed_for_constructors",
      "file": "src/callgraph/indexer.rs",
      "line": 792,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_class_indexed_for_constructors()",
      "docstring": "",
      "calls": [
        "build",
        "lookup",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:5",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "    fn test_class_indexed_for_constructors() {\n        let dir = TempDir::new().unwrap();\n\n        let content = r#\"\nclass MyService:\n    def __init__(self):\n        pass\n\"#;\n        let file = create_temp_file(&dir, \"service.py\", content);\n\n        let index = FunctionIndex::build(&[file]).unwrap();\n\n        // The class itself should be indexed (for constructor calls like MyService())\n        let classes = index.lookup(\"MyService\");\n        assert!(!classes.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 111
    },
    {
      "name": "FunctionDef",
      "qualified_name": "src/callgraph/indexer.rs::FunctionDef",
      "file": "src/callgraph/indexer.rs",
      "line": 22,
      "language": "rust",
      "unit_type": "class",
      "signature": "class FunctionDef",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "pub struct FunctionDef {\n    /// Reference to the function (file, name, qualified_name)\n    pub func_ref: FunctionRef,\n    /// Whether this is a method (belongs to a class)\n    pub is_method: bool,\n    /// Parent class name if this is a method\n    pub class_name: Option<String>,\n    /// Starting line number\n    pub line_number: usize,\n    /// Source language\n    pub language: String,\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 91
    },
    {
      "name": "FunctionIndex",
      "qualified_name": "src/callgraph/indexer.rs::FunctionIndex",
      "file": "src/callgraph/indexer.rs",
      "line": 70,
      "language": "rust",
      "unit_type": "class",
      "signature": "class FunctionIndex",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "pub struct FunctionIndex {\n    /// Map from simple function name to all definitions with that name.\n    ///\n    /// Used for initial candidate lookup before disambiguation.\n    pub by_name: HashMap<String, Vec<FunctionRef>>,\n\n    /// Map from fully qualified name to definition.\n    ///\n    /// Format varies by language:\n    /// - Python: module.Class.method or module.function\n    /// - TypeScript: file#Class.method or file#function\n    /// - Go: package.Function or package.Type.Method\n    /// - Rust: crate::module::function or crate::module::Type::method\n    pub by_qualified: HashMap<String, FunctionRef>,\n\n    /// Map from file path to all functions defined in that file.\n    ///\n    /// Used for resolving local/relative calls.\n    pub by_file: HashMap<String, Vec<FunctionRef>>,\n\n    /// Full metadata for each function (indexed by qualified name).\n    ///\n    /// Provides additional context for disambiguation.\n    definitions: HashMap<String, FunctionDef>,\n\n    /// Statistics for debugging\n    pub stats: IndexStats,\n}\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 5
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 227
    },
    {
      "name": "IndexStats",
      "qualified_name": "src/callgraph/indexer.rs::IndexStats",
      "file": "src/callgraph/indexer.rs",
      "line": 101,
      "language": "rust",
      "unit_type": "class",
      "signature": "class IndexStats",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "pub struct IndexStats {\n    /// Total files processed\n    pub files_processed: usize,\n    /// Files that failed to parse\n    pub parse_errors: usize,\n    /// Total functions indexed\n    pub functions_indexed: usize,\n    /// Total methods indexed\n    pub methods_indexed: usize,\n    /// Total classes indexed\n    pub classes_indexed: usize,\n}\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 76
    },
    {
      "name": "FileExtraction",
      "qualified_name": "src/callgraph/indexer.rs::FileExtraction",
      "file": "src/callgraph/indexer.rs",
      "line": 115,
      "language": "rust",
      "unit_type": "class",
      "signature": "class FileExtraction",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, std::path, rayon::prelude, crate::ast::extractor, crate::callgraph::types",
      "code_preview": "struct FileExtraction {\n    functions: Vec<FunctionDef>,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 14
    },
    {
      "name": "(TldrIgnore) new",
      "qualified_name": "src/util/ignore.rs::(TldrIgnore) new",
      "file": "src/util/ignore.rs",
      "line": 130,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TldrIgnore) new(project_dir: &Path) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    pub fn new(project_dir: &Path) -> Self {\n        let root = project_dir\n            .canonicalize()\n            .unwrap_or_else(|_| project_dir.to_path_buf());\n\n        let tldrignore_path = root.join(\".tldrignore\");\n        let gitignore_path = root.join(\".gitignore\");\n\n        let mut builder = GitignoreBuilder::new(&root);\n\n        // Load .tldrignore if it exists (highest priority)\n        let mut loaded_patterns = false;\n        if tldrignore_path.exists() {\n            if let Some(err) = builder.add(&tldrignore_path) {\n                tracing::warn!(\"Error loading .tldrignore: {}\", err);\n            } else {\n                loaded_patterns = true;\n                tracing::debug!(\"Loaded .tldrignore from {:?}\", tldrignore_path);\n            }\n        }\n\n        // Also load .gitignore if it exists (lower priority, loaded after .tldrignore)\n        if gitignore_path.exists() {\n            if let Some(err) = builder.add(&gitignore_path) {\n                tracing::warn!(\"Error loading .gitignore: {}\", err);\n            } else {\n                loaded_patterns = true;\n                tracing::debug!(\"Loaded .gitignore from {:?}\", gitignore_path);\n            }\n        }\n\n        // If no ignore files found, use defaults\n        if !loaded_patterns {\n            for line in DEFAULT_PATTERNS.lines() {\n                let line = line.trim();\n                if !line.is_empty() && !line.starts_with('#') {\n                    if let Err(e) = builder.add_line(None, line) {\n                        tracing::warn!(\"Invalid pattern '{}': {}\", line, e);\n                    }\n                }\n            }\n            tracing::debug!(\"Using default ignore patterns\");\n        }\n\n        let matcher = builder.build().unwrap_or_else(|e| {\n            tracing::error!(\"Failed to build gitignore matcher: {}\", e);\n            // Return empty matcher as fallback\n            GitignoreBuilder::new(&root)\n                .build()\n                .unwrap_or_else(|_| panic!(\"Failed to build even empty gitignore matcher\"))\n        });\n\n        Self { matcher, root }\n    }\n",
      "semantic_tags": [
        "crud",
        "logging",
        "error_handling",
        "iteration",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 6,
        "branches": 11,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 434
    },
    {
      "name": "(TldrIgnore) is_ignored",
      "qualified_name": "src/util/ignore.rs::(TldrIgnore) is_ignored",
      "file": "src/util/ignore.rs",
      "line": 213,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TldrIgnore) is_ignored(&self, path: &Path) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    pub fn is_ignored(&self, path: &Path) -> bool {\n        // Make path relative to root for matching\n        let relative_path = if path.is_absolute() {\n            path.strip_prefix(&self.root)\n                .map(Path::to_path_buf)\n                .unwrap_or_else(|_| path.to_path_buf())\n        } else {\n            path.to_path_buf()\n        };\n\n        // Check if path is a directory (gitignore treats dirs specially)\n        let is_dir = path.is_dir()\n            || relative_path.to_string_lossy().ends_with('/')\n            || self.root.join(&relative_path).is_dir();\n\n        // Use the matcher\n        self.matcher\n            .matched_path_or_any_parents(&relative_path, is_dir)\n            .is_ignore()\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 158
    },
    {
      "name": "(TldrIgnore) filter_paths",
      "qualified_name": "src/util/ignore.rs::(TldrIgnore) filter_paths",
      "file": "src/util/ignore.rs",
      "line": 243,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TldrIgnore) filter_paths(&self, paths: I) -> Vec<PathBuf>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    pub fn filter_paths<'a, I>(&self, paths: I) -> Vec<PathBuf>\n    where\n        I: IntoIterator<Item = &'a Path>,\n    {\n        paths\n            .into_iter()\n            .filter(|p| !self.is_ignored(p))\n            .map(Path::to_path_buf)\n            .collect()\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 73
    },
    {
      "name": "(TldrIgnore) root",
      "qualified_name": "src/util/ignore.rs::(TldrIgnore) root",
      "file": "src/util/ignore.rs",
      "line": 256,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TldrIgnore) root(&self) -> &Path",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    pub fn root(&self) -> &Path {\n        &self.root\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 18
    },
    {
      "name": "load_ignore",
      "qualified_name": "src/util/ignore.rs::load_ignore",
      "file": "src/util/ignore.rs",
      "line": 273,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn load_ignore(project_dir: &Path) -> TldrIgnore",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:1",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "pub fn load_ignore(project_dir: &Path) -> TldrIgnore {\n    TldrIgnore::new(project_dir)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 25
    },
    {
      "name": "is_default_ignored",
      "qualified_name": "src/util/ignore.rs::is_default_ignored",
      "file": "src/util/ignore.rs",
      "line": 290,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_default_ignored(path: &Path) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:5, blocks:11",
      "dfg_summary": "vars:10, def-use chains:6",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "pub fn is_default_ignored(path: &Path) -> bool {\n    let path_str = path.to_string_lossy();\n\n    // Quick checks for common ignore patterns\n    let components: Vec<&str> = path_str.split(['/', '\\\\']).collect();\n\n    for component in &components {\n        match *component {\n            // Version control\n            \".git\" | \".hg\" | \".svn\" => return true,\n            // Dependencies\n            \"node_modules\" | \"__pycache__\" | \".venv\" | \"venv\" | \"env\" | \"vendor\" | \"Pods\" => {\n                return true\n            }\n            // Build outputs\n            \"dist\" | \"build\" | \"out\" | \"target\" => {\n                // Only ignore if not the last component (allow dist/main.py)\n                if components.last() != Some(component) {\n                    return true;\n                }\n            }\n            // Cache directories\n            \".tox\" | \".nox\" | \".pytest_cache\" | \".mypy_cache\" | \".ruff_cache\" => return true,\n            // IDE\n            \".idea\" | \".vscode\" => return true,\n            _ => {}\n        }\n    }\n\n    // Check file extensions\n    if let Some(ext) = path.extension().and_then(|e| e.to_str()) {\n        match ext {\n            \"pyc\" | \"pyo\" | \"whl\" | \"so\" | \"dylib\" | \"dll\" | \"exe\" | \"bin\" | \"o\" | \"a\" | \"lib\"\n            | \"pem\" | \"key\" | \"p12\" | \"pfx\" | \"swp\" | \"swo\" => return true,\n            _ => {}\n        }\n    }\n\n    // Check file names\n    if let Some(name) = path.file_name().and_then(|n| n.to_str()) {\n        match name {\n            \".DS_Store\" | \"Thumbs.db\" | \".env\" => return true,\n            _ if name.starts_with(\".env.\") => return true,\n            _ if name.ends_with('~') => return true,\n            _ if name.starts_with(\"credentials.\") || name.starts_with(\"secrets.\") => return true,\n            _ => {}\n        }\n    }\n\n    false\n}\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "config",
        "transform",
        "cache"
      ],
      "complexity": {
        "depth": 5,
        "branches": 10,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 479
    },
    {
      "name": "ensure_tldrignore",
      "qualified_name": "src/util/ignore.rs::ensure_tldrignore",
      "file": "src/util/ignore.rs",
      "line": 358,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn ensure_tldrignore(project_dir: &Path) -> std::io::Result<bool>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_ensure_tldrignore_creates_file"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:9, def-use chains:3",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "pub fn ensure_tldrignore(project_dir: &Path) -> std::io::Result<bool> {\n    let tldrignore_path = project_dir.join(\".tldrignore\");\n\n    if tldrignore_path.exists() {\n        return Ok(false);\n    }\n\n    std::fs::write(&tldrignore_path, DEFAULT_PATTERNS)?;\n    Ok(true)\n}\n",
      "semantic_tags": [
        "transform"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 74
    },
    {
      "name": "test_tldr_ignore_default_patterns",
      "qualified_name": "src/util/ignore.rs::test_tldr_ignore_default_patterns",
      "file": "src/util/ignore.rs",
      "line": 380,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_tldr_ignore_default_patterns()",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:6",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    fn test_tldr_ignore_default_patterns() {\n        let temp_dir = TempDir::new().unwrap();\n        let ignore = TldrIgnore::new(temp_dir.path());\n\n        // Should ignore common patterns\n        assert!(ignore.is_ignored(Path::new(\"node_modules/pkg/index.js\")));\n        assert!(ignore.is_ignored(Path::new(\"__pycache__/module.pyc\")));\n        assert!(ignore.is_ignored(Path::new(\".git/config\")));\n        assert!(ignore.is_ignored(Path::new(\"target/debug/binary\")));\n        assert!(ignore.is_ignored(Path::new(\".venv/bin/python\")));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "logging",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 125
    },
    {
      "name": "test_tldr_ignore_allows_source_files",
      "qualified_name": "src/util/ignore.rs::test_tldr_ignore_allows_source_files",
      "file": "src/util/ignore.rs",
      "line": 393,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_tldr_ignore_allows_source_files()",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:4",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    fn test_tldr_ignore_allows_source_files() {\n        let temp_dir = TempDir::new().unwrap();\n        let ignore = TldrIgnore::new(temp_dir.path());\n\n        // Should NOT ignore source files\n        assert!(!ignore.is_ignored(Path::new(\"src/main.rs\")));\n        assert!(!ignore.is_ignored(Path::new(\"lib/utils.py\")));\n        assert!(!ignore.is_ignored(Path::new(\"app.ts\")));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 94
    },
    {
      "name": "test_tldr_ignore_custom_patterns",
      "qualified_name": "src/util/ignore.rs::test_tldr_ignore_custom_patterns",
      "file": "src/util/ignore.rs",
      "line": 404,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_tldr_ignore_custom_patterns()",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:4",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    fn test_tldr_ignore_custom_patterns() {\n        let temp_dir = TempDir::new().unwrap();\n\n        // Create custom .tldrignore\n        fs::write(\n            temp_dir.path().join(\".tldrignore\"),\n            \"custom_ignore/\\n*.custom\\n\",\n        )\n        .unwrap();\n\n        let ignore = TldrIgnore::new(temp_dir.path());\n\n        // Custom patterns should work\n        assert!(ignore.is_ignored(Path::new(\"custom_ignore/file.txt\")));\n        assert!(ignore.is_ignored(Path::new(\"test.custom\")));\n\n        // Default patterns should still work (from gitignore if present)\n        // Note: with custom .tldrignore, defaults may not be loaded\n        // unless we also have .gitignore\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "validation",
        "test"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 156
    },
    {
      "name": "test_is_default_ignored",
      "qualified_name": "src/util/ignore.rs::test_is_default_ignored",
      "file": "src/util/ignore.rs",
      "line": 426,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_is_default_ignored()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:0",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    fn test_is_default_ignored() {\n        // Directories\n        assert!(is_default_ignored(Path::new(\"node_modules/pkg\")));\n        assert!(is_default_ignored(Path::new(\"__pycache__/cache\")));\n        assert!(is_default_ignored(Path::new(\".git/config\")));\n\n        // Files by extension\n        assert!(is_default_ignored(Path::new(\"file.pyc\")));\n        assert!(is_default_ignored(Path::new(\"lib.so\")));\n        assert!(is_default_ignored(Path::new(\"secret.pem\")));\n\n        // Files by name\n        assert!(is_default_ignored(Path::new(\".DS_Store\")));\n        assert!(is_default_ignored(Path::new(\".env\")));\n        assert!(is_default_ignored(Path::new(\".env.local\")));\n\n        // Should NOT ignore\n        assert!(!is_default_ignored(Path::new(\"src/main.py\")));\n        assert!(!is_default_ignored(Path::new(\"lib.rs\")));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "cache",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 194
    },
    {
      "name": "test_ensure_tldrignore_creates_file",
      "qualified_name": "src/util/ignore.rs::test_ensure_tldrignore_creates_file",
      "file": "src/util/ignore.rs",
      "line": 448,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_ensure_tldrignore_creates_file()",
      "docstring": "",
      "calls": [
        "new",
        "ensure_tldrignore"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:7",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    fn test_ensure_tldrignore_creates_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let tldrignore_path = temp_dir.path().join(\".tldrignore\");\n\n        // Should not exist initially\n        assert!(!tldrignore_path.exists());\n\n        // Create it\n        let created = ensure_tldrignore(temp_dir.path()).unwrap();\n        assert!(created);\n        assert!(tldrignore_path.exists());\n\n        // Calling again should return false (already exists)\n        let created_again = ensure_tldrignore(temp_dir.path()).unwrap();\n        assert!(!created_again);\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "validation",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 127
    },
    {
      "name": "test_filter_paths",
      "qualified_name": "src/util/ignore.rs::test_filter_paths",
      "file": "src/util/ignore.rs",
      "line": 466,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_filter_paths()",
      "docstring": "",
      "calls": [
        "filter_paths",
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:6",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    fn test_filter_paths() {\n        let temp_dir = TempDir::new().unwrap();\n        let ignore = TldrIgnore::new(temp_dir.path());\n\n        let paths = vec![\n            Path::new(\"src/main.rs\"),\n            Path::new(\"node_modules/pkg/index.js\"),\n            Path::new(\"lib/utils.py\"),\n            Path::new(\"__pycache__/cache.pyc\"),\n        ];\n\n        let filtered = ignore.filter_paths(paths.iter().copied());\n\n        assert_eq!(filtered.len(), 2);\n        assert!(filtered.contains(&PathBuf::from(\"src/main.rs\")));\n        assert!(filtered.contains(&PathBuf::from(\"lib/utils.py\")));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "cache"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 136
    },
    {
      "name": "test_gitignore_integration",
      "qualified_name": "src/util/ignore.rs::test_gitignore_integration",
      "file": "src/util/ignore.rs",
      "line": 485,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_gitignore_integration()",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:5",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    fn test_gitignore_integration() {\n        let temp_dir = TempDir::new().unwrap();\n\n        // Create .gitignore with custom pattern\n        fs::write(temp_dir.path().join(\".gitignore\"), \"*.log\\nlogs/\\n\").unwrap();\n\n        let ignore = TldrIgnore::new(temp_dir.path());\n\n        // gitignore patterns should work\n        assert!(ignore.is_ignored(Path::new(\"debug.log\")));\n        assert!(ignore.is_ignored(Path::new(\"logs/app.txt\")));\n\n        // Source files should still be allowed\n        assert!(!ignore.is_ignored(Path::new(\"main.py\")));\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "logging",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 128
    },
    {
      "name": "test_tldrignore_overrides_gitignore",
      "qualified_name": "src/util/ignore.rs::test_tldrignore_overrides_gitignore",
      "file": "src/util/ignore.rs",
      "line": 502,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_tldrignore_overrides_gitignore()",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:5",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "    fn test_tldrignore_overrides_gitignore() {\n        let temp_dir = TempDir::new().unwrap();\n\n        // Create both ignore files\n        fs::write(temp_dir.path().join(\".gitignore\"), \"*.txt\\n\").unwrap();\n        fs::write(temp_dir.path().join(\".tldrignore\"), \"*.custom\\n\").unwrap();\n\n        let ignore = TldrIgnore::new(temp_dir.path());\n\n        // Both patterns should work when both files exist\n        // (tldrignore is loaded first, then gitignore)\n        assert!(ignore.is_ignored(Path::new(\"test.custom\")));\n        // gitignore patterns also loaded\n        assert!(ignore.is_ignored(Path::new(\"test.txt\")));\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 146
    },
    {
      "name": "TldrIgnore",
      "qualified_name": "src/util/ignore.rs::TldrIgnore",
      "file": "src/util/ignore.rs",
      "line": 98,
      "language": "rust",
      "unit_type": "class",
      "signature": "class TldrIgnore",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::path, ignore::gitignore, super, std, tempfile",
      "code_preview": "pub struct TldrIgnore {\n    /// The compiled gitignore matcher\n    matcher: Gitignore,\n    /// Project root directory (for relative path matching)\n    root: PathBuf,\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 38
    },
    {
      "name": "escape_mermaid_label",
      "qualified_name": "src/cfg/render.rs::escape_mermaid_label",
      "file": "src/cfg/render.rs",
      "line": 17,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn escape_mermaid_label(s: &str) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_mermaid_escaping",
        "to_mermaid"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:1",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "fn escape_mermaid_label(s: &str) -> String {\n    s.replace('\"', \"'\")\n        .replace('\\n', \" \")\n        .replace('\\r', \"\")\n        .replace('|', \"/\")\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 44
    },
    {
      "name": "escape_dot_label",
      "qualified_name": "src/cfg/render.rs::escape_dot_label",
      "file": "src/cfg/render.rs",
      "line": 30,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn escape_dot_label(s: &str) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_dot_escaping",
        "to_dot"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:1",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "fn escape_dot_label(s: &str) -> String {\n    s.replace('\\\\', \"\\\\\\\\\")\n        .replace('\"', \"\\\\\\\"\")\n        .replace('\\n', \"\\\\n\")\n        .replace('\\r', \"\")\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 45
    },
    {
      "name": "sanitize_dot_id",
      "qualified_name": "src/cfg/render.rs::sanitize_dot_id",
      "file": "src/cfg/render.rs",
      "line": 41,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn sanitize_dot_id(s: &str) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [
        "to_dot"
      ],
      "cfg_summary": "complexity:5, blocks:11",
      "dfg_summary": "vars:6, def-use chains:9",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "fn sanitize_dot_id(s: &str) -> String {\n    let mut result = String::with_capacity(s.len());\n    for c in s.chars() {\n        if c.is_alphanumeric() || c == '_' {\n            result.push(c);\n        } else {\n            result.push('_');\n        }\n    }\n    // DOT identifiers cannot start with a digit\n    if result.starts_with(|c: char| c.is_ascii_digit()) {\n        result.insert(0, '_');\n    }\n    if result.is_empty() {\n        result.push_str(\"_anonymous\");\n    }\n    result\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 119
    },
    {
      "name": "sorted_block_ids",
      "qualified_name": "src/cfg/render.rs::sorted_block_ids",
      "file": "src/cfg/render.rs",
      "line": 61,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn sorted_block_ids(cfg: &CFGInfo) -> Vec<BlockId>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "to_mermaid",
        "to_ascii",
        "to_dot"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:3",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "fn sorted_block_ids(cfg: &CFGInfo) -> Vec<BlockId> {\n    let mut ids: Vec<_> = cfg.blocks.keys().copied().collect();\n    ids.sort_by_key(|id| id.0);\n    ids\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 50
    },
    {
      "name": "to_mermaid",
      "qualified_name": "src/cfg/render.rs::to_mermaid",
      "file": "src/cfg/render.rs",
      "line": 87,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn to_mermaid(cfg: &CFGInfo) -> String",
      "docstring": "",
      "calls": [
        "escape_mermaid_label",
        "sorted_block_ids"
      ],
      "called_by": [
        "test_mermaid_output",
        "test_mermaid_output",
        "test_deterministic_output"
      ],
      "cfg_summary": "complexity:3, blocks:7",
      "dfg_summary": "vars:16, def-use chains:11",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "pub fn to_mermaid(cfg: &CFGInfo) -> String {\n    let mut out = String::from(\"flowchart TD\\n\");\n\n    // Render blocks in sorted order for deterministic output\n    for id in sorted_block_ids(cfg) {\n        let block = &cfg.blocks[&id];\n        let label = escape_mermaid_label(&block.label);\n        out.push_str(&format!(\"    B{}[\\\"{}\\\"]\\n\", id.0, label));\n    }\n\n    // Render edges\n    for edge in &cfg.edges {\n        let arrow = match &edge.label {\n            Some(label) => format!(\"-->|{}|\", escape_mermaid_label(label)),\n            None => \"-->\".to_string(),\n        };\n        out.push_str(&format!(\"    B{} {} B{}\\n\", edge.from.0, arrow, edge.to.0));\n    }\n\n    out\n}\n",
      "semantic_tags": [
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 183
    },
    {
      "name": "to_dot",
      "qualified_name": "src/cfg/render.rs::to_dot",
      "file": "src/cfg/render.rs",
      "line": 131,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn to_dot(cfg: &CFGInfo) -> String",
      "docstring": "",
      "calls": [
        "escape_dot_label",
        "sanitize_dot_id",
        "sorted_block_ids"
      ],
      "called_by": [
        "test_dot_output",
        "test_deterministic_output"
      ],
      "cfg_summary": "complexity:4, blocks:10",
      "dfg_summary": "vars:21, def-use chains:20",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "pub fn to_dot(cfg: &CFGInfo) -> String {\n    let graph_name = sanitize_dot_id(&cfg.function_name);\n    let mut out = format!(\"digraph {} {{\\n\", graph_name);\n    out.push_str(\"    rankdir=TB;\\n\");\n    out.push_str(\"    node [shape=box, fontname=\\\"monospace\\\"];\\n\");\n\n    // Mark entry and exit nodes with special styling\n    out.push_str(&format!(\n        \"    B{} [style=filled, fillcolor=lightgreen];\\n\",\n        cfg.entry.0\n    ));\n    for exit in &cfg.exits {\n        out.push_str(&format!(\n            \"    B{} [style=filled, fillcolor=lightcoral];\\n\",\n            exit.0\n        ));\n    }\n    out.push('\\n');\n\n    // Render blocks in sorted order for deterministic output\n    for id in sorted_block_ids(cfg) {\n        let block = &cfg.blocks[&id];\n        let label = escape_dot_label(&block.label);\n        out.push_str(&format!(\"    B{} [label=\\\"{}\\\"];\\n\", id.0, label));\n    }\n\n    out.push('\\n');\n\n    // Render edges\n    for edge in &cfg.edges {\n        let label_attr = match &edge.label {\n            Some(l) => format!(\" [label=\\\"{}\\\"]\", escape_dot_label(l)),\n            None => String::new(),\n        };\n        out.push_str(&format!(\n            \"    B{} -> B{}{};\\n\",\n            edge.from.0, edge.to.0, label_attr\n        ));\n    }\n\n    out.push_str(\"}\\n\");\n    out\n}\n",
      "semantic_tags": [
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 347
    },
    {
      "name": "to_ascii",
      "qualified_name": "src/cfg/render.rs::to_ascii",
      "file": "src/cfg/render.rs",
      "line": 195,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn to_ascii(cfg: &CFGInfo) -> String",
      "docstring": "",
      "calls": [
        "sorted_block_ids"
      ],
      "called_by": [
        "test_ascii_output"
      ],
      "cfg_summary": "complexity:5, blocks:12",
      "dfg_summary": "vars:30, def-use chains:29",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "pub fn to_ascii(cfg: &CFGInfo) -> String {\n    let mut out = format!(\"CFG: {}\\n\", cfg.function_name);\n    out.push_str(&\"=\".repeat(40));\n    out.push('\\n');\n    out.push_str(&format!(\"Blocks: {}\\n\", cfg.blocks.len()));\n    out.push_str(&format!(\"Edges: {}\\n\", cfg.edges.len()));\n    out.push_str(&format!(\"Complexity: {}\\n\", cfg.cyclomatic_complexity()));\n    out.push_str(&format!(\"Entry: B{}\\n\", cfg.entry.0));\n    out.push_str(&format!(\n        \"Exits: {}\\n\",\n        cfg.exits\n            .iter()\n            .map(|id| format!(\"B{}\", id.0))\n            .collect::<Vec<_>>()\n            .join(\", \")\n    ));\n    out.push('\\n');\n\n    // Render blocks in sorted order\n    for id in sorted_block_ids(cfg) {\n        let block = &cfg.blocks[&id];\n        out.push_str(&format!(\n            \"[B{}] {} (lines {}-{})\\n\",\n            id.0, block.label, block.start_line, block.end_line\n        ));\n        for stmt in &block.statements {\n            out.push_str(&format!(\"    {}\\n\", stmt));\n        }\n        if !block.statements.is_empty() {\n            out.push('\\n');\n        }\n    }\n\n    out.push_str(\"\\nEdges:\\n\");\n    for edge in &cfg.edges {\n        let label = match &edge.label {\n            Some(l) => format!(\" [{}]\", l),\n            None => String::new(),\n        };\n        out.push_str(&format!(\n            \"    B{} -> B{}{}\\n\",\n            edge.from.0, edge.to.0, label\n        ));\n    }\n\n    out\n}\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 374
    },
    {
      "name": "to_json",
      "qualified_name": "src/cfg/render.rs::to_json",
      "file": "src/cfg/render.rs",
      "line": 258,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn to_json(cfg: &CFGInfo) -> Result<String, serde_json::Error>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_json_output"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:1",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "pub fn to_json(cfg: &CFGInfo) -> Result<String, serde_json::Error> {\n    serde_json::to_string_pretty(cfg)\n}\n",
      "semantic_tags": [
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 31
    },
    {
      "name": "to_json_compact",
      "qualified_name": "src/cfg/render.rs::to_json_compact",
      "file": "src/cfg/render.rs",
      "line": 263,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn to_json_compact(cfg: &CFGInfo) -> Result<String, serde_json::Error>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:1",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "pub fn to_json_compact(cfg: &CFGInfo) -> Result<String, serde_json::Error> {\n    serde_json::to_string(cfg)\n}\n",
      "semantic_tags": [
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 31
    },
    {
      "name": "sample_cfg",
      "qualified_name": "src/cfg/render.rs::sample_cfg",
      "file": "src/cfg/render.rs",
      "line": 273,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn sample_cfg() -> CFGInfo",
      "docstring": "",
      "calls": [
        "BlockId"
      ],
      "called_by": [
        "test_json_output",
        "test_mermaid_output",
        "test_deterministic_output",
        "test_dot_output",
        "test_ascii_output"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:4",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "    fn sample_cfg() -> CFGInfo {\n        let mut blocks = HashMap::new();\n        blocks.insert(\n            BlockId(0),\n            CFGBlock {\n                id: BlockId(0),\n                label: \"entry\".to_string(),\n                statements: vec![\"x = 1\".to_string()],\n                start_line: 1,\n                end_line: 1,\n            },\n        );\n        blocks.insert(\n            BlockId(1),\n            CFGBlock {\n                id: BlockId(1),\n                label: \"if x > 0\".to_string(),\n                statements: vec![],\n                start_line: 2,\n                end_line: 2,\n            },\n        );\n        blocks.insert(\n            BlockId(2),\n            CFGBlock {\n                id: BlockId(2),\n                label: \"exit\".to_string(),\n                statements: vec![\"return x\".to_string()],\n                start_line: 3,\n                end_line: 3,\n            },\n        );\n\n        CFGInfo {\n            function_name: \"test_func\".to_string(),\n            blocks,\n            edges: vec![\n                CFGEdge {\n                    from: BlockId(0),\n                    to: BlockId(1),\n                    label: None,\n                },\n                CFGEdge {\n                    from: BlockId(1),\n                    to: BlockId(2),\n                    label: Some(\"true\".to_string()),\n                },\n            ],\n            entry: BlockId(0),\n            exits: vec![BlockId(2)],\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 307
    },
    {
      "name": "test_mermaid_output",
      "qualified_name": "src/cfg/render.rs::test_mermaid_output",
      "file": "src/cfg/render.rs",
      "line": 327,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_mermaid_output() -> B1\"));\n        assert!(mermaid.contains(\"-",
      "docstring": "",
      "calls": [
        "extract_from_source",
        "sample_cfg",
        "to_mermaid",
        "to_mermaid"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:6",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "    fn test_mermaid_output() {\n        let cfg = sample_cfg();\n        let mermaid = to_mermaid(&cfg);\n\n        assert!(mermaid.starts_with(\"flowchart TD\"));\n        assert!(mermaid.contains(\"B0[\\\"entry\\\"]\"));\n        assert!(mermaid.contains(\"B1[\\\"if x > 0\\\"]\"));\n        assert!(mermaid.contains(\"B0 --> B1\"));\n        assert!(mermaid.contains(\"-->|true|\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 99
    },
    {
      "name": "test_mermaid_escaping",
      "qualified_name": "src/cfg/render.rs::test_mermaid_escaping",
      "file": "src/cfg/render.rs",
      "line": 339,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_mermaid_escaping()",
      "docstring": "",
      "calls": [
        "escape_mermaid_label"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:4",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "    fn test_mermaid_escaping() {\n        let label = \"test \\\"quoted\\\" label\\nwith newline|and pipe\";\n        let escaped = escape_mermaid_label(label);\n        assert!(!escaped.contains('\"'));\n        assert!(!escaped.contains('\\n'));\n        assert!(!escaped.contains('|'));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 65
    },
    {
      "name": "test_dot_output",
      "qualified_name": "src/cfg/render.rs::test_dot_output",
      "file": "src/cfg/render.rs",
      "line": 348,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_dot_output() -> B1\"));\n        assert!(dot.contains(\"[label=\\\"true\\\"]\"));\n    }",
      "docstring": "",
      "calls": [
        "to_dot",
        "sample_cfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:6",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "    fn test_dot_output() {\n        let cfg = sample_cfg();\n        let dot = to_dot(&cfg);\n\n        assert!(dot.starts_with(\"digraph test_func\"));\n        assert!(dot.contains(\"rankdir=TB\"));\n        assert!(dot.contains(\"B0 [label=\\\"entry\\\"]\"));\n        assert!(dot.contains(\"B0 -> B1\"));\n        assert!(dot.contains(\"[label=\\\"true\\\"]\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 86
    },
    {
      "name": "test_dot_escaping",
      "qualified_name": "src/cfg/render.rs::test_dot_escaping",
      "file": "src/cfg/render.rs",
      "line": 360,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_dot_escaping()",
      "docstring": "",
      "calls": [
        "escape_dot_label"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:2",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "    fn test_dot_escaping() {\n        let label = \"test \\\"quoted\\\"\\nwith newline\";\n        let escaped = escape_dot_label(label);\n        assert_eq!(escaped, \"test \\\\\\\"quoted\\\\\\\"\\\\nwith newline\");\n    }\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 50
    },
    {
      "name": "test_dot_id_sanitization",
      "qualified_name": "src/cfg/render.rs::test_dot_id_sanitization",
      "file": "src/cfg/render.rs",
      "line": 367,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_dot_id_sanitization()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "    fn test_dot_id_sanitization() {\n        assert_eq!(sanitize_dot_id(\"simple\"), \"simple\");\n        assert_eq!(sanitize_dot_id(\"with spaces\"), \"with_spaces\");\n        assert_eq!(sanitize_dot_id(\"123start\"), \"_123start\");\n        assert_eq!(sanitize_dot_id(\"\"), \"_anonymous\");\n        assert_eq!(sanitize_dot_id(\"a::b\"), \"a__b\");\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 87
    },
    {
      "name": "test_ascii_output",
      "qualified_name": "src/cfg/render.rs::test_ascii_output",
      "file": "src/cfg/render.rs",
      "line": 376,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_ascii_output() -> B1\"));\n        assert!(ascii.contains(\"[true]\"));\n    }",
      "docstring": "",
      "calls": [
        "to_ascii",
        "sample_cfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:7",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "    fn test_ascii_output() {\n        let cfg = sample_cfg();\n        let ascii = to_ascii(&cfg);\n\n        assert!(ascii.contains(\"CFG: test_func\"));\n        assert!(ascii.contains(\"Blocks: 3\"));\n        assert!(ascii.contains(\"Edges: 2\"));\n        assert!(ascii.contains(\"[B0] entry\"));\n        assert!(ascii.contains(\"B0 -> B1\"));\n        assert!(ascii.contains(\"[true]\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 90
    },
    {
      "name": "test_json_output",
      "qualified_name": "src/cfg/render.rs::test_json_output",
      "file": "src/cfg/render.rs",
      "line": 389,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_json_output()",
      "docstring": "",
      "calls": [
        "to_json",
        "sample_cfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:4",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "    fn test_json_output() {\n        let cfg = sample_cfg();\n        let json = to_json(&cfg).unwrap();\n\n        assert!(json.contains(\"\\\"function_name\\\": \\\"test_func\\\"\"));\n        assert!(json.contains(\"\\\"entry\\\"\"));\n        assert!(json.contains(\"\\\"exits\\\"\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 60
    },
    {
      "name": "test_deterministic_output",
      "qualified_name": "src/cfg/render.rs::test_deterministic_output",
      "file": "src/cfg/render.rs",
      "line": 399,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_deterministic_output()",
      "docstring": "",
      "calls": [
        "to_dot",
        "sample_cfg",
        "to_mermaid"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:8",
      "dependencies": "crate::cfg::types, super, crate::cfg::types, std::collections",
      "code_preview": "    fn test_deterministic_output() {\n        // Verify output is consistent across multiple calls\n        let cfg = sample_cfg();\n        let mermaid1 = to_mermaid(&cfg);\n        let mermaid2 = to_mermaid(&cfg);\n        assert_eq!(mermaid1, mermaid2);\n\n        let dot1 = to_dot(&cfg);\n        let dot2 = to_dot(&cfg);\n        assert_eq!(dot1, dot2);\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 96
    },
    {
      "name": "count_tokens",
      "qualified_name": "src/semantic/extractor.rs::count_tokens",
      "file": "src/semantic/extractor.rs",
      "line": 34,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn count_tokens(text: &str) -> usize",
      "docstring": "",
      "calls": [
        "estimate_tokens",
        "count_tokens",
        "tokenize",
        "estimate_tokens"
      ],
      "called_by": [
        "test_count_tokens_code",
        "enrich_unit",
        "fits_in_tokens",
        "truncate_to_tokens",
        "count_tokens"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "pub fn count_tokens(text: &str) -> usize {\n    match TOKENIZER.as_ref() {\n        Some(bpe) => bpe.encode_with_special_tokens(text).len(),\n        None => {\n            // Fallback: ~4 characters per token (rough estimate)\n            text.len() / 4\n        }\n    }\n}\n",
      "semantic_tags": [
        "auth"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 67
    },
    {
      "name": "truncate_to_tokens",
      "qualified_name": "src/semantic/extractor.rs::truncate_to_tokens",
      "file": "src/semantic/extractor.rs",
      "line": 47,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn truncate_to_tokens(text: &str, max_tokens: usize) -> String",
      "docstring": "",
      "calls": [
        "count_tokens",
        "new",
        "truncate_by_chars"
      ],
      "called_by": [
        "force_split_by_lines",
        "test_tokenizer_consistency",
        "build_embedding_text",
        "test_truncate_to_tokens_long",
        "test_truncate_to_tokens_truncates"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:10, def-use chains:12",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "pub fn truncate_to_tokens(text: &str, max_tokens: usize) -> String {\n    match TOKENIZER.as_ref() {\n        Some(bpe) => {\n            let tokens = bpe.encode_with_special_tokens(text);\n            if tokens.len() <= max_tokens {\n                return text.to_string();\n            }\n            let truncated_tokens = &tokens[..max_tokens];\n            bpe.decode(truncated_tokens.to_vec())\n                .unwrap_or_else(|_| text.chars().take(max_tokens * 4).collect())\n        }\n        None => {\n            // Fallback: estimate ~4 chars per token\n            let estimated_chars = max_tokens * 4;\n            text.chars().take(estimated_chars).collect()\n        }\n    }\n}\n",
      "semantic_tags": [
        "auth"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 147
    },
    {
      "name": "detect_semantic_patterns",
      "qualified_name": "src/semantic/extractor.rs::detect_semantic_patterns",
      "file": "src/semantic/extractor.rs",
      "line": 83,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn detect_semantic_patterns(code: &str) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "chunk_unit",
        "enrich_unit",
        "test_detect_semantic_patterns"
      ],
      "cfg_summary": "complexity:4, blocks:8",
      "dfg_summary": "vars:8, def-use chains:6",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "pub fn detect_semantic_patterns(code: &str) -> Vec<String> {\n    if code.is_empty() {\n        return Vec::new();\n    }\n\n    let code_lower = code.to_lowercase();\n    let mut matched = Vec::new();\n\n    for (name, regex) in COMPILED_PATTERNS.iter() {\n        if regex.is_match(&code_lower) {\n            matched.push((*name).to_string());\n        }\n    }\n\n    matched.sort();\n    matched\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 97
    },
    {
      "name": "get_indent_depth",
      "qualified_name": "src/semantic/extractor.rs::get_indent_depth",
      "file": "src/semantic/extractor.rs",
      "line": 107,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_indent_depth(line: &str) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [
        "detect_boundaries"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:6, def-use chains:8",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "fn get_indent_depth(line: &str) -> usize {\n    let stripped = line.trim_start();\n    if stripped.is_empty() {\n        return 0;\n    }\n\n    let leading_len = line.len() - stripped.len();\n    let leading = &line[..leading_len];\n    let expanded = leading.replace('\\t', \"    \");\n    expanded.len() / 4\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 77
    },
    {
      "name": "detect_code_complexity",
      "qualified_name": "src/semantic/extractor.rs::detect_code_complexity",
      "file": "src/semantic/extractor.rs",
      "line": 122,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn detect_code_complexity(code: &str) -> CodeComplexity",
      "docstring": "",
      "calls": [],
      "called_by": [
        "chunk_unit",
        "test_detect_code_complexity",
        "enrich_unit"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:12, def-use chains:7",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "pub fn detect_code_complexity(code: &str) -> CodeComplexity {\n    if code.is_empty() {\n        return CodeComplexity::empty();\n    }\n\n    // Count maximum indentation depth\n    let max_depth = code.lines().map(get_indent_depth).max().unwrap_or(0);\n\n    // Compile patterns once\n    static BRANCH_PATTERN: Lazy<Regex> =\n        Lazy::new(|| Regex::new(r\"\\b(if|elif|else|case|switch|match)\\b\").expect(\"valid regex\"));\n    static LOOP_PATTERN: Lazy<Regex> =\n        Lazy::new(|| Regex::new(r\"\\b(for|while|loop)\\b\").expect(\"valid regex\"));\n\n    let branches = BRANCH_PATTERN.find_iter(code).count();\n    let loops = LOOP_PATTERN.find_iter(code).count();\n\n    CodeComplexity {\n        depth: max_depth,\n        branches,\n        loops,\n    }\n}\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 7,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 186
    },
    {
      "name": "split_into_chunks",
      "qualified_name": "src/semantic/extractor.rs::split_into_chunks",
      "file": "src/semantic/extractor.rs",
      "line": 155,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn split_into_chunks(code: &str, max_tokens: usize, overlap_tokens: usize) -> Vec<ChunkInfo>",
      "docstring": "",
      "calls": [
        "count_tokens"
      ],
      "called_by": [
        "test_split_into_chunks",
        "chunk_unit"
      ],
      "cfg_summary": "complexity:9, blocks:20",
      "dfg_summary": "vars:29, def-use chains:47",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "pub fn split_into_chunks(code: &str, max_tokens: usize, overlap_tokens: usize) -> Vec<ChunkInfo> {\n    if code.is_empty() {\n        return Vec::new();\n    }\n\n    let total_tokens = count_tokens(code);\n    if total_tokens <= max_tokens {\n        return vec![ChunkInfo::new(code.to_string(), 0, code.len())];\n    }\n\n    let mut chunks = Vec::new();\n    let lines: Vec<&str> = code.lines().collect();\n\n    let mut current_chunk: Vec<&str> = Vec::new();\n    let mut current_tokens = 0usize;\n    let mut chunk_start_byte = 0usize;\n    let mut char_offset = 0usize;\n\n    for (i, line) in lines.iter().enumerate() {\n        let line_with_newline = if i < lines.len() - 1 {\n            format!(\"{}\\n\", line)\n        } else {\n            (*line).to_string()\n        };\n        let line_tokens = count_tokens(&line_with_newline);\n\n        // Check if adding this line would exceed limit\n        if current_tokens + line_tokens > max_tokens && !current_chunk.is_empty() {\n            // Save current chunk\n            let chunk_text: String = code[chunk_start_byte..char_offset].to_string();\n            chunks.push(ChunkInfo::new(chunk_text, chunk_start_byte, char_offset));\n\n            // Start new chunk with overlap\n            let mut overlap_lines: Vec<&str> = Vec::new();\n            let mut overlap_count = 0usize;\n\n            for prev_line in current_chunk.iter().rev() {\n                let prev_tokens = count_tokens(&format!(\"{}\\n\", prev_line));\n                if overlap_count + prev_tokens > overlap_tokens {\n                    break;\n                }\n                overlap_lines.insert(0, prev_line);\n                overlap_count += prev_tokens;\n            }\n\n            current_chunk = overlap_lines.clone();\n            current_tokens = overlap_count;\n\n            // Calculate new chunk start accounting for newlines\n            let overlap_char_count: usize = overlap_lines.iter().map(|l| l.len() + 1).sum();\n            chunk_start_byte = char_offset.saturating_sub(overlap_char_count);\n        }\n\n        current_chunk.push(line);\n        current_tokens += line_tokens;\n        char_offset += line_with_newline.len();\n    }\n\n    // Don't forget the last chunk\n    if !current_chunk.is_empty() {\n        let chunk_text = code[chunk_start_byte..char_offset].to_string();\n        chunks.push(ChunkInfo::new(chunk_text, chunk_start_byte, char_offset));\n    }\n\n    chunks\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 8,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 535
    },
    {
      "name": "chunk_unit",
      "qualified_name": "src/semantic/extractor.rs::chunk_unit",
      "file": "src/semantic/extractor.rs",
      "line": 228,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn chunk_unit(unit: &EmbeddingUnit) -> Vec<EmbeddingUnit>",
      "docstring": "",
      "calls": [
        "split_into_chunks",
        "detect_code_complexity",
        "detect_semantic_patterns",
        "truncate_to_tokens",
        "count_tokens"
      ],
      "called_by": [
        "test_chunk_unit_small",
        "process_file"
      ],
      "cfg_summary": "complexity:11, blocks:28",
      "dfg_summary": "vars:28, def-use chains:36",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "pub fn chunk_unit(unit: &EmbeddingUnit) -> Vec<EmbeddingUnit> {\n    if unit.code.is_empty() {\n        return vec![unit.clone()];\n    }\n\n    let code_tokens = count_tokens(&unit.code);\n    if code_tokens <= MAX_CODE_PREVIEW_TOKENS {\n        let mut result = unit.clone();\n        result.token_count = code_tokens;\n        return vec![result];\n    }\n\n    // Split the code into chunks\n    let chunks = split_into_chunks(&unit.code, MAX_CODE_PREVIEW_TOKENS, CHUNK_OVERLAP_TOKENS);\n\n    if chunks.len() <= 1 {\n        // Couldn't split effectively, just truncate\n        let mut result = unit.clone();\n        result.code = truncate_to_tokens(&unit.code, MAX_CODE_PREVIEW_TOKENS);\n        result.token_count = count_tokens(&result.code);\n        return vec![result];\n    }\n\n    // Create chunk units\n    chunks\n        .iter()\n        .enumerate()\n        .map(|(i, chunk)| {\n            let chunk_name = format!(\"{}[{}/{}]\", unit.name, i + 1, chunks.len());\n            let lines_before = unit.code[..chunk.start_char].matches('\\n').count();\n\n            EmbeddingUnit {\n                id: format!(\"{}#chunk{}\", unit.id, i + 1),\n                file: unit.file.clone(),\n                name: chunk_name,\n                kind: UnitKind::Chunk,\n                code: chunk.text.clone(),\n                // First chunk gets full signature/docstring\n                signature: if i == 0 {\n                    unit.signature.clone()\n                } else {\n                    format!(\"// continued from {}\", unit.name)\n                },\n                docstring: if i == 0 { unit.docstring.clone() } else { None },\n                start_line: if i == 0 {\n                    unit.start_line\n                } else {\n                    unit.start_line + lines_before\n                },\n                end_line: unit.start_line + lines_before + chunk.text.matches('\\n').count(),\n                token_count: count_tokens(&chunk.text),\n                semantic_tags: detect_semantic_patterns(&chunk.text),\n                parent: Some(unit.name.clone()),\n                language: unit.language.clone(),\n                calls: if i == 0 {\n                    unit.calls.clone()\n                } else {\n                    Vec::new()\n                },\n                called_by: if i == 0 {\n                    unit.called_by.clone()\n                } else {\n                    Vec::new()\n                },\n                cfg_summary: if i == 0 {\n                    unit.cfg_summary.clone()\n                } else {\n                    String::new()\n                },\n                dfg_summary: if i == 0 {\n                    unit.dfg_summary.clone()\n                } else {\n                    String::new()\n                },\n                dependencies: unit.dependencies.clone(),\n                complexity: detect_code_complexity(&chunk.text),\n                chunk_index: i,\n                chunk_total: chunks.len(),\n            }\n        })\n        .collect()\n}\n",
      "semantic_tags": [
        "crud",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 17,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 588
    },
    {
      "name": "enrich_unit",
      "qualified_name": "src/semantic/extractor.rs::enrich_unit",
      "file": "src/semantic/extractor.rs",
      "line": 318,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn enrich_unit(unit: &mut EmbeddingUnit)",
      "docstring": "",
      "calls": [
        "count_tokens",
        "detect_code_complexity",
        "detect_semantic_patterns"
      ],
      "called_by": [
        "test_enrich_unit",
        "process_file"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:7, def-use chains:5",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "pub fn enrich_unit(unit: &mut EmbeddingUnit) {\n    if !unit.code.is_empty() {\n        unit.semantic_tags = detect_semantic_patterns(&unit.code);\n        unit.complexity = detect_code_complexity(&unit.code);\n        unit.token_count = count_tokens(&unit.code);\n    } else {\n        unit.semantic_tags.clear();\n        unit.complexity = CodeComplexity::empty();\n        unit.token_count = 0;\n    }\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 93
    },
    {
      "name": "get_language_extensions",
      "qualified_name": "src/semantic/extractor.rs::get_language_extensions",
      "file": "src/semantic/extractor.rs",
      "line": 335,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_language_extensions(lang: &str) -> &'static [&'static str]",
      "docstring": "",
      "calls": [],
      "called_by": [
        "scan_source_files"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:1",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "fn get_language_extensions(lang: &str) -> &'static [&'static str] {\n    match lang {\n        \"python\" => &[\".py\"],\n        \"typescript\" => &[\".ts\", \".tsx\"],\n        \"javascript\" => &[\".js\", \".jsx\"],\n        \"go\" => &[\".go\"],\n        \"rust\" => &[\".rs\"],\n        \"java\" => &[\".java\"],\n        \"c\" => &[\".c\", \".h\"],\n        \"cpp\" => &[\".cpp\", \".hpp\", \".cc\", \".hh\", \".cxx\", \".hxx\"],\n        _ => &[],\n    }\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 127
    },
    {
      "name": "is_binary_file",
      "qualified_name": "src/semantic/extractor.rs::is_binary_file",
      "file": "src/semantic/extractor.rs",
      "line": 350,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_binary_file(path: &Path) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "scan_source_files"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:5",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "fn is_binary_file(path: &Path) -> bool {\n    use std::fs::File;\n    use std::io::Read;\n\n    let Ok(mut file) = File::open(path) else {\n        return false;\n    };\n\n    let mut buffer = [0u8; 8192];\n    let Ok(bytes_read) = file.read(&mut buffer) else {\n        return false;\n    };\n\n    buffer[..bytes_read].contains(&0)\n}\n",
      "semantic_tags": [
        "crud"
      ],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 96
    },
    {
      "name": "scan_source_files",
      "qualified_name": "src/semantic/extractor.rs::scan_source_files",
      "file": "src/semantic/extractor.rs",
      "line": 367,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn scan_source_files(project_path: &Path, language: &str) -> Vec<PathBuf>",
      "docstring": "",
      "calls": [
        "get_language_extensions",
        "is_binary_file"
      ],
      "called_by": [
        "extract_units"
      ],
      "cfg_summary": "complexity:6, blocks:12",
      "dfg_summary": "vars:18, def-use chains:12",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "fn scan_source_files(project_path: &Path, language: &str) -> Vec<PathBuf> {\n    let extensions = get_language_extensions(language);\n    if extensions.is_empty() {\n        return Vec::new();\n    }\n\n    let mut files = Vec::new();\n\n    for entry in WalkDir::new(project_path)\n        .into_iter()\n        .filter_entry(|e| {\n            let name = e.file_name().to_string_lossy();\n            // Skip common directories to ignore\n            !matches!(\n                name.as_ref(),\n                \"node_modules\"\n                    | \"__pycache__\"\n                    | \".git\"\n                    | \".hg\"\n                    | \".svn\"\n                    | \"target\"\n                    | \"build\"\n                    | \"dist\"\n                    | \".venv\"\n                    | \"venv\"\n                    | \".env\"\n                    | \".mypy_cache\"\n                    | \".pytest_cache\"\n                    | \".tox\"\n                    | \"vendor\"\n            )\n        })\n        .filter_map(|e| e.ok())\n    {\n        let path = entry.path();\n        if path.is_file() {\n            let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or(\"\");\n            if extensions.iter().any(|ext| file_name.ends_with(ext)) {\n                if !is_binary_file(path) {\n                    files.push(path.to_path_buf());\n                }\n            }\n        }\n    }\n\n    files\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 287
    },
    {
      "name": "function_to_unit",
      "qualified_name": "src/semantic/extractor.rs::function_to_unit",
      "file": "src/semantic/extractor.rs",
      "line": 420,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn function_to_unit(func: &FunctionInfo, file_path: &str, code_content: &str, language: &str) -> EmbeddingUnit",
      "docstring": "",
      "calls": [
        "extract_function_code"
      ],
      "called_by": [
        "process_file"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:12, def-use chains:5",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "fn function_to_unit(\n    func: &FunctionInfo,\n    file_path: &str,\n    code_content: &str,\n    language: &str,\n) -> EmbeddingUnit {\n    // Extract code for this function\n    let code = extract_function_code(code_content, func.line_number, func.end_line_number);\n\n    let mut unit = EmbeddingUnit::new(\n        file_path,\n        &func.name,\n        if func.is_method {\n            UnitKind::Method\n        } else {\n            UnitKind::Function\n        },\n        code,\n        func.line_number,\n        language,\n    );\n\n    unit.signature = func.signature();\n    unit.docstring = func.docstring.clone();\n    unit.end_line = func.end_line_number.unwrap_or(func.line_number);\n\n    unit\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 158
    },
    {
      "name": "class_to_unit",
      "qualified_name": "src/semantic/extractor.rs::class_to_unit",
      "file": "src/semantic/extractor.rs",
      "line": 450,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn class_to_unit(class: &ClassInfo, file_path: &str, code_content: &str, language: &str) -> EmbeddingUnit",
      "docstring": "",
      "calls": [
        "extract_function_code"
      ],
      "called_by": [
        "process_file"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:15, def-use chains:16",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "fn class_to_unit(\n    class: &ClassInfo,\n    file_path: &str,\n    code_content: &str,\n    language: &str,\n) -> EmbeddingUnit {\n    // Extract code for this class\n    let code = extract_function_code(code_content, class.line_number, class.end_line_number);\n\n    let mut unit = EmbeddingUnit::new(\n        file_path,\n        &class.name,\n        UnitKind::Class,\n        code,\n        class.line_number,\n        language,\n    );\n\n    unit.signature = format!(\"class {}\", class.name);\n    if !class.bases.is_empty() {\n        unit.signature = format!(\"class {}({})\", class.name, class.bases.join(\", \"));\n    }\n    unit.docstring = class.docstring.clone();\n    unit.end_line = class.end_line_number.unwrap_or(class.line_number);\n\n    unit\n}\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 175
    },
    {
      "name": "methods_to_units",
      "qualified_name": "src/semantic/extractor.rs::methods_to_units",
      "file": "src/semantic/extractor.rs",
      "line": 479,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn methods_to_units(class: &ClassInfo, file_path: &str, code_content: &str, language: &str) -> Vec<EmbeddingUnit>",
      "docstring": "",
      "calls": [
        "extract_function_code"
      ],
      "called_by": [
        "process_file"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:9",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "fn methods_to_units(\n    class: &ClassInfo,\n    file_path: &str,\n    code_content: &str,\n    language: &str,\n) -> Vec<EmbeddingUnit> {\n    class\n        .methods\n        .iter()\n        .map(|method| {\n            let code =\n                extract_function_code(code_content, method.line_number, method.end_line_number);\n\n            let mut unit = EmbeddingUnit::new(\n                file_path,\n                &method.name,\n                UnitKind::Method,\n                code,\n                method.line_number,\n                language,\n            );\n\n            unit.id = format!(\"{}::{}.{}\", file_path, class.name, method.name);\n            unit.signature = method.signature();\n            unit.docstring = method.docstring.clone();\n            unit.end_line = method.end_line_number.unwrap_or(method.line_number);\n            unit.parent = Some(class.name.clone());\n\n            unit\n        })\n        .collect()\n}\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 188
    },
    {
      "name": "extract_function_code",
      "qualified_name": "src/semantic/extractor.rs::extract_function_code",
      "file": "src/semantic/extractor.rs",
      "line": 513,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_function_code(content: &str, start_line: usize, end_line: Option<usize>) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [
        "methods_to_units",
        "test_extract_function_code",
        "class_to_unit",
        "function_to_unit"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:8, def-use chains:10",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "fn extract_function_code(content: &str, start_line: usize, end_line: Option<usize>) -> String {\n    let lines: Vec<&str> = content.lines().collect();\n\n    let start_idx = start_line.saturating_sub(1);\n    let end_idx = end_line.unwrap_or(lines.len()).min(lines.len());\n\n    if start_idx >= lines.len() {\n        return String::new();\n    }\n\n    lines[start_idx..end_idx].join(\"\\n\")\n}\n",
      "semantic_tags": [
        "transform",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 97
    },
    {
      "name": "extract_units",
      "qualified_name": "src/semantic/extractor.rs::extract_units",
      "file": "src/semantic/extractor.rs",
      "line": 548,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_units(project_path: &str, language: &str) -> Result<Vec<EmbeddingUnit>>",
      "docstring": "",
      "calls": [
        "process_file",
        "scan_source_files"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:5",
      "dfg_summary": "vars:22, def-use chains:10",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "pub fn extract_units(project_path: &str, language: &str) -> Result<Vec<EmbeddingUnit>> {\n    let project = Path::new(project_path)\n        .canonicalize()\n        .map_err(|e| TldrError::Io(e))?;\n\n    if !project.exists() {\n        return Err(TldrError::Io(std::io::Error::new(\n            std::io::ErrorKind::NotFound,\n            format!(\"Project path not found: {}\", project_path),\n        )));\n    }\n\n    // Scan for source files\n    let source_files = scan_source_files(&project, language);\n\n    if source_files.is_empty() {\n        return Ok(Vec::new());\n    }\n\n    // Process files in parallel\n    let units: Vec<EmbeddingUnit> = source_files\n        .par_iter()\n        .flat_map(|file_path| process_file(&project, file_path, language).unwrap_or_default())\n        .collect();\n\n    Ok(units)\n}\n",
      "semantic_tags": [
        "validation",
        "logging",
        "error_handling",
        "async_ops",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 198
    },
    {
      "name": "process_file",
      "qualified_name": "src/semantic/extractor.rs::process_file",
      "file": "src/semantic/extractor.rs",
      "line": 577,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn process_file(project_root: &Path, file_path: &Path, language: &str) -> Result<Vec<EmbeddingUnit>>",
      "docstring": "",
      "calls": [
        "methods_to_units",
        "function_to_unit",
        "enrich_unit",
        "class_to_unit",
        "chunk_unit"
      ],
      "called_by": [
        "extract_units_from_file",
        "extract_units"
      ],
      "cfg_summary": "complexity:4, blocks:10",
      "dfg_summary": "vars:27, def-use chains:27",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "fn process_file(\n    project_root: &Path,\n    file_path: &Path,\n    language: &str,\n) -> Result<Vec<EmbeddingUnit>> {\n    // Get relative path for unit IDs\n    let relative_path = file_path\n        .strip_prefix(project_root)\n        .unwrap_or(file_path)\n        .to_string_lossy()\n        .to_string();\n\n    // Read file content\n    let content = std::fs::read_to_string(file_path)?;\n\n    // Parse with AST extractor\n    let module_info = AstExtractor::extract_file(file_path)?;\n\n    let mut all_units = Vec::new();\n\n    // Process top-level functions\n    for func in &module_info.functions {\n        let mut unit = function_to_unit(func, &relative_path, &content, language);\n        enrich_unit(&mut unit);\n\n        // Chunk if needed\n        let chunked = chunk_unit(&unit);\n        all_units.extend(chunked);\n    }\n\n    // Process classes and their methods\n    for class in &module_info.classes {\n        // Add class unit\n        let mut class_unit = class_to_unit(class, &relative_path, &content, language);\n        enrich_unit(&mut class_unit);\n\n        let chunked_class = chunk_unit(&class_unit);\n        all_units.extend(chunked_class);\n\n        // Add method units\n        for mut method_unit in methods_to_units(class, &relative_path, &content, language) {\n            enrich_unit(&mut method_unit);\n\n            let chunked_method = chunk_unit(&method_unit);\n            all_units.extend(chunked_method);\n        }\n    }\n\n    Ok(all_units)\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 330
    },
    {
      "name": "extract_units_from_file",
      "qualified_name": "src/semantic/extractor.rs::extract_units_from_file",
      "file": "src/semantic/extractor.rs",
      "line": 637,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_units_from_file(file_path: &str) -> Result<Vec<EmbeddingUnit>>",
      "docstring": "",
      "calls": [
        "process_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:21, def-use chains:10",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "pub fn extract_units_from_file(file_path: &str) -> Result<Vec<EmbeddingUnit>> {\n    let path = Path::new(file_path);\n\n    if !path.exists() {\n        return Err(TldrError::Io(std::io::Error::new(\n            std::io::ErrorKind::NotFound,\n            format!(\"File not found: {}\", file_path),\n        )));\n    }\n\n    // Detect language\n    let registry = LanguageRegistry::global();\n    let lang = registry.detect_language(path).ok_or_else(|| {\n        TldrError::UnsupportedLanguage(\n            path.extension()\n                .and_then(|e| e.to_str())\n                .unwrap_or(\"unknown\")\n                .to_string(),\n        )\n    })?;\n\n    let parent = path.parent().unwrap_or(Path::new(\".\"));\n    process_file(parent, path, lang.name())\n}\n",
      "semantic_tags": [
        "validation",
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 173
    },
    {
      "name": "parse_identifier_to_words",
      "qualified_name": "src/semantic/extractor.rs::parse_identifier_to_words",
      "file": "src/semantic/extractor.rs",
      "line": 669,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn parse_identifier_to_words(name: &str) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [
        "build_embedding_text"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:8, def-use chains:6",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "pub fn parse_identifier_to_words(name: &str) -> String {\n    let name = name.trim_matches('_');\n    if name.is_empty() {\n        return String::new();\n    }\n\n    // Handle snake_case\n    let name = name.replace('_', \" \");\n\n    // Handle camelCase and PascalCase\n    static CAMEL_RE: Lazy<Regex> =\n        Lazy::new(|| Regex::new(r\"([a-z])([A-Z])\").expect(\"valid regex\"));\n    static ACRONYM_RE: Lazy<Regex> =\n        Lazy::new(|| Regex::new(r\"([A-Z]+)([A-Z][a-z])\").expect(\"valid regex\"));\n\n    let words = CAMEL_RE.replace_all(&name, \"$1 $2\");\n    let words = ACRONYM_RE.replace_all(&words, \"$1 $2\");\n\n    // Clean up and lowercase\n    words\n        .split_whitespace()\n        .collect::<Vec<_>>()\n        .join(\" \")\n        .to_lowercase()\n}\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 210
    },
    {
      "name": "build_embedding_text",
      "qualified_name": "src/semantic/extractor.rs::build_embedding_text",
      "file": "src/semantic/extractor.rs",
      "line": 700,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn build_embedding_text(unit: &EmbeddingUnit) -> String",
      "docstring": "",
      "calls": [
        "truncate_to_tokens",
        "build_embedding_text",
        "parse_identifier_to_words"
      ],
      "called_by": [
        "test_build_embedding_text",
        "build_embedding_text"
      ],
      "cfg_summary": "complexity:14, blocks:28",
      "dfg_summary": "vars:32, def-use chains:43",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "pub fn build_embedding_text(unit: &EmbeddingUnit) -> String {\n    let mut parts = Vec::new();\n\n    // Header with type and name\n    let header = if unit.is_chunk() {\n        format!(\n            \"Chunk [{}/{}] of {}\",\n            unit.chunk_index + 1,\n            unit.chunk_total,\n            unit.parent.as_deref().unwrap_or(&unit.name)\n        )\n    } else {\n        format!(\"{}: {}\", unit.kind.as_str().to_uppercase(), unit.name)\n    };\n    parts.push(header);\n\n    // Semantic tags\n    if !unit.semantic_tags.is_empty() {\n        parts.push(format!(\"Categories: {}\", unit.semantic_tags.join(\", \")));\n    }\n\n    // Description (docstring or generated)\n    if let Some(doc) = &unit.docstring {\n        if !doc.is_empty() {\n            parts.push(format!(\"Description: {}\", doc));\n        }\n    }\n\n    // Parse name as natural language\n    let name_words = parse_identifier_to_words(&unit.name);\n    if !name_words.is_empty() && name_words != unit.name.to_lowercase() {\n        parts.push(format!(\"Purpose: {}\", name_words));\n    }\n\n    // Signature\n    if !unit.signature.is_empty() {\n        parts.push(format!(\"Signature: {}\", unit.signature));\n    }\n\n    // Complexity\n    if let Some(complexity_desc) = unit.complexity.describe() {\n        parts.push(format!(\"Complexity: {}\", complexity_desc));\n    }\n\n    // Call relationships\n    if !unit.calls.is_empty() {\n        let calls_words: Vec<_> = unit\n            .calls\n            .iter()\n            .take(5)\n            .map(|c| parse_identifier_to_words(c))\n            .filter(|w| !w.is_empty())\n            .collect();\n        if !calls_words.is_empty() {\n            parts.push(format!(\"Uses: {}\", calls_words.join(\", \")));\n        }\n    }\n\n    if !unit.called_by.is_empty() {\n        let callers_words: Vec<_> = unit\n            .called_by\n            .iter()\n            .take(5)\n            .map(|c| parse_identifier_to_words(c))\n            .filter(|w| !w.is_empty())\n            .collect();\n        if !callers_words.is_empty() {\n            parts.push(format!(\"Used by: {}\", callers_words.join(\", \")));\n        }\n    }\n\n    // Dependencies\n    if !unit.dependencies.is_empty() {\n        parts.push(format!(\"Dependencies: {}\", unit.dependencies));\n    }\n\n    // Code preview\n    if !unit.code.is_empty() {\n        parts.push(format!(\"Code:\\n{}\", unit.code));\n    }\n\n    // Join and truncate\n    let result = parts.join(\"\\n\");\n    truncate_to_tokens(&result, MAX_EMBEDDING_TOKENS)\n}\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 14,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 569
    },
    {
      "name": "test_count_tokens",
      "qualified_name": "src/semantic/extractor.rs::test_count_tokens",
      "file": "src/semantic/extractor.rs",
      "line": 795,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_count_tokens()",
      "docstring": "",
      "calls": [
        "count_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:4",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_count_tokens() {\n        let text = \"Hello, world!\";\n        let count = count_tokens(text);\n        assert!(count > 0);\n        assert!(count < text.len()); // Tokens should be fewer than chars\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 50
    },
    {
      "name": "test_truncate_to_tokens",
      "qualified_name": "src/semantic/extractor.rs::test_truncate_to_tokens",
      "file": "src/semantic/extractor.rs",
      "line": 803,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_truncate_to_tokens()",
      "docstring": "",
      "calls": [
        "truncate_to_tokens",
        "count_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_truncate_to_tokens() {\n        let long_text = \"word \".repeat(10000);\n        let truncated = truncate_to_tokens(&long_text, 100);\n        let truncated_tokens = count_tokens(&truncated);\n        assert!(truncated_tokens <= 100);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 66
    },
    {
      "name": "test_detect_semantic_patterns",
      "qualified_name": "src/semantic/extractor.rs::test_detect_semantic_patterns",
      "file": "src/semantic/extractor.rs",
      "line": 811,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_detect_semantic_patterns()",
      "docstring": "",
      "calls": [
        "detect_semantic_patterns"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:10",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_detect_semantic_patterns() {\n        // CRUD pattern - standalone verbs at word boundaries\n        let crud_code = \"def handler(data):\\n    db.save(data)\\n    return fetch(id)\";\n        let patterns = detect_semantic_patterns(crud_code);\n        assert!(\n            patterns.contains(&\"crud\".to_string()),\n            \"Expected 'crud' in {:?}\",\n            patterns\n        );\n\n        // Validation pattern - check/validate as standalone words\n        let validation_code = \"def handler(data):\\n    check(data)\\n    ensure(valid)\";\n        let patterns = detect_semantic_patterns(validation_code);\n        assert!(\n            patterns.contains(&\"validation\".to_string()),\n            \"Expected 'validation' in {:?}\",\n            patterns\n        );\n\n        // Error handling pattern\n        let error_code = \"try:\\n    do_stuff()\\nexcept Exception:\\n    raise ValueError()\";\n        let patterns = detect_semantic_patterns(error_code);\n        assert!(\n            patterns.contains(&\"error_handling\".to_string()),\n            \"Expected 'error_handling' in {:?}\",\n            patterns\n        );\n\n        // Empty code returns empty patterns\n        let empty_patterns = detect_semantic_patterns(\"\");\n        assert!(empty_patterns.is_empty());\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "logging",
        "error_handling",
        "api_endpoint",
        "test"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 251
    },
    {
      "name": "test_detect_code_complexity",
      "qualified_name": "src/semantic/extractor.rs::test_detect_code_complexity",
      "file": "src/semantic/extractor.rs",
      "line": 845,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_detect_code_complexity()",
      "docstring": "",
      "calls": [
        "detect_code_complexity"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:8",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_detect_code_complexity() {\n        let simple_code = \"def foo():\\n    return 1\";\n        let complexity = detect_code_complexity(simple_code);\n        assert!(complexity.depth <= 1);\n        assert_eq!(complexity.branches, 0);\n        assert_eq!(complexity.loops, 0);\n\n        let complex_code = \"if x:\\n    if y:\\n        for i in range(10):\\n            while True:\\n                pass\";\n        let complexity = detect_code_complexity(complex_code);\n        assert!(complexity.depth >= 3);\n        assert!(complexity.branches > 0);\n        assert!(complexity.loops >= 2);\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 150
    },
    {
      "name": "test_split_into_chunks",
      "qualified_name": "src/semantic/extractor.rs::test_split_into_chunks",
      "file": "src/semantic/extractor.rs",
      "line": 860,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_split_into_chunks()",
      "docstring": "",
      "calls": [
        "split_into_chunks"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:5",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_split_into_chunks() {\n        let short_code = \"def foo(): pass\";\n        let chunks = split_into_chunks(short_code, 1000, 50);\n        assert_eq!(chunks.len(), 1);\n        assert_eq!(chunks[0].text, short_code);\n\n        // Empty code\n        let chunks = split_into_chunks(\"\", 100, 10);\n        assert!(chunks.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 93
    },
    {
      "name": "test_parse_identifier_to_words",
      "qualified_name": "src/semantic/extractor.rs::test_parse_identifier_to_words",
      "file": "src/semantic/extractor.rs",
      "line": 872,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_parse_identifier_to_words()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_parse_identifier_to_words() {\n        assert_eq!(parse_identifier_to_words(\"getUserData\"), \"get user data\");\n        assert_eq!(parse_identifier_to_words(\"get_user_data\"), \"get user data\");\n        assert_eq!(parse_identifier_to_words(\"XMLParser\"), \"xml parser\");\n        assert_eq!(\n            parse_identifier_to_words(\"_private_method\"),\n            \"private method\"\n        );\n        assert_eq!(parse_identifier_to_words(\"HTMLElement\"), \"html element\");\n        assert_eq!(parse_identifier_to_words(\"\"), \"\");\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 107
    },
    {
      "name": "test_enrich_unit",
      "qualified_name": "src/semantic/extractor.rs::test_enrich_unit",
      "file": "src/semantic/extractor.rs",
      "line": 885,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_enrich_unit()",
      "docstring": "",
      "calls": [
        "enrich_unit"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:6",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_enrich_unit() {\n        let mut unit = EmbeddingUnit::new(\n            \"test.py\",\n            \"process_data\",\n            UnitKind::Function,\n            // Code with standalone keywords that match patterns\n            \"def process_data(user):\\n    check(user)  # validate\\n    if not user:\\n        raise ValueError('Invalid')\",\n            1,\n            \"python\",\n        );\n\n        enrich_unit(&mut unit);\n\n        assert!(\n            !unit.semantic_tags.is_empty(),\n            \"Expected semantic tags to be detected\"\n        );\n        // Should match 'validation' (check) and 'error_handling' (raise)\n        assert!(\n            unit.semantic_tags.contains(&\"validation\".to_string())\n                || unit.semantic_tags.contains(&\"error_handling\".to_string()),\n            \"Expected 'validation' or 'error_handling' in {:?}\",\n            unit.semantic_tags\n        );\n        assert!(unit.token_count > 0);\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "error_handling"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 194
    },
    {
      "name": "test_chunk_unit_small",
      "qualified_name": "src/semantic/extractor.rs::test_chunk_unit_small",
      "file": "src/semantic/extractor.rs",
      "line": 913,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_unit_small()",
      "docstring": "",
      "calls": [
        "chunk_unit"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:3",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_chunk_unit_small() {\n        let mut unit = EmbeddingUnit::new(\n            \"test.py\",\n            \"small_func\",\n            UnitKind::Function,\n            \"def small_func(): pass\",\n            1,\n            \"python\",\n        );\n        unit.token_count = 10;\n\n        let chunks = chunk_unit(&unit);\n        assert_eq!(chunks.len(), 1);\n        assert!(!chunks[0].is_chunk());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 94
    },
    {
      "name": "test_build_embedding_text",
      "qualified_name": "src/semantic/extractor.rs::test_build_embedding_text",
      "file": "src/semantic/extractor.rs",
      "line": 930,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_embedding_text() -> Result\".to_string();\n        unit.docstring = Some(\"Process user data and return result.\".to_string());\n        unit.semantic_tags = vec![\"crud\".to_string()];\n\n        let text = build_embedding_text(&unit);\n\n        assert!(text.contains(\"FUNCTION: processUserData\"));\n        assert!(text.contains(\"Categories: crud\"));\n        assert!(text.contains(\"Description: Process user data\"));\n        assert!(text.contains(\"Purpose: process user data\"));\n        assert!(text.contains(\"Signature:\"));\n    }",
      "docstring": "",
      "calls": [
        "build_embedding_text"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:6",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_build_embedding_text() {\n        let mut unit = EmbeddingUnit::new(\n            \"test.py\",\n            \"processUserData\",\n            UnitKind::Function,\n            \"def processUserData(user): pass\",\n            1,\n            \"python\",\n        );\n        unit.signature = \"def processUserData(user: User) -> Result\".to_string();\n        unit.docstring = Some(\"Process user data and return result.\".to_string());\n        unit.semantic_tags = vec![\"crud\".to_string()];\n\n        let text = build_embedding_text(&unit);\n\n        assert!(text.contains(\"FUNCTION: processUserData\"));\n        assert!(text.contains(\"Categories: crud\"));\n        assert!(text.contains(\"Description: Process user data\"));\n        assert!(text.contains(\"Purpose: process user data\"));\n        assert!(text.contains(\"Signature:\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 169
    },
    {
      "name": "test_get_indent_depth",
      "qualified_name": "src/semantic/extractor.rs::test_get_indent_depth",
      "file": "src/semantic/extractor.rs",
      "line": 953,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_get_indent_depth()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_get_indent_depth() {\n        assert_eq!(get_indent_depth(\"\"), 0);\n        assert_eq!(get_indent_depth(\"    code\"), 1);\n        assert_eq!(get_indent_depth(\"        code\"), 2);\n        assert_eq!(get_indent_depth(\"\\tcode\"), 1);\n        assert_eq!(get_indent_depth(\"\\t\\tcode\"), 2);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 78
    },
    {
      "name": "test_is_binary_file",
      "qualified_name": "src/semantic/extractor.rs::test_is_binary_file",
      "file": "src/semantic/extractor.rs",
      "line": 962,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_is_binary_file()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:4",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_is_binary_file() {\n        use std::io::Write;\n        use tempfile::NamedTempFile;\n\n        // Text file\n        let mut text_file = NamedTempFile::new().unwrap();\n        text_file.write_all(b\"Hello, world!\").unwrap();\n        assert!(!is_binary_file(text_file.path()));\n\n        // Binary file with null bytes\n        let mut binary_file = NamedTempFile::new().unwrap();\n        binary_file.write_all(b\"Hello\\x00world\").unwrap();\n        assert!(is_binary_file(binary_file.path()));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 117
    },
    {
      "name": "test_extract_function_code",
      "qualified_name": "src/semantic/extractor.rs::test_extract_function_code",
      "file": "src/semantic/extractor.rs",
      "line": 978,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_function_code()",
      "docstring": "",
      "calls": [
        "extract_function_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:6",
      "dependencies": "std::path, once_cell::sync, rayon::prelude, regex, tiktoken_rs",
      "code_preview": "    fn test_extract_function_code() {\n        let content = \"line 1\\nline 2\\nline 3\\nline 4\\nline 5\";\n\n        let code = extract_function_code(content, 2, Some(4));\n        assert_eq!(code, \"line 2\\nline 3\\nline 4\");\n\n        let code_no_end = extract_function_code(content, 3, None);\n        assert_eq!(code_no_end, \"line 3\\nline 4\\nline 5\");\n\n        let code_out_of_bounds = extract_function_code(content, 100, None);\n        assert!(code_out_of_bounds.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 136
    },
    {
      "name": "(SliceDirection) default",
      "qualified_name": "src/main.rs::(SliceDirection) default",
      "file": "src/main.rs",
      "line": 85,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (SliceDirection) default() -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "    fn default() -> Self {\n        Self::Backward\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 15
    },
    {
      "name": "(Language) fmt",
      "qualified_name": "src/main.rs::(Language) fmt",
      "file": "src/main.rs",
      "line": 112,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Language) fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let s = match self {\n            Language::Python => \"python\",\n            Language::Typescript => \"typescript\",\n            Language::Javascript => \"javascript\",\n            Language::Go => \"go\",\n            Language::Rust => \"rust\",\n            Language::Java => \"java\",\n            Language::C => \"c\",\n            Language::Cpp => \"cpp\",\n            Language::Ruby => \"ruby\",\n            Language::Php => \"php\",\n            Language::Kotlin => \"kotlin\",\n            Language::Swift => \"swift\",\n            Language::Csharp => \"csharp\",\n            Language::Scala => \"scala\",\n            Language::Lua => \"lua\",\n            Language::Elixir => \"elixir\",\n        };\n        write!(f, \"{}\", s)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 181
    },
    {
      "name": "(WarmLanguage) default",
      "qualified_name": "src/main.rs::(WarmLanguage) default",
      "file": "src/main.rs",
      "line": 150,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (WarmLanguage) default() -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "    fn default() -> Self {\n        Self::Python\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 14
    },
    {
      "name": "(WarmLanguage) fmt",
      "qualified_name": "src/main.rs::(WarmLanguage) fmt",
      "file": "src/main.rs",
      "line": 156,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (WarmLanguage) fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let s = match self {\n            WarmLanguage::Python => \"python\",\n            WarmLanguage::Typescript => \"typescript\",\n            WarmLanguage::Javascript => \"javascript\",\n            WarmLanguage::Go => \"go\",\n            WarmLanguage::Rust => \"rust\",\n            WarmLanguage::Java => \"java\",\n            WarmLanguage::C => \"c\",\n            WarmLanguage::Cpp => \"cpp\",\n            WarmLanguage::All => \"all\",\n        };\n        write!(f, \"{}\", s)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 128
    },
    {
      "name": "main",
      "qualified_name": "src/main.rs::main",
      "file": "src/main.rs",
      "line": 777,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn main() -> Result<()>",
      "docstring": "",
      "calls": [
        "cmd_diagnostics",
        "cmd_search",
        "cmd_imports",
        "cmd_dead",
        "cmd_tree"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:63, def-use chains:14",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "async fn main() -> Result<()> {\n    let cli = Cli::parse();\n\n    // Initialize tracing based on verbosity\n    let filter = match cli.verbose {\n        0 => EnvFilter::new(\"warn\"),\n        1 => EnvFilter::new(\"info\"),\n        2 => EnvFilter::new(\"debug\"),\n        _ => EnvFilter::new(\"trace\"),\n    };\n\n    tracing_subscriber::fmt()\n        .with_env_filter(filter)\n        .with_target(false)\n        .init();\n\n    match cli.command {\n        Commands::Tree {\n            path,\n            ext,\n            show_hidden,\n        } => {\n            cmd_tree(&path, &ext, show_hidden, cli.no_ignore)?;\n        }\n\n        Commands::Structure { path, lang, limit } => {\n            cmd_structure(&path, lang, limit, cli.no_ignore)?;\n        }\n\n        Commands::Search {\n            pattern,\n            path,\n            ext,\n            context,\n            max,\n            max_files,\n        } => {\n            cmd_search(\n                &pattern,\n                &path,\n                &ext,\n                context,\n                max,\n                max_files,\n                cli.no_ignore,\n            )?;\n        }\n\n        Commands::Extract {\n            file,\n            filter_class,\n            filter_function,\n            filter_method,\n        } => {\n            cmd_extract(&file, filter_class, filter_function, filter_method)?;\n        }\n\n        Commands::Context {\n            entry,\n            project,\n            depth,\n            lang,\n        } => {\n            cmd_context(&entry, &project, depth, lang)?;\n        }\n\n        Commands::Cfg {\n            file,\n            function,\n            lang,\n            format,\n        } => {\n            cmd_cfg(&file, &function, lang, format)?;\n        }\n\n        Commands::Dfg {\n            file,\n            function,\n            lang,\n        } => {\n            cmd_dfg(&file, &function, lang)?;\n        }\n\n        Commands::Slice {\n            file,\n            function,\n            line,\n            direction,\n            var,\n            lang,\n        } => {\n            cmd_slice(&file, &function, line, direction, var, lang)?;\n        }\n\n        Commands::Calls { path, lang } => {\n            cmd_calls(&path, lang, cli.no_ignore)?;\n        }\n\n        Commands::Impact {\n            func,\n            path,\n            depth,\n            file,\n            lang,\n        } => {\n            cmd_impact(&func, &path, depth, file, lang, cli.no_ignore)?;\n        }\n\n        Commands::Dead { path, entry, lang } => {\n            cmd_dead(&path, &entry, lang, cli.no_ignore)?;\n        }\n\n        Commands::Arch { path, lang } => {\n            cmd_arch(&path, lang, cli.no_ignore)?;\n        }\n\n        Commands::Imports { file, lang } => {\n            cmd_imports(&file, lang)?;\n        }\n\n        Commands::Importers { module, path, lang } => {\n            cmd_importers(&module, &path, lang, cli.no_ignore)?;\n        }\n\n        Commands::Warm {\n            path,\n            background,\n            lang,\n        } => {\n            cmd_warm(&path, background, lang, cli.no_ignore)?;\n        }\n\n        Commands::ChangeImpact {\n            files,\n            session,\n            git,\n            git_base,\n            lang,\n            depth,\n            run,\n            project,\n        } => {\n            cmd_change_impact(\n                &files,\n                session,\n                git,\n                &git_base,\n                lang,\n                depth,\n                run,\n                &project,\n                cli.no_ignore,\n            )?;\n        }\n\n        Commands::Diagnostics {\n            target,\n            project,\n            no_lint,\n            format,\n            lang,\n        } => {\n            cmd_diagnostics(&target, project, no_lint, format, lang)?;\n        }\n\n        Commands::Semantic(subcmd) => {\n            cmd_semantic(subcmd, cli.no_ignore).await?;\n        }\n\n        Commands::Daemon(subcmd) => {\n            cmd_daemon(subcmd).await?;\n        }\n\n        Commands::Doctor { install, json } => {\n            cmd_doctor(install, json)?;\n        }\n    }\n\n    Ok(())\n}\n",
      "semantic_tags": [
        "auth",
        "validation",
        "logging",
        "async_ops",
        "iteration",
        "transform"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 840
    },
    {
      "name": "cmd_tree",
      "qualified_name": "src/main.rs::cmd_tree",
      "file": "src/main.rs",
      "line": 962,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_tree(path: &PathBuf, ext: &[String], _show_hidden: bool, _no_ignore: bool) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:4",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_tree(path: &PathBuf, ext: &[String], _show_hidden: bool, _no_ignore: bool) -> Result<()> {\n    // file_tree takes a single extension filter; use the first one if multiple provided\n    let ext_filter = ext.first().map(|s| s.as_str());\n\n    let result = ast::file_tree(path.to_str().context(\"Invalid path\")?, ext_filter)\n        .context(\"Failed to build file tree\")?;\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 127
    },
    {
      "name": "cmd_structure",
      "qualified_name": "src/main.rs::cmd_structure",
      "file": "src/main.rs",
      "line": 976,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_structure(path: &PathBuf, lang: Option<Language>, limit: usize, _no_ignore: bool) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:5",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_structure(\n    path: &PathBuf,\n    lang: Option<Language>,\n    limit: usize,\n    _no_ignore: bool,\n) -> Result<()> {\n    let lang_str = lang.map(|l| l.to_string());\n    let result = ast::code_structure(\n        path.to_str().context(\"Invalid path\")?,\n        lang_str.as_deref(),\n        limit,\n    )\n    .context(\"Failed to extract code structure\")?;\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 123
    },
    {
      "name": "cmd_search",
      "qualified_name": "src/main.rs::cmd_search",
      "file": "src/main.rs",
      "line": 997,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_search(pattern: &str, path: &PathBuf, ext: &[String], context: usize, max: usize, max_files: usize, _no_ignore: bool) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:16, def-use chains:8",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_search(\n    pattern: &str,\n    path: &PathBuf,\n    ext: &[String],\n    context: usize,\n    max: usize,\n    max_files: usize,\n    _no_ignore: bool,\n) -> Result<()> {\n    // TODO: Implement search functionality\n    let result = serde_json::json!({\n        \"pattern\": pattern,\n        \"path\": path.display().to_string(),\n        \"extensions\": ext,\n        \"context_lines\": context,\n        \"max_results\": max,\n        \"max_files\": max_files,\n        \"matches\": [],\n        \"error\": \"Search not yet implemented in Rust CLI\"\n    });\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "transform",
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 164
    },
    {
      "name": "cmd_extract",
      "qualified_name": "src/main.rs::cmd_extract",
      "file": "src/main.rs",
      "line": 1025,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_extract(file: &PathBuf, filter_class: Option<String>, filter_function: Option<String>, filter_method: Option<String>) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:6, blocks:14",
      "dfg_summary": "vars:22, def-use chains:12",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_extract(\n    file: &PathBuf,\n    filter_class: Option<String>,\n    filter_function: Option<String>,\n    filter_method: Option<String>,\n) -> Result<()> {\n    let mut module = ast::extract_file(file.to_str().context(\"Invalid file path\")?)\n        .context(\"Failed to extract file info\")?;\n\n    // Apply filters if specified\n    if let Some(class_name) = &filter_class {\n        // Filter to specific class\n        module.classes.retain(|c| c.name == *class_name);\n        // Clear functions when filtering by class\n        module.functions.clear();\n    } else if let Some(method_spec) = &filter_method {\n        // Parse Class.method syntax\n        if let Some((class_name, method_name)) = method_spec.split_once('.') {\n            module.classes.retain(|c| c.name == class_name);\n            // Filter methods within matching classes\n            for class in &mut module.classes {\n                class.methods.retain(|m| m.name == method_name);\n            }\n        }\n        // Clear functions when filtering by method\n        module.functions.clear();\n    } else if let Some(func_name) = &filter_function {\n        // Filter to specific function\n        module.functions.retain(|f| f.name == *func_name);\n        // Clear classes when filtering by function\n        module.classes.clear();\n    }\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&module).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "validation",
        "logging",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 4,
        "branches": 7,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 308
    },
    {
      "name": "cmd_context",
      "qualified_name": "src/main.rs::cmd_context",
      "file": "src/main.rs",
      "line": 1065,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_context(entry: &str, project: &PathBuf, depth: usize, _lang: Option<Language>) -> Result<()>",
      "docstring": "",
      "calls": [
        "get_context"
      ],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:16, def-use chains:5",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_context(\n    entry: &str,\n    project: &PathBuf,\n    depth: usize,\n    _lang: Option<Language>,\n) -> Result<()> {\n    let result = callgraph::get_context(\n        project.to_str().context(\"Invalid project path\")?,\n        entry,\n        depth,\n    )\n    .context(\"Failed to get context\")?;\n\n    // Context outputs LLM-ready text, not JSON\n    if let Some(text) = result.get(\"llm_context\").and_then(|v| v.as_str()) {\n        println!(\"{}\", text);\n    } else {\n        // Fallback to JSON if no LLM context available\n        println!(\n            \"{}\",\n            serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n        );\n    }\n    Ok(())\n}\n",
      "semantic_tags": [
        "crud",
        "transform",
        "api_endpoint",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 166
    },
    {
      "name": "cmd_cfg",
      "qualified_name": "src/main.rs::cmd_cfg",
      "file": "src/main.rs",
      "line": 1091,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_cfg(file: &PathBuf, function: &str, _lang: Option<Language>, format: OutputFormat) -> Result<()>",
      "docstring": "",
      "calls": [
        "extract"
      ],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:32, def-use chains:17",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_cfg(\n    file: &PathBuf,\n    function: &str,\n    _lang: Option<Language>,\n    format: OutputFormat,\n) -> Result<()> {\n    let cfg_result = cfg::extract(file.to_str().context(\"Invalid file path\")?, function)\n        .context(\"Failed to extract CFG\")?;\n\n    match format {\n        OutputFormat::Json => {\n            println!(\n                \"{}\",\n                serde_json::to_string_pretty(&cfg_result).context(\"Failed to serialize output\")?\n            );\n        }\n        OutputFormat::Mermaid => {\n            let mermaid = cfg::render::to_mermaid(&cfg_result);\n            println!(\"{}\", mermaid);\n        }\n        OutputFormat::Dot => {\n            let dot = cfg::render::to_dot(&cfg_result);\n            println!(\"{}\", dot);\n        }\n        OutputFormat::Text => {\n            // Text format: simplified output\n            println!(\"Control Flow Graph for: {}\", function);\n            println!(\"Blocks: {}\", cfg_result.blocks.len());\n            println!(\"Edges: {}\", cfg_result.edges.len());\n            println!(\"Complexity: {}\", cfg_result.cyclomatic_complexity());\n            // Sort blocks by ID for consistent output\n            let mut block_ids: Vec<_> = cfg_result.blocks.keys().collect();\n            block_ids.sort_by_key(|id| id.0);\n            for id in block_ids {\n                let block = &cfg_result.blocks[id];\n                println!(\n                    \"  Block {}: lines {}-{}\",\n                    block.id.0, block.start_line, block.end_line\n                );\n            }\n        }\n    }\n    Ok(())\n}\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 328
    },
    {
      "name": "cmd_dfg",
      "qualified_name": "src/main.rs::cmd_dfg",
      "file": "src/main.rs",
      "line": 1136,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_dfg(file: &PathBuf, function: &str, _lang: Option<Language>) -> Result<()>",
      "docstring": "",
      "calls": [
        "extract"
      ],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:2",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_dfg(file: &PathBuf, function: &str, _lang: Option<Language>) -> Result<()> {\n    let result = dfg::extract(file.to_str().context(\"Invalid file path\")?, function)\n        .context(\"Failed to extract DFG\")?;\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "transform",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 89
    },
    {
      "name": "cmd_slice",
      "qualified_name": "src/main.rs::cmd_slice",
      "file": "src/main.rs",
      "line": 1147,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_slice(file: &PathBuf, function: &str, line: usize, direction: SliceDirection, _var: Option<String>, _lang: Option<Language>) -> Result<()>",
      "docstring": "",
      "calls": [
        "get_slice",
        "get_forward_slice"
      ],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:23, def-use chains:10",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_slice(\n    file: &PathBuf,\n    function: &str,\n    line: usize,\n    direction: SliceDirection,\n    _var: Option<String>,\n    _lang: Option<Language>,\n) -> Result<()> {\n    // Use the appropriate slice function based on direction\n    let file_path = file.to_str().context(\"Invalid file path\")?;\n    let lines = match direction {\n        SliceDirection::Backward => {\n            dfg::get_slice(file_path, function, line).context(\"Failed to compute backward slice\")?\n        }\n        SliceDirection::Forward => dfg::get_forward_slice(file_path, function, line)\n            .context(\"Failed to compute forward slice\")?,\n    };\n\n    let result = serde_json::json!({\n        \"lines\": lines,\n        \"count\": lines.len(),\n        \"direction\": match direction {\n            SliceDirection::Backward => \"backward\",\n            SliceDirection::Forward => \"forward\",\n        }\n    });\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "transform",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 230
    },
    {
      "name": "cmd_calls",
      "qualified_name": "src/main.rs::cmd_calls",
      "file": "src/main.rs",
      "line": 1181,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_calls(path: &PathBuf, _lang: Option<Language>, _no_ignore: bool) -> Result<()>",
      "docstring": "",
      "calls": [
        "build"
      ],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:26, def-use chains:4",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_calls(path: &PathBuf, _lang: Option<Language>, _no_ignore: bool) -> Result<()> {\n    let graph = callgraph::build(path.to_str().context(\"Invalid path\")?)\n        .context(\"Failed to build call graph\")?;\n\n    let result = serde_json::json!({\n        \"edges\": graph.edges.iter().map(|e| {\n            serde_json::json!({\n                \"from_file\": e.caller.file,\n                \"from_func\": e.caller.name,\n                \"to_file\": e.callee.file,\n                \"to_func\": e.callee.name,\n                \"call_line\": e.call_line,\n            })\n        }).collect::<Vec<_>>(),\n        \"count\": graph.edges.len(),\n    });\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 185
    },
    {
      "name": "cmd_impact",
      "qualified_name": "src/main.rs::cmd_impact",
      "file": "src/main.rs",
      "line": 1205,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_impact(func: &str, path: &PathBuf, depth: usize, file_filter: Option<String>, _lang: Option<Language>, _no_ignore: bool) -> Result<()>",
      "docstring": "",
      "calls": [
        "impact"
      ],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:29, def-use chains:8",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_impact(\n    func: &str,\n    path: &PathBuf,\n    depth: usize,\n    file_filter: Option<String>,\n    _lang: Option<Language>,\n    _no_ignore: bool,\n) -> Result<()> {\n    let callers = callgraph::impact(path.to_str().context(\"Invalid path\")?, func, depth)\n        .context(\"Failed to analyze impact\")?;\n\n    // Apply file filter if specified\n    let filtered: Vec<_> = if let Some(filter) = file_filter {\n        callers\n            .into_iter()\n            .filter(|f| f.file.contains(&filter))\n            .collect()\n    } else {\n        callers\n    };\n\n    let result = serde_json::json!({\n        \"function\": func,\n        \"callers\": filtered.iter().map(|f| {\n            serde_json::json!({\n                \"file\": f.file,\n                \"name\": f.name,\n                \"qualified_name\": f.qualified_name,\n            })\n        }).collect::<Vec<_>>(),\n        \"count\": filtered.len(),\n    });\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 250
    },
    {
      "name": "cmd_dead",
      "qualified_name": "src/main.rs::cmd_dead",
      "file": "src/main.rs",
      "line": 1245,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_dead(path: &PathBuf, _entry_points: &[String], _lang: Option<Language>, _no_ignore: bool) -> Result<()>",
      "docstring": "",
      "calls": [
        "dead_code"
      ],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:24, def-use chains:4",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_dead(\n    path: &PathBuf,\n    _entry_points: &[String],\n    _lang: Option<Language>,\n    _no_ignore: bool,\n) -> Result<()> {\n    let dead = callgraph::dead_code(path.to_str().context(\"Invalid path\")?)\n        .context(\"Failed to find dead code\")?;\n\n    let result = serde_json::json!({\n        \"dead_functions\": dead.iter().map(|f| {\n            serde_json::json!({\n                \"file\": f.file,\n                \"name\": f.name,\n                \"qualified_name\": f.qualified_name,\n            })\n        }).collect::<Vec<_>>(),\n        \"count\": dead.len(),\n    });\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 173
    },
    {
      "name": "cmd_arch",
      "qualified_name": "src/main.rs::cmd_arch",
      "file": "src/main.rs",
      "line": 1272,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_arch(path: &PathBuf, _lang: Option<Language>, _no_ignore: bool) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:2",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_arch(path: &PathBuf, _lang: Option<Language>, _no_ignore: bool) -> Result<()> {\n    // TODO: Implement architecture analysis\n    let result = serde_json::json!({\n        \"path\": path.display().to_string(),\n        \"layers\": {\n            \"entry\": [],\n            \"middle\": [],\n            \"leaf\": []\n        },\n        \"circular_dependencies\": [],\n        \"error\": \"Architecture analysis not yet implemented in Rust CLI\"\n    });\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "config",
        "transform",
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 130
    },
    {
      "name": "cmd_imports",
      "qualified_name": "src/main.rs::cmd_imports",
      "file": "src/main.rs",
      "line": 1292,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_imports(file: &PathBuf, _lang: Option<Language>) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:2",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_imports(file: &PathBuf, _lang: Option<Language>) -> Result<()> {\n    // TODO: Implement imports extraction\n    let result = serde_json::json!({\n        \"file\": file.display().to_string(),\n        \"imports\": [],\n        \"error\": \"Imports extraction not yet implemented in Rust CLI\"\n    });\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "config",
        "transform",
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 101
    },
    {
      "name": "cmd_importers",
      "qualified_name": "src/main.rs::cmd_importers",
      "file": "src/main.rs",
      "line": 1307,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_importers(module: &str, path: &PathBuf, _lang: Option<Language>, _no_ignore: bool) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:3",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_importers(\n    module: &str,\n    path: &PathBuf,\n    _lang: Option<Language>,\n    _no_ignore: bool,\n) -> Result<()> {\n    // TODO: Implement importers search\n    let result = serde_json::json!({\n        \"module\": module,\n        \"path\": path.display().to_string(),\n        \"importers\": [],\n        \"error\": \"Importers search not yet implemented in Rust CLI\"\n    });\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "config",
        "transform",
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 127
    },
    {
      "name": "cmd_warm",
      "qualified_name": "src/main.rs::cmd_warm",
      "file": "src/main.rs",
      "line": 1328,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_warm(path: &PathBuf, background: bool, lang: WarmLanguage, _no_ignore: bool) -> Result<()>",
      "docstring": "",
      "calls": [
        "warm"
      ],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:15, def-use chains:8",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_warm(path: &PathBuf, background: bool, lang: WarmLanguage, _no_ignore: bool) -> Result<()> {\n    if background {\n        // TODO: Spawn background process\n        println!(\"Background indexing spawned for {}\", path.display());\n        return Ok(());\n    }\n\n    let lang_str = lang.to_string();\n    let langs = if lang_str == \"all\" {\n        None\n    } else {\n        Some(vec![lang_str])\n    };\n\n    callgraph::warm(path.to_str().context(\"Invalid path\")?, langs.as_deref())\n        .context(\"Failed to warm cache\")?;\n\n    println!(\"Cache warmed successfully for {}\", path.display());\n    Ok(())\n}\n",
      "semantic_tags": [
        "cache",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 3,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 141
    },
    {
      "name": "cmd_change_impact",
      "qualified_name": "src/main.rs::cmd_change_impact",
      "file": "src/main.rs",
      "line": 1349,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_change_impact(_files: &[PathBuf], _session: bool, _git: bool, _git_base: &str, _lang: Option<Language>, _depth: usize, _run: bool, _project: &PathBuf, _no_ignore: bool) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:17, def-use chains:1",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_change_impact(\n    _files: &[PathBuf],\n    _session: bool,\n    _git: bool,\n    _git_base: &str,\n    _lang: Option<Language>,\n    _depth: usize,\n    _run: bool,\n    _project: &PathBuf,\n    _no_ignore: bool,\n) -> Result<()> {\n    // TODO: Implement change impact analysis\n    let result = serde_json::json!({\n        \"changed_files\": [],\n        \"affected_tests\": [],\n        \"test_command\": null,\n        \"error\": \"Change impact analysis not yet implemented in Rust CLI\"\n    });\n\n    println!(\n        \"{}\",\n        serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n    );\n    Ok(())\n}\n",
      "semantic_tags": [
        "config",
        "transform",
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 160
    },
    {
      "name": "cmd_diagnostics",
      "qualified_name": "src/main.rs::cmd_diagnostics",
      "file": "src/main.rs",
      "line": 1375,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_diagnostics(target: &PathBuf, _project: bool, _no_lint: bool, format: OutputFormat, _lang: Option<Language>) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:18, def-use chains:5",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_diagnostics(\n    target: &PathBuf,\n    _project: bool,\n    _no_lint: bool,\n    format: OutputFormat,\n    _lang: Option<Language>,\n) -> Result<()> {\n    // TODO: Implement diagnostics\n    let result = serde_json::json!({\n        \"target\": target.display().to_string(),\n        \"type_errors\": [],\n        \"lint_errors\": [],\n        \"error\": \"Diagnostics not yet implemented in Rust CLI\"\n    });\n\n    match format {\n        OutputFormat::Json => {\n            println!(\n                \"{}\",\n                serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n            );\n        }\n        OutputFormat::Text => {\n            println!(\"Diagnostics for: {}\", target.display());\n            println!(\"Type errors: 0\");\n            println!(\"Lint errors: 0\");\n            println!(\"(Not yet implemented in Rust CLI)\");\n        }\n        _ => {\n            println!(\n                \"{}\",\n                serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n            );\n        }\n    }\n    Ok(())\n}\n",
      "semantic_tags": [
        "validation",
        "logging",
        "error_handling",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 228
    },
    {
      "name": "cmd_semantic",
      "qualified_name": "src/main.rs::cmd_semantic",
      "file": "src/main.rs",
      "line": 1413,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn cmd_semantic(subcmd: SemanticCommands, _no_ignore: bool) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:27, def-use chains:7",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "async fn cmd_semantic(subcmd: SemanticCommands, _no_ignore: bool) -> Result<()> {\n    match subcmd {\n        SemanticCommands::Index {\n            path,\n            lang,\n            model,\n            backend: _,\n            dimension: _,\n        } => {\n            // TODO: Implement semantic indexing\n            let result = serde_json::json!({\n                \"path\": path.display().to_string(),\n                \"lang\": lang.to_string(),\n                \"model\": model.unwrap_or_else(|| \"bge-large-en-v1.5\".to_string()),\n                \"indexed_count\": 0,\n                \"error\": \"Semantic indexing not yet implemented in Rust CLI\"\n            });\n            println!(\n                \"{}\",\n                serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n            );\n        }\n\n        SemanticCommands::Search {\n            query,\n            path,\n            k,\n            expand: _,\n            model: _,\n            backend: _,\n            task: _,\n            force_reload: _,\n        } => {\n            // TODO: Implement semantic search\n            let result = serde_json::json!({\n                \"query\": query,\n                \"path\": path.display().to_string(),\n                \"k\": k,\n                \"results\": [],\n                \"error\": \"Semantic search not yet implemented in Rust CLI\"\n            });\n            println!(\n                \"{}\",\n                serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n            );\n        }\n\n        SemanticCommands::Warmup { model } => {\n            let result = serde_json::json!({\n                \"model\": model.unwrap_or_else(|| \"Qwen3-Embedding-0.6B\".to_string()),\n                \"status\": \"not_implemented\",\n                \"error\": \"Model warmup not yet implemented in Rust CLI\"\n            });\n            println!(\n                \"{}\",\n                serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n            );\n        }\n\n        SemanticCommands::Unload => {\n            println!(\"Model unloading not yet implemented in Rust CLI\");\n        }\n\n        SemanticCommands::Cache(cache_cmd) => match cache_cmd {\n            CacheCommands::Clear => {\n                println!(\"Cache cleared (not yet implemented)\");\n            }\n            CacheCommands::Stats => {\n                let result = serde_json::json!({\n                    \"cached_projects\": 0,\n                    \"memory_usage_mb\": 0,\n                    \"error\": \"Cache stats not yet implemented in Rust CLI\"\n                });\n                println!(\n                    \"{}\",\n                    serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n                );\n            }\n            CacheCommands::Invalidate { path } => {\n                println!(\"Cache invalidated for: {}\", path.display());\n            }\n        },\n\n        SemanticCommands::Device => {\n            let result = serde_json::json!({\n                \"device\": \"cpu\",\n                \"device_count\": 1,\n                \"total_memory_gb\": 0,\n                \"free_memory_gb\": 0,\n                \"supports_bf16\": false,\n                \"tei_available\": false,\n                \"error\": \"Device detection not yet implemented in Rust CLI\"\n            });\n            println!(\n                \"{}\",\n                serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n            );\n        }\n\n        SemanticCommands::Memory => {\n            let result = serde_json::json!({\n                \"model_loaded\": false,\n                \"gpu_memory_used_mb\": 0,\n                \"error\": \"Memory stats not yet implemented in Rust CLI\"\n            });\n            println!(\n                \"{}\",\n                serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n            );\n        }\n    }\n    Ok(())\n}\n",
      "semantic_tags": [
        "logging",
        "error_handling",
        "async_ops",
        "iteration",
        "transform",
        "cache",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 759
    },
    {
      "name": "cmd_daemon",
      "qualified_name": "src/main.rs::cmd_daemon",
      "file": "src/main.rs",
      "line": 1527,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn cmd_daemon(subcmd: DaemonCommands) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:3",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "async fn cmd_daemon(subcmd: DaemonCommands) -> Result<()> {\n    match subcmd {\n        DaemonCommands::Start { project } => {\n            // TODO: Implement daemon start\n            println!(\n                \"Daemon start not yet implemented in Rust CLI (project: {})\",\n                project.display()\n            );\n        }\n\n        DaemonCommands::Stop { project } => {\n            // TODO: Implement daemon stop\n            println!(\n                \"Daemon stop not yet implemented in Rust CLI (project: {})\",\n                project.display()\n            );\n        }\n\n        DaemonCommands::Status { project } => {\n            let result = serde_json::json!({\n                \"project\": project.display().to_string(),\n                \"running\": false,\n                \"error\": \"Daemon status not yet implemented in Rust CLI\"\n            });\n            println!(\n                \"{}\",\n                serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n            );\n        }\n\n        DaemonCommands::Query { cmd, project } => {\n            let result = serde_json::json!({\n                \"command\": cmd,\n                \"project\": project.display().to_string(),\n                \"result\": null,\n                \"error\": \"Daemon query not yet implemented in Rust CLI\"\n            });\n            println!(\n                \"{}\",\n                serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n            );\n        }\n\n        DaemonCommands::Notify { file, project } => {\n            println!(\n                \"File notification not yet implemented (file: {}, project: {})\",\n                file.display(),\n                project.display()\n            );\n        }\n    }\n    Ok(())\n}\n",
      "semantic_tags": [
        "logging",
        "error_handling",
        "async_ops",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 326
    },
    {
      "name": "cmd_doctor",
      "qualified_name": "src/main.rs::cmd_doctor",
      "file": "src/main.rs",
      "line": 1581,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn cmd_doctor(install: Option<String>, json: bool) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "main"
      ],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:13, def-use chains:6",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "fn cmd_doctor(install: Option<String>, json: bool) -> Result<()> {\n    // Tool definitions for each language\n    let tools = serde_json::json!({\n        \"python\": {\n            \"type_checker\": {\"name\": \"pyright\", \"install\": \"pip install pyright\"},\n            \"linter\": {\"name\": \"ruff\", \"install\": \"pip install ruff\"}\n        },\n        \"typescript\": {\n            \"type_checker\": {\"name\": \"tsc\", \"install\": \"npm install -g typescript\"},\n            \"linter\": null\n        },\n        \"go\": {\n            \"type_checker\": {\"name\": \"go\", \"install\": \"https://go.dev/dl/\"},\n            \"linter\": {\"name\": \"golangci-lint\", \"install\": \"go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\"}\n        },\n        \"rust\": {\n            \"type_checker\": {\"name\": \"cargo\", \"install\": \"https://rustup.rs/\"},\n            \"linter\": {\"name\": \"clippy\", \"install\": \"rustup component add clippy\"}\n        }\n    });\n\n    if let Some(lang) = install {\n        println!(\"Installing tools for {} (not yet implemented)\", lang);\n        return Ok(());\n    }\n\n    if json {\n        // Check tool availability (simplified - just output structure)\n        let result = serde_json::json!({\n            \"tools\": tools,\n            \"error\": \"Full tool detection not yet implemented in Rust CLI\"\n        });\n        println!(\n            \"{}\",\n            serde_json::to_string_pretty(&result).context(\"Failed to serialize output\")?\n        );\n    } else {\n        println!(\"TLDR Diagnostics Check\");\n        println!(\"{}\", \"=\".repeat(50));\n        println!();\n        println!(\"Python:\");\n        println!(\"  pyright - check with: which pyright\");\n        println!(\"  ruff - check with: which ruff\");\n        println!();\n        println!(\"TypeScript:\");\n        println!(\"  tsc - check with: which tsc\");\n        println!();\n        println!(\"Go:\");\n        println!(\"  go - check with: which go\");\n        println!(\"  golangci-lint - check with: which golangci-lint\");\n        println!();\n        println!(\"Rust:\");\n        println!(\"  cargo - check with: which cargo\");\n        println!(\"  clippy - check with: cargo clippy --version\");\n        println!();\n        println!(\"(Full tool detection not yet implemented in Rust CLI)\");\n    }\n\n    Ok(())\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "logging",
        "error_handling",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 3,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 540
    },
    {
      "name": "Cli",
      "qualified_name": "src/main.rs::Cli",
      "file": "src/main.rs",
      "line": 52,
      "language": "rust",
      "unit_type": "class",
      "signature": "class Cli",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "anyhow, clap, std::path, tracing_subscriber, ast",
      "code_preview": "struct Cli {\n    /// Ignore .tldrignore patterns (include all files)\n    #[arg(long, global = true)]\n    no_ignore: bool,\n\n    /// Verbosity level (-v, -vv, -vvv)\n    #[arg(short, long, action = clap::ArgAction::Count, global = true)]\n    verbose: u8,\n\n    /// Output format (json by default for most commands)\n    #[arg(long, global = true, value_enum, default_value = \"json\")]\n    format: OutputFormat,\n\n    #[command(subcommand)]\n    command: Commands,\n}\n",
      "semantic_tags": [
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 120
    },
    {
      "name": "(DfgBuilder) extract_from_file",
      "qualified_name": "src/dfg/builder.rs::(DfgBuilder) extract_from_file",
      "file": "src/dfg/builder.rs",
      "line": 79,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DfgBuilder) extract_from_file(file: &str, function: &str) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    pub fn extract_from_file(file: &str, function: &str) -> Result<DFGInfo> {\n        let path = Path::new(file);\n        let registry = LanguageRegistry::global();\n\n        // Detect language from file extension\n        let lang = registry.detect_language(path).ok_or_else(|| {\n            TldrError::UnsupportedLanguage(\n                path.extension()\n                    .and_then(|e| e.to_str())\n                    .unwrap_or(\"unknown\")\n                    .to_string(),\n            )\n        })?;\n\n        // Read and parse the file\n        let source = std::fs::read(path)?;\n        let mut parser = lang.parser()?;\n        let tree = parser\n            .parse(&source, None)\n            .ok_or_else(|| TldrError::Parse {\n                file: file.to_string(),\n                message: \"Failed to parse file\".to_string(),\n            })?;\n\n        // Find the function node by name\n        let function_node = Self::find_function_node(&tree, &source, lang, function)?;\n\n        // Delegate to language-specific DFG builder\n        lang.build_dfg(function_node, &source)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation"
      ],
      "complexity": {
        "depth": 5,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 231
    },
    {
      "name": "(DfgBuilder) extract_from_source",
      "qualified_name": "src/dfg/builder.rs::(DfgBuilder) extract_from_source",
      "file": "src/dfg/builder.rs",
      "line": 136,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DfgBuilder) extract_from_source(source: &str, language: &str, function: &str) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    pub fn extract_from_source(source: &str, language: &str, function: &str) -> Result<DFGInfo> {\n        let registry = LanguageRegistry::global();\n        let lang = registry\n            .get_by_name(language)\n            .ok_or_else(|| TldrError::UnsupportedLanguage(language.to_string()))?;\n\n        let source_bytes = source.as_bytes();\n        let mut parser = lang.parser()?;\n        let tree = parser\n            .parse(source_bytes, None)\n            .ok_or_else(|| TldrError::Parse {\n                file: \"<string>\".to_string(),\n                message: \"Failed to parse source\".to_string(),\n            })?;\n\n        let function_node = Self::find_function_node(&tree, source_bytes, lang, function)?;\n        lang.build_dfg(function_node, source_bytes)\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 168
    },
    {
      "name": "(DfgBuilder) find_function_node",
      "qualified_name": "src/dfg/builder.rs::(DfgBuilder) find_function_node",
      "file": "src/dfg/builder.rs",
      "line": 160,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DfgBuilder) find_function_node(tree: &'a tree_sitter::Tree, source: &'a [u8], lang: &dyn crate::lang::Language, function_name: &str) -> Result<tree_sitter::Node<'a>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn find_function_node<'a>(\n        tree: &'a tree_sitter::Tree,\n        source: &'a [u8],\n        lang: &dyn crate::lang::Language,\n        function_name: &str,\n    ) -> Result<tree_sitter::Node<'a>> {\n        let query_str = lang.function_query();\n        let ts_lang = tree.language();\n\n        let query = Query::new(&ts_lang, query_str).map_err(|e| {\n            TldrError::TreeSitter(format!(\"Invalid function query for {}: {}\", lang.name(), e))\n        })?;\n\n        let mut cursor = QueryCursor::new();\n        let mut matches = cursor.matches(&query, tree.root_node(), source);\n\n        // Find capture indices for function and name\n        let function_capture_idx = query.capture_index_for_name(\"function\");\n        let name_capture_idx = query.capture_index_for_name(\"name\");\n\n        // Track seen byte ranges to avoid duplicate matches (e.g., decorated functions)\n        let mut seen_ranges: Vec<(usize, usize)> = Vec::new();\n\n        while let Some(match_) = matches.next() {\n            // Get the function node from captures\n            let func_node = if let Some(idx) = function_capture_idx {\n                match_\n                    .captures\n                    .iter()\n                    .find(|c| c.index == idx)\n                    .map(|c| c.node)\n            } else {\n                match_.captures.first().map(|c| c.node)\n            };\n\n            // Get the name node from captures\n            let name_node = if let Some(idx) = name_capture_idx {\n                match_\n                    .captures\n                    .iter()\n                    .find(|c| c.index == idx)\n                    .map(|c| c.node)\n            } else {\n                None\n            };\n\n            if let (Some(func_node), Some(name_node)) = (func_node, name_node) {\n                // Skip if we've already processed this byte range\n                let start = func_node.start_byte();\n                let end = func_node.end_byte();\n\n                let overlaps = seen_ranges\n                    .iter()\n                    .any(|(s, e)| (start <= *s && end >= *e) || (*s <= start && *e >= end));\n\n                if overlaps {\n                    continue;\n                }\n                seen_ranges.push((start, end));\n\n                // Check if function name matches\n                let name =\n                    std::str::from_utf8(&source[name_node.start_byte()..name_node.end_byte()])\n                        .unwrap_or(\"\");\n\n                if name == function_name {\n                    // For decorated functions, unwrap to get the inner function_definition\n                    return Ok(Self::unwrap_decorated_function(func_node));\n                }\n            }\n        }\n\n        // Function not found at module level - search class methods\n        Self::find_method_node(tree, source, lang, function_name)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 6,
        "branches": 9,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 586
    },
    {
      "name": "(DfgBuilder) unwrap_decorated_function",
      "qualified_name": "src/dfg/builder.rs::(DfgBuilder) unwrap_decorated_function",
      "file": "src/dfg/builder.rs",
      "line": 240,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DfgBuilder) unwrap_decorated_function(node: tree_sitter::Node) -> tree_sitter::Node",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn unwrap_decorated_function(node: tree_sitter::Node) -> tree_sitter::Node {\n        if node.kind() == \"decorated_definition\" {\n            let mut cursor = node.walk();\n            for child in node.children(&mut cursor) {\n                if child.kind() == \"function_definition\" {\n                    return child;\n                }\n            }\n        }\n        node\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 78
    },
    {
      "name": "(DfgBuilder) find_method_node",
      "qualified_name": "src/dfg/builder.rs::(DfgBuilder) find_method_node",
      "file": "src/dfg/builder.rs",
      "line": 256,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DfgBuilder) find_method_node(tree: &'a tree_sitter::Tree, source: &'a [u8], lang: &dyn crate::lang::Language, method_name: &str) -> Result<tree_sitter::Node<'a>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn find_method_node<'a>(\n        tree: &'a tree_sitter::Tree,\n        source: &'a [u8],\n        lang: &dyn crate::lang::Language,\n        method_name: &str,\n    ) -> Result<tree_sitter::Node<'a>> {\n        let class_query_str = lang.class_query();\n        let ts_lang = tree.language();\n\n        let query = Query::new(&ts_lang, class_query_str).map_err(|e| {\n            TldrError::TreeSitter(format!(\"Invalid class query for {}: {}\", lang.name(), e))\n        })?;\n\n        let mut cursor = QueryCursor::new();\n        let mut matches = cursor.matches(&query, tree.root_node(), source);\n\n        let class_capture_idx = query.capture_index_for_name(\"class\");\n\n        while let Some(match_) = matches.next() {\n            let class_node = if let Some(idx) = class_capture_idx {\n                match_\n                    .captures\n                    .iter()\n                    .find(|c| c.index == idx)\n                    .map(|c| c.node)\n            } else {\n                match_.captures.first().map(|c| c.node)\n            };\n\n            if let Some(class_node) = class_node {\n                // Search for method inside this class body\n                if let Some(method_node) =\n                    Self::find_method_in_class(class_node, source, method_name)\n                {\n                    return Ok(method_node);\n                }\n            }\n        }\n\n        Err(TldrError::FunctionNotFound(format!(\n            \"Function '{}' not found in file\",\n            method_name\n        )))\n    }\n",
      "semantic_tags": [
        "database",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 325
    },
    {
      "name": "(DfgBuilder) find_method_in_class",
      "qualified_name": "src/dfg/builder.rs::(DfgBuilder) find_method_in_class",
      "file": "src/dfg/builder.rs",
      "line": 305,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DfgBuilder) find_method_in_class(class_node: tree_sitter::Node<'a>, source: &[u8], method_name: &str) -> Option<tree_sitter::Node<'a>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn find_method_in_class<'a>(\n        class_node: tree_sitter::Node<'a>,\n        source: &[u8],\n        method_name: &str,\n    ) -> Option<tree_sitter::Node<'a>> {\n        // Find the class body node (block in Python, class_body in other languages)\n        let body_node = Self::find_class_body(class_node)?;\n\n        let mut cursor = body_node.walk();\n        for child in body_node.children(&mut cursor) {\n            match child.kind() {\n                \"function_definition\" | \"method_definition\" | \"method_declaration\" => {\n                    if let Some(name) = Self::extract_function_name(child, source) {\n                        if name == method_name {\n                            return Some(child);\n                        }\n                    }\n                }\n                \"decorated_definition\" => {\n                    // Look for function inside decorated definition\n                    let mut inner_cursor = child.walk();\n                    for inner in child.children(&mut inner_cursor) {\n                        if inner.kind() == \"function_definition\" {\n                            if let Some(name) = Self::extract_function_name(inner, source) {\n                                if name == method_name {\n                                    return Some(inner);\n                                }\n                            }\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 9,
        "branches": 6,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 260
    },
    {
      "name": "(DfgBuilder) find_class_body",
      "qualified_name": "src/dfg/builder.rs::(DfgBuilder) find_class_body",
      "file": "src/dfg/builder.rs",
      "line": 349,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DfgBuilder) find_class_body(class_node: tree_sitter::Node) -> Option<tree_sitter::Node>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn find_class_body(class_node: tree_sitter::Node) -> Option<tree_sitter::Node> {\n        let mut cursor = class_node.walk();\n        for child in class_node.children(&mut cursor) {\n            match child.kind() {\n                \"block\" | \"class_body\" | \"declaration_list\" => {\n                    return Some(child);\n                }\n                _ => {}\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 87
    },
    {
      "name": "(DfgBuilder) extract_function_name",
      "qualified_name": "src/dfg/builder.rs::(DfgBuilder) extract_function_name",
      "file": "src/dfg/builder.rs",
      "line": 367,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DfgBuilder) extract_function_name(node: tree_sitter::Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn extract_function_name(node: tree_sitter::Node, source: &[u8]) -> Option<String> {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"identifier\" | \"property_identifier\" | \"field_identifier\" => {\n                    return std::str::from_utf8(&source[child.start_byte()..child.end_byte()])\n                        .ok()\n                        .map(|s| s.to_string());\n                }\n                \"name\" => {\n                    // Some languages wrap the name in a \"name\" node\n                    let mut inner = child.walk();\n                    for inner_child in child.children(&mut inner) {\n                        if inner_child.kind() == \"identifier\" {\n                            return std::str::from_utf8(\n                                &source[inner_child.start_byte()..inner_child.end_byte()],\n                            )\n                            .ok()\n                            .map(|s| s.to_string());\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 8,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 212
    },
    {
      "name": "create_temp_file",
      "qualified_name": "src/dfg/builder.rs::create_temp_file",
      "file": "src/dfg/builder.rs",
      "line": 402,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_temp_file(content: &str, extension: &str) -> NamedTempFile",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_extract_python_functions",
        "test_decorated_python_class",
        "test_lookup_pattern",
        "test_extract_python_imports",
        "test_extract_python_classes"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:4",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn create_temp_file(content: &str, extension: &str) -> NamedTempFile {\n        let mut file = tempfile::Builder::new()\n            .suffix(extension)\n            .tempfile()\n            .unwrap();\n        file.write_all(content.as_bytes()).unwrap();\n        file\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 60
    },
    {
      "name": "test_extract_simple_function_dfg",
      "qualified_name": "src/dfg/builder.rs::test_extract_simple_function_dfg",
      "file": "src/dfg/builder.rs",
      "line": 412,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_simple_function_dfg()",
      "docstring": "",
      "calls": [
        "extract_from_file",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:16, def-use chains:12",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_extract_simple_function_dfg() {\n        let source = r#\"\ndef example(x, y):\n    z = x + y\n    return z\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let dfg = DfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"example\");\n\n        assert!(dfg.is_ok());\n        let dfg = dfg.unwrap();\n        assert_eq!(dfg.function_name, \"example\");\n\n        // Check parameters are tracked as definitions\n        assert!(dfg.definitions.contains_key(\"x\"));\n        assert!(dfg.definitions.contains_key(\"y\"));\n\n        // Check local variable is tracked\n        assert!(dfg.definitions.contains_key(\"z\"));\n\n        // Check uses\n        assert!(dfg.uses.contains_key(\"x\"));\n        assert!(dfg.uses.contains_key(\"y\"));\n        assert!(dfg.uses.contains_key(\"z\"));\n\n        // Check edges exist\n        assert!(!dfg.edges.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 212
    },
    {
      "name": "test_extract_function_with_mutation",
      "qualified_name": "src/dfg/builder.rs::test_extract_function_with_mutation",
      "file": "src/dfg/builder.rs",
      "line": 442,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_function_with_mutation()",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "extract_from_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:9",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_extract_function_with_mutation() {\n        let source = r#\"\ndef accumulate(items):\n    total = 0\n    for item in items:\n        total += item\n    return total\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let dfg = DfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"accumulate\");\n\n        assert!(dfg.is_ok());\n        let dfg = dfg.unwrap();\n        assert_eq!(dfg.function_name, \"accumulate\");\n\n        // total should appear in both definitions (initial + mutation) and uses (mutation reads)\n        assert!(dfg.definitions.contains_key(\"total\"));\n        assert!(dfg.uses.contains_key(\"total\"));\n\n        // item should be defined (loop variable) and used (in augmented assignment)\n        assert!(dfg.definitions.contains_key(\"item\"));\n        assert!(dfg.uses.contains_key(\"item\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 194
    },
    {
      "name": "test_extract_function_with_conditional",
      "qualified_name": "src/dfg/builder.rs::test_extract_function_with_conditional",
      "file": "src/dfg/builder.rs",
      "line": 467,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_function_with_conditional()",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "extract_from_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:6",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_extract_function_with_conditional() {\n        let source = r#\"\ndef process(x):\n    if x > 0:\n        result = x * 2\n    else:\n        result = 0\n    return result\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let dfg = DfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"process\");\n\n        assert!(dfg.is_ok());\n        let dfg = dfg.unwrap();\n\n        // result is defined in both branches\n        assert!(dfg.definitions.contains_key(\"result\"));\n\n        // x is used in condition and assignment\n        assert!(dfg.uses.contains_key(\"x\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 148
    },
    {
      "name": "test_extract_decorated_function",
      "qualified_name": "src/dfg/builder.rs::test_extract_decorated_function",
      "file": "src/dfg/builder.rs",
      "line": 490,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_decorated_function()",
      "docstring": "",
      "calls": [
        "extract_from_file",
        "extract_from_file",
        "parse_python",
        "create_temp_file",
        "extract_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:7",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_extract_decorated_function() {\n        let source = r#\"\n@staticmethod\ndef my_static(x):\n    y = x + 1\n    return y\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let dfg = DfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"my_static\");\n\n        assert!(dfg.is_ok());\n        let dfg = dfg.unwrap();\n        assert_eq!(dfg.function_name, \"my_static\");\n        assert!(dfg.definitions.contains_key(\"x\"));\n        assert!(dfg.definitions.contains_key(\"y\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 130
    },
    {
      "name": "test_extract_class_method",
      "qualified_name": "src/dfg/builder.rs::test_extract_class_method",
      "file": "src/dfg/builder.rs",
      "line": 508,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_class_method()",
      "docstring": "",
      "calls": [
        "extract_from_file",
        "create_temp_file",
        "extract_from_file",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:10",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_extract_class_method() {\n        let source = r#\"\nclass Calculator:\n    def add(self, a, b):\n        result = a + b\n        return result\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let dfg = DfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"add\");\n\n        assert!(dfg.is_ok());\n        let dfg = dfg.unwrap();\n        assert_eq!(dfg.function_name, \"add\");\n\n        // self, a, b should be parameters\n        assert!(dfg.definitions.contains_key(\"self\"));\n        assert!(dfg.definitions.contains_key(\"a\"));\n        assert!(dfg.definitions.contains_key(\"b\"));\n\n        // result should be defined and used\n        assert!(dfg.definitions.contains_key(\"result\"));\n        assert!(dfg.uses.contains_key(\"result\"));\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 186
    },
    {
      "name": "test_function_not_found",
      "qualified_name": "src/dfg/builder.rs::test_function_not_found",
      "file": "src/dfg/builder.rs",
      "line": 533,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_function_not_found()",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "extract_from_file",
        "create_temp_file",
        "extract_from_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:4",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_function_not_found() {\n        let source = r#\"\ndef existing_function():\n    pass\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let dfg = DfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"nonexistent\");\n\n        assert!(dfg.is_err());\n        assert!(matches!(dfg, Err(TldrError::FunctionNotFound(_))));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 87
    },
    {
      "name": "test_extract_from_source",
      "qualified_name": "src/dfg/builder.rs::test_extract_from_source",
      "file": "src/dfg/builder.rs",
      "line": 546,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_from_source()",
      "docstring": "",
      "calls": [
        "extract_from_source",
        "extract_from_source",
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:8",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_extract_from_source() {\n        let source = r#\"\ndef multiply(a, b):\n    return a * b\n\"#;\n        let dfg = DfgBuilder::extract_from_source(source, \"python\", \"multiply\");\n\n        assert!(dfg.is_ok());\n        let dfg = dfg.unwrap();\n        assert_eq!(dfg.function_name, \"multiply\");\n        assert!(dfg.definitions.contains_key(\"a\"));\n        assert!(dfg.definitions.contains_key(\"b\"));\n        assert!(dfg.uses.contains_key(\"a\"));\n        assert!(dfg.uses.contains_key(\"b\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 128
    },
    {
      "name": "test_unsupported_language",
      "qualified_name": "src/dfg/builder.rs::test_unsupported_language",
      "file": "src/dfg/builder.rs",
      "line": 563,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_unsupported_language()",
      "docstring": "",
      "calls": [
        "extract_file",
        "create_temp_file",
        "extract_from_file",
        "create_temp_file",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:2",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_unsupported_language() {\n        let file = create_temp_file(\"content\", \".xyz\");\n        let result = DfgBuilder::extract_from_file(file.path().to_str().unwrap(), \"func\");\n\n        assert!(matches!(result, Err(TldrError::UnsupportedLanguage(_))));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 61
    },
    {
      "name": "test_backward_slice",
      "qualified_name": "src/dfg/builder.rs::test_backward_slice",
      "file": "src/dfg/builder.rs",
      "line": 571,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_backward_slice()",
      "docstring": "",
      "calls": [
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:3",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_backward_slice() {\n        let source = r#\"\ndef compute(x):\n    a = x + 1\n    b = a * 2\n    c = b + x\n    return c\n\"#;\n        let dfg = DfgBuilder::extract_from_source(source, \"python\", \"compute\").unwrap();\n\n        // Line 5 (c = b + x) should be affected by lines defining x, a, b\n        // Note: exact line numbers depend on the source format\n        let slice = dfg.backward_slice(5);\n        assert!(!slice.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 127
    },
    {
      "name": "test_forward_slice",
      "qualified_name": "src/dfg/builder.rs::test_forward_slice",
      "file": "src/dfg/builder.rs",
      "line": 588,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_forward_slice()",
      "docstring": "",
      "calls": [
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:3",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_forward_slice() {\n        let source = r#\"\ndef compute(x):\n    a = x + 1\n    b = a * 2\n    return b\n\"#;\n        let dfg = DfgBuilder::extract_from_source(source, \"python\", \"compute\").unwrap();\n\n        // Changes to x should affect lines using x and variables derived from it\n        let slice = dfg.forward_slice(2);\n        assert!(!slice.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 99
    },
    {
      "name": "test_multiple_assignment_targets",
      "qualified_name": "src/dfg/builder.rs::test_multiple_assignment_targets",
      "file": "src/dfg/builder.rs",
      "line": 603,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_multiple_assignment_targets()",
      "docstring": "",
      "calls": [
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:6",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_multiple_assignment_targets() {\n        let source = r#\"\ndef swap(pair):\n    a, b = pair\n    return b, a\n\"#;\n        let dfg = DfgBuilder::extract_from_source(source, \"python\", \"swap\").unwrap();\n\n        assert!(dfg.definitions.contains_key(\"a\"));\n        assert!(dfg.definitions.contains_key(\"b\"));\n        assert!(dfg.uses.contains_key(\"a\"));\n        assert!(dfg.uses.contains_key(\"b\"));\n        assert!(dfg.uses.contains_key(\"pair\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 118
    },
    {
      "name": "test_comprehension_variables",
      "qualified_name": "src/dfg/builder.rs::test_comprehension_variables",
      "file": "src/dfg/builder.rs",
      "line": 619,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_comprehension_variables()",
      "docstring": "",
      "calls": [
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:4",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_comprehension_variables() {\n        let source = r#\"\ndef squared(items):\n    result = [x * x for x in items]\n    return result\n\"#;\n        let dfg = DfgBuilder::extract_from_source(source, \"python\", \"squared\").unwrap();\n\n        // x is defined in comprehension and used in expression\n        assert!(dfg.definitions.contains_key(\"x\"));\n        assert!(dfg.uses.contains_key(\"x\"));\n        assert!(dfg.uses.contains_key(\"items\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 111
    },
    {
      "name": "test_with_statement",
      "qualified_name": "src/dfg/builder.rs::test_with_statement",
      "file": "src/dfg/builder.rs",
      "line": 634,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_with_statement()",
      "docstring": "",
      "calls": [
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:4",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_with_statement() {\n        let source = r#\"\ndef read_file(path):\n    with open(path) as f:\n        content = f.read()\n    return content\n\"#;\n        let dfg = DfgBuilder::extract_from_source(source, \"python\", \"read_file\").unwrap();\n\n        // f is defined by with statement\n        assert!(dfg.definitions.contains_key(\"f\"));\n        assert!(dfg.uses.contains_key(\"f\"));\n        assert!(dfg.definitions.contains_key(\"content\"));\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 109
    },
    {
      "name": "test_try_except_variables",
      "qualified_name": "src/dfg/builder.rs::test_try_except_variables",
      "file": "src/dfg/builder.rs",
      "line": 650,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_try_except_variables()",
      "docstring": "",
      "calls": [
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:3",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_try_except_variables() {\n        let source = r#\"\ndef safe_parse(text):\n    try:\n        result = int(text)\n    except ValueError as e:\n        result = 0\n    return result\n\"#;\n        let dfg = DfgBuilder::extract_from_source(source, \"python\", \"safe_parse\").unwrap();\n\n        // e is defined in except clause\n        assert!(dfg.definitions.contains_key(\"e\"));\n        // result is defined in both branches\n        assert!(dfg.definitions.contains_key(\"result\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "error_handling"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 114
    },
    {
      "name": "test_variables_method",
      "qualified_name": "src/dfg/builder.rs::test_variables_method",
      "file": "src/dfg/builder.rs",
      "line": 668,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_variables_method()",
      "docstring": "",
      "calls": [
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:6",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "    fn test_variables_method() {\n        let source = r#\"\ndef example(x, y):\n    z = x + y\n    w = z * 2\n    return w\n\"#;\n        let dfg = DfgBuilder::extract_from_source(source, \"python\", \"example\").unwrap();\n        let vars = dfg.variables();\n\n        assert!(vars.contains(&\"x\"));\n        assert!(vars.contains(&\"y\"));\n        assert!(vars.contains(&\"z\"));\n        assert!(vars.contains(&\"w\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 109
    },
    {
      "name": "DfgBuilder",
      "qualified_name": "src/dfg/builder.rs::DfgBuilder",
      "file": "src/dfg/builder.rs",
      "line": 45,
      "language": "rust",
      "unit_type": "class",
      "signature": "class DfgBuilder",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::path, streaming_iterator, tree_sitter, crate::dfg::types, crate::error",
      "code_preview": "pub struct DfgBuilder;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 0,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 6
    },
    {
      "name": "(DeadCodeConfig) default",
      "qualified_name": "src/callgraph/dead.rs::(DeadCodeConfig) default",
      "file": "src/callgraph/dead.rs",
      "line": 105,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (DeadCodeConfig) default() -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn default() -> Self {\n        Self {\n            include_tests: false,\n            min_confidence: 0.7,\n            extra_entry_patterns: Vec::new(),\n            filter_patterns: Vec::new(),\n            language: None,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 52
    },
    {
      "name": "detect_entry_points",
      "qualified_name": "src/callgraph/dead.rs::detect_entry_points",
      "file": "src/callgraph/dead.rs",
      "line": 136,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn detect_entry_points(graph: &CallGraph) -> Vec<FunctionRef>",
      "docstring": "",
      "calls": [
        "is_definitely_entry_point",
        "is_likely_entry_point"
      ],
      "called_by": [
        "test_compute_reachability",
        "test_detect_entry_points",
        "analyze_dead_code_with_config"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "pub fn detect_entry_points(graph: &CallGraph) -> Vec<FunctionRef> {\n    let all_funcs = graph.all_functions();\n    let called: HashSet<_> = graph.edges.iter().map(|e| &e.callee).collect();\n\n    all_funcs\n        .iter()\n        .filter(|f| !called.contains(f) || is_definitely_entry_point(&f.name))\n        .filter(|f| is_likely_entry_point(&f.name))\n        .cloned()\n        .collect()\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 104
    },
    {
      "name": "detect_entry_points_with_index",
      "qualified_name": "src/callgraph/dead.rs::detect_entry_points_with_index",
      "file": "src/callgraph/dead.rs",
      "line": 151,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn detect_entry_points_with_index(graph: &CallGraph, index: &FunctionIndex) -> Vec<FunctionRef>",
      "docstring": "",
      "calls": [
        "is_definitely_entry_point",
        "is_likely_entry_point",
        "is_test_class_method",
        "is_qualified_entry_point"
      ],
      "called_by": [
        "analyze_dead_code_with_index"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:17, def-use chains:10",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "pub fn detect_entry_points_with_index(\n    graph: &CallGraph,\n    index: &FunctionIndex,\n) -> Vec<FunctionRef> {\n    let all_funcs = graph.all_functions();\n    let called: HashSet<_> = graph.edges.iter().map(|e| &e.callee).collect();\n\n    all_funcs\n        .iter()\n        .filter(|f| {\n            // Entry point if uncalled AND looks like entry point\n            // OR if it's definitely an entry point (main, etc)\n            let uncalled = !called.contains(f);\n            let is_entry = is_likely_entry_point(&f.name);\n            let is_definite = is_definitely_entry_point(&f.name);\n\n            // Check qualified name for additional patterns\n            let qname_is_entry = f\n                .qualified_name\n                .as_ref()\n                .map(|q| is_qualified_entry_point(q))\n                .unwrap_or(false);\n\n            // Check if method in test class\n            let in_test_class = is_test_class_method(f, index);\n\n            is_definite || ((uncalled || qname_is_entry || in_test_class) && is_entry)\n        })\n        .cloned()\n        .collect()\n}\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 248
    },
    {
      "name": "classify_entry_point",
      "qualified_name": "src/callgraph/dead.rs::classify_entry_point",
      "file": "src/callgraph/dead.rs",
      "line": 184,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn classify_entry_point(name: &str) -> Option<EntryPointKind>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "is_likely_entry_point"
      ],
      "cfg_summary": "complexity:7, blocks:13",
      "dfg_summary": "vars:11, def-use chains:60",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "pub fn classify_entry_point(name: &str) -> Option<EntryPointKind> {\n    // Main entry points\n    if name == \"main\" || name == \"Main\" || name == \"__main__\" {\n        return Some(EntryPointKind::Main);\n    }\n\n    // Test functions - comprehensive patterns\n    if name.starts_with(\"test_\")\n        || name.starts_with(\"Test\")\n        || name.ends_with(\"_test\")\n        || name.ends_with(\"Test\")\n        || name.ends_with(\"Tests\")\n        || name.starts_with(\"spec_\")\n        || name.ends_with(\"_spec\")\n        || name.starts_with(\"it_\")\n        || name.starts_with(\"should_\")\n        || name == \"setUp\"\n        || name == \"tearDown\"\n        || name == \"setUpClass\"\n        || name == \"tearDownClass\"\n        || name == \"beforeEach\"\n        || name == \"afterEach\"\n        || name == \"beforeAll\"\n        || name == \"afterAll\"\n    {\n        return Some(EntryPointKind::Test);\n    }\n\n    // CLI handlers\n    if name.starts_with(\"cmd_\")\n        || name.starts_with(\"handle_\")\n        || name.starts_with(\"run_\")\n        || name.starts_with(\"execute_\")\n        || name.starts_with(\"do_\")\n        || name.starts_with(\"action_\")\n        || name.starts_with(\"command_\")\n    {\n        return Some(EntryPointKind::CliHandler);\n    }\n\n    // API endpoints - REST patterns\n    if name.starts_with(\"api_\")\n        || name.starts_with(\"get_\")\n        || name.starts_with(\"post_\")\n        || name.starts_with(\"put_\")\n        || name.starts_with(\"delete_\")\n        || name.starts_with(\"patch_\")\n        || name.starts_with(\"list_\")\n        || name.starts_with(\"create_\")\n        || name.starts_with(\"update_\")\n        || name.starts_with(\"destroy_\")\n        || name.starts_with(\"index_\")\n        || name.starts_with(\"show_\")\n        || name.starts_with(\"new_\")\n        || name.starts_with(\"edit_\")\n    {\n        return Some(EntryPointKind::ApiEndpoint);\n    }\n\n    // Framework hooks and lifecycle methods\n    if name == \"setup\"\n        || name == \"teardown\"\n        || name == \"init\"\n        || name == \"cleanup\"\n        || name == \"configure\"\n        || name == \"register\"\n        || name == \"bootstrap\"\n        || name == \"mount\"\n        || name == \"unmount\"\n        || name == \"render\"\n        || name == \"componentDidMount\"\n        || name == \"componentWillUnmount\"\n        || name == \"ngOnInit\"\n        || name == \"ngOnDestroy\"\n        || name == \"created\"\n        || name == \"mounted\"\n        || name == \"destroyed\"\n    {\n        return Some(EntryPointKind::FrameworkHook);\n    }\n\n    // Python dunder methods (special methods)\n    if name.starts_with(\"__\") && name.ends_with(\"__\") {\n        return Some(EntryPointKind::PythonDunder);\n    }\n\n    None\n}\n",
      "semantic_tags": [
        "test",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 6,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 663
    },
    {
      "name": "is_likely_entry_point",
      "qualified_name": "src/callgraph/dead.rs::is_likely_entry_point",
      "file": "src/callgraph/dead.rs",
      "line": 274,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_likely_entry_point(name: &str) -> bool",
      "docstring": "",
      "calls": [
        "is_likely_callback",
        "is_likely_public_api",
        "is_likely_factory",
        "classify_entry_point"
      ],
      "called_by": [
        "detect_entry_points_with_index",
        "detect_entry_points"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn is_likely_entry_point(name: &str) -> bool {\n    classify_entry_point(name).is_some()\n        || is_likely_callback(name)\n        || is_likely_factory(name)\n        || is_likely_public_api(name)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 49
    },
    {
      "name": "is_definitely_entry_point",
      "qualified_name": "src/callgraph/dead.rs::is_definitely_entry_point",
      "file": "src/callgraph/dead.rs",
      "line": 282,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_definitely_entry_point(name: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "detect_entry_points_with_index",
        "detect_entry_points"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:6",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn is_definitely_entry_point(name: &str) -> bool {\n    name == \"main\"\n        || name == \"Main\"\n        || name == \"__main__\"\n        || name == \"app\"\n        || name == \"start\"\n        || name == \"run\"\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 57
    },
    {
      "name": "is_qualified_entry_point",
      "qualified_name": "src/callgraph/dead.rs::is_qualified_entry_point",
      "file": "src/callgraph/dead.rs",
      "line": 292,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_qualified_entry_point(qname: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "detect_entry_points_with_index"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:17",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn is_qualified_entry_point(qname: &str) -> bool {\n    // Check for common entry point module patterns\n    qname.contains(\"__main__\")\n        || qname.contains(\"cli.\")\n        || qname.contains(\"::cli::\")\n        || qname.contains(\"commands.\")\n        || qname.contains(\"::commands::\")\n        || qname.contains(\"handlers.\")\n        || qname.contains(\"::handlers::\")\n        || qname.contains(\"api.\")\n        || qname.contains(\"::api::\")\n        || qname.contains(\"routes.\")\n        || qname.contains(\"::routes::\")\n        || qname.contains(\"views.\")\n        || qname.contains(\"::views::\")\n        || qname.contains(\"endpoints.\")\n        || qname.contains(\"::endpoints::\")\n        || qname.ends_with(\"::main\")\n        || qname.ends_with(\".main\")\n}\n",
      "semantic_tags": [
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 181
    },
    {
      "name": "is_test_class_method",
      "qualified_name": "src/callgraph/dead.rs::is_test_class_method",
      "file": "src/callgraph/dead.rs",
      "line": 314,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_test_class_method(func: &FunctionRef, index: &FunctionIndex) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "detect_entry_points_with_index"
      ],
      "cfg_summary": "complexity:4, blocks:7",
      "dfg_summary": "vars:7, def-use chains:1",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn is_test_class_method(func: &FunctionRef, index: &FunctionIndex) -> bool {\n    if let Some(qname) = &func.qualified_name {\n        if let Some(def) = index.get_definition(qname) {\n            if let Some(ref class_name) = def.class_name {\n                return class_name.starts_with(\"Test\")\n                    || class_name.ends_with(\"Test\")\n                    || class_name.ends_with(\"Tests\")\n                    || class_name.ends_with(\"TestCase\")\n                    || class_name.ends_with(\"Spec\");\n            }\n        }\n    }\n    false\n}\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 117
    },
    {
      "name": "is_likely_callback",
      "qualified_name": "src/callgraph/dead.rs::is_likely_callback",
      "file": "src/callgraph/dead.rs",
      "line": 330,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_likely_callback(name: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "is_likely_entry_point",
        "check_false_positive"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:12",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn is_likely_callback(name: &str) -> bool {\n    name.starts_with(\"on_\")\n        || name.starts_with(\"on\")  // camelCase: onClick, onSubmit\n        || name.starts_with(\"On\")\n        || name.ends_with(\"_callback\")\n        || name.ends_with(\"Callback\")\n        || name.ends_with(\"_handler\")\n        || name.ends_with(\"Handler\")\n        || name.ends_with(\"_listener\")\n        || name.ends_with(\"Listener\")\n        || name.starts_with(\"handle\")\n        || name.contains(\"Callback\")\n        || name.contains(\"Handler\")\n}\n",
      "semantic_tags": [
        "async_ops",
        "api_endpoint"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 121
    },
    {
      "name": "is_likely_factory",
      "qualified_name": "src/callgraph/dead.rs::is_likely_factory",
      "file": "src/callgraph/dead.rs",
      "line": 346,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_likely_factory(name: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "compute_confidence",
        "is_likely_entry_point"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:10",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn is_likely_factory(name: &str) -> bool {\n    name.starts_with(\"create_\")\n        || name.starts_with(\"make_\")\n        || name.starts_with(\"build_\")\n        || name.starts_with(\"new_\")\n        || name.ends_with(\"_factory\")\n        || name.ends_with(\"Factory\")\n        || name.starts_with(\"Create\")\n        || name.starts_with(\"Make\")\n        || name.starts_with(\"Build\")\n        || name.starts_with(\"New\")\n}\n",
      "semantic_tags": [
        "crud"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 105
    },
    {
      "name": "is_likely_public_api",
      "qualified_name": "src/callgraph/dead.rs::is_likely_public_api",
      "file": "src/callgraph/dead.rs",
      "line": 360,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_likely_public_api(name: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "is_likely_entry_point"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:12",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn is_likely_public_api(name: &str) -> bool {\n    // Exported/public patterns - not starting with underscore\n    // and following common public API naming\n    !name.starts_with('_')\n        && (name\n            .chars()\n            .next()\n            .map(|c| c.is_uppercase())\n            .unwrap_or(false)\n            || name.starts_with(\"get\")\n            || name.starts_with(\"set\")\n            || name.starts_with(\"is_\")\n            || name.starts_with(\"has_\")\n            || name.starts_with(\"can_\")\n            || name.starts_with(\"should_\")\n            || name.starts_with(\"with_\")\n            || name.starts_with(\"from_\")\n            || name.starts_with(\"to_\")\n            || name.starts_with(\"as_\"))\n}\n",
      "semantic_tags": [
        "crud",
        "transform",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 172
    },
    {
      "name": "analyze_dead_code",
      "qualified_name": "src/callgraph/dead.rs::analyze_dead_code",
      "file": "src/callgraph/dead.rs",
      "line": 382,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn analyze_dead_code(graph: &CallGraph) -> DeadCodeResult",
      "docstring": "",
      "calls": [
        "analyze_dead_code_with_config",
        "default"
      ],
      "called_by": [
        "test_analyze_dead_code"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:1",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "pub fn analyze_dead_code(graph: &CallGraph) -> DeadCodeResult {\n    analyze_dead_code_with_config(graph, &DeadCodeConfig::default())\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 32
    },
    {
      "name": "analyze_dead_code_with_config",
      "qualified_name": "src/callgraph/dead.rs::analyze_dead_code_with_config",
      "file": "src/callgraph/dead.rs",
      "line": 387,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn analyze_dead_code_with_config(graph: &CallGraph, config: &DeadCodeConfig) -> DeadCodeResult",
      "docstring": "",
      "calls": [
        "compute_reachability",
        "determine_dead_reason",
        "default",
        "compute_confidence",
        "check_false_positive"
      ],
      "called_by": [
        "analyze_dead_code",
        "analyze_dead_code_full",
        "test_config_min_confidence",
        "test_user_defined_filter_patterns"
      ],
      "cfg_summary": "complexity:4, blocks:8",
      "dfg_summary": "vars:24, def-use chains:33",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "pub fn analyze_dead_code_with_config(graph: &CallGraph, config: &DeadCodeConfig) -> DeadCodeResult {\n    let entry_points = detect_entry_points(graph);\n    let all_funcs = graph.all_functions();\n\n    let mut stats = DeadCodeStats {\n        total_functions: all_funcs.len(),\n        entry_point_count: entry_points.len(),\n        ..Default::default()\n    };\n\n    // Compute reachable functions via BFS\n    let reachable = compute_reachability(graph, &entry_points);\n    stats.reachable_count = reachable.len();\n\n    // Find potentially dead functions\n    let mut potentially_dead: Vec<_> = all_funcs\n        .difference(&reachable)\n        .filter(|f| !entry_points.contains(f))\n        .cloned()\n        .collect();\n\n    // Filter false positives and compute confidence\n    let mut dead_functions = Vec::new();\n    let mut filtered_count = 0;\n\n    for func in potentially_dead.drain(..) {\n        let (is_false_positive, filter_reason) = check_false_positive(&func, config);\n\n        if is_false_positive {\n            filtered_count += 1;\n            match filter_reason.as_str() {\n                \"callback\" => stats.filtered_as_callback += 1,\n                \"handler\" => stats.filtered_as_handler += 1,\n                \"decorator\" => stats.filtered_as_decorator += 1,\n                \"dynamic\" => stats.filtered_as_dynamic += 1,\n                _ => {}\n            }\n            continue;\n        }\n\n        let confidence = compute_confidence(&func, graph, &reachable);\n\n        if confidence >= config.min_confidence {\n            let reason = determine_dead_reason(&func, graph, &reachable);\n\n            dead_functions.push(DeadFunction {\n                file: func.file.clone(),\n                name: func.name.clone(),\n                qualified_name: func.qualified_name.clone(),\n                line: None, // Would need index for line numbers\n                reason,\n                confidence,\n            });\n        }\n    }\n\n    DeadCodeResult {\n        total_dead: dead_functions.len(),\n        dead_functions,\n        entry_points: entry_points.iter().map(|f| f.name.clone()).collect(),\n        filtered_count,\n        stats,\n    }\n}\n",
      "semantic_tags": [
        "async_ops",
        "api_endpoint",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 440
    },
    {
      "name": "analyze_dead_code_with_index",
      "qualified_name": "src/callgraph/dead.rs::analyze_dead_code_with_index",
      "file": "src/callgraph/dead.rs",
      "line": 453,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn analyze_dead_code_with_index(graph: &CallGraph, index: &FunctionIndex, config: &DeadCodeConfig) -> DeadCodeResult",
      "docstring": "",
      "calls": [
        "compute_reachability",
        "detect_entry_points_with_index",
        "default",
        "compute_confidence",
        "determine_dead_reason"
      ],
      "called_by": [],
      "cfg_summary": "complexity:4, blocks:8",
      "dfg_summary": "vars:27, def-use chains:37",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "pub fn analyze_dead_code_with_index(\n    graph: &CallGraph,\n    index: &FunctionIndex,\n    config: &DeadCodeConfig,\n) -> DeadCodeResult {\n    let entry_points = detect_entry_points_with_index(graph, index);\n    let all_funcs = graph.all_functions();\n\n    let mut stats = DeadCodeStats {\n        total_functions: all_funcs.len(),\n        entry_point_count: entry_points.len(),\n        ..Default::default()\n    };\n\n    // Compute reachable functions via BFS\n    let reachable = compute_reachability(graph, &entry_points);\n    stats.reachable_count = reachable.len();\n\n    // Find potentially dead functions\n    let mut potentially_dead: Vec<_> = all_funcs\n        .difference(&reachable)\n        .filter(|f| !entry_points.contains(f))\n        .cloned()\n        .collect();\n\n    // Filter false positives and compute confidence\n    let mut dead_functions = Vec::new();\n    let mut filtered_count = 0;\n\n    for func in potentially_dead.drain(..) {\n        let (is_false_positive, filter_reason) =\n            check_false_positive_with_index(&func, index, config);\n\n        if is_false_positive {\n            filtered_count += 1;\n            match filter_reason.as_str() {\n                \"callback\" => stats.filtered_as_callback += 1,\n                \"handler\" => stats.filtered_as_handler += 1,\n                \"decorator\" => stats.filtered_as_decorator += 1,\n                \"dynamic\" => stats.filtered_as_dynamic += 1,\n                _ => {}\n            }\n            continue;\n        }\n\n        let confidence = compute_confidence(&func, graph, &reachable);\n\n        if confidence >= config.min_confidence {\n            let reason = determine_dead_reason(&func, graph, &reachable);\n\n            // Get line number from index\n            let line = func\n                .qualified_name\n                .as_ref()\n                .and_then(|q| index.get_definition(q))\n                .map(|d| d.line_number);\n\n            dead_functions.push(DeadFunction {\n                file: func.file.clone(),\n                name: func.name.clone(),\n                qualified_name: func.qualified_name.clone(),\n                line,\n                reason,\n                confidence,\n            });\n        }\n    }\n\n    DeadCodeResult {\n        total_dead: dead_functions.len(),\n        dead_functions,\n        entry_points: entry_points.iter().map(|f| f.name.clone()).collect(),\n        filtered_count,\n        stats,\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "async_ops",
        "api_endpoint",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 496
    },
    {
      "name": "compute_reachability",
      "qualified_name": "src/callgraph/dead.rs::compute_reachability",
      "file": "src/callgraph/dead.rs",
      "line": 533,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn compute_reachability(graph: &CallGraph, entry_points: &[FunctionRef]) -> HashSet<FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "analyze_dead_code_with_config",
        "analyze_dead_code_with_index",
        "test_compute_reachability"
      ],
      "cfg_summary": "complexity:6, blocks:13",
      "dfg_summary": "vars:9, def-use chains:7",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn compute_reachability(graph: &CallGraph, entry_points: &[FunctionRef]) -> HashSet<FunctionRef> {\n    let mut reachable = HashSet::new();\n    let mut queue: VecDeque<FunctionRef> = entry_points.iter().cloned().collect();\n\n    while let Some(func) = queue.pop_front() {\n        if reachable.insert(func.clone()) {\n            // Add all functions called by this function\n            if let Some(callees) = graph.callees.get(&func) {\n                for callee in callees {\n                    if !reachable.contains(callee) {\n                        queue.push_back(callee.clone());\n                    }\n                }\n            }\n        }\n    }\n\n    reachable\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 3,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 141
    },
    {
      "name": "check_false_positive",
      "qualified_name": "src/callgraph/dead.rs::check_false_positive",
      "file": "src/callgraph/dead.rs",
      "line": 556,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn check_false_positive(func: &FunctionRef, config: &DeadCodeConfig) -> (bool, String)",
      "docstring": "",
      "calls": [
        "is_likely_callback",
        "is_protocol_method"
      ],
      "called_by": [
        "test_check_false_positive",
        "check_false_positive_with_index",
        "analyze_dead_code_with_config"
      ],
      "cfg_summary": "complexity:8, blocks:16",
      "dfg_summary": "vars:8, def-use chains:21",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn check_false_positive(func: &FunctionRef, config: &DeadCodeConfig) -> (bool, String) {\n    let name = &func.name;\n\n    // Callback patterns - dynamically invoked\n    if is_likely_callback(name) {\n        return (true, \"callback\".to_string());\n    }\n\n    // Event handler patterns\n    if name.starts_with(\"on_\")\n        || name.starts_with(\"On\")\n        || name.ends_with(\"_event\")\n        || name.ends_with(\"Event\")\n    {\n        return (true, \"handler\".to_string());\n    }\n\n    // Decorator-registered patterns\n    if name.starts_with(\"route_\")\n        || name.starts_with(\"endpoint_\")\n        || name.starts_with(\"task_\")\n        || name.starts_with(\"job_\")\n        || name.starts_with(\"signal_\")\n        || name.starts_with(\"hook_\")\n    {\n        return (true, \"decorator\".to_string());\n    }\n\n    // Dynamic dispatch patterns (visitor pattern, dispatch methods)\n    // Note: process_* is intentionally NOT included as it's a common naming\n    // pattern for regular data processing functions\n    if name.starts_with(\"visit_\")\n        || name.starts_with(\"Visit\")\n        || name.starts_with(\"dispatch_\")\n        || name.starts_with(\"Dispatch\")\n        || name.contains(\"Strategy\")\n        || name.contains(\"Visitor\")\n    {\n        return (true, \"dynamic\".to_string());\n    }\n\n    // Protocol/interface implementation patterns\n    if name.starts_with(\"impl_\") || is_protocol_method(name) {\n        return (true, \"dynamic\".to_string());\n    }\n\n    // Check user-defined filter patterns\n    for pattern in &config.filter_patterns {\n        if name.contains(pattern) {\n            return (true, \"user_filter\".to_string());\n        }\n    }\n\n    (false, String::new())\n}\n",
      "semantic_tags": [
        "validation",
        "async_ops",
        "api_endpoint",
        "iteration",
        "config",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 6,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 393
    },
    {
      "name": "check_false_positive_with_index",
      "qualified_name": "src/callgraph/dead.rs::check_false_positive_with_index",
      "file": "src/callgraph/dead.rs",
      "line": 613,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn check_false_positive_with_index(func: &FunctionRef, index: &FunctionIndex, config: &DeadCodeConfig) -> (bool, String)",
      "docstring": "",
      "calls": [
        "check_false_positive"
      ],
      "called_by": [
        "analyze_dead_code_with_index"
      ],
      "cfg_summary": "complexity:7, blocks:13",
      "dfg_summary": "vars:12, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn check_false_positive_with_index(\n    func: &FunctionRef,\n    index: &FunctionIndex,\n    config: &DeadCodeConfig,\n) -> (bool, String) {\n    // First check basic patterns\n    let (is_fp, reason) = check_false_positive(func, config);\n    if is_fp {\n        return (true, reason);\n    }\n\n    // Check if method in a class that looks like it implements an interface/trait\n    if let Some(qname) = &func.qualified_name {\n        if let Some(def) = index.get_definition(qname) {\n            if def.is_method {\n                if let Some(ref class_name) = def.class_name {\n                    // Classes implementing common patterns\n                    if class_name.ends_with(\"Handler\")\n                        || class_name.ends_with(\"Listener\")\n                        || class_name.ends_with(\"Observer\")\n                        || class_name.ends_with(\"Strategy\")\n                        || class_name.ends_with(\"Visitor\")\n                        || class_name.ends_with(\"Callback\")\n                        || class_name.ends_with(\"Plugin\")\n                        || class_name.ends_with(\"Extension\")\n                        || class_name.ends_with(\"Middleware\")\n                        || class_name.starts_with(\"Abstract\")\n                        || class_name.starts_with(\"Base\")\n                    {\n                        return (true, \"dynamic\".to_string());\n                    }\n                }\n            }\n        }\n    }\n\n    (false, String::new())\n}\n",
      "semantic_tags": [
        "validation",
        "async_ops",
        "api_endpoint",
        "config",
        "test"
      ],
      "complexity": {
        "depth": 6,
        "branches": 7,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 279
    },
    {
      "name": "is_protocol_method",
      "qualified_name": "src/callgraph/dead.rs::is_protocol_method",
      "file": "src/callgraph/dead.rs",
      "line": 653,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_protocol_method(name: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "check_false_positive"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:1",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn is_protocol_method(name: &str) -> bool {\n    matches!(\n        name,\n        \"next\"\n            | \"iter\"\n            | \"len\"\n            | \"hash\"\n            | \"eq\"\n            | \"cmp\"\n            | \"clone\"\n            | \"drop\"\n            | \"deref\"\n            | \"index\"\n            | \"call\"\n            | \"enter\"\n            | \"exit\"\n            | \"read\"\n            | \"write\"\n            | \"close\"\n            | \"flush\"\n            | \"seek\"\n            | \"accept\"\n            | \"connect\"\n            | \"bind\"\n            | \"listen\"\n            | \"send\"\n            | \"recv\"\n    )\n}\n",
      "semantic_tags": [
        "crud"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 141
    },
    {
      "name": "compute_confidence",
      "qualified_name": "src/callgraph/dead.rs::compute_confidence",
      "file": "src/callgraph/dead.rs",
      "line": 686,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn compute_confidence(func: &FunctionRef, graph: &CallGraph, reachable: &HashSet<FunctionRef>) -> f64",
      "docstring": "",
      "calls": [
        "is_likely_factory"
      ],
      "called_by": [
        "analyze_dead_code_with_index",
        "analyze_dead_code_with_config"
      ],
      "cfg_summary": "complexity:8, blocks:15",
      "dfg_summary": "vars:11, def-use chains:16",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn compute_confidence(\n    func: &FunctionRef,\n    graph: &CallGraph,\n    reachable: &HashSet<FunctionRef>,\n) -> f64 {\n    let mut confidence: f64 = 1.0;\n    let name = &func.name;\n\n    // Lower confidence for common public API patterns\n    if name\n        .chars()\n        .next()\n        .map(|c| c.is_uppercase())\n        .unwrap_or(false)\n    {\n        confidence -= 0.1; // Public class/function\n    }\n\n    // Lower confidence for short generic names (likely interface methods)\n    if name.len() <= 3 {\n        confidence -= 0.2;\n    }\n\n    // Lower confidence for underscore-prefixed (internal but maybe intentional)\n    if name.starts_with('_') && !name.starts_with(\"__\") {\n        confidence -= 0.1;\n    }\n\n    // Higher confidence if function calls other dead functions\n    if let Some(callees) = graph.callees.get(func) {\n        let dead_callees = callees.iter().filter(|c| !reachable.contains(*c)).count();\n        if dead_callees > 0 {\n            confidence += 0.1; // Calls dead functions = more likely dead itself\n        }\n    }\n\n    // Higher confidence if no one calls this function at all\n    if !graph.callers.contains_key(func) {\n        confidence += 0.1;\n    }\n\n    // Lower confidence for factory-like names\n    if is_likely_factory(name) {\n        confidence -= 0.15;\n    }\n\n    confidence.clamp(0.0, 1.0)\n}\n",
      "semantic_tags": [
        "crud",
        "transform",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 9,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 347
    },
    {
      "name": "determine_dead_reason",
      "qualified_name": "src/callgraph/dead.rs::determine_dead_reason",
      "file": "src/callgraph/dead.rs",
      "line": 736,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn determine_dead_reason(func: &FunctionRef, graph: &CallGraph, reachable: &HashSet<FunctionRef>) -> DeadReason",
      "docstring": "",
      "calls": [],
      "called_by": [
        "analyze_dead_code_with_config",
        "analyze_dead_code_with_index",
        "test_dead_reason_classification"
      ],
      "cfg_summary": "complexity:4, blocks:7",
      "dfg_summary": "vars:12, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "fn determine_dead_reason(\n    func: &FunctionRef,\n    graph: &CallGraph,\n    reachable: &HashSet<FunctionRef>,\n) -> DeadReason {\n    // Check if never called\n    if !graph.callers.contains_key(func) {\n        return DeadReason::NeverCalled;\n    }\n\n    // Check if only called by other dead functions\n    if let Some(callers) = graph.callers.get(func) {\n        let live_callers = callers.iter().filter(|c| reachable.contains(*c)).count();\n        if live_callers == 0 {\n            return DeadReason::CalledOnlyByDead;\n        }\n    }\n\n    DeadReason::Unreachable\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "iteration",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 5,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 138
    },
    {
      "name": "create_test_graph",
      "qualified_name": "src/callgraph/dead.rs::create_test_graph",
      "file": "src/callgraph/dead.rs",
      "line": 762,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_test_graph() -> CallGraph",
      "docstring": "",
      "calls": [
        "default"
      ],
      "called_by": [
        "test_impact_language_filter",
        "test_impact_with_depth_limit",
        "test_impact_exclude_tests",
        "test_impact_distance_tracking",
        "test_detect_entry_points"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:17",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn create_test_graph() -> CallGraph {\n        let mut graph = CallGraph::default();\n\n        // main -> helper -> utility\n        // orphan_func (not called)\n        // test_something (entry point)\n        // dead_island -> dead_helper (isolated)\n\n        let main_ref = FunctionRef {\n            file: \"main.py\".to_string(),\n            name: \"main\".to_string(),\n            qualified_name: Some(\"main.main\".to_string()),\n        };\n        let helper_ref = FunctionRef {\n            file: \"main.py\".to_string(),\n            name: \"helper\".to_string(),\n            qualified_name: Some(\"main.helper\".to_string()),\n        };\n        let utility_ref = FunctionRef {\n            file: \"utils.py\".to_string(),\n            name: \"utility\".to_string(),\n            qualified_name: Some(\"utils.utility\".to_string()),\n        };\n        let orphan_ref = FunctionRef {\n            file: \"orphan.py\".to_string(),\n            name: \"orphan_func\".to_string(),\n            qualified_name: Some(\"orphan.orphan_func\".to_string()),\n        };\n        let test_ref = FunctionRef {\n            file: \"test_main.py\".to_string(),\n            name: \"test_something\".to_string(),\n            qualified_name: Some(\"test_main.test_something\".to_string()),\n        };\n        let dead_island_ref = FunctionRef {\n            file: \"dead.py\".to_string(),\n            name: \"dead_island\".to_string(),\n            qualified_name: Some(\"dead.dead_island\".to_string()),\n        };\n        let dead_helper_ref = FunctionRef {\n            file: \"dead.py\".to_string(),\n            name: \"dead_helper\".to_string(),\n            qualified_name: Some(\"dead.dead_helper\".to_string()),\n        };\n\n        graph.edges.push(CallEdge {\n            caller: main_ref.clone(),\n            callee: helper_ref.clone(),\n            call_line: 5,\n        });\n        graph.edges.push(CallEdge {\n            caller: helper_ref.clone(),\n            callee: utility_ref.clone(),\n            call_line: 10,\n        });\n        graph.edges.push(CallEdge {\n            caller: test_ref.clone(),\n            callee: helper_ref.clone(),\n            call_line: 3,\n        });\n        graph.edges.push(CallEdge {\n            caller: dead_island_ref.clone(),\n            callee: dead_helper_ref.clone(),\n            call_line: 2,\n        });\n        // orphan_ref has no edges (never called, calls nothing)\n\n        // Need to add orphan to the graph somehow - add a self-reference edge\n        // Actually, for testing, let's add it calling utility\n        graph.edges.push(CallEdge {\n            caller: orphan_ref.clone(),\n            callee: utility_ref.clone(),\n            call_line: 1,\n        });\n\n        graph.build_indexes();\n        graph\n    }\n",
      "semantic_tags": [
        "crud",
        "test",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 574
    },
    {
      "name": "test_detect_entry_points",
      "qualified_name": "src/callgraph/dead.rs::test_detect_entry_points",
      "file": "src/callgraph/dead.rs",
      "line": 841,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_detect_entry_points()",
      "docstring": "",
      "calls": [
        "detect_entry_points",
        "create_test_graph"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn test_detect_entry_points() {\n        let graph = create_test_graph();\n        let entry_points = detect_entry_points(&graph);\n\n        // Should detect main and test_something as entry points\n        let names: Vec<_> = entry_points.iter().map(|f| f.name.as_str()).collect();\n        assert!(names.contains(&\"main\"));\n        assert!(names.contains(&\"test_something\"));\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 85
    },
    {
      "name": "test_classify_entry_point",
      "qualified_name": "src/callgraph/dead.rs::test_classify_entry_point",
      "file": "src/callgraph/dead.rs",
      "line": 852,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_classify_entry_point()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn test_classify_entry_point() {\n        assert_eq!(classify_entry_point(\"main\"), Some(EntryPointKind::Main));\n        assert_eq!(classify_entry_point(\"test_foo\"), Some(EntryPointKind::Test));\n        assert_eq!(\n            classify_entry_point(\"cmd_deploy\"),\n            Some(EntryPointKind::CliHandler)\n        );\n        assert_eq!(\n            classify_entry_point(\"api_users\"),\n            Some(EntryPointKind::ApiEndpoint)\n        );\n        assert_eq!(\n            classify_entry_point(\"__init__\"),\n            Some(EntryPointKind::PythonDunder)\n        );\n        assert_eq!(\n            classify_entry_point(\"setup\"),\n            Some(EntryPointKind::FrameworkHook)\n        );\n        assert_eq!(classify_entry_point(\"random_name\"), None);\n    }\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 152
    },
    {
      "name": "test_is_likely_callback",
      "qualified_name": "src/callgraph/dead.rs::test_is_likely_callback",
      "file": "src/callgraph/dead.rs",
      "line": 875,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_is_likely_callback()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn test_is_likely_callback() {\n        assert!(is_likely_callback(\"on_click\"));\n        assert!(is_likely_callback(\"onClick\"));\n        assert!(is_likely_callback(\"button_callback\"));\n        assert!(is_likely_callback(\"MyHandler\"));\n        assert!(!is_likely_callback(\"process_data\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 66
    },
    {
      "name": "test_is_likely_factory",
      "qualified_name": "src/callgraph/dead.rs::test_is_likely_factory",
      "file": "src/callgraph/dead.rs",
      "line": 884,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_is_likely_factory()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn test_is_likely_factory() {\n        assert!(is_likely_factory(\"create_user\"));\n        assert!(is_likely_factory(\"make_config\"));\n        assert!(is_likely_factory(\"build_query\"));\n        assert!(is_likely_factory(\"UserFactory\"));\n        assert!(!is_likely_factory(\"process_user\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 67
    },
    {
      "name": "test_analyze_dead_code",
      "qualified_name": "src/callgraph/dead.rs::test_analyze_dead_code",
      "file": "src/callgraph/dead.rs",
      "line": 893,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_analyze_dead_code()",
      "docstring": "",
      "calls": [
        "analyze_dead_code",
        "create_test_graph"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn test_analyze_dead_code() {\n        let graph = create_test_graph();\n        let result = analyze_dead_code(&graph);\n\n        // dead_island and dead_helper should be detected as dead\n        // orphan_func might be detected depending on heuristics\n        assert!(result.total_dead > 0);\n\n        // Check stats\n        assert!(result.stats.entry_point_count > 0);\n        assert!(result.stats.reachable_count > 0);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 95
    },
    {
      "name": "test_compute_reachability",
      "qualified_name": "src/callgraph/dead.rs::test_compute_reachability",
      "file": "src/callgraph/dead.rs",
      "line": 907,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_compute_reachability()",
      "docstring": "",
      "calls": [
        "detect_entry_points",
        "compute_reachability",
        "create_test_graph"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:8",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn test_compute_reachability() {\n        let graph = create_test_graph();\n        let entry_points = detect_entry_points(&graph);\n        let reachable = compute_reachability(&graph, &entry_points);\n\n        // main, helper, utility should be reachable\n        // test_something should be reachable (it's an entry point)\n        assert!(reachable.iter().any(|f| f.name == \"main\"));\n        assert!(reachable.iter().any(|f| f.name == \"helper\"));\n        assert!(reachable.iter().any(|f| f.name == \"utility\"));\n        assert!(reachable.iter().any(|f| f.name == \"test_something\"));\n\n        // dead_island should NOT be reachable\n        assert!(!reachable.iter().any(|f| f.name == \"dead_island\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 166
    },
    {
      "name": "test_check_false_positive",
      "qualified_name": "src/callgraph/dead.rs::test_check_false_positive",
      "file": "src/callgraph/dead.rs",
      "line": 924,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_check_false_positive()",
      "docstring": "",
      "calls": [
        "default",
        "check_false_positive"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:7",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn test_check_false_positive() {\n        let config = DeadCodeConfig::default();\n\n        let callback_func = FunctionRef {\n            file: \"test.py\".to_string(),\n            name: \"on_click\".to_string(),\n            qualified_name: None,\n        };\n        let (is_fp, reason) = check_false_positive(&callback_func, &config);\n        assert!(is_fp);\n        assert_eq!(reason, \"callback\");\n\n        let normal_func = FunctionRef {\n            file: \"test.py\".to_string(),\n            name: \"process_data\".to_string(),\n            qualified_name: None,\n        };\n        let (is_fp, _) = check_false_positive(&normal_func, &config);\n        assert!(!is_fp);\n    }\n",
      "semantic_tags": [
        "test",
        "async_ops",
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 151
    },
    {
      "name": "test_dead_reason_classification",
      "qualified_name": "src/callgraph/dead.rs::test_dead_reason_classification",
      "file": "src/callgraph/dead.rs",
      "line": 946,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_dead_reason_classification()",
      "docstring": "",
      "calls": [
        "default",
        "determine_dead_reason"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:17, def-use chains:14",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn test_dead_reason_classification() {\n        let mut graph = CallGraph::default();\n\n        let caller = FunctionRef {\n            file: \"a.py\".to_string(),\n            name: \"caller\".to_string(),\n            qualified_name: None,\n        };\n        let callee = FunctionRef {\n            file: \"a.py\".to_string(),\n            name: \"callee\".to_string(),\n            qualified_name: None,\n        };\n        let orphan = FunctionRef {\n            file: \"a.py\".to_string(),\n            name: \"orphan\".to_string(),\n            qualified_name: None,\n        };\n\n        graph.edges.push(CallEdge {\n            caller: caller.clone(),\n            callee: callee.clone(),\n            call_line: 1,\n        });\n        graph.build_indexes();\n\n        let mut reachable = HashSet::new();\n        reachable.insert(caller.clone());\n\n        // orphan is never called\n        let reason = determine_dead_reason(&orphan, &graph, &reachable);\n        assert_eq!(reason, DeadReason::NeverCalled);\n\n        // callee is called only by reachable caller, so actually not dead\n        // But if we make caller not reachable...\n        let empty_reachable = HashSet::new();\n        let reason = determine_dead_reason(&callee, &graph, &empty_reachable);\n        assert_eq!(reason, DeadReason::CalledOnlyByDead);\n    }\n",
      "semantic_tags": [
        "crud",
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 275
    },
    {
      "name": "test_config_min_confidence",
      "qualified_name": "src/callgraph/dead.rs::test_config_min_confidence",
      "file": "src/callgraph/dead.rs",
      "line": 987,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_config_min_confidence()",
      "docstring": "",
      "calls": [
        "default",
        "analyze_dead_code_with_config",
        "create_test_graph"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:6",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn test_config_min_confidence() {\n        let graph = create_test_graph();\n\n        // With high confidence threshold, should filter more\n        let config = DeadCodeConfig {\n            min_confidence: 0.99,\n            ..Default::default()\n        };\n        let result = analyze_dead_code_with_config(&graph, &config);\n\n        // With lower threshold, should report more\n        let config_low = DeadCodeConfig {\n            min_confidence: 0.1,\n            ..Default::default()\n        };\n        let result_low = analyze_dead_code_with_config(&graph, &config_low);\n\n        // Lower threshold should find same or more dead code\n        assert!(result_low.total_dead >= result.total_dead);\n    }\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "config",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 150
    },
    {
      "name": "test_user_defined_filter_patterns",
      "qualified_name": "src/callgraph/dead.rs::test_user_defined_filter_patterns",
      "file": "src/callgraph/dead.rs",
      "line": 1009,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_user_defined_filter_patterns()",
      "docstring": "",
      "calls": [
        "default",
        "analyze_dead_code_with_config",
        "create_test_graph"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:17, def-use chains:3",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "    fn test_user_defined_filter_patterns() {\n        let graph = create_test_graph();\n\n        // Add custom filter pattern\n        let config = DeadCodeConfig {\n            filter_patterns: vec![\"orphan\".to_string()],\n            ..Default::default()\n        };\n\n        let result = analyze_dead_code_with_config(&graph, &config);\n\n        // orphan_func should be filtered out\n        assert!(!result\n            .dead_functions\n            .iter()\n            .any(|f| f.name.contains(\"orphan\")));\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "config",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 107
    },
    {
      "name": "DeadCodeResult",
      "qualified_name": "src/callgraph/dead.rs::DeadCodeResult",
      "file": "src/callgraph/dead.rs",
      "line": 32,
      "language": "rust",
      "unit_type": "class",
      "signature": "class DeadCodeResult",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "pub struct DeadCodeResult {\n    /// Functions identified as dead (unreachable)\n    pub dead_functions: Vec<DeadFunction>,\n    /// Total count\n    pub total_dead: usize,\n    /// Entry points used for analysis\n    pub entry_points: Vec<String>,\n    /// Functions filtered as likely false positives\n    pub filtered_count: usize,\n    /// Analysis statistics\n    pub stats: DeadCodeStats,\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 84
    },
    {
      "name": "DeadFunction",
      "qualified_name": "src/callgraph/dead.rs::DeadFunction",
      "file": "src/callgraph/dead.rs",
      "line": 47,
      "language": "rust",
      "unit_type": "class",
      "signature": "class DeadFunction",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "pub struct DeadFunction {\n    /// File containing the function\n    pub file: String,\n    /// Function name\n    pub name: String,\n    /// Fully qualified name\n    pub qualified_name: Option<String>,\n    /// Line number\n    pub line: Option<usize>,\n    /// Reason this function is considered dead\n    pub reason: DeadReason,\n    /// Confidence score (0.0 - 1.0)\n    pub confidence: f64,\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 94
    },
    {
      "name": "DeadCodeStats",
      "qualified_name": "src/callgraph/dead.rs::DeadCodeStats",
      "file": "src/callgraph/dead.rs",
      "line": 75,
      "language": "rust",
      "unit_type": "class",
      "signature": "class DeadCodeStats",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "pub struct DeadCodeStats {\n    /// Total functions analyzed\n    pub total_functions: usize,\n    /// Functions marked as entry points\n    pub entry_point_count: usize,\n    /// Functions reachable from entry points\n    pub reachable_count: usize,\n    /// Functions filtered as false positives\n    pub filtered_as_callback: usize,\n    pub filtered_as_handler: usize,\n    pub filtered_as_decorator: usize,\n    pub filtered_as_dynamic: usize,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 91
    },
    {
      "name": "DeadCodeConfig",
      "qualified_name": "src/callgraph/dead.rs::DeadCodeConfig",
      "file": "src/callgraph/dead.rs",
      "line": 91,
      "language": "rust",
      "unit_type": "class",
      "signature": "class DeadCodeConfig",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, serde, crate::callgraph::indexer, crate::callgraph::types, super",
      "code_preview": "pub struct DeadCodeConfig {\n    /// Include test files in analysis\n    pub include_tests: bool,\n    /// Minimum confidence threshold for reporting (0.0 - 1.0)\n    pub min_confidence: f64,\n    /// Additional entry point patterns (regex-like simple patterns)\n    pub extra_entry_patterns: Vec<String>,\n    /// Additional false positive patterns to filter\n    pub filter_patterns: Vec<String>,\n    /// Language-specific mode (enables language-specific heuristics)\n    pub language: Option<String>,\n}\n",
      "semantic_tags": [
        "test",
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 108
    },
    {
      "name": "count_tokens",
      "qualified_name": "src/util/tokenizer.rs::count_tokens",
      "file": "src/util/tokenizer.rs",
      "line": 56,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn count_tokens(text: &str) -> usize",
      "docstring": "",
      "calls": [
        "estimate_tokens",
        "count_tokens",
        "tokenize",
        "estimate_tokens"
      ],
      "called_by": [
        "test_count_tokens_code",
        "enrich_unit",
        "fits_in_tokens",
        "truncate_to_tokens",
        "count_tokens"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "pub fn count_tokens(text: &str) -> usize {\n    if text.is_empty() {\n        return 0;\n    }\n\n    match TOKENIZER.as_ref() {\n        Some(bpe) => bpe.encode_with_special_tokens(text).len(),\n        None => estimate_tokens(text),\n    }\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 60
    },
    {
      "name": "estimate_tokens",
      "qualified_name": "src/util/tokenizer.rs::estimate_tokens",
      "file": "src/util/tokenizer.rs",
      "line": 103,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn estimate_tokens(text: &str) -> usize",
      "docstring": "",
      "calls": [
        "is_cjk_codepoint",
        "is_emoji_codepoint"
      ],
      "called_by": [
        "count_tokens",
        "fits_in_tokens",
        "count_tokens",
        "test_estimate_tokens_cjk",
        "test_estimate_tokens_ascii"
      ],
      "cfg_summary": "complexity:6, blocks:15",
      "dfg_summary": "vars:11, def-use chains:14",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "pub fn estimate_tokens(text: &str) -> usize {\n    if text.is_empty() {\n        return 0;\n    }\n\n    let mut ascii_chars = 0usize;\n    let mut cjk_chars = 0usize;\n    let mut emoji_chars = 0usize;\n    let mut other_chars = 0usize;\n\n    for char in text.chars() {\n        let code = char as u32;\n\n        if code < 128 {\n            // ASCII (includes code, English text)\n            ascii_chars += 1;\n        } else if is_cjk_codepoint(code) {\n            cjk_chars += 1;\n        } else if is_emoji_codepoint(code) {\n            emoji_chars += 1;\n        } else {\n            // Other Unicode (extended Latin, Cyrillic, Arabic, etc.)\n            other_chars += 1;\n        }\n    }\n\n    // Estimate tokens by character type density\n    let estimated = (ascii_chars as f64 / 4.0)      // ~4 ASCII chars per token\n        + (cjk_chars as f64 * 1.5)                   // Each CJK char often = 1-2 tokens\n        + (emoji_chars as f64 * 3.0)                 // Emoji = 2-4 tokens each\n        + (other_chars as f64 / 2.0); // Other Unicode ~2 chars per token\n\n    // Always return at least 1 for non-empty text\n    (estimated as usize).max(1)\n}\n",
      "semantic_tags": [
        "auth",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 7,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 319
    },
    {
      "name": "is_cjk_codepoint",
      "qualified_name": "src/util/tokenizer.rs::is_cjk_codepoint",
      "file": "src/util/tokenizer.rs",
      "line": 141,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_cjk_codepoint(code: u32) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "estimate_tokens"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:1",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "fn is_cjk_codepoint(code: u32) -> bool {\n    matches!(code,\n        0x4E00..=0x9FFF |      // CJK Unified Ideographs\n        0x3400..=0x4DBF |      // CJK Extension A\n        0x20000..=0x2A6DF |    // CJK Extension B\n        0x2A700..=0x2B73F |    // CJK Extension C\n        0x2B740..=0x2B81F |    // CJK Extension D\n        0xF900..=0xFAFF |      // CJK Compatibility Ideographs\n        0x3000..=0x303F |      // CJK Punctuation\n        0x3040..=0x309F |      // Hiragana\n        0x30A0..=0x30FF |      // Katakana\n        0xAC00..=0xD7AF        // Korean Hangul\n    )\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 254
    },
    {
      "name": "is_emoji_codepoint",
      "qualified_name": "src/util/tokenizer.rs::is_emoji_codepoint",
      "file": "src/util/tokenizer.rs",
      "line": 158,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_emoji_codepoint(code: u32) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "estimate_tokens"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:1",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "fn is_emoji_codepoint(code: u32) -> bool {\n    matches!(code,\n        0x1F000..=0x1F02F |    // Mahjong, Dominos\n        0x1F300..=0x1F9FF |    // Misc Symbols and Pictographs, Emoticons (includes 0x1F600..=0x1F64F)\n        0x1FA00..=0x1FA6F |    // Chess Symbols, Extended-A\n        0x2600..=0x26FF |      // Misc Symbols\n        0x2700..=0x27BF |      // Dingbats\n        0xFE00..=0xFE0F        // Variation Selectors\n    )\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 186
    },
    {
      "name": "truncate_to_tokens",
      "qualified_name": "src/util/tokenizer.rs::truncate_to_tokens",
      "file": "src/util/tokenizer.rs",
      "line": 204,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn truncate_to_tokens(text: &str, max_tokens: usize) -> String",
      "docstring": "",
      "calls": [
        "count_tokens",
        "new",
        "truncate_by_chars"
      ],
      "called_by": [
        "force_split_by_lines",
        "test_tokenizer_consistency",
        "build_embedding_text",
        "test_truncate_to_tokens_long",
        "test_truncate_to_tokens_truncates"
      ],
      "cfg_summary": "complexity:3, blocks:5",
      "dfg_summary": "vars:11, def-use chains:13",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "pub fn truncate_to_tokens(text: &str, max_tokens: usize) -> String {\n    if text.is_empty() || max_tokens == 0 {\n        return String::new();\n    }\n\n    match TOKENIZER.as_ref() {\n        Some(bpe) => {\n            let tokens = bpe.encode_with_special_tokens(text);\n            if tokens.len() <= max_tokens {\n                return text.to_string();\n            }\n\n            let truncated_tokens = &tokens[..max_tokens];\n            bpe.decode(truncated_tokens.to_vec()).unwrap_or_else(|_| {\n                // Fallback if decode fails\n                truncate_by_chars(text, max_tokens)\n            })\n        }\n        None => truncate_by_chars(text, max_tokens),\n    }\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 4,
        "branches": 4,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 145
    },
    {
      "name": "truncate_by_chars",
      "qualified_name": "src/util/tokenizer.rs::truncate_by_chars",
      "file": "src/util/tokenizer.rs",
      "line": 229,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn truncate_by_chars(text: &str, max_tokens: usize) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [
        "truncate_to_tokens"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:3",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "fn truncate_by_chars(text: &str, max_tokens: usize) -> String {\n    // Estimate ~4 chars per token on average\n    let estimated_chars = max_tokens * 4;\n    text.chars().take(estimated_chars).collect()\n}\n",
      "semantic_tags": [
        "auth"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 51
    },
    {
      "name": "fits_in_tokens",
      "qualified_name": "src/util/tokenizer.rs::fits_in_tokens",
      "file": "src/util/tokenizer.rs",
      "line": 258,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn fits_in_tokens(text: &str, max_tokens: usize) -> bool",
      "docstring": "",
      "calls": [
        "count_tokens",
        "estimate_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:4, blocks:7",
      "dfg_summary": "vars:6, def-use chains:8",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "pub fn fits_in_tokens(text: &str, max_tokens: usize) -> bool {\n    if text.is_empty() {\n        return true;\n    }\n\n    // Quick estimate first for short-circuit\n    let estimated = estimate_tokens(text);\n    if estimated > max_tokens * 2 {\n        // Way over budget, no need for exact count\n        return false;\n    }\n    if estimated < max_tokens / 2 {\n        // Way under budget, probably fits\n        return true;\n    }\n\n    // Need exact count\n    count_tokens(text) <= max_tokens\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 3,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 118
    },
    {
      "name": "split_at_tokens",
      "qualified_name": "src/util/tokenizer.rs::split_at_tokens",
      "file": "src/util/tokenizer.rs",
      "line": 307,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn split_at_tokens(text: &str, chunk_size: usize) -> Vec<String>",
      "docstring": "",
      "calls": [
        "count_tokens"
      ],
      "called_by": [
        "test_split_at_tokens_short",
        "test_split_at_tokens_long"
      ],
      "cfg_summary": "complexity:6, blocks:12",
      "dfg_summary": "vars:16, def-use chains:22",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "pub fn split_at_tokens(text: &str, chunk_size: usize) -> Vec<String> {\n    if text.is_empty() || chunk_size == 0 {\n        return Vec::new();\n    }\n\n    let total_tokens = count_tokens(text);\n    if total_tokens <= chunk_size {\n        return vec![text.to_string()];\n    }\n\n    let mut chunks = Vec::new();\n    let mut current_chunk = String::new();\n    let mut current_tokens = 0usize;\n\n    // Split by lines first for better boundaries\n    for line in text.lines() {\n        let line_with_newline = format!(\"{}\\n\", line);\n        let line_tokens = count_tokens(&line_with_newline);\n\n        if current_tokens + line_tokens > chunk_size && !current_chunk.is_empty() {\n            // Save current chunk\n            chunks.push(current_chunk.trim_end().to_string());\n            current_chunk = String::new();\n            current_tokens = 0;\n        }\n\n        current_chunk.push_str(&line_with_newline);\n        current_tokens += line_tokens;\n    }\n\n    // Don't forget last chunk\n    if !current_chunk.is_empty() {\n        chunks.push(current_chunk.trim_end().to_string());\n    }\n\n    chunks\n}\n",
      "semantic_tags": [
        "crud",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 4,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 248
    },
    {
      "name": "test_count_tokens_empty",
      "qualified_name": "src/util/tokenizer.rs::test_count_tokens_empty",
      "file": "src/util/tokenizer.rs",
      "line": 354,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_count_tokens_empty()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_count_tokens_empty() {\n        assert_eq!(count_tokens(\"\"), 0);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 20
    },
    {
      "name": "test_count_tokens_simple",
      "qualified_name": "src/util/tokenizer.rs::test_count_tokens_simple",
      "file": "src/util/tokenizer.rs",
      "line": 359,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_count_tokens_simple()",
      "docstring": "",
      "calls": [
        "count_tokens",
        "count_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:2",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_count_tokens_simple() {\n        let count = count_tokens(\"Hello, world!\");\n        assert!(count > 0);\n        assert!(count < 10); // Should be around 4 tokens\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 46
    },
    {
      "name": "test_count_tokens_code",
      "qualified_name": "src/util/tokenizer.rs::test_count_tokens_code",
      "file": "src/util/tokenizer.rs",
      "line": 366,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_count_tokens_code()",
      "docstring": "",
      "calls": [
        "count_tokens",
        "count_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_count_tokens_code() {\n        let code = r#\"\nfn main() {\n    println!(\"Hello, world!\");\n}\n\"#;\n        let count = count_tokens(code);\n        assert!(count > 0);\n        assert!(count < 50); // Reasonable for this small snippet\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 64
    },
    {
      "name": "test_estimate_tokens_ascii",
      "qualified_name": "src/util/tokenizer.rs::test_estimate_tokens_ascii",
      "file": "src/util/tokenizer.rs",
      "line": 378,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_estimate_tokens_ascii()",
      "docstring": "",
      "calls": [
        "estimate_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_estimate_tokens_ascii() {\n        // ASCII: ~4 chars per token\n        let text = \"Hello, world!\"; // 13 chars\n        let estimate = estimate_tokens(text);\n        assert!(estimate >= 1);\n        assert!(estimate <= 10);\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "auth"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 61
    },
    {
      "name": "test_estimate_tokens_empty",
      "qualified_name": "src/util/tokenizer.rs::test_estimate_tokens_empty",
      "file": "src/util/tokenizer.rs",
      "line": 387,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_estimate_tokens_empty()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_estimate_tokens_empty() {\n        assert_eq!(estimate_tokens(\"\"), 0);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 20
    },
    {
      "name": "test_estimate_tokens_cjk",
      "qualified_name": "src/util/tokenizer.rs::test_estimate_tokens_cjk",
      "file": "src/util/tokenizer.rs",
      "line": 392,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_estimate_tokens_cjk()",
      "docstring": "",
      "calls": [
        "estimate_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_estimate_tokens_cjk() {\n        // CJK: ~1.5 chars per token\n        let text = \"\\u{4E2D}\\u{6587}\"; // \"Chinese\" in Chinese\n        let estimate = estimate_tokens(text);\n        assert!(estimate >= 1);\n        // 2 CJK chars * 1.5 = 3 tokens estimated\n        assert!(estimate <= 5);\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "auth"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 93
    },
    {
      "name": "test_truncate_to_tokens_short",
      "qualified_name": "src/util/tokenizer.rs::test_truncate_to_tokens_short",
      "file": "src/util/tokenizer.rs",
      "line": 402,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_truncate_to_tokens_short()",
      "docstring": "",
      "calls": [
        "truncate_to_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_truncate_to_tokens_short() {\n        let short = \"Hello\";\n        let result = truncate_to_tokens(short, 100);\n        assert_eq!(result, short);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 41
    },
    {
      "name": "test_truncate_to_tokens_long",
      "qualified_name": "src/util/tokenizer.rs::test_truncate_to_tokens_long",
      "file": "src/util/tokenizer.rs",
      "line": 409,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_truncate_to_tokens_long()",
      "docstring": "",
      "calls": [
        "truncate_to_tokens",
        "count_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:5",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_truncate_to_tokens_long() {\n        let long = \"word \".repeat(10000);\n        let truncated = truncate_to_tokens(&long, 100);\n\n        // Should be significantly shorter\n        assert!(truncated.len() < long.len());\n\n        // Should fit in budget\n        let token_count = count_tokens(&truncated);\n        assert!(token_count <= 100);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 89
    },
    {
      "name": "test_truncate_to_tokens_empty",
      "qualified_name": "src/util/tokenizer.rs::test_truncate_to_tokens_empty",
      "file": "src/util/tokenizer.rs",
      "line": 422,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_truncate_to_tokens_empty()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_truncate_to_tokens_empty() {\n        assert_eq!(truncate_to_tokens(\"\", 100), \"\");\n        assert_eq!(truncate_to_tokens(\"hello\", 0), \"\");\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 40
    },
    {
      "name": "test_fits_in_tokens",
      "qualified_name": "src/util/tokenizer.rs::test_fits_in_tokens",
      "file": "src/util/tokenizer.rs",
      "line": 428,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_fits_in_tokens()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:1",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_fits_in_tokens() {\n        assert!(fits_in_tokens(\"Hello\", 100));\n        assert!(fits_in_tokens(\"\", 0));\n\n        let long = \"word \".repeat(10000);\n        assert!(!fits_in_tokens(&long, 10));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 64
    },
    {
      "name": "test_split_at_tokens_short",
      "qualified_name": "src/util/tokenizer.rs::test_split_at_tokens_short",
      "file": "src/util/tokenizer.rs",
      "line": 437,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_split_at_tokens_short()",
      "docstring": "",
      "calls": [
        "split_at_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:4",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_split_at_tokens_short() {\n        let short = \"Hello, world!\";\n        let chunks = split_at_tokens(short, 100);\n        assert_eq!(chunks.len(), 1);\n        assert_eq!(chunks[0], short);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 54
    },
    {
      "name": "test_split_at_tokens_long",
      "qualified_name": "src/util/tokenizer.rs::test_split_at_tokens_long",
      "file": "src/util/tokenizer.rs",
      "line": 445,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_split_at_tokens_long()",
      "docstring": "",
      "calls": [
        "split_at_tokens",
        "count_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:9, def-use chains:5",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_split_at_tokens_long() {\n        let text = \"This is a test line.\\n\".repeat(100);\n        let chunks = split_at_tokens(&text, 50);\n\n        assert!(chunks.len() > 1);\n\n        // Each chunk should be around the target size\n        for chunk in &chunks {\n            let tokens = count_tokens(chunk);\n            // Allow some slack (chunks may exceed slightly due to line boundaries)\n            assert!(\n                tokens <= 100,\n                \"Chunk has {} tokens, expected <= 100\",\n                tokens\n            );\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 127
    },
    {
      "name": "test_split_at_tokens_empty",
      "qualified_name": "src/util/tokenizer.rs::test_split_at_tokens_empty",
      "file": "src/util/tokenizer.rs",
      "line": 464,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_split_at_tokens_empty()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:0",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_split_at_tokens_empty() {\n        assert!(split_at_tokens(\"\", 100).is_empty());\n        assert!(split_at_tokens(\"hello\", 0).is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 41
    },
    {
      "name": "test_is_cjk_codepoint",
      "qualified_name": "src/util/tokenizer.rs::test_is_cjk_codepoint",
      "file": "src/util/tokenizer.rs",
      "line": 470,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_is_cjk_codepoint()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_is_cjk_codepoint() {\n        assert!(is_cjk_codepoint(0x4E2D)); // Chinese character\n        assert!(is_cjk_codepoint(0x3042)); // Hiragana 'a'\n        assert!(is_cjk_codepoint(0xAC00)); // Korean Hangul\n        assert!(!is_cjk_codepoint(0x0041)); // ASCII 'A'\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 96
    },
    {
      "name": "test_is_emoji_codepoint",
      "qualified_name": "src/util/tokenizer.rs::test_is_emoji_codepoint",
      "file": "src/util/tokenizer.rs",
      "line": 478,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_is_emoji_codepoint()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_is_emoji_codepoint() {\n        assert!(is_emoji_codepoint(0x1F600)); // Grinning face\n        assert!(is_emoji_codepoint(0x2764)); // Heart (in misc symbols)\n        assert!(!is_emoji_codepoint(0x0041)); // ASCII 'A'\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 79
    },
    {
      "name": "test_tokenizer_consistency",
      "qualified_name": "src/util/tokenizer.rs::test_tokenizer_consistency",
      "file": "src/util/tokenizer.rs",
      "line": 485,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_tokenizer_consistency()",
      "docstring": "",
      "calls": [
        "truncate_to_tokens",
        "count_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:9",
      "dependencies": "once_cell::sync, tiktoken_rs, super",
      "code_preview": "    fn test_tokenizer_consistency() {\n        // Verify that count_tokens and truncate_to_tokens are consistent\n        let text = \"This is a test of the tokenizer consistency.\";\n        let count = count_tokens(text);\n\n        // Truncate to exact count should return original\n        let truncated = truncate_to_tokens(text, count);\n        assert_eq!(truncated, text);\n\n        // Truncate to less should return shorter\n        let shorter = truncate_to_tokens(text, count / 2);\n        assert!(shorter.len() < text.len());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 112
    },
    {
      "name": "count_tokens",
      "qualified_name": "src/semantic/chunker.rs::count_tokens",
      "file": "src/semantic/chunker.rs",
      "line": 49,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn count_tokens(text: &str) -> usize",
      "docstring": "",
      "calls": [
        "estimate_tokens",
        "count_tokens",
        "tokenize",
        "estimate_tokens"
      ],
      "called_by": [
        "test_count_tokens_code",
        "enrich_unit",
        "fits_in_tokens",
        "truncate_to_tokens",
        "count_tokens"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:9, def-use chains:4",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "pub fn count_tokens(text: &str) -> usize {\n    if text.is_empty() {\n        return 0;\n    }\n\n    let guard = TOKENIZER.lock().unwrap_or_else(|e| e.into_inner());\n    match guard.as_ref() {\n        Some(bpe) => bpe.encode_ordinary(text).len(),\n        None => estimate_tokens(text),\n    }\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 76
    },
    {
      "name": "estimate_tokens",
      "qualified_name": "src/semantic/chunker.rs::estimate_tokens",
      "file": "src/semantic/chunker.rs",
      "line": 67,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn estimate_tokens(text: &str) -> usize",
      "docstring": "",
      "calls": [
        "is_cjk_codepoint",
        "is_emoji_codepoint"
      ],
      "called_by": [
        "count_tokens",
        "fits_in_tokens",
        "count_tokens",
        "test_estimate_tokens_cjk",
        "test_estimate_tokens_ascii"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:1",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "fn estimate_tokens(text: &str) -> usize {\n    // More accurate estimation: ~3.5 chars per token for code\n    // But we use 4 to be conservative (underestimate = safer)\n    (text.len() + 3) / 4\n}\n",
      "semantic_tags": [
        "auth",
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 57
    },
    {
      "name": "truncate_to_tokens",
      "qualified_name": "src/semantic/chunker.rs::truncate_to_tokens",
      "file": "src/semantic/chunker.rs",
      "line": 87,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn truncate_to_tokens(text: &str, max_tokens: usize) -> String",
      "docstring": "",
      "calls": [
        "count_tokens",
        "new",
        "truncate_by_chars"
      ],
      "called_by": [
        "force_split_by_lines",
        "test_tokenizer_consistency",
        "build_embedding_text",
        "test_truncate_to_tokens_long",
        "test_truncate_to_tokens_truncates"
      ],
      "cfg_summary": "complexity:4, blocks:8",
      "dfg_summary": "vars:16, def-use chains:25",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "pub fn truncate_to_tokens(text: &str, max_tokens: usize) -> String {\n    if text.is_empty() || max_tokens == 0 {\n        return String::new();\n    }\n\n    let current_tokens = count_tokens(text);\n    if current_tokens <= max_tokens {\n        return text.to_string();\n    }\n\n    let guard = TOKENIZER.lock().unwrap_or_else(|e| e.into_inner());\n    match guard.as_ref() {\n        Some(bpe) => {\n            let tokens = bpe.encode_ordinary(text);\n            let truncated_tokens = &tokens[..max_tokens.min(tokens.len())];\n            bpe.decode(truncated_tokens.to_vec())\n                .unwrap_or_else(|_| text[..text.len() * max_tokens / current_tokens].to_string())\n        }\n        None => {\n            // Fallback: estimate character count\n            let estimated_chars = max_tokens * 4;\n            let mut end = estimated_chars.min(text.len());\n            // Ensure we don't cut in the middle of a UTF-8 character\n            while end > 0 && !text.is_char_boundary(end) {\n                end -= 1;\n            }\n            text[..end].to_string()\n        }\n    }\n}\n",
      "semantic_tags": [
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 244
    },
    {
      "name": "(Chunk) new",
      "qualified_name": "src/semantic/chunker.rs::(Chunk) new",
      "file": "src/semantic/chunker.rs",
      "line": 159,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Chunk) new(content: String, start_line: usize, end_line: usize, start_char: usize, end_char: usize) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    pub fn new(\n        content: String,\n        start_line: usize,\n        end_line: usize,\n        start_char: usize,\n        end_char: usize,\n    ) -> Self {\n        let token_count = count_tokens(&content);\n        Self {\n            chunk_id: String::new(),\n            content,\n            token_count,\n            start_line,\n            end_line,\n            start_char,\n            end_char,\n            chunk_index: 0,\n            chunk_total: 1,\n            parent_ref: None,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 107
    },
    {
      "name": "(Chunk) with_id",
      "qualified_name": "src/semantic/chunker.rs::(Chunk) with_id",
      "file": "src/semantic/chunker.rs",
      "line": 183,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Chunk) with_id(mut self, id: impl Into<String>) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    pub fn with_id(mut self, id: impl Into<String>) -> Self {\n        self.chunk_id = id.into();\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 30
    },
    {
      "name": "(Chunk) with_parent",
      "qualified_name": "src/semantic/chunker.rs::(Chunk) with_parent",
      "file": "src/semantic/chunker.rs",
      "line": 190,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Chunk) with_parent(mut self, parent: impl Into<String>) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    pub fn with_parent(mut self, parent: impl Into<String>) -> Self {\n        self.parent_ref = Some(parent.into());\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 31
    },
    {
      "name": "(Chunk) with_chunk_info",
      "qualified_name": "src/semantic/chunker.rs::(Chunk) with_chunk_info",
      "file": "src/semantic/chunker.rs",
      "line": 197,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Chunk) with_chunk_info(mut self, index: usize, total: usize) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    pub fn with_chunk_info(mut self, index: usize, total: usize) -> Self {\n        self.chunk_index = index;\n        self.chunk_total = total;\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 39
    },
    {
      "name": "(Chunk) is_standalone",
      "qualified_name": "src/semantic/chunker.rs::(Chunk) is_standalone",
      "file": "src/semantic/chunker.rs",
      "line": 205,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Chunk) is_standalone(&self) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    pub fn is_standalone(&self) -> bool {\n        self.chunk_total == 1\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 22
    },
    {
      "name": "(BoundaryPatterns) new",
      "qualified_name": "src/semantic/chunker.rs::(BoundaryPatterns) new",
      "file": "src/semantic/chunker.rs",
      "line": 256,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (BoundaryPatterns) new() -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn new() -> Self {\n        Self {\n            // Function patterns: def, fn, func, function, async function, public/private methods\n            function_start: Regex::new(r\"^\\s*(pub\\s+)?(async\\s+)?(def|fn|func|function|fun)\\s+\\w+\")\n                .expect(\"valid regex\"),\n\n            // Class patterns: class, struct, interface, trait, impl, type (Go/TS)\n            class_start: Regex::new(r\"^\\s*(pub\\s+)?(class|struct|interface|trait|impl|type)\\s+\\w+\")\n                .expect(\"valid regex\"),\n\n            // Comment patterns: #, //, /*, \"\"\", '''\n            comment: Regex::new(r#\"^\\s*(#[^!]|//|/\\*|\"\"\"|''')\"#).expect(\"valid regex\"),\n\n            // Blank line\n            blank: Regex::new(r\"^\\s*$\").expect(\"valid regex\"),\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "async_ops",
        "validation"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 207
    },
    {
      "name": "detect_boundaries",
      "qualified_name": "src/semantic/chunker.rs::detect_boundaries",
      "file": "src/semantic/chunker.rs",
      "line": 279,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn detect_boundaries(lines: &[&str], line_offsets: &[usize]) -> Vec<Boundary>",
      "docstring": "",
      "calls": [
        "new",
        "get_indent_depth"
      ],
      "called_by": [
        "chunk_code_with_overlap",
        "test_boundary_detection",
        "handle_oversized_chunk"
      ],
      "cfg_summary": "complexity:8, blocks:19",
      "dfg_summary": "vars:19, def-use chains:20",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "fn detect_boundaries(lines: &[&str], line_offsets: &[usize]) -> Vec<Boundary> {\n    let mut boundaries = Vec::new();\n    let patterns = &*BOUNDARY_PATTERNS;\n\n    for (idx, line) in lines.iter().enumerate() {\n        let char_offset = line_offsets.get(idx).copied().unwrap_or(0);\n\n        // Check patterns in order of priority (highest first)\n        if patterns.class_start.is_match(line) {\n            boundaries.push(Boundary {\n                line_idx: idx,\n                char_offset,\n                kind: BoundaryKind::ClassStart,\n            });\n        } else if patterns.function_start.is_match(line) {\n            boundaries.push(Boundary {\n                line_idx: idx,\n                char_offset,\n                kind: BoundaryKind::FunctionStart,\n            });\n        } else if patterns.blank.is_match(line) {\n            boundaries.push(Boundary {\n                line_idx: idx,\n                char_offset,\n                kind: BoundaryKind::BlankLine,\n            });\n        } else if patterns.comment.is_match(line) {\n            boundaries.push(Boundary {\n                line_idx: idx,\n                char_offset,\n                kind: BoundaryKind::Comment,\n            });\n        }\n\n        // Detect block ends by checking for significant dedent\n        if idx > 0 {\n            let prev_indent = get_indent_depth(lines[idx - 1]);\n            let curr_indent = get_indent_depth(line);\n            // Significant dedent (more than 1 level) indicates block end\n            if prev_indent > curr_indent + 1 && !line.trim().is_empty() {\n                boundaries.push(Boundary {\n                    line_idx: idx,\n                    char_offset,\n                    kind: BoundaryKind::BlockEnd,\n                });\n            }\n        }\n    }\n\n    boundaries\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 9,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 355
    },
    {
      "name": "get_indent_depth",
      "qualified_name": "src/semantic/chunker.rs::get_indent_depth",
      "file": "src/semantic/chunker.rs",
      "line": 335,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_indent_depth(line: &str) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [
        "detect_boundaries"
      ],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:7, def-use chains:8",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "fn get_indent_depth(line: &str) -> usize {\n    let stripped = line.trim_start();\n    if stripped.is_empty() {\n        return 0;\n    }\n\n    let leading_len = line.len() - stripped.len();\n    let leading = &line[..leading_len];\n    // Expand tabs to 4 spaces\n    let expanded_len: usize = leading.chars().map(|c| if c == '\\t' { 4 } else { 1 }).sum();\n\n    expanded_len / 4\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 104
    },
    {
      "name": "chunk_code",
      "qualified_name": "src/semantic/chunker.rs::chunk_code",
      "file": "src/semantic/chunker.rs",
      "line": 405,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn chunk_code(code: &str, max_tokens: usize) -> Vec<Chunk>",
      "docstring": "",
      "calls": [
        "chunk_code_with_overlap"
      ],
      "called_by": [
        "test_chunk_fits_single",
        "test_chunk_line_numbers",
        "chunk_code_default",
        "test_chunk_typescript_code",
        "test_chunk_python_with_docstrings"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:2",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "pub fn chunk_code(code: &str, max_tokens: usize) -> Vec<Chunk> {\n    chunk_code_with_overlap(code, max_tokens, CHUNK_OVERLAP_TOKENS)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 38
    },
    {
      "name": "chunk_code_with_overlap",
      "qualified_name": "src/semantic/chunker.rs::chunk_code_with_overlap",
      "file": "src/semantic/chunker.rs",
      "line": 413,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn chunk_code_with_overlap(code: &str, max_tokens: usize, overlap_tokens: usize) -> Vec<Chunk>",
      "docstring": "",
      "calls": [
        "detect_boundaries",
        "count_tokens",
        "new",
        "build_line_offsets",
        "chunk_with_boundaries"
      ],
      "called_by": [
        "chunk_code",
        "test_chunk_with_overlap"
      ],
      "cfg_summary": "complexity:3, blocks:5",
      "dfg_summary": "vars:18, def-use chains:19",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "pub fn chunk_code_with_overlap(code: &str, max_tokens: usize, overlap_tokens: usize) -> Vec<Chunk> {\n    if code.is_empty() {\n        return Vec::new();\n    }\n\n    // Check if code fits in a single chunk\n    let total_tokens = count_tokens(code);\n    if total_tokens <= max_tokens {\n        let line_count = code.lines().count().max(1);\n        return vec![Chunk::new(code.to_string(), 1, line_count, 0, code.len())];\n    }\n\n    // Parse lines and build offset map\n    let lines: Vec<&str> = code.lines().collect();\n    let line_offsets = build_line_offsets(&lines, code);\n\n    // Detect natural boundaries\n    let boundaries = detect_boundaries(&lines, &line_offsets);\n\n    // Smart chunking with boundary awareness\n    chunk_with_boundaries(\n        code,\n        &lines,\n        &line_offsets,\n        &boundaries,\n        max_tokens,\n        overlap_tokens,\n    )\n}\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 209
    },
    {
      "name": "build_line_offsets",
      "qualified_name": "src/semantic/chunker.rs::build_line_offsets",
      "file": "src/semantic/chunker.rs",
      "line": 444,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn build_line_offsets(lines: &[&str], code: &str) -> Vec<usize>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "handle_oversized_chunk",
        "chunk_code_with_overlap",
        "test_boundary_detection"
      ],
      "cfg_summary": "complexity:4, blocks:8",
      "dfg_summary": "vars:9, def-use chains:10",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "fn build_line_offsets(lines: &[&str], code: &str) -> Vec<usize> {\n    let mut offsets = Vec::with_capacity(lines.len());\n    let mut current_offset = 0;\n\n    for (i, line) in lines.iter().enumerate() {\n        offsets.push(current_offset);\n        current_offset += line.len();\n        // Add 1 for newline if not the last line\n        if i < lines.len() - 1 {\n            current_offset += 1;\n        }\n    }\n\n    // Handle trailing newline\n    if code.ends_with('\\n') && !lines.is_empty() {\n        // The last line_offset already accounts for content\n    }\n\n    offsets\n}\n",
      "semantic_tags": [
        "crud",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 3,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 141
    },
    {
      "name": "chunk_with_boundaries",
      "qualified_name": "src/semantic/chunker.rs::chunk_with_boundaries",
      "file": "src/semantic/chunker.rs",
      "line": 466,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn chunk_with_boundaries(code: &str, lines: &[&str], line_offsets: &[usize], boundaries: &[Boundary], max_tokens: usize, overlap_tokens: usize) -> Vec<Chunk>",
      "docstring": "",
      "calls": [
        "find_best_split",
        "handle_oversized_chunk",
        "calculate_overlap",
        "count_tokens",
        "new"
      ],
      "called_by": [
        "handle_oversized_chunk",
        "chunk_code_with_overlap"
      ],
      "cfg_summary": "complexity:8, blocks:18",
      "dfg_summary": "vars:31, def-use chains:46",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "fn chunk_with_boundaries(\n    code: &str,\n    lines: &[&str],\n    line_offsets: &[usize],\n    boundaries: &[Boundary],\n    max_tokens: usize,\n    overlap_tokens: usize,\n) -> Vec<Chunk> {\n    let mut chunks = Vec::new();\n\n    // Track current chunk state\n    let mut chunk_start_line = 0;\n    let mut current_tokens = 0;\n    let mut last_good_boundary: Option<usize> = None; // line index of last good split point\n\n    // Track overlap for context continuity (values set on chunk split)\n    let mut overlap_lines: Vec<usize>;\n    let mut overlap_token_count: usize;\n\n    for (line_idx, line) in lines.iter().enumerate() {\n        let line_with_newline = if line_idx < lines.len() - 1 {\n            format!(\"{}\\n\", line)\n        } else {\n            (*line).to_string()\n        };\n        let line_tokens = count_tokens(&line_with_newline);\n\n        // Check if adding this line would exceed limit\n        if current_tokens + line_tokens > max_tokens && line_idx > chunk_start_line {\n            // Find best split point\n            let split_line =\n                find_best_split(chunk_start_line, line_idx, last_good_boundary, boundaries);\n\n            // Create chunk\n            let chunk =\n                create_chunk_from_range(code, lines, line_offsets, chunk_start_line, split_line);\n            chunks.push(chunk);\n\n            // Calculate overlap for next chunk\n            (overlap_lines, overlap_token_count) =\n                calculate_overlap(lines, split_line, overlap_tokens);\n\n            // Start new chunk with overlap\n            chunk_start_line = split_line.saturating_sub(overlap_lines.len());\n            current_tokens = overlap_token_count;\n            last_good_boundary = None;\n        }\n\n        // Check if this line is a good boundary\n        if boundaries.iter().any(|b| b.line_idx == line_idx) {\n            last_good_boundary = Some(line_idx);\n        }\n\n        current_tokens += line_tokens;\n    }\n\n    // Don't forget the last chunk\n    if chunk_start_line < lines.len() {\n        let chunk =\n            create_chunk_from_range(code, lines, line_offsets, chunk_start_line, lines.len());\n        chunks.push(chunk);\n    }\n\n    // Assign chunk metadata\n    let total_chunks = chunks.len();\n    for (i, chunk) in chunks.iter_mut().enumerate() {\n        chunk.chunk_index = i;\n        chunk.chunk_total = total_chunks;\n        chunk.chunk_id = format!(\"chunk_{}\", i + 1);\n    }\n\n    // Handle edge case: single oversized line\n    if chunks.len() == 1 && chunks[0].token_count > max_tokens {\n        return handle_oversized_chunk(&chunks[0], max_tokens, overlap_tokens);\n    }\n\n    chunks\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 4,
        "branches": 9,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 579
    },
    {
      "name": "find_best_split",
      "qualified_name": "src/semantic/chunker.rs::find_best_split",
      "file": "src/semantic/chunker.rs",
      "line": 546,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn find_best_split(chunk_start: usize, current_line: usize, last_boundary: Option<usize>, boundaries: &[Boundary]) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [
        "chunk_with_boundaries"
      ],
      "cfg_summary": "complexity:4, blocks:7",
      "dfg_summary": "vars:10, def-use chains:8",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "fn find_best_split(\n    chunk_start: usize,\n    current_line: usize,\n    last_boundary: Option<usize>,\n    boundaries: &[Boundary],\n) -> usize {\n    // First choice: use the last good boundary if available\n    if let Some(boundary_line) = last_boundary {\n        if boundary_line > chunk_start && boundary_line < current_line {\n            return boundary_line;\n        }\n    }\n\n    // Second choice: find the highest priority boundary in range\n    let candidates: Vec<_> = boundaries\n        .iter()\n        .filter(|b| b.line_idx > chunk_start && b.line_idx < current_line)\n        .collect();\n\n    if let Some(best) = candidates.iter().max_by_key(|b| b.kind) {\n        return best.line_idx;\n    }\n\n    // Fallback: split at current line\n    current_line\n}\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 4,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 176
    },
    {
      "name": "create_chunk_from_range",
      "qualified_name": "src/semantic/chunker.rs::create_chunk_from_range",
      "file": "src/semantic/chunker.rs",
      "line": 574,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_chunk_from_range(code: &str, lines: &[&str], line_offsets: &[usize], start_line: usize, end_line: usize) -> Chunk",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [
        "chunk_with_boundaries"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:10, def-use chains:18",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "fn create_chunk_from_range(\n    code: &str,\n    lines: &[&str],\n    line_offsets: &[usize],\n    start_line: usize,\n    end_line: usize,\n) -> Chunk {\n    let start_char = line_offsets.get(start_line).copied().unwrap_or(0);\n    let end_char = if end_line >= lines.len() {\n        code.len()\n    } else {\n        line_offsets.get(end_line).copied().unwrap_or(code.len())\n    };\n\n    // Ensure we don't go past the end of code\n    let end_char = end_char.min(code.len());\n    let content = code[start_char..end_char].to_string();\n\n    Chunk::new(\n        content,\n        start_line + 1, // Convert to 1-indexed\n        end_line,       // end_line is exclusive, so this is the last line (1-indexed)\n        start_char,\n        end_char,\n    )\n}\n",
      "semantic_tags": [
        "crud",
        "transform",
        "validation",
        "api_endpoint"
      ],
      "complexity": {
        "depth": 2,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 193
    },
    {
      "name": "calculate_overlap",
      "qualified_name": "src/semantic/chunker.rs::calculate_overlap",
      "file": "src/semantic/chunker.rs",
      "line": 602,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn calculate_overlap(lines: &[&str], split_line: usize, overlap_tokens: usize) -> (Vec<usize>, usize)",
      "docstring": "",
      "calls": [
        "new",
        "count_tokens"
      ],
      "called_by": [
        "chunk_with_boundaries"
      ],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:11, def-use chains:11",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "fn calculate_overlap(\n    lines: &[&str],\n    split_line: usize,\n    overlap_tokens: usize,\n) -> (Vec<usize>, usize) {\n    let mut overlap_lines = Vec::new();\n    let mut token_count = 0;\n\n    // Go backwards from split point to accumulate overlap\n    for line_idx in (0..split_line).rev() {\n        let line = lines.get(line_idx).copied().unwrap_or(\"\");\n        let line_tokens = count_tokens(line);\n\n        if token_count + line_tokens > overlap_tokens {\n            break;\n        }\n\n        overlap_lines.insert(0, line_idx);\n        token_count += line_tokens;\n    }\n\n    (overlap_lines, token_count)\n}\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 144
    },
    {
      "name": "handle_oversized_chunk",
      "qualified_name": "src/semantic/chunker.rs::handle_oversized_chunk",
      "file": "src/semantic/chunker.rs",
      "line": 630,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn handle_oversized_chunk(chunk: &Chunk, max_tokens: usize, overlap_tokens: usize) -> Vec<Chunk>",
      "docstring": "",
      "calls": [
        "build_line_offsets",
        "chunk_with_boundaries",
        "detect_boundaries",
        "truncate_to_tokens",
        "force_split_by_lines"
      ],
      "called_by": [
        "chunk_with_boundaries"
      ],
      "cfg_summary": "complexity:4, blocks:7",
      "dfg_summary": "vars:23, def-use chains:33",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "fn handle_oversized_chunk(chunk: &Chunk, max_tokens: usize, overlap_tokens: usize) -> Vec<Chunk> {\n    let lines: Vec<&str> = chunk.content.lines().collect();\n\n    if lines.len() <= 1 {\n        // Single line that's too long - just truncate\n        let truncated = truncate_to_tokens(&chunk.content, max_tokens);\n        return vec![Chunk::new(\n            truncated,\n            chunk.start_line,\n            chunk.start_line,\n            chunk.start_char,\n            chunk.start_char + chunk.content.len().min(max_tokens * 4),\n        )];\n    }\n\n    // Try to split at blank lines within the oversized chunk\n    let line_offsets = build_line_offsets(&lines, &chunk.content);\n    let boundaries = detect_boundaries(&lines, &line_offsets);\n\n    // If we have boundaries, try chunking again with smaller target\n    if !boundaries.is_empty() {\n        let reduced_max = max_tokens * 3 / 4; // Try 75% of max\n        let sub_chunks = chunk_with_boundaries(\n            &chunk.content,\n            &lines,\n            &line_offsets,\n            &boundaries,\n            reduced_max,\n            overlap_tokens,\n        );\n\n        if sub_chunks.len() > 1 {\n            // Adjust line numbers to be relative to original chunk\n            return sub_chunks\n                .into_iter()\n                .map(|mut c| {\n                    c.start_line += chunk.start_line - 1;\n                    c.end_line += chunk.start_line - 1;\n                    c.start_char += chunk.start_char;\n                    c.end_char += chunk.start_char;\n                    c\n                })\n                .collect();\n        }\n    }\n\n    // Last resort: split by lines, trying to stay under token limit\n    force_split_by_lines(\n        &chunk.content,\n        chunk.start_line,\n        chunk.start_char,\n        max_tokens,\n    )\n}\n",
      "semantic_tags": [
        "transform",
        "auth",
        "iteration",
        "error_handling"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 391
    },
    {
      "name": "force_split_by_lines",
      "qualified_name": "src/semantic/chunker.rs::force_split_by_lines",
      "file": "src/semantic/chunker.rs",
      "line": 686,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn force_split_by_lines(content: &str, base_line: usize, base_char: usize, max_tokens: usize) -> Vec<Chunk>",
      "docstring": "",
      "calls": [
        "truncate_to_tokens",
        "count_tokens",
        "new"
      ],
      "called_by": [
        "handle_oversized_chunk"
      ],
      "cfg_summary": "complexity:6, blocks:13",
      "dfg_summary": "vars:29, def-use chains:55",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "fn force_split_by_lines(\n    content: &str,\n    base_line: usize,\n    base_char: usize,\n    max_tokens: usize,\n) -> Vec<Chunk> {\n    let mut chunks = Vec::new();\n    let mut current_content = String::new();\n    let mut current_tokens = 0;\n    let mut current_start_line = base_line;\n    let mut current_start_char = base_char;\n    let mut char_offset = 0;\n\n    for (i, line) in content.lines().enumerate() {\n        let line_with_newline = format!(\"{}\\n\", line);\n        let line_tokens = count_tokens(&line_with_newline);\n\n        // If single line exceeds limit, truncate it\n        if line_tokens > max_tokens && current_content.is_empty() {\n            let truncated = truncate_to_tokens(line, max_tokens);\n            chunks.push(Chunk::new(\n                truncated,\n                base_line + i,\n                base_line + i,\n                base_char + char_offset,\n                base_char + char_offset + line.len(),\n            ));\n            char_offset += line.len() + 1;\n            current_start_line = base_line + i + 1;\n            current_start_char = base_char + char_offset;\n            continue;\n        }\n\n        // Check if adding this line would exceed limit\n        if current_tokens + line_tokens > max_tokens && !current_content.is_empty() {\n            // Save current chunk\n            let end_line = base_line + i - 1;\n            let end_char = base_char + char_offset;\n            chunks.push(Chunk::new(\n                std::mem::take(&mut current_content),\n                current_start_line,\n                end_line,\n                current_start_char,\n                end_char,\n            ));\n            current_tokens = 0;\n            current_start_line = base_line + i;\n            current_start_char = base_char + char_offset;\n        }\n\n        current_content.push_str(&line_with_newline);\n        current_tokens += line_tokens;\n        char_offset += line.len() + 1;\n    }\n\n    // Don't forget the last chunk\n    if !current_content.is_empty() {\n        let end_line = base_line + content.lines().count().saturating_sub(1);\n        chunks.push(Chunk::new(\n            current_content,\n            current_start_line,\n            end_line,\n            current_start_char,\n            base_char + content.len(),\n        ));\n    }\n\n    // Assign metadata\n    let total = chunks.len();\n    for (i, chunk) in chunks.iter_mut().enumerate() {\n        chunk.chunk_index = i;\n        chunk.chunk_total = total;\n        chunk.chunk_id = format!(\"chunk_{}\", i + 1);\n    }\n\n    chunks\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "test"
      ],
      "complexity": {
        "depth": 4,
        "branches": 4,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 550
    },
    {
      "name": "chunk_code_default",
      "qualified_name": "src/semantic/chunker.rs::chunk_code_default",
      "file": "src/semantic/chunker.rs",
      "line": 773,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn chunk_code_default(code: &str) -> Vec<Chunk>",
      "docstring": "",
      "calls": [
        "chunk_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:1",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "pub fn chunk_code_default(code: &str) -> Vec<Chunk> {\n    chunk_code(code, MAX_CODE_PREVIEW_TOKENS)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 28
    },
    {
      "name": "needs_chunking",
      "qualified_name": "src/semantic/chunker.rs::needs_chunking",
      "file": "src/semantic/chunker.rs",
      "line": 788,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn needs_chunking(code: &str, max_tokens: usize) -> bool",
      "docstring": "",
      "calls": [
        "count_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:2",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "pub fn needs_chunking(code: &str, max_tokens: usize) -> bool {\n    count_tokens(code) > max_tokens\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 28
    },
    {
      "name": "test_count_tokens_empty",
      "qualified_name": "src/semantic/chunker.rs::test_count_tokens_empty",
      "file": "src/semantic/chunker.rs",
      "line": 801,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_count_tokens_empty()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_count_tokens_empty() {\n        assert_eq!(count_tokens(\"\"), 0);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 20
    },
    {
      "name": "test_count_tokens_simple",
      "qualified_name": "src/semantic/chunker.rs::test_count_tokens_simple",
      "file": "src/semantic/chunker.rs",
      "line": 806,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_count_tokens_simple()",
      "docstring": "",
      "calls": [
        "count_tokens",
        "count_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:2",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_count_tokens_simple() {\n        // \"hello world\" should be around 2-3 tokens\n        let count = count_tokens(\"hello world\");\n        assert!(count > 0);\n        assert!(count < 10);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 52
    },
    {
      "name": "test_count_tokens_code",
      "qualified_name": "src/semantic/chunker.rs::test_count_tokens_code",
      "file": "src/semantic/chunker.rs",
      "line": 814,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_count_tokens_code()",
      "docstring": "",
      "calls": [
        "count_tokens",
        "count_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_count_tokens_code() {\n        let code = \"def hello():\\n    print('world')\\n\";\n        let count = count_tokens(code);\n        assert!(count > 0);\n        // Should be reasonable for this small snippet\n        assert!(count < 50);\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "logging",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 63
    },
    {
      "name": "test_truncate_to_tokens_empty",
      "qualified_name": "src/semantic/chunker.rs::test_truncate_to_tokens_empty",
      "file": "src/semantic/chunker.rs",
      "line": 823,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_truncate_to_tokens_empty()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_truncate_to_tokens_empty() {\n        assert_eq!(truncate_to_tokens(\"\", 100), \"\");\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 26
    },
    {
      "name": "test_truncate_to_tokens_fits",
      "qualified_name": "src/semantic/chunker.rs::test_truncate_to_tokens_fits",
      "file": "src/semantic/chunker.rs",
      "line": 828,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_truncate_to_tokens_fits()",
      "docstring": "",
      "calls": [
        "truncate_to_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_truncate_to_tokens_fits() {\n        let text = \"hello world\";\n        let result = truncate_to_tokens(text, 100);\n        assert_eq!(result, text);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 43
    },
    {
      "name": "test_truncate_to_tokens_truncates",
      "qualified_name": "src/semantic/chunker.rs::test_truncate_to_tokens_truncates",
      "file": "src/semantic/chunker.rs",
      "line": 835,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_truncate_to_tokens_truncates()",
      "docstring": "",
      "calls": [
        "truncate_to_tokens"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:4",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_truncate_to_tokens_truncates() {\n        let text = \"hello world this is a longer text that should be truncated\";\n        let result = truncate_to_tokens(text, 3);\n        assert!(result.len() < text.len());\n        assert!(!result.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 61
    },
    {
      "name": "test_chunk_empty",
      "qualified_name": "src/semantic/chunker.rs::test_chunk_empty",
      "file": "src/semantic/chunker.rs",
      "line": 843,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_empty()",
      "docstring": "",
      "calls": [
        "chunk_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:1",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_chunk_empty() {\n        let chunks = chunk_code(\"\", 100);\n        assert!(chunks.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 28
    },
    {
      "name": "test_chunk_fits_single",
      "qualified_name": "src/semantic/chunker.rs::test_chunk_fits_single",
      "file": "src/semantic/chunker.rs",
      "line": 849,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_fits_single()",
      "docstring": "",
      "calls": [
        "chunk_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:6",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_chunk_fits_single() {\n        let code = \"def hello():\\n    pass\\n\";\n        let chunks = chunk_code(code, 1000);\n        assert_eq!(chunks.len(), 1);\n        assert_eq!(chunks[0].content, code);\n        assert_eq!(chunks[0].start_line, 1);\n        assert!(chunks[0].is_standalone());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 86
    },
    {
      "name": "test_chunk_splits_at_functions",
      "qualified_name": "src/semantic/chunker.rs::test_chunk_splits_at_functions",
      "file": "src/semantic/chunker.rs",
      "line": 859,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_splits_at_functions()",
      "docstring": "",
      "calls": [
        "chunk_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:9, def-use chains:3",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_chunk_splits_at_functions() {\n        let code = r#\"def func1():\n    \"\"\"First function.\"\"\"\n    pass\n\ndef func2():\n    \"\"\"Second function.\"\"\"\n    pass\n\ndef func3():\n    \"\"\"Third function.\"\"\"\n    pass\n\"#;\n        // Use a small token limit to force splitting\n        let chunks = chunk_code(code, 20);\n        assert!(chunks.len() > 1);\n\n        // Each chunk should be reasonably close to the limit\n        // With small limits (20 tokens), exact splitting is difficult as\n        // we prioritize semantic boundaries over strict limits\n        for chunk in &chunks {\n            // Allow 2x tolerance for boundary-aware splitting with small limits\n            assert!(\n                chunk.token_count <= 50,\n                \"Chunk {} has {} tokens (expected <= 50)\",\n                chunk.chunk_index,\n                chunk.token_count\n            );\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "auth",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 188
    },
    {
      "name": "test_chunk_preserves_content",
      "qualified_name": "src/semantic/chunker.rs::test_chunk_preserves_content",
      "file": "src/semantic/chunker.rs",
      "line": 891,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_preserves_content()",
      "docstring": "",
      "calls": [
        "chunk_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:10, def-use chains:5",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_chunk_preserves_content() {\n        let code = \"line1\\nline2\\nline3\\nline4\\nline5\\n\";\n        let chunks = chunk_code(code, 5);\n\n        // All content should be covered (with possible overlap)\n        let all_lines: std::collections::HashSet<_> = code.lines().collect();\n        let chunked_lines: std::collections::HashSet<_> =\n            chunks.iter().flat_map(|c| c.content.lines()).collect();\n\n        for line in &all_lines {\n            assert!(\n                chunked_lines.contains(line),\n                \"Line '{}' missing from chunks\",\n                line\n            );\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 135
    },
    {
      "name": "test_chunk_metadata",
      "qualified_name": "src/semantic/chunker.rs::test_chunk_metadata",
      "file": "src/semantic/chunker.rs",
      "line": 910,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_metadata()",
      "docstring": "",
      "calls": [
        "chunk_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:10, def-use chains:3",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_chunk_metadata() {\n        let code = \"a\\nb\\nc\\nd\\ne\\nf\\ng\\nh\\n\";\n        let chunks = chunk_code(code, 3);\n\n        for (i, chunk) in chunks.iter().enumerate() {\n            assert_eq!(chunk.chunk_index, i);\n            assert_eq!(chunk.chunk_total, chunks.len());\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 79
    },
    {
      "name": "test_get_indent_depth",
      "qualified_name": "src/semantic/chunker.rs::test_get_indent_depth",
      "file": "src/semantic/chunker.rs",
      "line": 921,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_get_indent_depth()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_get_indent_depth() {\n        assert_eq!(get_indent_depth(\"\"), 0);\n        assert_eq!(get_indent_depth(\"    code\"), 1);\n        assert_eq!(get_indent_depth(\"        code\"), 2);\n        assert_eq!(get_indent_depth(\"\\tcode\"), 1);\n        assert_eq!(get_indent_depth(\"\\t\\tcode\"), 2);\n        assert_eq!(get_indent_depth(\"  \\tcode\"), 1); // 2 spaces + 4 (tab) = 6 / 4 = 1\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 114
    },
    {
      "name": "test_boundary_detection",
      "qualified_name": "src/semantic/chunker.rs::test_boundary_detection",
      "file": "src/semantic/chunker.rs",
      "line": 931,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_boundary_detection()",
      "docstring": "",
      "calls": [
        "detect_boundaries",
        "build_line_offsets"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:9",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_boundary_detection() {\n        let code = \"def func():\\n    pass\\n\\nclass MyClass:\\n    pass\\n\";\n        let lines: Vec<&str> = code.lines().collect();\n        let offsets = build_line_offsets(&lines, code);\n        let boundaries = detect_boundaries(&lines, &offsets);\n\n        // Should detect function start, blank line, and class start\n        let kinds: Vec<_> = boundaries.iter().map(|b| b.kind).collect();\n        assert!(kinds.contains(&BoundaryKind::FunctionStart));\n        assert!(kinds.contains(&BoundaryKind::BlankLine));\n        assert!(kinds.contains(&BoundaryKind::ClassStart));\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 145
    },
    {
      "name": "test_needs_chunking",
      "qualified_name": "src/semantic/chunker.rs::test_needs_chunking",
      "file": "src/semantic/chunker.rs",
      "line": 945,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_needs_chunking()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:0",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_needs_chunking() {\n        assert!(!needs_chunking(\"short\", 100));\n        assert!(needs_chunking(&\"x\".repeat(1000), 10));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 47
    },
    {
      "name": "test_chunk_with_overlap",
      "qualified_name": "src/semantic/chunker.rs::test_chunk_with_overlap",
      "file": "src/semantic/chunker.rs",
      "line": 951,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_with_overlap()",
      "docstring": "",
      "calls": [
        "chunk_code_with_overlap"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:8, def-use chains:7",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_chunk_with_overlap() {\n        let code = \"line1\\nline2\\nline3\\nline4\\nline5\\n\";\n        let chunks = chunk_code_with_overlap(code, 5, 2);\n\n        if chunks.len() > 1 {\n            // Check that chunks have reasonable overlap\n            // (exact overlap depends on tokenization)\n            for i in 1..chunks.len() {\n                let prev_end = chunks[i - 1].end_line;\n                let curr_start = chunks[i].start_line;\n                // Overlap means current start should be <= previous end\n                assert!(\n                    curr_start <= prev_end + 1,\n                    \"No overlap between chunks {} and {}\",\n                    i - 1,\n                    i\n                );\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 162
    },
    {
      "name": "test_chunk_line_numbers",
      "qualified_name": "src/semantic/chunker.rs::test_chunk_line_numbers",
      "file": "src/semantic/chunker.rs",
      "line": 973,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_line_numbers()",
      "docstring": "",
      "calls": [
        "chunk_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:4",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_chunk_line_numbers() {\n        let code = \"line1\\nline2\\nline3\\n\";\n        let chunks = chunk_code(code, 1000);\n\n        assert_eq!(chunks.len(), 1);\n        assert_eq!(chunks[0].start_line, 1);\n        assert_eq!(chunks[0].end_line, 3);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 77
    },
    {
      "name": "test_chunk_handles_long_single_line",
      "qualified_name": "src/semantic/chunker.rs::test_chunk_handles_long_single_line",
      "file": "src/semantic/chunker.rs",
      "line": 983,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_handles_long_single_line()",
      "docstring": "",
      "calls": [
        "chunk_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:5",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_chunk_handles_long_single_line() {\n        // A very long line that exceeds token limit\n        let long_line = \"x\".repeat(10000);\n        let chunks = chunk_code(&long_line, 100);\n\n        assert!(!chunks.is_empty());\n        // The first chunk should be truncated\n        assert!(chunks[0].token_count <= 100 || chunks[0].content.len() < long_line.len());\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "auth"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 98
    },
    {
      "name": "test_estimate_tokens",
      "qualified_name": "src/semantic/chunker.rs::test_estimate_tokens",
      "file": "src/semantic/chunker.rs",
      "line": 994,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_estimate_tokens()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_estimate_tokens() {\n        // Estimation should be roughly 1 token per 4 chars\n        assert_eq!(estimate_tokens(\"12345678\"), 2); // 8 chars / 4 = 2\n        assert_eq!(estimate_tokens(\"\"), 0);\n        assert_eq!(estimate_tokens(\"abc\"), 1); // (3 + 3) / 4 = 1\n    }\n",
      "semantic_tags": [
        "test",
        "auth"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 90
    },
    {
      "name": "test_chunk_python_with_docstrings",
      "qualified_name": "src/semantic/chunker.rs::test_chunk_python_with_docstrings",
      "file": "src/semantic/chunker.rs",
      "line": 1002,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_python_with_docstrings()",
      "docstring": "",
      "calls": [
        "chunk_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:4",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_chunk_python_with_docstrings() {\n        let code = r#\"def process_data(items):\n    \"\"\"Process a list of items.\n\n    This function takes items and processes them\n    in a very important way.\n\n    Args:\n        items: List of items to process\n\n    Returns:\n        Processed items\n    \"\"\"\n    result = []\n    for item in items:\n        result.append(transform(item))\n    return result\n\"#;\n        // With reasonable limit, docstring should stay with function\n        let chunks = chunk_code(code, 100);\n        assert!(!chunks.is_empty());\n\n        // First chunk should contain the docstring\n        let first_chunk = &chunks[0];\n        assert!(\n            first_chunk.content.contains(\"Process a list\"),\n            \"Docstring should be in first chunk\"\n        );\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 170
    },
    {
      "name": "test_chunk_rust_code",
      "qualified_name": "src/semantic/chunker.rs::test_chunk_rust_code",
      "file": "src/semantic/chunker.rs",
      "line": 1033,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_rust_code()",
      "docstring": "",
      "calls": [
        "chunk_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_chunk_rust_code() {\n        let code = r#\"fn main() {\n    println!(\"Hello\");\n}\n\npub fn helper() {\n    // Helper function\n}\n\nimpl MyStruct {\n    fn method(&self) {\n        // Method body\n    }\n}\n\"#;\n        let chunks = chunk_code(code, 30);\n\n        // Should have detected function and impl boundaries\n        assert!(!chunks.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 89
    },
    {
      "name": "test_chunk_typescript_code",
      "qualified_name": "src/semantic/chunker.rs::test_chunk_typescript_code",
      "file": "src/semantic/chunker.rs",
      "line": 1055,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_chunk_typescript_code()",
      "docstring": "",
      "calls": [
        "chunk_code"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "    fn test_chunk_typescript_code() {\n        let code = r#\"function processData(data: string[]): void {\n    console.log(data);\n}\n\nasync function fetchData(): Promise<string> {\n    return \"data\";\n}\n\nclass DataProcessor {\n    private data: string[];\n\n    constructor() {\n        this.data = [];\n    }\n}\n\"#;\n        let chunks = chunk_code(code, 40);\n        assert!(!chunks.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "async_ops",
        "validation",
        "logging"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 89
    },
    {
      "name": "Chunk",
      "qualified_name": "src/semantic/chunker.rs::Chunk",
      "file": "src/semantic/chunker.rs",
      "line": 124,
      "language": "rust",
      "unit_type": "class",
      "signature": "class Chunk",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "pub struct Chunk {\n    /// Unique identifier for this chunk (e.g., \"file.py::func_name#chunk1\")\n    pub chunk_id: String,\n\n    /// The actual code content of this chunk\n    pub content: String,\n\n    /// Number of tokens in this chunk\n    pub token_count: usize,\n\n    /// Starting line number (1-indexed) in the original code\n    pub start_line: usize,\n\n    /// Ending line number (1-indexed) in the original code\n    pub end_line: usize,\n\n    /// Starting character offset in the original code\n    pub start_char: usize,\n\n    /// Ending character offset in the original code\n    pub end_char: usize,\n\n    /// Index of this chunk (0-indexed)\n    pub chunk_index: usize,\n\n    /// Total number of chunks for the parent unit\n    pub chunk_total: usize,\n\n    /// Reference to the parent unit name (for reconstruction)\n    pub parent_ref: Option<String>,\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 199
    },
    {
      "name": "Boundary",
      "qualified_name": "src/semantic/chunker.rs::Boundary",
      "file": "src/semantic/chunker.rs",
      "line": 231,
      "language": "rust",
      "unit_type": "class",
      "signature": "class Boundary",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "struct Boundary {\n    /// Line index (0-indexed)\n    line_idx: usize,\n    /// Character offset (preserved for potential future use in precise slicing)\n    #[allow(dead_code)]\n    char_offset: usize,\n    /// Type of boundary\n    kind: BoundaryKind,\n}\n",
      "semantic_tags": [
        "async_ops",
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 58
    },
    {
      "name": "BoundaryPatterns",
      "qualified_name": "src/semantic/chunker.rs::BoundaryPatterns",
      "file": "src/semantic/chunker.rs",
      "line": 244,
      "language": "rust",
      "unit_type": "class",
      "signature": "class BoundaryPatterns",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "once_cell::sync, regex, std::sync, tiktoken_rs, super::types",
      "code_preview": "struct BoundaryPatterns {\n    /// Matches function/method definitions across languages\n    function_start: Regex,\n    /// Matches class/struct/interface definitions\n    class_start: Regex,\n    /// Matches comment lines\n    comment: Regex,\n    /// Matches blank or whitespace-only lines\n    blank: Regex,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 60
    },
    {
      "name": "(AstExtractor) extract_file",
      "qualified_name": "src/ast/extractor.rs::(AstExtractor) extract_file",
      "file": "src/ast/extractor.rs",
      "line": 39,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (AstExtractor) extract_file(path: &Path) -> Result<ModuleInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    pub fn extract_file(path: &Path) -> Result<ModuleInfo> {\n        let registry = LanguageRegistry::global();\n        let lang = registry.detect_language(path).ok_or_else(|| {\n            TldrError::UnsupportedLanguage(\n                path.extension()\n                    .and_then(|e| e.to_str())\n                    .unwrap_or(\"unknown\")\n                    .to_string(),\n            )\n        })?;\n\n        let source = std::fs::read(path)?;\n        let mut parser = lang.parser()?;\n        let tree = parser\n            .parse(&source, None)\n            .ok_or_else(|| TldrError::Parse {\n                file: path.display().to_string(),\n                message: \"Failed to parse file\".to_string(),\n            })?;\n\n        Self::extract_module(&tree, &source, lang, path)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation"
      ],
      "complexity": {
        "depth": 5,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 166
    },
    {
      "name": "(AstExtractor) extract_module",
      "qualified_name": "src/ast/extractor.rs::(AstExtractor) extract_module",
      "file": "src/ast/extractor.rs",
      "line": 66,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (AstExtractor) extract_module(tree: &Tree, source: &[u8], lang: &dyn Language, path: &Path) -> Result<ModuleInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn extract_module(\n        tree: &Tree,\n        source: &[u8],\n        lang: &dyn Language,\n        path: &Path,\n    ) -> Result<ModuleInfo> {\n        let functions = Self::extract_functions(tree, source, lang)?;\n        let classes = Self::extract_classes(tree, source, lang)?;\n        let imports = lang.extract_imports(tree, source);\n\n        Ok(ModuleInfo {\n            path: path.display().to_string(),\n            language: lang.name().to_string(),\n            functions,\n            classes,\n            imports,\n        })\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 116
    },
    {
      "name": "(AstExtractor) extract_functions",
      "qualified_name": "src/ast/extractor.rs::(AstExtractor) extract_functions",
      "file": "src/ast/extractor.rs",
      "line": 98,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (AstExtractor) extract_functions(tree: &Tree, source: &[u8], lang: &dyn Language) -> Result<Vec<FunctionInfo>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn extract_functions(\n        tree: &Tree,\n        source: &[u8],\n        lang: &dyn Language,\n    ) -> Result<Vec<FunctionInfo>> {\n        let query_str = lang.function_query();\n        let ts_lang = tree.language();\n\n        let query = Query::new(&ts_lang, query_str).map_err(|e| {\n            TldrError::TreeSitter(format!(\"Invalid function query for {}: {}\", lang.name(), e))\n        })?;\n\n        let mut cursor = QueryCursor::new();\n        let mut matches = cursor.matches(&query, tree.root_node(), source);\n\n        let mut functions = Vec::new();\n        let mut seen_ranges: Vec<(usize, usize)> = Vec::new();\n\n        // Find the capture index for @function (the outer node)\n        let function_capture_idx = query.capture_index_for_name(\"function\");\n\n        // Use streaming iterator pattern (tree-sitter 0.24+)\n        use streaming_iterator::StreamingIterator;\n        while let Some(match_) = matches.next() {\n            // Get the function node from the match\n            let node = if let Some(idx) = function_capture_idx {\n                match_\n                    .captures\n                    .iter()\n                    .find(|c| c.index == idx)\n                    .map(|c| c.node)\n            } else {\n                // Fallback: use the first capture's node if @function not found\n                match_.captures.first().map(|c| c.node)\n            };\n\n            if let Some(node) = node {\n                // Skip if we've already processed this range or a containing range\n                // (handles decorated functions where both the decorator and inner function match)\n                let start = node.start_byte();\n                let end = node.end_byte();\n\n                // Check if this range overlaps with any existing range\n                let overlaps = seen_ranges.iter().any(|(s, e)| {\n                    // Check for overlap: either this range contains an existing one,\n                    // or an existing one contains this range\n                    (start <= *s && end >= *e) || (*s <= start && *e >= end)\n                });\n\n                if overlaps {\n                    continue;\n                }\n                seen_ranges.push((start, end));\n\n                if let Some(func_info) = lang.extract_function(node, source) {\n                    functions.push(func_info);\n                }\n            }\n        }\n\n        // Sort by line number for consistent output\n        functions.sort_by_key(|f| f.line_number);\n        Ok(functions)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 10,
        "loops": 5
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 510
    },
    {
      "name": "(AstExtractor) extract_classes",
      "qualified_name": "src/ast/extractor.rs::(AstExtractor) extract_classes",
      "file": "src/ast/extractor.rs",
      "line": 176,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (AstExtractor) extract_classes(tree: &Tree, source: &[u8], lang: &dyn Language) -> Result<Vec<ClassInfo>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn extract_classes(tree: &Tree, source: &[u8], lang: &dyn Language) -> Result<Vec<ClassInfo>> {\n        let query_str = lang.class_query();\n        let ts_lang = tree.language();\n\n        let query = Query::new(&ts_lang, query_str).map_err(|e| {\n            TldrError::TreeSitter(format!(\"Invalid class query for {}: {}\", lang.name(), e))\n        })?;\n\n        let mut cursor = QueryCursor::new();\n        let mut matches = cursor.matches(&query, tree.root_node(), source);\n\n        let mut classes = Vec::new();\n        let mut seen_ranges: Vec<(usize, usize)> = Vec::new();\n\n        // Find the capture index for @class (the outer node)\n        let class_capture_idx = query.capture_index_for_name(\"class\");\n\n        // Use streaming iterator pattern (tree-sitter 0.24+)\n        use streaming_iterator::StreamingIterator;\n        while let Some(match_) = matches.next() {\n            // Get the class node from the match\n            let node = if let Some(idx) = class_capture_idx {\n                match_\n                    .captures\n                    .iter()\n                    .find(|c| c.index == idx)\n                    .map(|c| c.node)\n            } else {\n                // Fallback: use the first capture's node if @class not found\n                match_.captures.first().map(|c| c.node)\n            };\n\n            if let Some(node) = node {\n                // Skip if we've already processed this range or a containing range\n                // (handles decorated classes where both the decorator and inner class match)\n                let start = node.start_byte();\n                let end = node.end_byte();\n\n                // Check if this range overlaps with any existing range\n                let overlaps = seen_ranges.iter().any(|(s, e)| {\n                    // Check for overlap: either this range contains an existing one,\n                    // or an existing one contains this range\n                    (start <= *s && end >= *e) || (*s <= start && *e >= end)\n                });\n\n                if overlaps {\n                    continue;\n                }\n                seen_ranges.push((start, end));\n\n                if let Some(class_info) = lang.extract_class(node, source) {\n                    classes.push(class_info);\n                }\n            }\n        }\n\n        // Sort by line number for consistent output\n        classes.sort_by_key(|c| c.line_number);\n        Ok(classes)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 10,
        "loops": 5
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 502
    },
    {
      "name": "(AstExtractor) extract_from_source",
      "qualified_name": "src/ast/extractor.rs::(AstExtractor) extract_from_source",
      "file": "src/ast/extractor.rs",
      "line": 248,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (AstExtractor) extract_from_source(source: &str, language: &str) -> Result<ModuleInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    pub fn extract_from_source(source: &str, language: &str) -> Result<ModuleInfo> {\n        let registry = LanguageRegistry::global();\n        let lang = registry\n            .get_by_name(language)\n            .ok_or_else(|| TldrError::UnsupportedLanguage(language.to_string()))?;\n\n        let source_bytes = source.as_bytes();\n        let mut parser = lang.parser()?;\n        let tree = parser\n            .parse(source_bytes, None)\n            .ok_or_else(|| TldrError::Parse {\n                file: \"<string>\".to_string(),\n                message: \"Failed to parse source\".to_string(),\n            })?;\n\n        let functions = Self::extract_functions(&tree, source_bytes, lang)?;\n        let classes = Self::extract_classes(&tree, source_bytes, lang)?;\n        let imports = lang.extract_imports(&tree, source_bytes);\n\n        Ok(ModuleInfo {\n            path: \"<string>\".to_string(),\n            language: lang.name().to_string(),\n            functions,\n            classes,\n            imports,\n        })\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 211
    },
    {
      "name": "(AstExtractor) find_function",
      "qualified_name": "src/ast/extractor.rs::(AstExtractor) find_function",
      "file": "src/ast/extractor.rs",
      "line": 284,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (AstExtractor) find_function(path: &Path, function_name: &str) -> Result<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    pub fn find_function(path: &Path, function_name: &str) -> Result<FunctionInfo> {\n        let module_info = Self::extract_file(path)?;\n\n        // Search in top-level functions\n        if let Some(func) = module_info\n            .functions\n            .iter()\n            .find(|f| f.name == function_name)\n        {\n            return Ok(func.clone());\n        }\n\n        // Search in class methods\n        for class in &module_info.classes {\n            if let Some(method) = class.methods.iter().find(|m| m.name == function_name) {\n                return Ok(method.clone());\n            }\n        }\n\n        Err(TldrError::FunctionNotFound(function_name.to_string()))\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 145
    },
    {
      "name": "(AstExtractor) find_class",
      "qualified_name": "src/ast/extractor.rs::(AstExtractor) find_class",
      "file": "src/ast/extractor.rs",
      "line": 314,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (AstExtractor) find_class(path: &Path, class_name: &str) -> Result<ClassInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    pub fn find_class(path: &Path, class_name: &str) -> Result<ClassInfo> {\n        let module_info = Self::extract_file(path)?;\n\n        module_info\n            .classes\n            .into_iter()\n            .find(|c| c.name == class_name)\n            .ok_or_else(|| TldrError::FunctionNotFound(format!(\"Class '{}' not found\", class_name)))\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 82
    },
    {
      "name": "extract_imports",
      "qualified_name": "src/ast/extractor.rs::extract_imports",
      "file": "src/ast/extractor.rs",
      "line": 328,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_imports(path: &Path) -> Result<Vec<ImportInfo>>",
      "docstring": "",
      "calls": [
        "new",
        "extract_include",
        "extract_import",
        "extract_imports",
        "extract_single_import"
      ],
      "called_by": [
        "test_extract_imports",
        "test_extract_imports",
        "test_extract_imports",
        "extract_imports",
        "test_extract_python_imports"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:17, def-use chains:11",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "pub fn extract_imports(path: &Path) -> Result<Vec<ImportInfo>> {\n    let registry = LanguageRegistry::global();\n    let lang = registry.detect_language(path).ok_or_else(|| {\n        TldrError::UnsupportedLanguage(\n            path.extension()\n                .and_then(|e| e.to_str())\n                .unwrap_or(\"unknown\")\n                .to_string(),\n        )\n    })?;\n\n    let source = std::fs::read(path)?;\n    let mut parser = lang.parser()?;\n    let tree = parser\n        .parse(&source, None)\n        .ok_or_else(|| TldrError::Parse {\n            file: path.display().to_string(),\n            message: \"Failed to parse file\".to_string(),\n        })?;\n\n    Ok(lang.extract_imports(&tree, &source))\n}\n",
      "semantic_tags": [
        "crud",
        "validation"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 163
    },
    {
      "name": "create_temp_file",
      "qualified_name": "src/ast/extractor.rs::create_temp_file",
      "file": "src/ast/extractor.rs",
      "line": 357,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_temp_file(content: &str, extension: &str) -> NamedTempFile",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_extract_python_functions",
        "test_decorated_python_class",
        "test_lookup_pattern",
        "test_extract_python_imports",
        "test_extract_python_classes"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:4",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn create_temp_file(content: &str, extension: &str) -> NamedTempFile {\n        let mut file = tempfile::Builder::new()\n            .suffix(extension)\n            .tempfile()\n            .unwrap();\n        file.write_all(content.as_bytes()).unwrap();\n        file\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 60
    },
    {
      "name": "test_extract_python_functions",
      "qualified_name": "src/ast/extractor.rs::test_extract_python_functions",
      "file": "src/ast/extractor.rs",
      "line": 367,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_python_functions() -> str:\n    \"\"\"Say hello to someone.\"\"\"\n    return f\"Hello,",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "extract_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:30, def-use chains:16",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn test_extract_python_functions() {\n        let source = r#\"\ndef hello(name: str) -> str:\n    \"\"\"Say hello to someone.\"\"\"\n    return f\"Hello, {name}!\"\n\nasync def fetch_data(url: str) -> bytes:\n    \"\"\"Fetch data from URL.\"\"\"\n    pass\n\nclass MyClass:\n    def method(self, x: int) -> int:\n        return x * 2\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let result = AstExtractor::extract_file(file.path()).unwrap();\n\n        assert_eq!(result.language, \"python\");\n        assert!(result.functions.len() >= 2);\n\n        // Find hello function\n        let hello = result.functions.iter().find(|f| f.name == \"hello\");\n        assert!(hello.is_some());\n        let hello = hello.unwrap();\n        assert_eq!(hello.return_type, Some(\"str\".to_string()));\n        assert!(hello\n            .docstring\n            .as_ref()\n            .map_or(false, |d| d.contains(\"Say hello\")));\n        assert!(!hello.is_async);\n\n        // Find async function\n        let fetch = result.functions.iter().find(|f| f.name == \"fetch_data\");\n        assert!(fetch.is_some());\n        assert!(fetch.unwrap().is_async);\n\n        // Check class was extracted\n        assert_eq!(result.classes.len(), 1);\n        assert_eq!(result.classes[0].name, \"MyClass\");\n        assert!(!result.classes[0].methods.is_empty());\n    }\n",
      "semantic_tags": [
        "crud",
        "async_ops",
        "validation",
        "test"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 313
    },
    {
      "name": "test_extract_python_classes",
      "qualified_name": "src/ast/extractor.rs::test_extract_python_classes",
      "file": "src/ast/extractor.rs",
      "line": 410,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_python_classes() -> str:\n        pass\n\nclass Dog(Animal):\n    \"\"\"A dog.\"\"\"\n\n    def speak(self)",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "extract_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:22, def-use chains:8",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn test_extract_python_classes() {\n        let source = r#\"\nclass Animal:\n    \"\"\"Base class for animals.\"\"\"\n\n    def __init__(self, name: str):\n        self.name = name\n\n    def speak(self) -> str:\n        pass\n\nclass Dog(Animal):\n    \"\"\"A dog.\"\"\"\n\n    def speak(self) -> str:\n        return \"Woof!\"\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let result = AstExtractor::extract_file(file.path()).unwrap();\n\n        assert_eq!(result.classes.len(), 2);\n\n        let animal = result.classes.iter().find(|c| c.name == \"Animal\").unwrap();\n        assert!(animal\n            .docstring\n            .as_ref()\n            .map_or(false, |d| d.contains(\"Base class\")));\n        assert!(animal.methods.len() >= 2);\n\n        let dog = result.classes.iter().find(|c| c.name == \"Dog\").unwrap();\n        assert!(dog.bases.contains(&\"Animal\".to_string()));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 213
    },
    {
      "name": "test_extract_python_imports",
      "qualified_name": "src/ast/extractor.rs::test_extract_python_imports",
      "file": "src/ast/extractor.rs",
      "line": 444,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_python_imports()",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "extract_imports"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:20, def-use chains:13",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn test_extract_python_imports() {\n        let source = r#\"\nimport os\nimport sys as system\nfrom pathlib import Path\nfrom collections import defaultdict as dd\nfrom . import local\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let imports = extract_imports(file.path()).unwrap();\n\n        assert!(imports.len() >= 4);\n\n        // Check regular import\n        let os_import = imports.iter().find(|i| i.module == \"os\");\n        assert!(os_import.is_some());\n        assert!(!os_import.unwrap().is_from);\n\n        // Check aliased import\n        let sys_import = imports.iter().find(|i| i.module == \"sys\");\n        assert!(sys_import.is_some());\n        assert!(sys_import.unwrap().aliases.contains_key(\"sys\"));\n\n        // Check from import\n        let pathlib_import = imports.iter().find(|i| i.module == \"pathlib\");\n        assert!(pathlib_import.is_some());\n        assert!(pathlib_import.unwrap().is_from);\n        assert!(pathlib_import.unwrap().names.contains(&\"Path\".to_string()));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 230
    },
    {
      "name": "test_extract_typescript_functions",
      "qualified_name": "src/ast/extractor.rs::test_extract_typescript_functions",
      "file": "src/ast/extractor.rs",
      "line": 475,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_typescript_functions()",
      "docstring": "",
      "calls": [
        "extract_file",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:21, def-use chains:10",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn test_extract_typescript_functions() {\n        let source = r#\"\nfunction greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nasync function fetchData(url: string): Promise<Response> {\n    return fetch(url);\n}\n\nconst add = (a: number, b: number): number => a + b;\n\"#;\n        let file = create_temp_file(source, \".ts\");\n        let result = AstExtractor::extract_file(file.path()).unwrap();\n\n        assert_eq!(result.language, \"typescript\");\n        assert!(result.functions.len() >= 2);\n\n        let greet = result.functions.iter().find(|f| f.name == \"greet\");\n        assert!(greet.is_some());\n        assert_eq!(greet.unwrap().return_type, Some(\"string\".to_string()));\n\n        let fetch_data = result.functions.iter().find(|f| f.name == \"fetchData\");\n        assert!(fetch_data.is_some());\n        assert!(fetch_data.unwrap().is_async);\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "api_endpoint",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 203
    },
    {
      "name": "test_extract_typescript_classes",
      "qualified_name": "src/ast/extractor.rs::test_extract_typescript_classes",
      "file": "src/ast/extractor.rs",
      "line": 503,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_typescript_classes()",
      "docstring": "",
      "calls": [
        "extract_file",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:19, def-use chains:8",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn test_extract_typescript_classes() {\n        let source = r#\"\nclass Animal {\n    constructor(public name: string) {}\n\n    speak(): void {\n        console.log(this.name);\n    }\n}\n\nclass Dog extends Animal {\n    bark(): void {\n        console.log(\"Woof!\");\n    }\n}\n\"#;\n        let file = create_temp_file(source, \".ts\");\n        let result = AstExtractor::extract_file(file.path()).unwrap();\n\n        assert_eq!(result.classes.len(), 2);\n\n        let animal = result.classes.iter().find(|c| c.name == \"Animal\");\n        assert!(animal.is_some());\n\n        let dog = result.classes.iter().find(|c| c.name == \"Dog\");\n        assert!(dog.is_some());\n        assert!(dog.unwrap().bases.contains(&\"Animal\".to_string()));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "logging"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 167
    },
    {
      "name": "test_extract_from_source",
      "qualified_name": "src/ast/extractor.rs::test_extract_from_source",
      "file": "src/ast/extractor.rs",
      "line": 533,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_from_source() -> int:\n    return a + b\n\"#;\n        let result = AstExtractor::extract_from_source(source, \"python\").unwrap();\n\n        assert_eq!(result.language, \"python\");\n        assert_eq!(result.functions.len(), 1);\n        assert_eq!(result.functions[0].name, \"add\");\n    }",
      "docstring": "",
      "calls": [
        "extract_from_source",
        "extract_from_source",
        "extract_from_source"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:4",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn test_extract_from_source() {\n        let source = r#\"\ndef add(a: int, b: int) -> int:\n    return a + b\n\"#;\n        let result = AstExtractor::extract_from_source(source, \"python\").unwrap();\n\n        assert_eq!(result.language, \"python\");\n        assert_eq!(result.functions.len(), 1);\n        assert_eq!(result.functions[0].name, \"add\");\n    }\n",
      "semantic_tags": [
        "crud"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 90
    },
    {
      "name": "test_find_function",
      "qualified_name": "src/ast/extractor.rs::test_find_function",
      "file": "src/ast/extractor.rs",
      "line": 546,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_find_function() -> int:\n    return x * 2\n\ndef other_function():\n    pass\n\"#;\n        let file = create_temp_file(source, \".py\");\n\n        let func = AstExtractor::find_function(file.path(), \"target_function\");\n        assert!(func.is_ok());\n        assert_eq!(func.unwrap().name, \"target_function\");\n\n        let not_found = AstExtractor::find_function(file.path(), \"nonexistent\");\n        assert!(not_found.is_err());\n    }",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "find_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:4",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn test_find_function() {\n        let source = r#\"\ndef target_function(x: int) -> int:\n    return x * 2\n\ndef other_function():\n    pass\n\"#;\n        let file = create_temp_file(source, \".py\");\n\n        let func = AstExtractor::find_function(file.path(), \"target_function\");\n        assert!(func.is_ok());\n        assert_eq!(func.unwrap().name, \"target_function\");\n\n        let not_found = AstExtractor::find_function(file.path(), \"nonexistent\");\n        assert!(not_found.is_err());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 115
    },
    {
      "name": "test_find_class",
      "qualified_name": "src/ast/extractor.rs::test_find_class",
      "file": "src/ast/extractor.rs",
      "line": 565,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_find_class()",
      "docstring": "",
      "calls": [
        "find_class",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:6",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn test_find_class() {\n        let source = r#\"\nclass TargetClass:\n    pass\n\nclass OtherClass:\n    pass\n\"#;\n        let file = create_temp_file(source, \".py\");\n\n        let class = AstExtractor::find_class(file.path(), \"TargetClass\");\n        assert!(class.is_ok());\n        assert_eq!(class.unwrap().name, \"TargetClass\");\n\n        let not_found = AstExtractor::find_class(file.path(), \"NonexistentClass\");\n        assert!(not_found.is_err());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 106
    },
    {
      "name": "test_unsupported_language",
      "qualified_name": "src/ast/extractor.rs::test_unsupported_language",
      "file": "src/ast/extractor.rs",
      "line": 584,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_unsupported_language()",
      "docstring": "",
      "calls": [
        "extract_file",
        "create_temp_file",
        "extract_from_file",
        "create_temp_file",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:2",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn test_unsupported_language() {\n        let file = create_temp_file(\"some content\", \".xyz\");\n        let result = AstExtractor::extract_file(file.path());\n\n        assert!(matches!(result, Err(TldrError::UnsupportedLanguage(_))));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 52
    },
    {
      "name": "test_decorated_python_function",
      "qualified_name": "src/ast/extractor.rs::test_decorated_python_function",
      "file": "src/ast/extractor.rs",
      "line": 592,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_decorated_python_function() -> int:\n    return x * 2\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let result = AstExtractor::extract_file(file.path()).unwrap();\n\n        assert_eq!(result.functions.len(), 1);\n        let func = &result.functions[0];\n        assert_eq!(func.name, \"cached_function\");\n        assert!(!func.decorators.is_empty());\n    }",
      "docstring": "",
      "calls": [
        "extract_file",
        "create_temp_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:4",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn test_decorated_python_function() {\n        let source = r#\"\n@staticmethod\n@cache\ndef cached_function(x: int) -> int:\n    return x * 2\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let result = AstExtractor::extract_file(file.path()).unwrap();\n\n        assert_eq!(result.functions.len(), 1);\n        let func = &result.functions[0];\n        assert_eq!(func.name, \"cached_function\");\n        assert!(!func.decorators.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "cache"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 110
    },
    {
      "name": "test_decorated_python_class",
      "qualified_name": "src/ast/extractor.rs::test_decorated_python_class",
      "file": "src/ast/extractor.rs",
      "line": 609,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_decorated_python_class()",
      "docstring": "",
      "calls": [
        "create_temp_file",
        "extract_file"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:6",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "    fn test_decorated_python_class() {\n        let source = r#\"\n@dataclass\nclass Point:\n    x: float\n    y: float\n\"#;\n        let file = create_temp_file(source, \".py\");\n        let result = AstExtractor::extract_file(file.path()).unwrap();\n\n        assert_eq!(result.classes.len(), 1);\n        let class = &result.classes[0];\n        assert_eq!(class.name, \"Point\");\n        assert!(!class.decorators.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 103
    },
    {
      "name": "AstExtractor",
      "qualified_name": "src/ast/extractor.rs::AstExtractor",
      "file": "src/ast/extractor.rs",
      "line": 18,
      "language": "rust",
      "unit_type": "class",
      "signature": "class AstExtractor",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::path, tree_sitter, crate::ast::types, crate::error, crate::lang",
      "code_preview": "pub struct AstExtractor;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 0,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 5
    },
    {
      "name": "(ImpactConfig) new",
      "qualified_name": "src/callgraph/impact.rs::(ImpactConfig) new",
      "file": "src/callgraph/impact.rs",
      "line": 45,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ImpactConfig) new() -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    pub fn new() -> Self {\n        Self::default()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 15
    },
    {
      "name": "(ImpactConfig) with_depth",
      "qualified_name": "src/callgraph/impact.rs::(ImpactConfig) with_depth",
      "file": "src/callgraph/impact.rs",
      "line": 50,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ImpactConfig) with_depth(mut self, depth: usize) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    pub fn with_depth(mut self, depth: usize) -> Self {\n        self.max_depth = depth;\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 27
    },
    {
      "name": "(ImpactConfig) with_language",
      "qualified_name": "src/callgraph/impact.rs::(ImpactConfig) with_language",
      "file": "src/callgraph/impact.rs",
      "line": 56,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ImpactConfig) with_language(mut self, lang: &str) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    pub fn with_language(mut self, lang: &str) -> Self {\n        self.language = Some(lang.to_string());\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 30
    },
    {
      "name": "(ImpactConfig) with_includes",
      "qualified_name": "src/callgraph/impact.rs::(ImpactConfig) with_includes",
      "file": "src/callgraph/impact.rs",
      "line": 62,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ImpactConfig) with_includes(mut self, patterns: &[&str]) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    pub fn with_includes(mut self, patterns: &[&str]) -> Self {\n        self.include_patterns = patterns.iter().map(|s| (*s).to_string()).collect();\n        self\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 43
    },
    {
      "name": "(ImpactConfig) with_excludes",
      "qualified_name": "src/callgraph/impact.rs::(ImpactConfig) with_excludes",
      "file": "src/callgraph/impact.rs",
      "line": 68,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ImpactConfig) with_excludes(mut self, patterns: &[&str]) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    pub fn with_excludes(mut self, patterns: &[&str]) -> Self {\n        self.exclude_patterns = patterns.iter().map(|s| (*s).to_string()).collect();\n        self\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 43
    },
    {
      "name": "(ImpactConfig) exclude_tests",
      "qualified_name": "src/callgraph/impact.rs::(ImpactConfig) exclude_tests",
      "file": "src/callgraph/impact.rs",
      "line": 74,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ImpactConfig) exclude_tests(mut self) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    pub fn exclude_tests(mut self) -> Self {\n        self.exclude_tests = true;\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 23
    },
    {
      "name": "(ImpactConfig) with_call_sites",
      "qualified_name": "src/callgraph/impact.rs::(ImpactConfig) with_call_sites",
      "file": "src/callgraph/impact.rs",
      "line": 80,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ImpactConfig) with_call_sites(mut self) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    pub fn with_call_sites(mut self) -> Self {\n        self.include_call_sites = true;\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 25
    },
    {
      "name": "(ImpactResult) to_llm_context",
      "qualified_name": "src/callgraph/impact.rs::(ImpactResult) to_llm_context",
      "file": "src/callgraph/impact.rs",
      "line": 110,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ImpactResult) to_llm_context(&self) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    pub fn to_llm_context(&self) -> String {\n        let mut output = String::with_capacity(4096);\n\n        // Header\n        output.push_str(&format!(\"# Impact Analysis: {}\\n\\n\", self.target));\n\n        if let Some(ref file) = self.target_file {\n            output.push_str(&format!(\"Target file: {}\\n\", file));\n        }\n\n        output.push_str(&format!(\n            \"Total affected: {} functions at {} depth levels\\n\\n\",\n            self.total_affected,\n            self.by_distance.len()\n        ));\n\n        // Group callers by distance\n        let mut by_distance: HashMap<usize, Vec<&CallerInfo>> = HashMap::new();\n        for caller in &self.callers {\n            by_distance.entry(caller.distance).or_default().push(caller);\n        }\n\n        // Output by distance level\n        let mut distances: Vec<_> = by_distance.keys().copied().collect();\n        distances.sort();\n\n        for distance in distances {\n            let callers = &by_distance[&distance];\n            output.push_str(&format!(\n                \"## Distance {} ({} functions)\\n\\n\",\n                distance,\n                callers.len()\n            ));\n\n            // Group by file within distance level\n            let mut by_file: HashMap<&str, Vec<&CallerInfo>> = HashMap::new();\n            for caller in callers {\n                by_file.entry(&caller.file).or_default().push(caller);\n            }\n\n            let mut files: Vec<_> = by_file.keys().copied().collect();\n            files.sort();\n\n            for file in files {\n                let file_callers = &by_file[file];\n                output.push_str(&format!(\"### {}\\n\", file));\n\n                for caller in file_callers {\n                    output.push_str(&format!(\"- {}\", caller.name));\n                    if !caller.call_sites.is_empty() {\n                        let sites: Vec<_> =\n                            caller.call_sites.iter().map(|s| s.to_string()).collect();\n                        output.push_str(&format!(\" (lines: {})\", sites.join(\", \")));\n                    }\n                    output.push('\\n');\n                }\n                output.push('\\n');\n            }\n        }\n\n        // Summary section\n        output.push_str(\"## Summary by File\\n\\n\");\n        let mut file_counts: Vec<_> = self.by_file.iter().collect();\n        file_counts.sort_by(|a, b| b.1.cmp(a.1)); // Sort by count descending\n\n        for (file, count) in file_counts.iter().take(10) {\n            output.push_str(&format!(\"- {}: {} functions\\n\", file, count));\n        }\n\n        if file_counts.len() > 10 {\n            output.push_str(&format!(\n                \"- ... and {} more files\\n\",\n                file_counts.len() - 10\n            ));\n        }\n\n        output\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 3,
        "loops": 6
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 577
    },
    {
      "name": "(ImpactResult) to_json",
      "qualified_name": "src/callgraph/impact.rs::(ImpactResult) to_json",
      "file": "src/callgraph/impact.rs",
      "line": 190,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ImpactResult) to_json(&self) -> serde_json::Value",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    pub fn to_json(&self) -> serde_json::Value {\n        serde_json::json!({\n            \"target\": self.target,\n            \"target_file\": self.target_file,\n            \"depth\": self.depth,\n            \"total_affected\": self.total_affected,\n            \"callers\": self.callers,\n            \"by_distance\": self.by_distance,\n            \"by_file\": self.by_file\n        })\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 86
    },
    {
      "name": "analyze_impact",
      "qualified_name": "src/callgraph/impact.rs::analyze_impact",
      "file": "src/callgraph/impact.rs",
      "line": 232,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn analyze_impact(graph: &CallGraph, target: &str, config: ImpactConfig) -> ImpactResult",
      "docstring": "",
      "calls": [
        "should_include",
        "find_matching_targets",
        "build_reverse_index",
        "new"
      ],
      "called_by": [
        "impact",
        "test_basic_impact_analysis",
        "test_llm_context_output",
        "impact_full",
        "test_impact_nonexistent_target"
      ],
      "cfg_summary": "complexity:24, blocks:58",
      "dfg_summary": "vars:39, def-use chains:63",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "pub fn analyze_impact(graph: &CallGraph, target: &str, config: ImpactConfig) -> ImpactResult {\n    // Build reverse index: callee -> [(caller, call_line)]\n    let reverse_index = build_reverse_index(graph);\n\n    // Find all functions matching the target name\n    let target_matches = find_matching_targets(graph, target);\n\n    if target_matches.is_empty() {\n        return ImpactResult {\n            target: target.to_string(),\n            target_file: None,\n            depth: 0,\n            callers: Vec::new(),\n            total_affected: 0,\n            by_distance: HashMap::new(),\n            by_file: HashMap::new(),\n        };\n    }\n\n    // Determine target file (if unique)\n    let target_file = if target_matches.len() == 1 {\n        Some(target_matches[0].file.clone())\n    } else {\n        None\n    };\n\n    // BFS traversal with distance tracking\n    let mut visited: HashSet<FunctionRef> = HashSet::new();\n    let mut callers_map: HashMap<FunctionRef, (usize, Vec<usize>)> = HashMap::new();\n    let mut queue: VecDeque<(FunctionRef, usize)> = VecDeque::new();\n\n    // Initialize queue with direct callers of all matching targets\n    for target_ref in &target_matches {\n        if let Some(callers) = reverse_index.get(target_ref) {\n            for (caller, call_line) in callers {\n                if !visited.contains(caller) && should_include(caller, &config) {\n                    visited.insert(caller.clone());\n                    let entry = callers_map.entry(caller.clone()).or_insert((1, Vec::new()));\n                    entry.1.push(*call_line);\n                    queue.push_back((caller.clone(), 1));\n                }\n            }\n        }\n    }\n\n    // Also check for name-only matches in reverse index\n    for (callee, callers) in &reverse_index {\n        if callee.name == target && !target_matches.contains(callee) {\n            for (caller, call_line) in callers {\n                if !visited.contains(caller) && should_include(caller, &config) {\n                    visited.insert(caller.clone());\n                    let entry = callers_map.entry(caller.clone()).or_insert((1, Vec::new()));\n                    entry.1.push(*call_line);\n                    queue.push_back((caller.clone(), 1));\n                }\n            }\n        }\n    }\n\n    // BFS traversal\n    let max_depth = if config.max_depth == 0 {\n        usize::MAX\n    } else {\n        config.max_depth\n    };\n\n    while let Some((func, distance)) = queue.pop_front() {\n        // Stop if we've reached max depth\n        if distance >= max_depth {\n            continue;\n        }\n\n        // Find callers of this function\n        if let Some(callers) = reverse_index.get(&func) {\n            for (caller, call_line) in callers {\n                if !visited.contains(caller) && should_include(caller, &config) {\n                    visited.insert(caller.clone());\n                    let new_distance = distance + 1;\n                    let entry = callers_map\n                        .entry(caller.clone())\n                        .or_insert((new_distance, Vec::new()));\n                    if config.include_call_sites {\n                        entry.1.push(*call_line);\n                    }\n                    queue.push_back((caller.clone(), new_distance));\n                }\n            }\n        }\n\n        // Also check for name-only matches\n        for (potential_callee, callers) in &reverse_index {\n            if potential_callee.name == func.name\n                && potential_callee != &func\n                && !visited.contains(potential_callee)\n            {\n                for (caller, call_line) in callers {\n                    if !visited.contains(caller) && should_include(caller, &config) {\n                        visited.insert(caller.clone());\n                        let new_distance = distance + 1;\n                        let entry = callers_map\n                            .entry(caller.clone())\n                            .or_insert((new_distance, Vec::new()));\n                        if config.include_call_sites {\n                            entry.1.push(*call_line);\n                        }\n                        queue.push_back((caller.clone(), new_distance));\n                    }\n                }\n            }\n        }\n    }\n\n    // Convert to CallerInfo list\n    let mut callers: Vec<CallerInfo> = callers_map\n        .into_iter()\n        .map(|(func, (distance, call_sites))| CallerInfo {\n            file: func.file.clone(),\n            name: func.name.clone(),\n            qualified_name: func.qualified_name.clone(),\n            distance,\n            call_sites,\n        })\n        .collect();\n\n    // Sort by distance, then by file, then by name\n    callers.sort_by(|a, b| {\n        a.distance\n            .cmp(&b.distance)\n            .then_with(|| a.file.cmp(&b.file))\n            .then_with(|| a.name.cmp(&b.name))\n    });\n\n    // Calculate statistics\n    let total_affected = callers.len();\n    let max_distance = callers.iter().map(|c| c.distance).max().unwrap_or(0);\n\n    let mut by_distance: HashMap<usize, usize> = HashMap::new();\n    let mut by_file: HashMap<String, usize> = HashMap::new();\n\n    for caller in &callers {\n        *by_distance.entry(caller.distance).or_insert(0) += 1;\n        *by_file.entry(caller.file.clone()).or_insert(0) += 1;\n    }\n\n    ImpactResult {\n        target: target.to_string(),\n        target_file,\n        depth: max_distance,\n        callers,\n        total_affected,\n        by_distance,\n        by_file,\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "api_endpoint",
        "iteration",
        "config",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 7,
        "branches": 18,
        "loops": 11
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 1154
    },
    {
      "name": "build_reverse_index",
      "qualified_name": "src/callgraph/impact.rs::build_reverse_index",
      "file": "src/callgraph/impact.rs",
      "line": 388,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn build_reverse_index(graph: &CallGraph) -> HashMap<FunctionRef, Vec<(FunctionRef, usize)>>",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [
        "analyze_impact"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "fn build_reverse_index(graph: &CallGraph) -> HashMap<FunctionRef, Vec<(FunctionRef, usize)>> {\n    let mut index: HashMap<FunctionRef, Vec<(FunctionRef, usize)>> = HashMap::new();\n\n    for edge in &graph.edges {\n        index\n            .entry(edge.callee.clone())\n            .or_default()\n            .push((edge.caller.clone(), edge.call_line));\n    }\n\n    index\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 89
    },
    {
      "name": "find_matching_targets",
      "qualified_name": "src/callgraph/impact.rs::find_matching_targets",
      "file": "src/callgraph/impact.rs",
      "line": 402,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn find_matching_targets(graph: &CallGraph, target: &str) -> Vec<FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "analyze_impact"
      ],
      "cfg_summary": "complexity:4, blocks:7",
      "dfg_summary": "vars:8, def-use chains:5",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "fn find_matching_targets(graph: &CallGraph, target: &str) -> Vec<FunctionRef> {\n    let all_funcs = graph.all_functions();\n\n    all_funcs\n        .into_iter()\n        .filter(|f| {\n            // Match by name\n            if f.name == target {\n                return true;\n            }\n\n            // Match by qualified name\n            if let Some(ref qn) = f.qualified_name {\n                if qn == target || qn.ends_with(&format!(\".{}\", target)) {\n                    return true;\n                }\n            }\n\n            false\n        })\n        .collect()\n}\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 124
    },
    {
      "name": "should_include",
      "qualified_name": "src/callgraph/impact.rs::should_include",
      "file": "src/callgraph/impact.rs",
      "line": 426,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn should_include(func: &FunctionRef, config: &ImpactConfig) -> bool",
      "docstring": "",
      "calls": [
        "glob_match",
        "matches_language",
        "is_test_file"
      ],
      "called_by": [
        "analyze_impact"
      ],
      "cfg_summary": "complexity:8, blocks:16",
      "dfg_summary": "vars:11, def-use chains:6",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "fn should_include(func: &FunctionRef, config: &ImpactConfig) -> bool {\n    // Language filter\n    if let Some(ref lang) = config.language {\n        if !matches_language(&func.file, lang) {\n            return false;\n        }\n    }\n\n    // Test file exclusion\n    if config.exclude_tests && is_test_file(&func.file) {\n        return false;\n    }\n\n    // Include patterns (if any, file must match at least one)\n    if !config.include_patterns.is_empty() {\n        let matches_any = config\n            .include_patterns\n            .iter()\n            .any(|p| glob_match(p, &func.file));\n        if !matches_any {\n            return false;\n        }\n    }\n\n    // Exclude patterns\n    for pattern in &config.exclude_patterns {\n        if glob_match(pattern, &func.file) {\n            return false;\n        }\n    }\n\n    true\n}\n",
      "semantic_tags": [
        "test",
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 8,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 186
    },
    {
      "name": "matches_language",
      "qualified_name": "src/callgraph/impact.rs::matches_language",
      "file": "src/callgraph/impact.rs",
      "line": 461,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn matches_language(file: &str, lang: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "should_include"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "fn matches_language(file: &str, lang: &str) -> bool {\n    let extensions: &[&str] = match lang {\n        \"python\" => &[\".py\", \".pyi\"],\n        \"typescript\" => &[\".ts\", \".tsx\"],\n        \"javascript\" => &[\".js\", \".jsx\", \".mjs\"],\n        \"rust\" => &[\".rs\"],\n        \"go\" => &[\".go\"],\n        \"java\" => &[\".java\"],\n        \"c\" => &[\".c\", \".h\"],\n        \"cpp\" => &[\".cpp\", \".cc\", \".cxx\", \".hpp\", \".hxx\"],\n        \"csharp\" => &[\".cs\"],\n        \"ruby\" => &[\".rb\"],\n        \"php\" => &[\".php\"],\n        \"swift\" => &[\".swift\"],\n        \"kotlin\" => &[\".kt\", \".kts\"],\n        \"scala\" => &[\".scala\", \".sc\"],\n        _ => return true, // Unknown language, don't filter\n    };\n\n    extensions.iter().any(|ext| file.ends_with(ext))\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 223
    },
    {
      "name": "is_test_file",
      "qualified_name": "src/callgraph/impact.rs::is_test_file",
      "file": "src/callgraph/impact.rs",
      "line": 484,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_test_file(file: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [
        "should_include"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:5, def-use chains:19",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "fn is_test_file(file: &str) -> bool {\n    let path_lower = file.to_lowercase();\n\n    // Common test directory patterns\n    if path_lower.contains(\"/test/\")\n        || path_lower.contains(\"/tests/\")\n        || path_lower.contains(\"/__tests__/\")\n        || path_lower.contains(\"/spec/\")\n        || path_lower.contains(\"/specs/\")\n    {\n        return true;\n    }\n\n    // Common test file naming patterns\n    let filename = file.rsplit('/').next().unwrap_or(file);\n    let filename_lower = filename.to_lowercase();\n\n    filename_lower.starts_with(\"test_\")\n        || filename_lower.ends_with(\"_test.py\")\n        || filename_lower.ends_with(\"_test.rs\")\n        || filename_lower.ends_with(\"_test.go\")\n        || filename_lower.ends_with(\".test.ts\")\n        || filename_lower.ends_with(\".test.js\")\n        || filename_lower.ends_with(\".spec.ts\")\n        || filename_lower.ends_with(\".spec.js\")\n        || filename_lower.ends_with(\"_spec.rb\")\n        || filename_lower.ends_with(\"test.java\")\n}\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 211
    },
    {
      "name": "glob_match",
      "qualified_name": "src/callgraph/impact.rs::glob_match",
      "file": "src/callgraph/impact.rs",
      "line": 519,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn glob_match(pattern: &str, path: &str) -> bool",
      "docstring": "",
      "calls": [
        "glob_match_recursive"
      ],
      "called_by": [
        "should_include"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "fn glob_match(pattern: &str, path: &str) -> bool {\n    // Normalize paths for consistent matching\n    let pattern = pattern.replace('\\\\', \"/\");\n    let path = path.replace('\\\\', \"/\");\n\n    glob_match_recursive(&pattern, &path)\n}\n",
      "semantic_tags": [
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 54
    },
    {
      "name": "glob_match_recursive",
      "qualified_name": "src/callgraph/impact.rs::glob_match_recursive",
      "file": "src/callgraph/impact.rs",
      "line": 527,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn glob_match_recursive(pattern: &str, path: &str) -> bool",
      "docstring": "",
      "calls": [
        "glob_match_recursive"
      ],
      "called_by": [
        "glob_match",
        "glob_match_recursive"
      ],
      "cfg_summary": "complexity:11, blocks:25",
      "dfg_summary": "vars:11, def-use chains:24",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "fn glob_match_recursive(pattern: &str, path: &str) -> bool {\n    let mut pat_chars = pattern.chars().peekable();\n    let mut path_chars = path.chars().peekable();\n\n    while let Some(pc) = pat_chars.next() {\n        match pc {\n            '*' => {\n                // Check for **\n                if pat_chars.peek() == Some(&'*') {\n                    pat_chars.next(); // consume second *\n\n                    // Skip optional path separator after **\n                    if pat_chars.peek() == Some(&'/') {\n                        pat_chars.next();\n                    }\n\n                    let remaining_pattern: String = pat_chars.collect();\n\n                    // ** matches everything\n                    if remaining_pattern.is_empty() {\n                        return true;\n                    }\n\n                    // Try matching remaining pattern at every position\n                    let remaining_path: String = path_chars.collect();\n                    for i in 0..=remaining_path.len() {\n                        if glob_match_recursive(&remaining_pattern, &remaining_path[i..]) {\n                            return true;\n                        }\n                    }\n                    return false;\n                } else {\n                    // Single * - match until next /\n                    let remaining_pattern: String = pat_chars.collect();\n\n                    if remaining_pattern.is_empty() {\n                        // * at end matches rest of current segment\n                        return !path_chars.any(|c| c == '/');\n                    }\n\n                    // Try matching remaining pattern after consuming non-/ chars\n                    let remaining_path: String = path_chars.collect();\n                    for i in 0..=remaining_path.len() {\n                        if i > 0 && remaining_path.chars().nth(i - 1) == Some('/') {\n                            break; // * doesn't match across /\n                        }\n                        if glob_match_recursive(&remaining_pattern, &remaining_path[i..]) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            }\n            '?' => {\n                // Match any single character except /\n                match path_chars.next() {\n                    Some(c) if c != '/' => continue,\n                    _ => return false,\n                }\n            }\n            c => {\n                // Literal character match\n                match path_chars.next() {\n                    Some(pc) if pc == c => continue,\n                    _ => return false,\n                }\n            }\n        }\n    }\n\n    // Pattern consumed - path should also be consumed\n    path_chars.next().is_none()\n}\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration",
        "error_handling"
      ],
      "complexity": {
        "depth": 7,
        "branches": 16,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 467
    },
    {
      "name": "analyze_impact_simple",
      "qualified_name": "src/callgraph/impact.rs::analyze_impact_simple",
      "file": "src/callgraph/impact.rs",
      "line": 604,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn analyze_impact_simple(graph: &CallGraph, target: &str, depth: usize) -> ImpactResult",
      "docstring": "",
      "calls": [
        "with_depth",
        "new",
        "analyze_impact"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "pub fn analyze_impact_simple(graph: &CallGraph, target: &str, depth: usize) -> ImpactResult {\n    let config = ImpactConfig::new().with_depth(depth);\n    analyze_impact(graph, target, config)\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 49
    },
    {
      "name": "create_test_graph",
      "qualified_name": "src/callgraph/impact.rs::create_test_graph",
      "file": "src/callgraph/impact.rs",
      "line": 614,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_test_graph() -> CallGraph",
      "docstring": "",
      "calls": [
        "default"
      ],
      "called_by": [
        "test_impact_language_filter",
        "test_impact_with_depth_limit",
        "test_impact_exclude_tests",
        "test_impact_distance_tracking",
        "test_detect_entry_points"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:16, def-use chains:3",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    fn create_test_graph() -> CallGraph {\n        let mut graph = CallGraph::default();\n\n        // Build a call chain: main -> process -> validate -> helper\n        let edges = vec![\n            CallEdge {\n                caller: FunctionRef {\n                    file: \"src/main.py\".to_string(),\n                    name: \"main\".to_string(),\n                    qualified_name: None,\n                },\n                callee: FunctionRef {\n                    file: \"src/process.py\".to_string(),\n                    name: \"process\".to_string(),\n                    qualified_name: None,\n                },\n                call_line: 10,\n            },\n            CallEdge {\n                caller: FunctionRef {\n                    file: \"src/process.py\".to_string(),\n                    name: \"process\".to_string(),\n                    qualified_name: None,\n                },\n                callee: FunctionRef {\n                    file: \"src/validate.py\".to_string(),\n                    name: \"validate\".to_string(),\n                    qualified_name: None,\n                },\n                call_line: 25,\n            },\n            CallEdge {\n                caller: FunctionRef {\n                    file: \"src/validate.py\".to_string(),\n                    name: \"validate\".to_string(),\n                    qualified_name: None,\n                },\n                callee: FunctionRef {\n                    file: \"src/helper.py\".to_string(),\n                    name: \"helper\".to_string(),\n                    qualified_name: None,\n                },\n                call_line: 15,\n            },\n            // Additional caller of helper from tests\n            CallEdge {\n                caller: FunctionRef {\n                    file: \"tests/test_helper.py\".to_string(),\n                    name: \"test_helper\".to_string(),\n                    qualified_name: None,\n                },\n                callee: FunctionRef {\n                    file: \"src/helper.py\".to_string(),\n                    name: \"helper\".to_string(),\n                    qualified_name: None,\n                },\n                call_line: 8,\n            },\n        ];\n\n        graph.edges = edges;\n        graph.build_indexes();\n        graph\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 5,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 399
    },
    {
      "name": "test_basic_impact_analysis",
      "qualified_name": "src/callgraph/impact.rs::test_basic_impact_analysis",
      "file": "src/callgraph/impact.rs",
      "line": 680,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_basic_impact_analysis()",
      "docstring": "",
      "calls": [
        "analyze_impact",
        "create_test_graph",
        "with_depth",
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    fn test_basic_impact_analysis() {\n        let graph = create_test_graph();\n        let config = ImpactConfig::new().with_depth(10);\n        let result = analyze_impact(&graph, \"helper\", config);\n\n        assert_eq!(result.target, \"helper\");\n        assert_eq!(result.total_affected, 4); // validate, process, main, test_helper\n    }\n",
      "semantic_tags": [
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 81
    },
    {
      "name": "test_impact_with_depth_limit",
      "qualified_name": "src/callgraph/impact.rs::test_impact_with_depth_limit",
      "file": "src/callgraph/impact.rs",
      "line": 690,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_impact_with_depth_limit()",
      "docstring": "",
      "calls": [
        "create_test_graph",
        "with_depth",
        "new",
        "analyze_impact"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    fn test_impact_with_depth_limit() {\n        let graph = create_test_graph();\n        let config = ImpactConfig::new().with_depth(1);\n        let result = analyze_impact(&graph, \"helper\", config);\n\n        // Only direct callers: validate, test_helper\n        assert_eq!(result.total_affected, 2);\n        assert!(result.callers.iter().all(|c| c.distance == 1));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 90
    },
    {
      "name": "test_impact_exclude_tests",
      "qualified_name": "src/callgraph/impact.rs::test_impact_exclude_tests",
      "file": "src/callgraph/impact.rs",
      "line": 701,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_impact_exclude_tests()",
      "docstring": "",
      "calls": [
        "create_test_graph",
        "exclude_tests",
        "with_depth",
        "new",
        "analyze_impact"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    fn test_impact_exclude_tests() {\n        let graph = create_test_graph();\n        let config = ImpactConfig::new().with_depth(10).exclude_tests();\n        let result = analyze_impact(&graph, \"helper\", config);\n\n        // Should exclude test_helper\n        assert_eq!(result.total_affected, 3);\n        assert!(!result.callers.iter().any(|c| c.name == \"test_helper\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 91
    },
    {
      "name": "test_impact_language_filter",
      "qualified_name": "src/callgraph/impact.rs::test_impact_language_filter",
      "file": "src/callgraph/impact.rs",
      "line": 712,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_impact_language_filter()",
      "docstring": "",
      "calls": [
        "create_test_graph",
        "with_depth",
        "new",
        "with_language",
        "analyze_impact"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:3",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    fn test_impact_language_filter() {\n        let graph = create_test_graph();\n        let config = ImpactConfig::new().with_depth(10).with_language(\"python\");\n        let result = analyze_impact(&graph, \"helper\", config);\n\n        // All files are .py, so all should match\n        assert_eq!(result.total_affected, 4);\n    }\n",
      "semantic_tags": [
        "test",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 79
    },
    {
      "name": "test_impact_distance_tracking",
      "qualified_name": "src/callgraph/impact.rs::test_impact_distance_tracking",
      "file": "src/callgraph/impact.rs",
      "line": 722,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_impact_distance_tracking()",
      "docstring": "",
      "calls": [
        "create_test_graph",
        "exclude_tests",
        "with_depth",
        "new",
        "analyze_impact"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:8",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    fn test_impact_distance_tracking() {\n        let graph = create_test_graph();\n        let config = ImpactConfig::new().with_depth(10).exclude_tests();\n        let result = analyze_impact(&graph, \"helper\", config);\n\n        // Check distances\n        let validate = result\n            .callers\n            .iter()\n            .find(|c| c.name == \"validate\")\n            .unwrap();\n        assert_eq!(validate.distance, 1);\n\n        let process = result.callers.iter().find(|c| c.name == \"process\").unwrap();\n        assert_eq!(process.distance, 2);\n\n        let main_fn = result.callers.iter().find(|c| c.name == \"main\").unwrap();\n        assert_eq!(main_fn.distance, 3);\n    }\n",
      "semantic_tags": [
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 162
    },
    {
      "name": "test_impact_nonexistent_target",
      "qualified_name": "src/callgraph/impact.rs::test_impact_nonexistent_target",
      "file": "src/callgraph/impact.rs",
      "line": 743,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_impact_nonexistent_target()",
      "docstring": "",
      "calls": [
        "new",
        "analyze_impact",
        "create_test_graph"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:4",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    fn test_impact_nonexistent_target() {\n        let graph = create_test_graph();\n        let config = ImpactConfig::new();\n        let result = analyze_impact(&graph, \"nonexistent\", config);\n\n        assert_eq!(result.total_affected, 0);\n        assert!(result.callers.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 66
    },
    {
      "name": "test_glob_match",
      "qualified_name": "src/callgraph/impact.rs::test_glob_match",
      "file": "src/callgraph/impact.rs",
      "line": 753,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_glob_match()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    fn test_glob_match() {\n        // Basic matches\n        assert!(glob_match(\"*.py\", \"test.py\"));\n        assert!(!glob_match(\"*.py\", \"test.rs\"));\n\n        // Double star\n        assert!(glob_match(\"**/*.py\", \"src/lib/test.py\"));\n        assert!(glob_match(\"**/test/**\", \"foo/test/bar.py\"));\n\n        // Question mark\n        assert!(glob_match(\"test?.py\", \"test1.py\"));\n        assert!(!glob_match(\"test?.py\", \"test12.py\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 114
    },
    {
      "name": "test_is_test_file",
      "qualified_name": "src/callgraph/impact.rs::test_is_test_file",
      "file": "src/callgraph/impact.rs",
      "line": 768,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_is_test_file()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    fn test_is_test_file() {\n        assert!(is_test_file(\"tests/test_main.py\"));\n        assert!(is_test_file(\"src/__tests__/component.test.ts\"));\n        assert!(is_test_file(\"test/helper_test.go\"));\n        assert!(!is_test_file(\"src/main.py\"));\n        assert!(!is_test_file(\"lib/process.rs\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 73
    },
    {
      "name": "test_llm_context_output",
      "qualified_name": "src/callgraph/impact.rs::test_llm_context_output",
      "file": "src/callgraph/impact.rs",
      "line": 777,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_llm_context_output()",
      "docstring": "",
      "calls": [
        "analyze_impact",
        "new",
        "create_test_graph",
        "to_llm_context",
        "exclude_tests"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:8",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "    fn test_llm_context_output() {\n        let graph = create_test_graph();\n        let config = ImpactConfig::new().with_depth(10).exclude_tests();\n        let result = analyze_impact(&graph, \"helper\", config);\n\n        let context = result.to_llm_context();\n\n        assert!(context.contains(\"# Impact Analysis: helper\"));\n        assert!(context.contains(\"Distance 1\"));\n        assert!(context.contains(\"validate\"));\n        assert!(context.contains(\"Distance 2\"));\n        assert!(context.contains(\"process\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 109
    },
    {
      "name": "ImpactConfig",
      "qualified_name": "src/callgraph/impact.rs::ImpactConfig",
      "file": "src/callgraph/impact.rs",
      "line": 28,
      "language": "rust",
      "unit_type": "class",
      "signature": "class ImpactConfig",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "pub struct ImpactConfig {\n    /// Maximum depth to traverse (0 = unlimited).\n    pub max_depth: usize,\n    /// Filter by language (e.g., \"python\", \"rust\").\n    pub language: Option<String>,\n    /// Glob patterns to include (e.g., \"src/**/*.rs\").\n    pub include_patterns: Vec<String>,\n    /// Glob patterns to exclude (e.g., \"**/test/**\").\n    pub exclude_patterns: Vec<String>,\n    /// Whether to exclude test files from results.\n    pub exclude_tests: bool,\n    /// Whether to include call site information.\n    pub include_call_sites: bool,\n}\n",
      "semantic_tags": [
        "test",
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 126
    },
    {
      "name": "ImpactResult",
      "qualified_name": "src/callgraph/impact.rs::ImpactResult",
      "file": "src/callgraph/impact.rs",
      "line": 88,
      "language": "rust",
      "unit_type": "class",
      "signature": "class ImpactResult",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "pub struct ImpactResult {\n    /// Target function analyzed.\n    pub target: String,\n    /// File containing the target (if resolved to single file).\n    pub target_file: Option<String>,\n    /// Depth of analysis performed.\n    pub depth: usize,\n    /// Functions that directly or indirectly call the target.\n    pub callers: Vec<CallerInfo>,\n    /// Total count of affected functions.\n    pub total_affected: usize,\n    /// Callers grouped by distance level.\n    pub by_distance: HashMap<usize, usize>,\n    /// Callers grouped by file.\n    pub by_file: HashMap<String, usize>,\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 125
    },
    {
      "name": "CallerInfo",
      "qualified_name": "src/callgraph/impact.rs::CallerInfo",
      "file": "src/callgraph/impact.rs",
      "line": 205,
      "language": "rust",
      "unit_type": "class",
      "signature": "class CallerInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, serde, crate::callgraph::types, super, crate::callgraph::types",
      "code_preview": "pub struct CallerInfo {\n    /// File containing the caller.\n    pub file: String,\n    /// Function name.\n    pub name: String,\n    /// Fully qualified name (if available).\n    pub qualified_name: Option<String>,\n    /// Distance from target (1 = direct caller, 2 = caller of caller, etc.).\n    pub distance: usize,\n    /// Line numbers where calls to the target occur.\n    pub call_sites: Vec<usize>,\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 93
    },
    {
      "name": "resolve_calls",
      "qualified_name": "src/callgraph/resolver.rs::resolve_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 93,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn resolve_calls(files: &[PathBuf], index: &FunctionIndex) -> Result<CallGraph>",
      "docstring": "",
      "calls": [
        "extract_file_calls",
        "resolve_file_calls"
      ],
      "called_by": [
        "test_resolve_calls_basic",
        "build"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:17, def-use chains:10",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "pub fn resolve_calls(files: &[PathBuf], index: &FunctionIndex) -> Result<CallGraph> {\n    let registry = LanguageRegistry::global();\n\n    // Extract call sites in parallel for large projects\n    let file_infos: Vec<FileCallInfo> = if files.len() >= MIN_FILES_FOR_PARALLEL {\n        files\n            .par_iter()\n            .filter_map(|path| extract_file_calls(path, registry).ok().flatten())\n            .collect()\n    } else {\n        files\n            .iter()\n            .filter_map(|path| extract_file_calls(path, registry).ok().flatten())\n            .collect()\n    };\n\n    // Resolve calls to edges\n    let edges: Vec<CallEdge> = file_infos\n        .par_iter()\n        .flat_map(|info| resolve_file_calls(info, index))\n        .collect();\n\n    let mut graph = CallGraph {\n        edges,\n        ..Default::default()\n    };\n\n    graph.build_indexes();\n    Ok(graph)\n}\n",
      "semantic_tags": [
        "async_ops",
        "logging",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 202
    },
    {
      "name": "extract_file_calls",
      "qualified_name": "src/callgraph/resolver.rs::extract_file_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 125,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_file_calls(path: &PathBuf, registry: &'static LanguageRegistry) -> Result<Option<FileCallInfo>>",
      "docstring": "",
      "calls": [
        "extract_java_calls",
        "extract_python_calls",
        "extract_rust_calls",
        "build_import_map",
        "extract_c_calls"
      ],
      "called_by": [
        "resolve_calls"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:29, def-use chains:35",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_file_calls(\n    path: &PathBuf,\n    registry: &'static LanguageRegistry,\n) -> Result<Option<FileCallInfo>> {\n    // Detect language\n    let lang = match registry.detect_language(path) {\n        Some(l) => l,\n        None => return Ok(None),\n    };\n\n    // Read source\n    let source = fs::read(path).map_err(|e| TldrError::Io(e))?;\n\n    // Parse file\n    let mut parser = lang.parser()?;\n    let tree = parser\n        .parse(&source, None)\n        .ok_or_else(|| TldrError::Parse {\n            file: path.display().to_string(),\n            message: \"Failed to parse file\".to_string(),\n        })?;\n\n    // Build file context\n    let mut context = FileContext {\n        file_path: path.display().to_string(),\n        ..Default::default()\n    };\n\n    // Extract imports\n    let imports = lang.extract_imports(&tree, &source);\n    build_import_map(&imports, &mut context);\n\n    // Collect definitions and calls based on language\n    let call_sites = match lang.name() {\n        \"python\" => extract_python_calls(&tree, &source, &mut context),\n        \"typescript\" => extract_typescript_calls(&tree, &source, &mut context),\n        \"go\" => extract_go_calls(&tree, &source, &mut context),\n        \"rust\" => extract_rust_calls(&tree, &source, &mut context),\n        \"java\" => extract_java_calls(&tree, &source, &mut context),\n        \"c\" => extract_c_calls(&tree, &source, &mut context),\n        _ => Vec::new(),\n    };\n\n    Ok(Some(FileCallInfo {\n        file_path: path.display().to_string(),\n        call_sites,\n        context,\n    }))\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 379
    },
    {
      "name": "build_import_map",
      "qualified_name": "src/callgraph/resolver.rs::build_import_map",
      "file": "src/callgraph/resolver.rs",
      "line": 176,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn build_import_map(imports: &[ImportInfo], context: &mut FileContext)",
      "docstring": "",
      "calls": [],
      "called_by": [
        "extract_file_calls"
      ],
      "cfg_summary": "complexity:4, blocks:10",
      "dfg_summary": "vars:7, def-use chains:5",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn build_import_map(imports: &[ImportInfo], context: &mut FileContext) {\n    for import in imports {\n        if import.is_from {\n            // from X import Y, Z\n            for name in &import.names {\n                let original = import\n                    .aliases\n                    .get(name)\n                    .cloned()\n                    .unwrap_or_else(|| name.clone());\n                context\n                    .from_imports\n                    .insert(name.clone(), (import.module.clone(), original));\n            }\n        } else {\n            // import X or import X as Y\n            let alias = import.aliases.values().next().cloned().unwrap_or_else(|| {\n                // Get the last component of the module path as default alias\n                import\n                    .module\n                    .split(|c| c == '.' || c == '/')\n                    .last()\n                    .unwrap_or(&import.module)\n                    .to_string()\n            });\n            context.module_imports.insert(alias, import.module.clone());\n        }\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 204
    },
    {
      "name": "extract_python_calls",
      "qualified_name": "src/callgraph/resolver.rs::extract_python_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 207,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_python_calls(tree: &tree_sitter::Tree, source: &[u8], context: &mut FileContext) -> Vec<CallSite>",
      "docstring": "",
      "calls": [
        "collect_python_definitions",
        "collect_python_calls"
      ],
      "called_by": [
        "extract_file_calls"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:9",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_python_calls(\n    tree: &tree_sitter::Tree,\n    source: &[u8],\n    context: &mut FileContext,\n) -> Vec<CallSite> {\n    let mut calls = Vec::new();\n    let mut current_function: Option<String> = None;\n\n    collect_python_definitions(tree.root_node(), source, context, 0);\n    collect_python_calls(\n        tree.root_node(),\n        source,\n        context,\n        &mut current_function,\n        &mut calls,\n        0,\n    );\n\n    calls\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 111
    },
    {
      "name": "collect_python_definitions",
      "qualified_name": "src/callgraph/resolver.rs::collect_python_definitions",
      "file": "src/callgraph/resolver.rs",
      "line": 229,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_python_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize)",
      "docstring": "",
      "calls": [
        "get_child_text",
        "collect_python_definitions"
      ],
      "called_by": [
        "extract_python_calls",
        "collect_python_definitions"
      ],
      "cfg_summary": "complexity:7, blocks:15",
      "dfg_summary": "vars:11, def-use chains:20",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_python_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    match node.kind() {\n        \"function_definition\" => {\n            if let Some(name) = get_child_text(node, \"identifier\", source) {\n                context.defined_functions.insert(name);\n            }\n        }\n        \"class_definition\" => {\n            if let Some(name) = get_child_text(node, \"identifier\", source) {\n                context.defined_classes.insert(name);\n            }\n        }\n        \"decorated_definition\" => {\n            // Look inside for the actual definition\n            let mut cursor = node.walk();\n            for child in node.children(&mut cursor) {\n                if child.kind() == \"function_definition\" || child.kind() == \"class_definition\" {\n                    collect_python_definitions(child, source, context, depth + 1);\n                }\n            }\n        }\n        _ => {}\n    }\n\n    // Recurse into children\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_python_definitions(child, source, context, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 5,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 246
    },
    {
      "name": "collect_python_calls",
      "qualified_name": "src/callgraph/resolver.rs::collect_python_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 265,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_python_calls(node: Node, source: &[u8], context: &FileContext, current_function: &mut Option<String>, calls: &mut Vec<CallSite>, depth: usize)",
      "docstring": "",
      "calls": [
        "collect_python_calls",
        "get_child_text",
        "extract_python_call_target",
        "child_by_kind"
      ],
      "called_by": [
        "collect_python_calls",
        "extract_python_calls"
      ],
      "cfg_summary": "complexity:5, blocks:11",
      "dfg_summary": "vars:18, def-use chains:27",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_python_calls(\n    node: Node,\n    source: &[u8],\n    context: &FileContext,\n    current_function: &mut Option<String>,\n    calls: &mut Vec<CallSite>,\n    depth: usize,\n) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    match node.kind() {\n        \"function_definition\" => {\n            // Track current function context\n            let name = get_child_text(node, \"identifier\", source);\n            let prev = current_function.clone();\n            *current_function = name;\n\n            // Process body\n            if let Some(block) = child_by_kind(node, \"block\") {\n                collect_python_calls(block, source, context, current_function, calls, depth + 1);\n            }\n\n            *current_function = prev;\n            return;\n        }\n        \"call\" => {\n            if let Some(target) = extract_python_call_target(node, source, context) {\n                calls.push(CallSite {\n                    caller_name: current_function.clone(),\n                    target,\n                    line: node.start_position().row + 1,\n                });\n            }\n        }\n        _ => {}\n    }\n\n    // Recurse into children\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_python_calls(child, source, context, current_function, calls, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 281
    },
    {
      "name": "extract_python_call_target",
      "qualified_name": "src/callgraph/resolver.rs::extract_python_call_target",
      "file": "src/callgraph/resolver.rs",
      "line": 312,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_python_call_target(node: Node, source: &[u8], context: &FileContext) -> Option<CallTarget>",
      "docstring": "",
      "calls": [
        "child_by_kind",
        "node_text",
        "extract_attribute_chain"
      ],
      "called_by": [
        "collect_python_calls"
      ],
      "cfg_summary": "complexity:5, blocks:13",
      "dfg_summary": "vars:19, def-use chains:21",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_python_call_target(\n    node: Node,\n    source: &[u8],\n    context: &FileContext,\n) -> Option<CallTarget> {\n    // Get the function being called\n    let func_node =\n        child_by_kind(node, \"identifier\").or_else(|| child_by_kind(node, \"attribute\"))?;\n\n    match func_node.kind() {\n        \"identifier\" => {\n            let name = node_text(func_node, source).to_string();\n            // Check if it's a class instantiation\n            if context.defined_classes.contains(&name) {\n                Some(CallTarget::Constructor(name))\n            } else {\n                Some(CallTarget::Direct(name))\n            }\n        }\n        \"attribute\" => {\n            // obj.method() or module.func()\n            let parts = extract_attribute_chain(func_node, source);\n            if parts.len() >= 2 {\n                let obj = &parts[0];\n                let method = parts.last().unwrap();\n\n                // Check if obj is an imported module\n                if context.module_imports.contains_key(obj) {\n                    Some(CallTarget::Qualified(parts))\n                } else {\n                    Some(CallTarget::Method(obj.clone(), method.clone()))\n                }\n            } else if parts.len() == 1 {\n                Some(CallTarget::Direct(parts[0].clone()))\n            } else {\n                None\n            }\n        }\n        _ => None,\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "config",
        "test"
      ],
      "complexity": {
        "depth": 5,
        "branches": 11,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 282
    },
    {
      "name": "extract_typescript_calls",
      "qualified_name": "src/callgraph/resolver.rs::extract_typescript_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 355,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_typescript_calls(tree: &tree_sitter::Tree, source: &[u8], context: &mut FileContext) -> Vec<CallSite>",
      "docstring": "",
      "calls": [
        "collect_ts_calls",
        "collect_ts_definitions"
      ],
      "called_by": [
        "extract_file_calls"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:9",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_typescript_calls(\n    tree: &tree_sitter::Tree,\n    source: &[u8],\n    context: &mut FileContext,\n) -> Vec<CallSite> {\n    let mut calls = Vec::new();\n    let mut current_function: Option<String> = None;\n\n    collect_ts_definitions(tree.root_node(), source, context, 0);\n    collect_ts_calls(\n        tree.root_node(),\n        source,\n        context,\n        &mut current_function,\n        &mut calls,\n        0,\n    );\n\n    calls\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 112
    },
    {
      "name": "collect_ts_definitions",
      "qualified_name": "src/callgraph/resolver.rs::collect_ts_definitions",
      "file": "src/callgraph/resolver.rs",
      "line": 377,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_ts_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize)",
      "docstring": "",
      "calls": [
        "collect_ts_definitions",
        "get_child_text",
        "child_by_kind"
      ],
      "called_by": [
        "collect_ts_definitions",
        "extract_typescript_calls"
      ],
      "cfg_summary": "complexity:9, blocks:20",
      "dfg_summary": "vars:14, def-use chains:31",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_ts_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    match node.kind() {\n        \"function_declaration\" | \"method_definition\" => {\n            if let Some(name) = get_child_text(node, \"identifier\", source)\n                .or_else(|| get_child_text(node, \"property_identifier\", source))\n            {\n                context.defined_functions.insert(name);\n            }\n        }\n        \"class_declaration\" => {\n            if let Some(name) = get_child_text(node, \"type_identifier\", source)\n                .or_else(|| get_child_text(node, \"identifier\", source))\n            {\n                context.defined_classes.insert(name);\n            }\n        }\n        \"lexical_declaration\" | \"variable_declaration\" => {\n            // Arrow functions: const foo = () => {}\n            let mut cursor = node.walk();\n            for child in node.children(&mut cursor) {\n                if child.kind() == \"variable_declarator\" {\n                    let name = get_child_text(child, \"identifier\", source);\n                    let has_function = child_by_kind(child, \"arrow_function\").is_some()\n                        || child_by_kind(child, \"function_expression\").is_some();\n                    if let (Some(n), true) = (name, has_function) {\n                        context.defined_functions.insert(n);\n                    }\n                }\n            }\n        }\n        \"export_statement\" => {\n            // Look inside exports\n            let mut cursor = node.walk();\n            for child in node.children(&mut cursor) {\n                collect_ts_definitions(child, source, context, depth + 1);\n            }\n            return;\n        }\n        _ => {}\n    }\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_ts_definitions(child, source, context, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 6,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 388
    },
    {
      "name": "collect_ts_calls",
      "qualified_name": "src/callgraph/resolver.rs::collect_ts_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 429,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_ts_calls(node: Node, source: &[u8], context: &FileContext, current_function: &mut Option<String>, calls: &mut Vec<CallSite>, depth: usize)",
      "docstring": "",
      "calls": [
        "extract_ts_call_target",
        "get_child_text",
        "collect_ts_calls",
        "child_by_kind"
      ],
      "called_by": [
        "extract_typescript_calls",
        "collect_ts_calls"
      ],
      "cfg_summary": "complexity:6, blocks:14",
      "dfg_summary": "vars:19, def-use chains:43",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_ts_calls(\n    node: Node,\n    source: &[u8],\n    context: &FileContext,\n    current_function: &mut Option<String>,\n    calls: &mut Vec<CallSite>,\n    depth: usize,\n) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    match node.kind() {\n        \"function_declaration\" | \"arrow_function\" | \"function_expression\" => {\n            let name = get_child_text(node, \"identifier\", source);\n            let prev = current_function.clone();\n            *current_function = name.or_else(|| prev.clone());\n\n            // Process body\n            let body = child_by_kind(node, \"statement_block\")\n                .or_else(|| child_by_kind(node, \"expression_statement\"));\n            if let Some(b) = body {\n                collect_ts_calls(b, source, context, current_function, calls, depth + 1);\n            }\n\n            *current_function = prev;\n            return;\n        }\n        \"method_definition\" => {\n            let name = get_child_text(node, \"property_identifier\", source);\n            let prev = current_function.clone();\n            *current_function = name;\n\n            if let Some(body) = child_by_kind(node, \"statement_block\") {\n                collect_ts_calls(body, source, context, current_function, calls, depth + 1);\n            }\n\n            *current_function = prev;\n            return;\n        }\n        \"call_expression\" => {\n            if let Some(target) = extract_ts_call_target(node, source, context) {\n                calls.push(CallSite {\n                    caller_name: current_function.clone(),\n                    target,\n                    line: node.start_position().row + 1,\n                });\n            }\n        }\n        _ => {}\n    }\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_ts_calls(child, source, context, current_function, calls, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 5,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 391
    },
    {
      "name": "extract_ts_call_target",
      "qualified_name": "src/callgraph/resolver.rs::extract_ts_call_target",
      "file": "src/callgraph/resolver.rs",
      "line": 488,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_ts_call_target(node: Node, source: &[u8], context: &FileContext) -> Option<CallTarget>",
      "docstring": "",
      "calls": [
        "child_by_kind",
        "extract_member_expression_chain",
        "node_text"
      ],
      "called_by": [
        "collect_ts_calls"
      ],
      "cfg_summary": "complexity:6, blocks:13",
      "dfg_summary": "vars:21, def-use chains:20",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_ts_call_target(node: Node, source: &[u8], context: &FileContext) -> Option<CallTarget> {\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        match child.kind() {\n            \"identifier\" => {\n                let name = node_text(child, source).to_string();\n                if context.defined_classes.contains(&name) {\n                    return Some(CallTarget::Constructor(name));\n                }\n                return Some(CallTarget::Direct(name));\n            }\n            \"member_expression\" => {\n                let parts = extract_member_expression_chain(child, source);\n                if parts.len() >= 2 {\n                    let obj = &parts[0];\n                    let method = parts.last().unwrap();\n\n                    if context.module_imports.contains_key(obj)\n                        || context.from_imports.contains_key(obj)\n                    {\n                        return Some(CallTarget::Qualified(parts));\n                    }\n                    return Some(CallTarget::Method(obj.clone(), method.clone()));\n                }\n            }\n            \"new_expression\" => {\n                // new Constructor()\n                if let Some(id) = child_by_kind(child, \"identifier\") {\n                    return Some(CallTarget::Constructor(node_text(id, source).to_string()));\n                }\n            }\n            _ => {}\n        }\n    }\n    None\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 6,
        "branches": 5,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 261
    },
    {
      "name": "extract_go_calls",
      "qualified_name": "src/callgraph/resolver.rs::extract_go_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 526,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_go_calls(tree: &tree_sitter::Tree, source: &[u8], context: &mut FileContext) -> Vec<CallSite>",
      "docstring": "",
      "calls": [
        "collect_go_definitions",
        "collect_go_calls"
      ],
      "called_by": [
        "extract_file_calls"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:9",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_go_calls(\n    tree: &tree_sitter::Tree,\n    source: &[u8],\n    context: &mut FileContext,\n) -> Vec<CallSite> {\n    let mut calls = Vec::new();\n    let mut current_function: Option<String> = None;\n\n    collect_go_definitions(tree.root_node(), source, context, 0);\n    collect_go_calls(\n        tree.root_node(),\n        source,\n        context,\n        &mut current_function,\n        &mut calls,\n        0,\n    );\n\n    calls\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 111
    },
    {
      "name": "collect_go_definitions",
      "qualified_name": "src/callgraph/resolver.rs::collect_go_definitions",
      "file": "src/callgraph/resolver.rs",
      "line": 548,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_go_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize)",
      "docstring": "",
      "calls": [
        "get_child_text",
        "collect_go_definitions"
      ],
      "called_by": [
        "extract_go_calls",
        "collect_go_definitions"
      ],
      "cfg_summary": "complexity:8, blocks:17",
      "dfg_summary": "vars:11, def-use chains:19",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_go_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    match node.kind() {\n        \"function_declaration\" => {\n            if let Some(name) = get_child_text(node, \"identifier\", source) {\n                context.defined_functions.insert(name);\n            }\n        }\n        \"method_declaration\" => {\n            if let Some(name) = get_child_text(node, \"field_identifier\", source) {\n                context.defined_functions.insert(name);\n            }\n        }\n        \"type_declaration\" => {\n            // type Foo struct {...}\n            let mut cursor = node.walk();\n            for child in node.children(&mut cursor) {\n                if child.kind() == \"type_spec\" {\n                    if let Some(name) = get_child_text(child, \"type_identifier\", source) {\n                        context.defined_classes.insert(name);\n                    }\n                }\n            }\n        }\n        _ => {}\n    }\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_go_definitions(child, source, context, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 6,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 242
    },
    {
      "name": "collect_go_calls",
      "qualified_name": "src/callgraph/resolver.rs::collect_go_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 585,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_go_calls(node: Node, source: &[u8], context: &FileContext, current_function: &mut Option<String>, calls: &mut Vec<CallSite>, depth: usize)",
      "docstring": "",
      "calls": [
        "extract_go_call_target",
        "get_child_text",
        "collect_go_calls",
        "child_by_kind"
      ],
      "called_by": [
        "collect_go_calls",
        "extract_go_calls"
      ],
      "cfg_summary": "complexity:5, blocks:11",
      "dfg_summary": "vars:18, def-use chains:29",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_go_calls(\n    node: Node,\n    source: &[u8],\n    context: &FileContext,\n    current_function: &mut Option<String>,\n    calls: &mut Vec<CallSite>,\n    depth: usize,\n) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    match node.kind() {\n        \"function_declaration\" | \"method_declaration\" => {\n            let name = get_child_text(node, \"identifier\", source)\n                .or_else(|| get_child_text(node, \"field_identifier\", source));\n            let prev = current_function.clone();\n            *current_function = name;\n\n            if let Some(body) = child_by_kind(node, \"block\") {\n                collect_go_calls(body, source, context, current_function, calls, depth + 1);\n            }\n\n            *current_function = prev;\n            return;\n        }\n        \"call_expression\" => {\n            if let Some(target) = extract_go_call_target(node, source, context) {\n                calls.push(CallSite {\n                    caller_name: current_function.clone(),\n                    target,\n                    line: node.start_position().row + 1,\n                });\n            }\n        }\n        _ => {}\n    }\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_go_calls(child, source, context, current_function, calls, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 284
    },
    {
      "name": "extract_go_call_target",
      "qualified_name": "src/callgraph/resolver.rs::extract_go_call_target",
      "file": "src/callgraph/resolver.rs",
      "line": 630,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_go_call_target(node: Node, source: &[u8], context: &FileContext) -> Option<CallTarget>",
      "docstring": "",
      "calls": [
        "node_text",
        "extract_go_selector_parts"
      ],
      "called_by": [
        "collect_go_calls"
      ],
      "cfg_summary": "complexity:4, blocks:9",
      "dfg_summary": "vars:19, def-use chains:15",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_go_call_target(node: Node, source: &[u8], context: &FileContext) -> Option<CallTarget> {\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        match child.kind() {\n            \"identifier\" => {\n                return Some(CallTarget::Direct(node_text(child, source).to_string()));\n            }\n            \"selector_expression\" => {\n                // pkg.Func() or obj.Method()\n                let mut parts = Vec::new();\n                extract_go_selector_parts(child, source, &mut parts);\n\n                if parts.len() >= 2 {\n                    let obj = &parts[0];\n                    let method = parts.last().unwrap();\n\n                    // In Go, package imports use the package name directly\n                    if context.module_imports.contains_key(obj) {\n                        return Some(CallTarget::Qualified(parts));\n                    }\n                    return Some(CallTarget::Method(obj.clone(), method.clone()));\n                }\n            }\n            \"type_identifier\" => {\n                // Type conversion: int(x)\n                return Some(CallTarget::Constructor(\n                    node_text(child, source).to_string(),\n                ));\n            }\n            _ => {}\n        }\n    }\n    None\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 6,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 243
    },
    {
      "name": "extract_go_selector_parts",
      "qualified_name": "src/callgraph/resolver.rs::extract_go_selector_parts",
      "file": "src/callgraph/resolver.rs",
      "line": 666,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_go_selector_parts(node: Node, source: &[u8], parts: &mut Vec<String>)",
      "docstring": "",
      "calls": [
        "node_text",
        "extract_go_selector_parts"
      ],
      "called_by": [
        "extract_go_call_target",
        "extract_go_selector_parts"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:7, def-use chains:9",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_go_selector_parts(node: Node, source: &[u8], parts: &mut Vec<String>) {\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        match child.kind() {\n            \"identifier\" => {\n                parts.push(node_text(child, source).to_string());\n            }\n            \"field_identifier\" => {\n                parts.push(node_text(child, source).to_string());\n            }\n            \"selector_expression\" => {\n                extract_go_selector_parts(child, source, parts);\n            }\n            _ => {}\n        }\n    }\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 118
    },
    {
      "name": "extract_rust_calls",
      "qualified_name": "src/callgraph/resolver.rs::extract_rust_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 685,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_rust_calls(tree: &tree_sitter::Tree, source: &[u8], context: &mut FileContext) -> Vec<CallSite>",
      "docstring": "",
      "calls": [
        "collect_rust_calls",
        "collect_rust_definitions"
      ],
      "called_by": [
        "extract_file_calls"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:9",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_rust_calls(\n    tree: &tree_sitter::Tree,\n    source: &[u8],\n    context: &mut FileContext,\n) -> Vec<CallSite> {\n    let mut calls = Vec::new();\n    let mut current_function: Option<String> = None;\n\n    collect_rust_definitions(tree.root_node(), source, context, 0);\n    collect_rust_calls(\n        tree.root_node(),\n        source,\n        context,\n        &mut current_function,\n        &mut calls,\n        0,\n    );\n\n    calls\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 114
    },
    {
      "name": "collect_rust_definitions",
      "qualified_name": "src/callgraph/resolver.rs::collect_rust_definitions",
      "file": "src/callgraph/resolver.rs",
      "line": 707,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_rust_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize)",
      "docstring": "",
      "calls": [
        "get_child_text",
        "collect_rust_definitions"
      ],
      "called_by": [
        "collect_rust_definitions",
        "extract_rust_calls"
      ],
      "cfg_summary": "complexity:7, blocks:15",
      "dfg_summary": "vars:11, def-use chains:22",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_rust_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    match node.kind() {\n        \"function_item\" => {\n            if let Some(name) = get_child_text(node, \"identifier\", source) {\n                context.defined_functions.insert(name);\n            }\n        }\n        \"struct_item\" | \"enum_item\" => {\n            if let Some(name) = get_child_text(node, \"type_identifier\", source)\n                .or_else(|| get_child_text(node, \"identifier\", source))\n            {\n                context.defined_classes.insert(name);\n            }\n        }\n        \"impl_item\" => {\n            // Extract methods from impl blocks\n            let mut cursor = node.walk();\n            for child in node.children(&mut cursor) {\n                if child.kind() == \"declaration_list\" {\n                    collect_rust_definitions(child, source, context, depth + 1);\n                }\n            }\n        }\n        _ => {}\n    }\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_rust_definitions(child, source, context, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 5,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 253
    },
    {
      "name": "collect_rust_calls",
      "qualified_name": "src/callgraph/resolver.rs::collect_rust_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 744,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_rust_calls(node: Node, source: &[u8], context: &FileContext, current_function: &mut Option<String>, calls: &mut Vec<CallSite>, depth: usize)",
      "docstring": "",
      "calls": [
        "child_by_kind",
        "collect_rust_calls",
        "extract_rust_call_target",
        "get_child_text"
      ],
      "called_by": [
        "collect_rust_calls",
        "extract_rust_calls"
      ],
      "cfg_summary": "complexity:5, blocks:11",
      "dfg_summary": "vars:18, def-use chains:27",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_rust_calls(\n    node: Node,\n    source: &[u8],\n    context: &FileContext,\n    current_function: &mut Option<String>,\n    calls: &mut Vec<CallSite>,\n    depth: usize,\n) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    match node.kind() {\n        \"function_item\" => {\n            let name = get_child_text(node, \"identifier\", source);\n            let prev = current_function.clone();\n            *current_function = name;\n\n            if let Some(body) = child_by_kind(node, \"block\") {\n                collect_rust_calls(body, source, context, current_function, calls, depth + 1);\n            }\n\n            *current_function = prev;\n            return;\n        }\n        \"call_expression\" => {\n            if let Some(target) = extract_rust_call_target(node, source, context) {\n                calls.push(CallSite {\n                    caller_name: current_function.clone(),\n                    target,\n                    line: node.start_position().row + 1,\n                });\n            }\n        }\n        _ => {}\n    }\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_rust_calls(child, source, context, current_function, calls, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 267
    },
    {
      "name": "extract_rust_call_target",
      "qualified_name": "src/callgraph/resolver.rs::extract_rust_call_target",
      "file": "src/callgraph/resolver.rs",
      "line": 788,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_rust_call_target(node: Node, source: &[u8], context: &FileContext) -> Option<CallTarget>",
      "docstring": "",
      "calls": [
        "child_by_kind",
        "extract_rust_path_parts",
        "node_text",
        "get_child_text"
      ],
      "called_by": [
        "collect_rust_calls"
      ],
      "cfg_summary": "complexity:6, blocks:13",
      "dfg_summary": "vars:21, def-use chains:13",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_rust_call_target(\n    node: Node,\n    source: &[u8],\n    context: &FileContext,\n) -> Option<CallTarget> {\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        match child.kind() {\n            \"identifier\" => {\n                let name = node_text(child, source).to_string();\n                // Check for struct construction\n                if context.defined_classes.contains(&name) {\n                    return Some(CallTarget::Constructor(name));\n                }\n                return Some(CallTarget::Direct(name));\n            }\n            \"scoped_identifier\" => {\n                // path::to::func()\n                let parts = extract_rust_path_parts(child, source);\n                if !parts.is_empty() {\n                    return Some(CallTarget::Qualified(parts));\n                }\n            }\n            \"field_expression\" => {\n                // obj.method()\n                if let Some(method) = get_child_text(child, \"field_identifier\", source) {\n                    if let Some(obj) = child_by_kind(child, \"identifier\") {\n                        return Some(CallTarget::Method(\n                            node_text(obj, source).to_string(),\n                            method,\n                        ));\n                    }\n                    // Could be a chained call like a.b().c()\n                    return Some(CallTarget::Direct(method));\n                }\n            }\n            _ => {}\n        }\n    }\n    None\n}\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 7,
        "branches": 5,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 277
    },
    {
      "name": "extract_rust_path_parts",
      "qualified_name": "src/callgraph/resolver.rs::extract_rust_path_parts",
      "file": "src/callgraph/resolver.rs",
      "line": 831,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_rust_path_parts(node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [
        "node_text",
        "extract_rust_path_parts"
      ],
      "called_by": [
        "extract_rust_call_target",
        "extract_rust_path_parts"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:8, def-use chains:8",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_rust_path_parts(node: Node, source: &[u8]) -> Vec<String> {\n    let mut parts = Vec::new();\n    let mut cursor = node.walk();\n\n    for child in node.children(&mut cursor) {\n        match child.kind() {\n            \"identifier\" | \"type_identifier\" => {\n                parts.push(node_text(child, source).to_string());\n            }\n            \"scoped_identifier\" => {\n                parts.extend(extract_rust_path_parts(child, source));\n            }\n            _ => {}\n        }\n    }\n\n    parts\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 114
    },
    {
      "name": "extract_java_calls",
      "qualified_name": "src/callgraph/resolver.rs::extract_java_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 851,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_java_calls(tree: &tree_sitter::Tree, source: &[u8], context: &mut FileContext) -> Vec<CallSite>",
      "docstring": "",
      "calls": [
        "collect_java_calls",
        "collect_java_definitions"
      ],
      "called_by": [
        "extract_file_calls"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:9",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_java_calls(\n    tree: &tree_sitter::Tree,\n    source: &[u8],\n    context: &mut FileContext,\n) -> Vec<CallSite> {\n    let mut calls = Vec::new();\n    let mut current_function: Option<String> = None;\n\n    collect_java_definitions(tree.root_node(), source, context, 0);\n    collect_java_calls(\n        tree.root_node(),\n        source,\n        context,\n        &mut current_function,\n        &mut calls,\n        0,\n    );\n\n    calls\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 111
    },
    {
      "name": "collect_java_definitions",
      "qualified_name": "src/callgraph/resolver.rs::collect_java_definitions",
      "file": "src/callgraph/resolver.rs",
      "line": 873,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_java_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize)",
      "docstring": "",
      "calls": [
        "collect_java_definitions",
        "get_child_text"
      ],
      "called_by": [
        "collect_java_definitions",
        "extract_java_calls"
      ],
      "cfg_summary": "complexity:5, blocks:10",
      "dfg_summary": "vars:11, def-use chains:14",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_java_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    match node.kind() {\n        \"method_declaration\" | \"constructor_declaration\" => {\n            if let Some(name) = get_child_text(node, \"identifier\", source) {\n                context.defined_functions.insert(name);\n            }\n        }\n        \"class_declaration\" | \"interface_declaration\" => {\n            if let Some(name) = get_child_text(node, \"identifier\", source) {\n                context.defined_classes.insert(name);\n            }\n        }\n        _ => {}\n    }\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_java_definitions(child, source, context, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 172
    },
    {
      "name": "collect_java_calls",
      "qualified_name": "src/callgraph/resolver.rs::collect_java_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 899,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_java_calls(node: Node, source: &[u8], context: &FileContext, current_function: &mut Option<String>, calls: &mut Vec<CallSite>, depth: usize)",
      "docstring": "",
      "calls": [
        "collect_java_calls",
        "extract_java_call_target",
        "child_by_kind",
        "node_text",
        "get_child_text"
      ],
      "called_by": [
        "collect_java_calls",
        "extract_java_calls"
      ],
      "cfg_summary": "complexity:6, blocks:13",
      "dfg_summary": "vars:22, def-use chains:32",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_java_calls(\n    node: Node,\n    source: &[u8],\n    context: &FileContext,\n    current_function: &mut Option<String>,\n    calls: &mut Vec<CallSite>,\n    depth: usize,\n) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    match node.kind() {\n        \"method_declaration\" | \"constructor_declaration\" => {\n            let name = get_child_text(node, \"identifier\", source);\n            let prev = current_function.clone();\n            *current_function = name;\n\n            if let Some(body) = child_by_kind(node, \"block\") {\n                collect_java_calls(body, source, context, current_function, calls, depth + 1);\n            }\n\n            *current_function = prev;\n            return;\n        }\n        \"method_invocation\" => {\n            if let Some(target) = extract_java_call_target(node, source, context) {\n                calls.push(CallSite {\n                    caller_name: current_function.clone(),\n                    target,\n                    line: node.start_position().row + 1,\n                });\n            }\n        }\n        \"object_creation_expression\" => {\n            // new ClassName()\n            if let Some(type_node) = child_by_kind(node, \"type_identifier\") {\n                calls.push(CallSite {\n                    caller_name: current_function.clone(),\n                    target: CallTarget::Constructor(node_text(type_node, source).to_string()),\n                    line: node.start_position().row + 1,\n                });\n            }\n        }\n        _ => {}\n    }\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_java_calls(child, source, context, current_function, calls, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 5,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 349
    },
    {
      "name": "extract_java_call_target",
      "qualified_name": "src/callgraph/resolver.rs::extract_java_call_target",
      "file": "src/callgraph/resolver.rs",
      "line": 953,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_java_call_target(node: Node, source: &[u8], _context: &FileContext) -> Option<CallTarget>",
      "docstring": "",
      "calls": [
        "get_child_text",
        "extract_java_field_access_parts",
        "node_text"
      ],
      "called_by": [
        "collect_java_calls"
      ],
      "cfg_summary": "complexity:3, blocks:7",
      "dfg_summary": "vars:18, def-use chains:18",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_java_call_target(\n    node: Node,\n    source: &[u8],\n    _context: &FileContext,\n) -> Option<CallTarget> {\n    let method_name = get_child_text(node, \"identifier\", source)?;\n\n    // Check for object.method() pattern\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        match child.kind() {\n            \"identifier\" if node_text(child, source) != method_name => {\n                // obj.method()\n                let obj = node_text(child, source).to_string();\n                return Some(CallTarget::Method(obj, method_name));\n            }\n            \"field_access\" => {\n                // pkg.Class.method() or obj.field.method()\n                let parts = extract_java_field_access_parts(child, source);\n                if !parts.is_empty() {\n                    let mut full_parts = parts;\n                    full_parts.push(method_name.clone());\n                    return Some(CallTarget::Qualified(full_parts));\n                }\n            }\n            \"method_invocation\" => {\n                // Chained call: a().method()\n                return Some(CallTarget::Direct(method_name));\n            }\n            _ => {}\n        }\n    }\n\n    // Direct call\n    Some(CallTarget::Direct(method_name))\n}\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 253
    },
    {
      "name": "extract_java_field_access_parts",
      "qualified_name": "src/callgraph/resolver.rs::extract_java_field_access_parts",
      "file": "src/callgraph/resolver.rs",
      "line": 991,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_java_field_access_parts(node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [
        "node_text",
        "extract_java_field_access_parts"
      ],
      "called_by": [
        "extract_java_call_target",
        "extract_java_field_access_parts"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:8, def-use chains:8",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_java_field_access_parts(node: Node, source: &[u8]) -> Vec<String> {\n    let mut parts = Vec::new();\n    let mut cursor = node.walk();\n\n    for child in node.children(&mut cursor) {\n        match child.kind() {\n            \"identifier\" => {\n                parts.push(node_text(child, source).to_string());\n            }\n            \"field_access\" => {\n                parts.extend(extract_java_field_access_parts(child, source));\n            }\n            _ => {}\n        }\n    }\n\n    parts\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 109
    },
    {
      "name": "extract_c_calls",
      "qualified_name": "src/callgraph/resolver.rs::extract_c_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 1011,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_c_calls(tree: &tree_sitter::Tree, source: &[u8], context: &mut FileContext) -> Vec<CallSite>",
      "docstring": "",
      "calls": [
        "collect_c_calls",
        "collect_c_definitions"
      ],
      "called_by": [
        "extract_file_calls"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:9",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_c_calls(\n    tree: &tree_sitter::Tree,\n    source: &[u8],\n    context: &mut FileContext,\n) -> Vec<CallSite> {\n    let mut calls = Vec::new();\n    let mut current_function: Option<String> = None;\n\n    collect_c_definitions(tree.root_node(), source, context, 0);\n    collect_c_calls(\n        tree.root_node(),\n        source,\n        context,\n        &mut current_function,\n        &mut calls,\n        0,\n    );\n\n    calls\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 111
    },
    {
      "name": "collect_c_definitions",
      "qualified_name": "src/callgraph/resolver.rs::collect_c_definitions",
      "file": "src/callgraph/resolver.rs",
      "line": 1033,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_c_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize)",
      "docstring": "",
      "calls": [
        "collect_c_definitions",
        "get_child_text",
        "child_by_kind"
      ],
      "called_by": [
        "collect_c_definitions",
        "extract_c_calls"
      ],
      "cfg_summary": "complexity:9, blocks:18",
      "dfg_summary": "vars:15, def-use chains:14",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_c_definitions(node: Node, source: &[u8], context: &mut FileContext, depth: usize) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    if node.kind() == \"function_definition\" {\n        // Get function name from function_declarator\n        if let Some(decl) = child_by_kind(node, \"function_declarator\") {\n            if let Some(name) = get_child_text(decl, \"identifier\", source) {\n                context.defined_functions.insert(name);\n            }\n        }\n        // Handle pointer return types: int* func()\n        if let Some(ptr_decl) = child_by_kind(node, \"pointer_declarator\") {\n            if let Some(func_decl) = child_by_kind(ptr_decl, \"function_declarator\") {\n                if let Some(name) = get_child_text(func_decl, \"identifier\", source) {\n                    context.defined_functions.insert(name);\n                }\n            }\n        }\n    }\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_c_definitions(child, source, context, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "database",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 7,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 236
    },
    {
      "name": "collect_c_calls",
      "qualified_name": "src/callgraph/resolver.rs::collect_c_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 1062,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn collect_c_calls(node: Node, source: &[u8], context: &FileContext, current_function: &mut Option<String>, calls: &mut Vec<CallSite>, depth: usize)",
      "docstring": "",
      "calls": [
        "extract_c_call_target",
        "collect_c_calls",
        "child_by_kind",
        "get_child_text"
      ],
      "called_by": [
        "collect_c_calls",
        "extract_c_calls"
      ],
      "cfg_summary": "complexity:5, blocks:11",
      "dfg_summary": "vars:19, def-use chains:26",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn collect_c_calls(\n    node: Node,\n    source: &[u8],\n    context: &FileContext,\n    current_function: &mut Option<String>,\n    calls: &mut Vec<CallSite>,\n    depth: usize,\n) {\n    if depth > MAX_TREE_DEPTH {\n        return;\n    }\n\n    match node.kind() {\n        \"function_definition\" => {\n            let name = child_by_kind(node, \"function_declarator\")\n                .and_then(|d| get_child_text(d, \"identifier\", source));\n            let prev = current_function.clone();\n            *current_function = name;\n\n            if let Some(body) = child_by_kind(node, \"compound_statement\") {\n                collect_c_calls(body, source, context, current_function, calls, depth + 1);\n            }\n\n            *current_function = prev;\n            return;\n        }\n        \"call_expression\" => {\n            if let Some(target) = extract_c_call_target(node, source) {\n                calls.push(CallSite {\n                    caller_name: current_function.clone(),\n                    target,\n                    line: node.start_position().row + 1,\n                });\n            }\n        }\n        _ => {}\n    }\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        collect_c_calls(child, source, context, current_function, calls, depth + 1);\n    }\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 280
    },
    {
      "name": "extract_c_call_target",
      "qualified_name": "src/callgraph/resolver.rs::extract_c_call_target",
      "file": "src/callgraph/resolver.rs",
      "line": 1107,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_c_call_target(node: Node, source: &[u8]) -> Option<CallTarget>",
      "docstring": "",
      "calls": [
        "node_text",
        "get_child_text",
        "child_by_kind"
      ],
      "called_by": [
        "collect_c_calls"
      ],
      "cfg_summary": "complexity:4, blocks:9",
      "dfg_summary": "vars:15, def-use chains:6",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_c_call_target(node: Node, source: &[u8]) -> Option<CallTarget> {\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        match child.kind() {\n            \"identifier\" => {\n                return Some(CallTarget::Direct(node_text(child, source).to_string()));\n            }\n            \"field_expression\" => {\n                // ptr->method() or struct.field()\n                if let Some(field) = get_child_text(child, \"field_identifier\", source) {\n                    if let Some(obj) = child_by_kind(child, \"identifier\") {\n                        return Some(CallTarget::Method(\n                            node_text(obj, source).to_string(),\n                            field,\n                        ));\n                    }\n                }\n            }\n            _ => {}\n        }\n    }\n    None\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 7,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 164
    },
    {
      "name": "resolve_file_calls",
      "qualified_name": "src/callgraph/resolver.rs::resolve_file_calls",
      "file": "src/callgraph/resolver.rs",
      "line": 1136,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn resolve_file_calls(info: &FileCallInfo, index: &FunctionIndex) -> Vec<CallEdge>",
      "docstring": "",
      "calls": [
        "resolve_call_target"
      ],
      "called_by": [
        "resolve_calls"
      ],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:11, def-use chains:7",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn resolve_file_calls(info: &FileCallInfo, index: &FunctionIndex) -> Vec<CallEdge> {\n    let mut edges = Vec::new();\n\n    for call_site in &info.call_sites {\n        let caller = FunctionRef {\n            file: info.file_path.clone(),\n            name: call_site\n                .caller_name\n                .clone()\n                .unwrap_or_else(|| \"<module>\".to_string()),\n            qualified_name: None,\n        };\n\n        // Try to resolve the callee\n        if let Some(callee) = resolve_call_target(&call_site.target, &info.context, index) {\n            edges.push(CallEdge {\n                caller,\n                callee,\n                call_line: call_site.line,\n            });\n        }\n    }\n\n    edges\n}\n",
      "semantic_tags": [
        "logging",
        "iteration",
        "error_handling"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 154
    },
    {
      "name": "resolve_call_target",
      "qualified_name": "src/callgraph/resolver.rs::resolve_call_target",
      "file": "src/callgraph/resolver.rs",
      "line": 1163,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn resolve_call_target(target: &CallTarget, context: &FileContext, index: &FunctionIndex) -> Option<FunctionRef>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "resolve_file_calls"
      ],
      "cfg_summary": "complexity:15, blocks:31",
      "dfg_summary": "vars:25, def-use chains:32",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn resolve_call_target(\n    target: &CallTarget,\n    context: &FileContext,\n    index: &FunctionIndex,\n) -> Option<FunctionRef> {\n    match target {\n        CallTarget::Direct(name) => {\n            // First check if it's defined in the same file (intra-file call)\n            if context.defined_functions.contains(name) {\n                return Some(FunctionRef {\n                    file: context.file_path.clone(),\n                    name: name.clone(),\n                    qualified_name: None,\n                });\n            }\n\n            // Check from imports: from X import name\n            if let Some((module, original)) = context.from_imports.get(name) {\n                // Try to find in index with qualified name\n                let qname = format!(\"{}.{}\", module, original);\n                if let Some(func) = index.lookup_qualified(&qname) {\n                    return Some(func.clone());\n                }\n                // Fall back to simple name lookup\n                let candidates = index.lookup(original);\n                if candidates.len() == 1 {\n                    return Some(candidates[0].clone());\n                }\n            }\n\n            // Fall back to simple name lookup\n            let candidates = index.lookup(name);\n            if candidates.len() == 1 {\n                return Some(candidates[0].clone());\n            }\n            // If multiple candidates, can't resolve unambiguously\n            // Return first candidate as best guess\n            candidates.first().map(|f| (*f).clone())\n        }\n\n        CallTarget::Method(obj, method) => {\n            // Method calls are harder to resolve without type information\n            // Try to find any function with matching name\n            let candidates = index.lookup(method);\n            if candidates.len() == 1 {\n                return Some(candidates[0].clone());\n            }\n\n            // Check if obj is a module alias\n            if let Some(module) = context.module_imports.get(obj) {\n                let qname = format!(\"{}.{}\", module, method);\n                if let Some(func) = index.lookup_qualified(&qname) {\n                    return Some(func.clone());\n                }\n            }\n\n            // Return first candidate as best guess\n            candidates.first().map(|f| (*f).clone())\n        }\n\n        CallTarget::Qualified(parts) => {\n            // Try full qualified name\n            let full_name = parts.join(\".\");\n            if let Some(func) = index.lookup_qualified(&full_name) {\n                return Some(func.clone());\n            }\n\n            // Try last component\n            if let Some(name) = parts.last() {\n                let candidates = index.lookup(name);\n                if candidates.len() == 1 {\n                    return Some(candidates[0].clone());\n                }\n\n                // Try to narrow down using module context\n                let module_prefix = parts[..parts.len() - 1].join(\".\");\n                for candidate in &candidates {\n                    if candidate\n                        .qualified_name\n                        .as_ref()\n                        .is_some_and(|q| q.starts_with(&module_prefix))\n                    {\n                        return Some((*candidate).clone());\n                    }\n                }\n\n                candidates.first().map(|f| (*f).clone())\n            } else {\n                None\n            }\n        }\n\n        CallTarget::Constructor(name) => {\n            // Constructor - look up the class/struct\n            let candidates = index.lookup(name);\n            if candidates.len() == 1 {\n                return Some(candidates[0].clone());\n            }\n            candidates.first().map(|f| (*f).clone())\n        }\n    }\n}\n",
      "semantic_tags": [
        "crud",
        "validation",
        "error_handling",
        "api_endpoint",
        "iteration",
        "config",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 6,
        "branches": 17,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 711
    },
    {
      "name": "node_text",
      "qualified_name": "src/callgraph/resolver.rs::node_text",
      "file": "src/callgraph/resolver.rs",
      "line": 1271,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn node_text(node: Node<'a>, source: &'a [u8]) -> &'a str",
      "docstring": "",
      "calls": [
        "decode_text",
        "get_text",
        "node_text"
      ],
      "called_by": [
        "C.extract_type",
        "Language.extract_class",
        "Language.extract_class",
        "Language.extract_function",
        "extract_function_impl"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn node_text<'a>(node: Node<'a>, source: &'a [u8]) -> &'a str {\n    std::str::from_utf8(&source[node.start_byte()..node.end_byte()]).unwrap_or(\"\")\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 49
    },
    {
      "name": "child_by_kind",
      "qualified_name": "src/callgraph/resolver.rs::child_by_kind",
      "file": "src/callgraph/resolver.rs",
      "line": 1276,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn child_by_kind(node: Node<'a>, kind: &str) -> Option<Node<'a>>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "process_for",
        "Python.extract_bases",
        "Python.extract_class_impl",
        "extract_params",
        "collect_rust_calls"
      ],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:8, def-use chains:4",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn child_by_kind<'a>(node: Node<'a>, kind: &str) -> Option<Node<'a>> {\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        if child.kind() == kind {\n            return Some(child);\n        }\n    }\n    None\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 65
    },
    {
      "name": "get_child_text",
      "qualified_name": "src/callgraph/resolver.rs::get_child_text",
      "file": "src/callgraph/resolver.rs",
      "line": 1287,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn get_child_text(node: Node, kind: &str, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [
        "child_by_kind",
        "node_text"
      ],
      "called_by": [
        "collect_python_calls",
        "collect_ts_definitions",
        "collect_go_definitions",
        "collect_ts_calls",
        "extract_java_call_target"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn get_child_text(node: Node, kind: &str, source: &[u8]) -> Option<String> {\n    child_by_kind(node, kind).map(|n| node_text(n, source).to_string())\n}\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 46
    },
    {
      "name": "extract_attribute_chain",
      "qualified_name": "src/callgraph/resolver.rs::extract_attribute_chain",
      "file": "src/callgraph/resolver.rs",
      "line": 1292,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_attribute_chain(node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [
        "extract_attribute_chain",
        "node_text"
      ],
      "called_by": [
        "extract_attribute_chain",
        "extract_python_call_target"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:8, def-use chains:8",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_attribute_chain(node: Node, source: &[u8]) -> Vec<String> {\n    let mut parts = Vec::new();\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        match child.kind() {\n            \"identifier\" => {\n                parts.push(node_text(child, source).to_string());\n            }\n            \"attribute\" => {\n                parts.extend(extract_attribute_chain(child, source));\n            }\n            _ => {}\n        }\n    }\n\n    parts\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 104
    },
    {
      "name": "extract_member_expression_chain",
      "qualified_name": "src/callgraph/resolver.rs::extract_member_expression_chain",
      "file": "src/callgraph/resolver.rs",
      "line": 1312,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn extract_member_expression_chain(node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [
        "extract_member_expression_chain",
        "node_text"
      ],
      "called_by": [
        "extract_ts_call_target",
        "extract_member_expression_chain"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:8, def-use chains:9",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "fn extract_member_expression_chain(node: Node, source: &[u8]) -> Vec<String> {\n    let mut parts = Vec::new();\n\n    let mut cursor = node.walk();\n    for child in node.children(&mut cursor) {\n        match child.kind() {\n            \"identifier\" | \"property_identifier\" => {\n                parts.push(node_text(child, source).to_string());\n            }\n            \"member_expression\" => {\n                parts.extend(extract_member_expression_chain(child, source));\n            }\n            \"this\" => {\n                parts.push(\"this\".to_string());\n            }\n            _ => {}\n        }\n    }\n\n    parts\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 129
    },
    {
      "name": "setup_test_project",
      "qualified_name": "src/callgraph/resolver.rs::setup_test_project",
      "file": "src/callgraph/resolver.rs",
      "line": 1341,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn setup_test_project() -> TempDir",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_resolve_calls_basic"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:8",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "    fn setup_test_project() -> TempDir {\n        let dir = TempDir::new().unwrap();\n        let root = dir.path();\n\n        // Create a Python file with function calls\n        let py_content = r#\"\nfrom utils import helper\nimport os\n\ndef foo():\n    bar()\n    helper()\n    os.path.join(\"a\", \"b\")\n\ndef bar():\n    pass\n\"#;\n        let mut f = File::create(root.join(\"main.py\")).unwrap();\n        f.write_all(py_content.as_bytes()).unwrap();\n\n        // Create utils.py\n        let utils_content = r#\"\ndef helper():\n    pass\n\"#;\n        let mut f = File::create(root.join(\"utils.py\")).unwrap();\n        f.write_all(utils_content.as_bytes()).unwrap();\n\n        dir\n    }\n",
      "semantic_tags": [
        "crud",
        "transform"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 162
    },
    {
      "name": "test_resolve_calls_basic",
      "qualified_name": "src/callgraph/resolver.rs::test_resolve_calls_basic",
      "file": "src/callgraph/resolver.rs",
      "line": 1373,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_resolve_calls_basic() -> bar edge\n        let has_foo_bar = graph\n            .edges\n            .iter()\n            .any(|e| e.caller.name == \"foo\" && e.callee.name == \"bar\");\n        assert!(has_foo_bar, \"Should find foo",
      "docstring": "",
      "calls": [
        "resolve_calls",
        "setup_test_project"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:17, def-use chains:8",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "    fn test_resolve_calls_basic() {\n        let dir = setup_test_project();\n        let files = vec![dir.path().join(\"main.py\"), dir.path().join(\"utils.py\")];\n\n        let index = FunctionIndex::build(&files).unwrap();\n        let graph = resolve_calls(&files, &index).unwrap();\n\n        // Should have edges from foo to bar and helper\n        assert!(!graph.edges.is_empty());\n\n        // Check that we found the foo -> bar edge\n        let has_foo_bar = graph\n            .edges\n            .iter()\n            .any(|e| e.caller.name == \"foo\" && e.callee.name == \"bar\");\n        assert!(has_foo_bar, \"Should find foo -> bar edge\");\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 157
    },
    {
      "name": "test_call_target_variants",
      "qualified_name": "src/callgraph/resolver.rs::test_call_target_variants",
      "file": "src/callgraph/resolver.rs",
      "line": 1392,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_call_target_variants()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:4",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "    fn test_call_target_variants() {\n        // Test that all CallTarget variants are handled\n        let target = CallTarget::Direct(\"test\".to_string());\n        assert!(matches!(target, CallTarget::Direct(_)));\n\n        let target = CallTarget::Method(\"obj\".to_string(), \"method\".to_string());\n        assert!(matches!(target, CallTarget::Method(_, _)));\n\n        let target = CallTarget::Qualified(vec![\"a\".to_string(), \"b\".to_string()]);\n        assert!(matches!(target, CallTarget::Qualified(_)));\n\n        let target = CallTarget::Constructor(\"MyClass\".to_string());\n        assert!(matches!(target, CallTarget::Constructor(_)));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 146
    },
    {
      "name": "CallSite",
      "qualified_name": "src/callgraph/resolver.rs::CallSite",
      "file": "src/callgraph/resolver.rs",
      "line": 31,
      "language": "rust",
      "unit_type": "class",
      "signature": "class CallSite",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "struct CallSite {\n    /// Name of the calling function (None for module-level calls)\n    caller_name: Option<String>,\n    /// Call target (function name or qualified path)\n    target: CallTarget,\n    /// Line number of the call\n    line: usize,\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 56
    },
    {
      "name": "FileContext",
      "qualified_name": "src/callgraph/resolver.rs::FileContext",
      "file": "src/callgraph/resolver.rs",
      "line": 55,
      "language": "rust",
      "unit_type": "class",
      "signature": "class FileContext",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "struct FileContext {\n    /// File path (relative to project root)\n    file_path: String,\n    /// Functions defined in this file\n    defined_functions: HashSet<String>,\n    /// Classes defined in this file\n    defined_classes: HashSet<String>,\n    /// Module imports: alias -> module_path\n    module_imports: HashMap<String, String>,\n    /// From imports: name -> (module, original_name)\n    from_imports: HashMap<String, (String, String)>,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 98
    },
    {
      "name": "FileCallInfo",
      "qualified_name": "src/callgraph/resolver.rs::FileCallInfo",
      "file": "src/callgraph/resolver.rs",
      "line": 70,
      "language": "rust",
      "unit_type": "class",
      "signature": "class FileCallInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, std, std::path, rayon::prelude, tree_sitter",
      "code_preview": "struct FileCallInfo {\n    /// File path\n    file_path: String,\n    /// All call sites found\n    call_sites: Vec<CallSite>,\n    /// Context for resolution\n    context: FileContext,\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 45
    },
    {
      "name": "(ModelType) from",
      "qualified_name": "src/embedding/tei_client.rs::(ModelType) from",
      "file": "src/embedding/tei_client.rs",
      "line": 86,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (ModelType) from(val: i32) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    fn from(val: i32) -> Self {\n        match val {\n            0 => Self::Embedding,\n            1 => Self::Classifier,\n            2 => Self::Reranker,\n            _ => Self::Unknown,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 54
    },
    {
      "name": "(TeiClientConfig) default",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClientConfig) default",
      "file": "src/embedding/tei_client.rs",
      "line": 137,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TeiClientConfig) default() -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    fn default() -> Self {\n        Self {\n            endpoint: \"http://localhost:18080\".to_string(),\n            timeout_secs: 120,\n            max_retries: 3,\n            retry_base_delay_ms: 100,\n            retry_max_delay_ms: 5000,\n            batch_token_budget: 8192,\n            keepalive_secs: 30,\n        }\n    }\n",
      "semantic_tags": [
        "api_endpoint"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 91
    },
    {
      "name": "(TeiClientConfig) from_env",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClientConfig) from_env",
      "file": "src/embedding/tei_client.rs",
      "line": 156,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TeiClientConfig) from_env() -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub fn from_env() -> Self {\n        let host = std::env::var(\"TLDR_TEI_HOST\").unwrap_or_else(|_| \"localhost\".to_string());\n        let port = std::env::var(\"TLDR_TEI_PORT\")\n            .ok()\n            .and_then(|p| p.parse().ok())\n            .unwrap_or(18080u16);\n\n        Self {\n            endpoint: format!(\"http://{host}:{port}\"),\n            ..Default::default()\n        }\n    }\n",
      "semantic_tags": [
        "validation",
        "api_endpoint",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 107
    },
    {
      "name": "(TeiClient) new",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) new",
      "file": "src/embedding/tei_client.rs",
      "line": 208,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) new(endpoint: &str) -> Result<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub async fn new(endpoint: &str) -> Result<Self> {\n        let config = TeiClientConfig {\n            endpoint: endpoint.to_string(),\n            ..Default::default()\n        };\n        Self::with_config(config).await\n    }\n",
      "semantic_tags": [
        "async_ops",
        "api_endpoint",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 50
    },
    {
      "name": "(TeiClient) with_config",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) with_config",
      "file": "src/embedding/tei_client.rs",
      "line": 217,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) with_config(config: TeiClientConfig) -> Result<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub async fn with_config(config: TeiClientConfig) -> Result<Self> {\n        let channel = Self::create_channel(&config).await?;\n\n        Ok(Self {\n            config,\n            channel,\n            server_info: RwLock::new(None),\n        })\n    }\n",
      "semantic_tags": [
        "async_ops",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 55
    },
    {
      "name": "(TeiClient) from_env",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) from_env",
      "file": "src/embedding/tei_client.rs",
      "line": 230,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) from_env() -> Result<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub async fn from_env() -> Result<Self> {\n        Self::with_config(TeiClientConfig::from_env()).await\n    }\n",
      "semantic_tags": [
        "async_ops"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 29
    },
    {
      "name": "(TeiClient) create_channel",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) create_channel",
      "file": "src/embedding/tei_client.rs",
      "line": 235,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) create_channel(config: &TeiClientConfig) -> Result<Channel>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    async fn create_channel(config: &TeiClientConfig) -> Result<Channel> {\n        let endpoint = Endpoint::from_shared(config.endpoint.clone())\n            .map_err(|e| TeiError::Config(e.to_string()))?\n            .timeout(Duration::from_secs(config.timeout_secs))\n            .tcp_keepalive(Some(Duration::from_secs(config.keepalive_secs)))\n            .http2_keep_alive_interval(Duration::from_secs(config.keepalive_secs))\n            .keep_alive_timeout(Duration::from_secs(10))\n            .connect_timeout(Duration::from_secs(10));\n\n        endpoint\n            .connect()\n            .await\n            .map_err(|e| TeiError::Connection(e.to_string()))\n    }\n",
      "semantic_tags": [
        "async_ops",
        "api_endpoint",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 144
    },
    {
      "name": "(TeiClient) info",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) info",
      "file": "src/embedding/tei_client.rs",
      "line": 251,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) info(&self) -> Result<ServerInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub async fn info(&self) -> Result<ServerInfo> {\n        let mut client = InfoClient::new(self.channel.clone());\n        let response = client.info(InfoRequest {}).await?;\n        let info = response.into_inner();\n\n        Ok(ServerInfo {\n            model_id: info.model_id,\n            model_type: ModelType::from(info.model_type),\n            max_input_length: info.max_input_length,\n            max_batch_tokens: info.max_batch_tokens,\n            max_batch_requests: info.max_batch_requests,\n            max_client_batch_size: info.max_client_batch_size,\n            tokenization_workers: info.tokenization_workers,\n        })\n    }\n",
      "semantic_tags": [
        "async_ops",
        "logging",
        "api_endpoint"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 129
    },
    {
      "name": "(TeiClient) embed",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) embed",
      "file": "src/embedding/tei_client.rs",
      "line": 276,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) embed(&self, texts: &[&str]) -> Result<Vec<Vec<f32>>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub async fn embed(&self, texts: &[&str]) -> Result<Vec<Vec<f32>>> {\n        self.embed_with_options(texts, true, true, None).await\n    }\n",
      "semantic_tags": [
        "async_ops"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 41
    },
    {
      "name": "(TeiClient) embed_with_options",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) embed_with_options",
      "file": "src/embedding/tei_client.rs",
      "line": 288,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) embed_with_options(&self, texts: &[&str], normalize: bool, truncate: bool, dimensions: Option<u32>) -> Result<Vec<Vec<f32>>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub async fn embed_with_options(\n        &self,\n        texts: &[&str],\n        normalize: bool,\n        truncate: bool,\n        dimensions: Option<u32>,\n    ) -> Result<Vec<Vec<f32>>> {\n        if texts.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        // Use streaming for multiple texts with retry logic at batch level\n        self.embed_stream_with_retry(texts, normalize, truncate, dimensions)\n            .await\n    }\n",
      "semantic_tags": [
        "async_ops",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 99
    },
    {
      "name": "(TeiClient) embed_stream_with_retry",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) embed_stream_with_retry",
      "file": "src/embedding/tei_client.rs",
      "line": 307,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) embed_stream_with_retry(&self, texts: &[&str], normalize: bool, truncate: bool, dimensions: Option<u32>) -> Result<Vec<Vec<f32>>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    async fn embed_stream_with_retry(\n        &self,\n        texts: &[&str],\n        normalize: bool,\n        truncate: bool,\n        dimensions: Option<u32>,\n    ) -> Result<Vec<Vec<f32>>> {\n        let mut attempt = 0;\n        let mut last_error = None;\n\n        while attempt < self.config.max_retries {\n            match self\n                .embed_stream_once(texts, normalize, truncate, dimensions)\n                .await\n            {\n                Ok(results) => return Ok(results),\n                Err(TeiError::Grpc(status)) => {\n                    // Don't retry on certain error codes\n                    match status.code() {\n                        tonic::Code::InvalidArgument\n                        | tonic::Code::NotFound\n                        | tonic::Code::AlreadyExists\n                        | tonic::Code::PermissionDenied\n                        | tonic::Code::Unauthenticated => {\n                            return Err(TeiError::Grpc(status));\n                        }\n                        _ => {\n                            last_error = Some(status.to_string());\n                        }\n                    }\n                }\n                Err(e) => {\n                    last_error = Some(e.to_string());\n                }\n            }\n\n            attempt += 1;\n\n            if attempt < self.config.max_retries {\n                let base_delay = self.config.retry_base_delay_ms * (1 << attempt.min(6));\n                let delay = base_delay.min(self.config.retry_max_delay_ms);\n                let jitter = (delay / 4) * (attempt as u64 % 4);\n                tokio::time::sleep(Duration::from_millis(delay + jitter)).await;\n            }\n        }\n\n        Err(TeiError::RetryExhausted(\n            last_error.unwrap_or_else(|| \"Unknown error\".to_string()),\n        ))\n    }\n",
      "semantic_tags": [
        "validation",
        "logging",
        "error_handling",
        "async_ops",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 7,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 352
    },
    {
      "name": "(TeiClient) embed_stream_once",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) embed_stream_once",
      "file": "src/embedding/tei_client.rs",
      "line": 359,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) embed_stream_once(&self, texts: &[&str], normalize: bool, truncate: bool, dimensions: Option<u32>) -> Result<Vec<Vec<f32>>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    async fn embed_stream_once(\n        &self,\n        texts: &[&str],\n        normalize: bool,\n        truncate: bool,\n        dimensions: Option<u32>,\n    ) -> Result<Vec<Vec<f32>>> {\n        let mut client = EmbedClient::new(self.channel.clone());\n\n        // Create request stream - fresh for each attempt\n        let requests: Vec<EmbedRequest> = texts\n            .iter()\n            .map(|text| EmbedRequest {\n                inputs: (*text).to_string(),\n                truncate,\n                normalize,\n                truncation_direction: TruncationDirection::Right.into(),\n                prompt_name: None,\n                dimensions,\n            })\n            .collect();\n\n        let request_stream = tokio_stream::iter(requests);\n        let response = client.embed_stream(request_stream).await?;\n\n        let mut results = Vec::with_capacity(texts.len());\n        let mut stream = response.into_inner();\n\n        use tokio_stream::StreamExt;\n        while let Some(resp) = stream.next().await {\n            let resp = resp?;\n            results.push(resp.embeddings);\n        }\n\n        Ok(results)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "api_endpoint",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 228
    },
    {
      "name": "(TeiClient) embed_batch",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) embed_batch",
      "file": "src/embedding/tei_client.rs",
      "line": 410,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) embed_batch(&self, texts: &[&str], batch_size: Option<usize>) -> Result<Vec<Vec<f32>>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub async fn embed_batch(\n        &self,\n        texts: &[&str],\n        batch_size: Option<usize>,\n    ) -> Result<Vec<Vec<f32>>> {\n        if texts.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        // Get or fetch server info for batching decisions\n        let server_info = self.get_cached_server_info().await?;\n        let max_batch = batch_size\n            .unwrap_or(server_info.max_client_batch_size as usize)\n            .min(server_info.max_client_batch_size as usize);\n\n        // Count tokens for each text to optimize batching\n        let token_counts = self.count_tokens_batch(texts).await?;\n        let token_budget = self.config.batch_token_budget;\n\n        // Build batches based on token budget\n        let batches = Self::build_token_batches(texts, &token_counts, token_budget, max_batch);\n\n        // Process batches\n        let mut all_results = Vec::with_capacity(texts.len());\n\n        for batch in batches {\n            let batch_results = self.embed(&batch).await?;\n            all_results.extend(batch_results);\n        }\n\n        Ok(all_results)\n    }\n",
      "semantic_tags": [
        "crud",
        "auth",
        "logging",
        "async_ops",
        "api_endpoint",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 229
    },
    {
      "name": "(TeiClient) build_token_batches",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) build_token_batches",
      "file": "src/embedding/tei_client.rs",
      "line": 447,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TeiClient) build_token_batches(texts: &[&'a str], token_counts: &[usize], token_budget: usize, max_batch: usize) -> Vec<Vec<&'a str>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    fn build_token_batches<'a>(\n        texts: &[&'a str],\n        token_counts: &[usize],\n        token_budget: usize,\n        max_batch: usize,\n    ) -> Vec<Vec<&'a str>> {\n        let mut batches = Vec::new();\n        let mut current_batch = Vec::new();\n        let mut current_tokens = 0usize;\n\n        for (text, &count) in texts.iter().zip(token_counts.iter()) {\n            // Start new batch if adding this text would exceed budget\n            // or if we've hit the max batch size\n            if !current_batch.is_empty()\n                && (current_tokens + count > token_budget || current_batch.len() >= max_batch)\n            {\n                batches.push(std::mem::take(&mut current_batch));\n                current_tokens = 0;\n            }\n\n            current_batch.push(*text);\n            current_tokens += count;\n        }\n\n        // Don't forget the last batch\n        if !current_batch.is_empty() {\n            batches.push(current_batch);\n        }\n\n        batches\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 216
    },
    {
      "name": "(TeiClient) tokenize",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) tokenize",
      "file": "src/embedding/tei_client.rs",
      "line": 480,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) tokenize(&self, text: &str, add_special_tokens: bool) -> Result<Vec<Token>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub async fn tokenize(&self, text: &str, add_special_tokens: bool) -> Result<Vec<Token>> {\n        let client = TokenizeClient::new(self.channel.clone());\n\n        let request = EncodeRequest {\n            inputs: text.to_string(),\n            add_special_tokens,\n            prompt_name: None,\n        };\n\n        let response = self\n            .with_retry(|| async {\n                let mut client = client.clone();\n                client.tokenize(request.clone()).await\n            })\n            .await?;\n\n        let tokens = response\n            .into_inner()\n            .tokens\n            .into_iter()\n            .map(|t| Token {\n                id: t.id,\n                text: t.text,\n                special: t.special,\n                start: t.start,\n                stop: t.stop,\n            })\n            .collect();\n\n        Ok(tokens)\n    }\n",
      "semantic_tags": [
        "auth",
        "async_ops",
        "api_endpoint",
        "iteration",
        "transform"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 170
    },
    {
      "name": "(TeiClient) count_tokens",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) count_tokens",
      "file": "src/embedding/tei_client.rs",
      "line": 513,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) count_tokens(&self, text: &str) -> Result<usize>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub async fn count_tokens(&self, text: &str) -> Result<usize> {\n        let tokens = self.tokenize(text, false).await?;\n        Ok(tokens.len())\n    }\n",
      "semantic_tags": [
        "async_ops"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 38
    },
    {
      "name": "(TeiClient) count_tokens_batch",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) count_tokens_batch",
      "file": "src/embedding/tei_client.rs",
      "line": 519,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) count_tokens_batch(&self, texts: &[&str]) -> Result<Vec<usize>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub async fn count_tokens_batch(&self, texts: &[&str]) -> Result<Vec<usize>> {\n        if texts.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        self.count_tokens_batch_with_retry(texts).await\n    }\n",
      "semantic_tags": [
        "async_ops"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 52
    },
    {
      "name": "(TeiClient) count_tokens_batch_with_retry",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) count_tokens_batch_with_retry",
      "file": "src/embedding/tei_client.rs",
      "line": 528,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) count_tokens_batch_with_retry(&self, texts: &[&str]) -> Result<Vec<usize>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    async fn count_tokens_batch_with_retry(&self, texts: &[&str]) -> Result<Vec<usize>> {\n        let mut attempt = 0;\n        let mut last_error = None;\n\n        while attempt < self.config.max_retries {\n            match self.count_tokens_batch_once(texts).await {\n                Ok(counts) => return Ok(counts),\n                Err(TeiError::Grpc(status)) => match status.code() {\n                    tonic::Code::InvalidArgument\n                    | tonic::Code::NotFound\n                    | tonic::Code::AlreadyExists\n                    | tonic::Code::PermissionDenied\n                    | tonic::Code::Unauthenticated => {\n                        return Err(TeiError::Grpc(status));\n                    }\n                    _ => {\n                        last_error = Some(status.to_string());\n                    }\n                },\n                Err(e) => {\n                    last_error = Some(e.to_string());\n                }\n            }\n\n            attempt += 1;\n\n            if attempt < self.config.max_retries {\n                let base_delay = self.config.retry_base_delay_ms * (1 << attempt.min(6));\n                let delay = base_delay.min(self.config.retry_max_delay_ms);\n                let jitter = (delay / 4) * (attempt as u64 % 4);\n                tokio::time::sleep(Duration::from_millis(delay + jitter)).await;\n            }\n        }\n\n        Err(TeiError::RetryExhausted(\n            last_error.unwrap_or_else(|| \"Unknown error\".to_string()),\n        ))\n    }\n",
      "semantic_tags": [
        "logging",
        "error_handling",
        "async_ops",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 6,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 303
    },
    {
      "name": "(TeiClient) count_tokens_batch_once",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) count_tokens_batch_once",
      "file": "src/embedding/tei_client.rs",
      "line": 568,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) count_tokens_batch_once(&self, texts: &[&str]) -> Result<Vec<usize>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    async fn count_tokens_batch_once(&self, texts: &[&str]) -> Result<Vec<usize>> {\n        let mut client = TokenizeClient::new(self.channel.clone());\n\n        let requests: Vec<EncodeRequest> = texts\n            .iter()\n            .map(|text| EncodeRequest {\n                inputs: (*text).to_string(),\n                add_special_tokens: false,\n                prompt_name: None,\n            })\n            .collect();\n\n        let request_stream = tokio_stream::iter(requests);\n        let response = client.tokenize_stream(request_stream).await?;\n\n        let mut counts = Vec::with_capacity(texts.len());\n        let mut stream = response.into_inner();\n\n        use tokio_stream::StreamExt;\n        while let Some(resp) = stream.next().await {\n            let resp = resp?;\n            counts.push(resp.tokens.len());\n        }\n\n        Ok(counts)\n    }\n",
      "semantic_tags": [
        "transform",
        "async_ops",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 179
    },
    {
      "name": "(TeiClient) is_available",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) is_available",
      "file": "src/embedding/tei_client.rs",
      "line": 596,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) is_available(&self) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    pub async fn is_available(&self) -> bool {\n        self.info().await.is_ok()\n    }\n",
      "semantic_tags": [
        "async_ops",
        "logging"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 22
    },
    {
      "name": "(TeiClient) get_cached_server_info",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) get_cached_server_info",
      "file": "src/embedding/tei_client.rs",
      "line": 601,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) get_cached_server_info(&self) -> Result<ServerInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    async fn get_cached_server_info(&self) -> Result<ServerInfo> {\n        // Try to read from cache first\n        {\n            let cache = self.server_info.read().await;\n            if let Some(ref info) = *cache {\n                return Ok(info.clone());\n            }\n        }\n\n        // Fetch and cache\n        let info = self.info().await?;\n        {\n            let mut cache = self.server_info.write().await;\n            *cache = Some(info.clone());\n        }\n\n        Ok(info)\n    }\n",
      "semantic_tags": [
        "crud",
        "logging",
        "error_handling",
        "async_ops",
        "cache"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 105
    },
    {
      "name": "(TeiClient) with_retry",
      "qualified_name": "src/embedding/tei_client.rs::(TeiClient) with_retry",
      "file": "src/embedding/tei_client.rs",
      "line": 621,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn (TeiClient) with_retry(&self, operation: F) -> Result<T>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    async fn with_retry<F, Fut, T>(&self, operation: F) -> Result<T>\n    where\n        F: Fn() -> Fut,\n        Fut: std::future::Future<Output = std::result::Result<T, tonic::Status>>,\n    {\n        let mut attempt = 0;\n        let mut last_error = None;\n\n        while attempt < self.config.max_retries {\n            match operation().await {\n                Ok(result) => return Ok(result),\n                Err(status) => {\n                    // Don't retry on certain error codes\n                    match status.code() {\n                        tonic::Code::InvalidArgument\n                        | tonic::Code::NotFound\n                        | tonic::Code::AlreadyExists\n                        | tonic::Code::PermissionDenied\n                        | tonic::Code::Unauthenticated => {\n                            return Err(TeiError::Grpc(status));\n                        }\n                        _ => {\n                            last_error = Some(status);\n                        }\n                    }\n                }\n            }\n\n            attempt += 1;\n\n            if attempt < self.config.max_retries {\n                // Exponential backoff with jitter\n                let base_delay = self.config.retry_base_delay_ms * (1 << attempt.min(6));\n                let delay = base_delay.min(self.config.retry_max_delay_ms);\n                // Add some jitter (0-25% of delay)\n                let jitter = (delay / 4) * (attempt as u64 % 4);\n                tokio::time::sleep(Duration::from_millis(delay + jitter)).await;\n            }\n        }\n\n        Err(TeiError::RetryExhausted(\n            last_error\n                .map(|e| e.to_string())\n                .unwrap_or_else(|| \"Unknown error\".to_string()),\n        ))\n    }\n",
      "semantic_tags": [
        "crud",
        "logging",
        "error_handling",
        "async_ops",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 7,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 353
    },
    {
      "name": "test_config_default",
      "qualified_name": "src/embedding/tei_client.rs::test_config_default",
      "file": "src/embedding/tei_client.rs",
      "line": 678,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_config_default()",
      "docstring": "",
      "calls": [
        "default"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:3",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    fn test_config_default() {\n        let config = TeiClientConfig::default();\n        assert_eq!(config.endpoint, \"http://localhost:18080\");\n        assert_eq!(config.timeout_secs, 120);\n        assert_eq!(config.max_retries, 3);\n    }\n",
      "semantic_tags": [
        "api_endpoint",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 63
    },
    {
      "name": "test_model_type_from_i32",
      "qualified_name": "src/embedding/tei_client.rs::test_model_type_from_i32",
      "file": "src/embedding/tei_client.rs",
      "line": 686,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_model_type_from_i32()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:0",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    fn test_model_type_from_i32() {\n        assert_eq!(ModelType::from(0), ModelType::Embedding);\n        assert_eq!(ModelType::from(1), ModelType::Classifier);\n        assert_eq!(ModelType::from(2), ModelType::Reranker);\n        assert_eq!(ModelType::from(99), ModelType::Unknown);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 81
    },
    {
      "name": "test_build_token_batches_simple",
      "qualified_name": "src/embedding/tei_client.rs::test_build_token_batches_simple",
      "file": "src/embedding/tei_client.rs",
      "line": 694,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_token_batches_simple()",
      "docstring": "",
      "calls": [
        "build_token_batches"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:5",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    fn test_build_token_batches_simple() {\n        let texts = vec![\"a\", \"b\", \"c\", \"d\"];\n        let token_counts = vec![100, 100, 100, 100];\n\n        // With budget of 250, should get batches of 2\n        let batches = TeiClient::build_token_batches(&texts, &token_counts, 250, 100);\n        assert_eq!(batches.len(), 2);\n        assert_eq!(batches[0], vec![\"a\", \"b\"]);\n        assert_eq!(batches[1], vec![\"c\", \"d\"]);\n    }\n",
      "semantic_tags": [
        "crud",
        "test",
        "api_endpoint"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 145
    },
    {
      "name": "test_build_token_batches_max_size",
      "qualified_name": "src/embedding/tei_client.rs::test_build_token_batches_max_size",
      "file": "src/embedding/tei_client.rs",
      "line": 706,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_token_batches_max_size()",
      "docstring": "",
      "calls": [
        "build_token_batches"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:6",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    fn test_build_token_batches_max_size() {\n        let texts = vec![\"a\", \"b\", \"c\", \"d\", \"e\"];\n        let token_counts = vec![10, 10, 10, 10, 10];\n\n        // With large budget but max_batch of 2\n        let batches = TeiClient::build_token_batches(&texts, &token_counts, 10000, 2);\n        assert_eq!(batches.len(), 3);\n        assert_eq!(batches[0], vec![\"a\", \"b\"]);\n        assert_eq!(batches[1], vec![\"c\", \"d\"]);\n        assert_eq!(batches[2], vec![\"e\"]);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 158
    },
    {
      "name": "test_build_token_batches_empty",
      "qualified_name": "src/embedding/tei_client.rs::test_build_token_batches_empty",
      "file": "src/embedding/tei_client.rs",
      "line": 719,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_token_batches_empty()",
      "docstring": "",
      "calls": [
        "build_token_batches"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:3",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    fn test_build_token_batches_empty() {\n        let texts: Vec<&str> = vec![];\n        let token_counts: Vec<usize> = vec![];\n\n        let batches = TeiClient::build_token_batches(&texts, &token_counts, 1000, 10);\n        assert!(batches.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 71
    },
    {
      "name": "test_build_token_batches_single_large",
      "qualified_name": "src/embedding/tei_client.rs::test_build_token_batches_single_large",
      "file": "src/embedding/tei_client.rs",
      "line": 728,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_token_batches_single_large()",
      "docstring": "",
      "calls": [
        "build_token_batches"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:4",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "    fn test_build_token_batches_single_large() {\n        let texts = vec![\"large\"];\n        let token_counts = vec![5000];\n\n        // Single text exceeding budget should still be in its own batch\n        let batches = TeiClient::build_token_batches(&texts, &token_counts, 1000, 10);\n        assert_eq!(batches.len(), 1);\n        assert_eq!(batches[0], vec![\"large\"]);\n    }\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 100
    },
    {
      "name": "ServerInfo",
      "qualified_name": "src/embedding/tei_client.rs::ServerInfo",
      "file": "src/embedding/tei_client.rs",
      "line": 66,
      "language": "rust",
      "unit_type": "class",
      "signature": "class ServerInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "pub struct ServerInfo {\n    pub model_id: String,\n    pub model_type: ModelType,\n    pub max_input_length: u32,\n    pub max_batch_tokens: u32,\n    pub max_batch_requests: Option<u32>,\n    pub max_client_batch_size: u32,\n    pub tokenization_workers: u32,\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 73
    },
    {
      "name": "Token",
      "qualified_name": "src/embedding/tei_client.rs::Token",
      "file": "src/embedding/tei_client.rs",
      "line": 98,
      "language": "rust",
      "unit_type": "class",
      "signature": "class Token",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "pub struct Token {\n    pub id: u32,\n    pub text: String,\n    pub special: bool,\n    pub start: Option<u32>,\n    pub stop: Option<u32>,\n}\n",
      "semantic_tags": [
        "auth",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 43
    },
    {
      "name": "TeiClientConfig",
      "qualified_name": "src/embedding/tei_client.rs::TeiClientConfig",
      "file": "src/embedding/tei_client.rs",
      "line": 112,
      "language": "rust",
      "unit_type": "class",
      "signature": "class TeiClientConfig",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "pub struct TeiClientConfig {\n    /// Server endpoint (e.g., \"http://localhost:18080\")\n    pub endpoint: String,\n\n    /// Request timeout in seconds.\n    pub timeout_secs: u64,\n\n    /// Maximum retry attempts for failed requests.\n    pub max_retries: u32,\n\n    /// Base delay for exponential backoff (milliseconds).\n    pub retry_base_delay_ms: u64,\n\n    /// Maximum delay for exponential backoff (milliseconds).\n    pub retry_max_delay_ms: u64,\n\n    /// Token budget per batch (for batching optimization).\n    /// TEI batches by total tokens, not by request count.\n    pub batch_token_budget: usize,\n\n    /// Keep-alive interval in seconds.\n    pub keepalive_secs: u64,\n}\n",
      "semantic_tags": [
        "auth",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 164
    },
    {
      "name": "TeiClient",
      "qualified_name": "src/embedding/tei_client.rs::TeiClient",
      "file": "src/embedding/tei_client.rs",
      "line": 182,
      "language": "rust",
      "unit_type": "class",
      "signature": "class TeiClient",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::time, thiserror, tokio::sync, tonic::transport, tei_proto",
      "code_preview": "pub struct TeiClient {\n    config: TeiClientConfig,\n    channel: Channel,\n    // Cached server info for batching decisions\n    server_info: RwLock<Option<ServerInfo>>,\n}\n",
      "semantic_tags": [
        "logging",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 40
    },
    {
      "name": "(Go) decode_text",
      "qualified_name": "src/lang/go.rs::(Go) decode_text",
      "file": "src/lang/go.rs",
      "line": 30,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) decode_text(&self, source: &'a [u8], node: Node) -> &'a str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn decode_text<'a>(&self, source: &'a [u8], node: Node) -> &'a str {\n        let bytes = &source[node.start_byte()..node.end_byte()];\n        std::str::from_utf8(bytes).unwrap_or(\"\")\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 56
    },
    {
      "name": "(Go) node_text",
      "qualified_name": "src/lang/go.rs::(Go) node_text",
      "file": "src/lang/go.rs",
      "line": 36,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) node_text(&self, source: &[u8], node: Node) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn node_text(&self, source: &[u8], node: Node) -> String {\n        self.decode_text(source, node).to_string()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 33
    },
    {
      "name": "(Go) child_by_field",
      "qualified_name": "src/lang/go.rs::(Go) child_by_field",
      "file": "src/lang/go.rs",
      "line": 41,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) child_by_field(&self, node: Node<'a>, field: &str) -> Option<Node<'a>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn child_by_field<'a>(&self, node: Node<'a>, field: &str) -> Option<Node<'a>> {\n        node.child_by_field_name(field)\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 38
    },
    {
      "name": "(Go) get_doc_comment",
      "qualified_name": "src/lang/go.rs::(Go) get_doc_comment",
      "file": "src/lang/go.rs",
      "line": 47,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) get_doc_comment(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn get_doc_comment(&self, node: Node, source: &[u8]) -> Option<String> {\n        // Look for comment nodes that immediately precede this node\n        let mut comments = Vec::new();\n        let start_row = node.start_position().row;\n\n        // Walk backwards through siblings to find comments\n        if let Some(parent) = node.parent() {\n            let mut found_self = false;\n            let child_count = parent.child_count();\n\n            for i in (0..child_count).rev() {\n                if let Some(sibling) = parent.child(i as u32) {\n                    if sibling.id() == node.id() {\n                        found_self = true;\n                        continue;\n                    }\n\n                    if found_self && sibling.kind() == \"comment\" {\n                        // Check if comment is adjacent (within 1 line)\n                        let comment_end_row = sibling.end_position().row;\n                        if start_row.saturating_sub(1) <= comment_end_row + comments.len() {\n                            let text = self.decode_text(source, sibling);\n                            // Remove // prefix\n                            let cleaned = text.strip_prefix(\"//\").unwrap_or(text).trim();\n                            comments.push(cleaned.to_string());\n                        } else {\n                            break;\n                        }\n                    } else if found_self && sibling.kind() != \"comment\" {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if comments.is_empty() {\n            None\n        } else {\n            comments.reverse();\n            Some(comments.join(\"\\n\"))\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 7,
        "branches": 11,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 308
    },
    {
      "name": "(Go) extract_param_list",
      "qualified_name": "src/lang/go.rs::(Go) extract_param_list",
      "file": "src/lang/go.rs",
      "line": 92,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_param_list(&self, node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_param_list(&self, node: Node, source: &[u8]) -> Vec<String> {\n        let mut params = Vec::new();\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"parameter_declaration\" {\n                let param_text = self.extract_parameter_declaration(child, source);\n                if !param_text.is_empty() {\n                    params.push(param_text);\n                }\n            }\n        }\n\n        params\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 101
    },
    {
      "name": "(Go) extract_parameter_declaration",
      "qualified_name": "src/lang/go.rs::(Go) extract_parameter_declaration",
      "file": "src/lang/go.rs",
      "line": 110,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_parameter_declaration(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_parameter_declaration(&self, node: Node, source: &[u8]) -> String {\n        let mut names = Vec::new();\n        let mut type_str = String::new();\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"identifier\" | \"field_identifier\" => {\n                    names.push(self.node_text(source, child));\n                }\n                // Type nodes - extract the full type text\n                \"type_identifier\" | \"pointer_type\" | \"array_type\" | \"slice_type\" | \"map_type\"\n                | \"channel_type\" | \"function_type\" | \"interface_type\" | \"struct_type\"\n                | \"qualified_type\" | \"generic_type\" => {\n                    type_str = self.node_text(source, child);\n                }\n                \"variadic_parameter_declaration\" => {\n                    // Handle ...type\n                    return self.node_text(source, child);\n                }\n                _ => {}\n            }\n        }\n\n        if names.is_empty() {\n            // Unnamed parameter, just type\n            type_str\n        } else {\n            // Named parameter(s)\n            format!(\"{} {}\", names.join(\", \"), type_str)\n        }\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 251
    },
    {
      "name": "(Go) extract_return_type",
      "qualified_name": "src/lang/go.rs::(Go) extract_return_type",
      "file": "src/lang/go.rs",
      "line": 145,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_return_type(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_return_type(&self, node: Node, source: &[u8]) -> Option<String> {\n        match node.kind() {\n            \"type_identifier\" | \"pointer_type\" | \"array_type\" | \"slice_type\" | \"map_type\"\n            | \"channel_type\" | \"function_type\" | \"interface_type\" | \"struct_type\"\n            | \"qualified_type\" | \"generic_type\" => Some(self.node_text(source, node)),\n            \"parameter_list\" => {\n                // Multiple or named returns: (int, error) or (result string, err error)\n                let params = self.extract_param_list(node, source);\n                if params.is_empty() {\n                    None\n                } else {\n                    Some(format!(\"({})\", params.join(\", \")))\n                }\n            }\n            _ => None,\n        }\n    }\n",
      "semantic_tags": [
        "validation",
        "logging",
        "error_handling",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 172
    },
    {
      "name": "(Go) extract_receiver",
      "qualified_name": "src/lang/go.rs::(Go) extract_receiver",
      "file": "src/lang/go.rs",
      "line": 165,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_receiver(&self, node: Node, source: &[u8]) -> Option<(String, String)>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_receiver(&self, node: Node, source: &[u8]) -> Option<(String, String)> {\n        let receiver_list = self.child_by_field(node, \"receiver\")?;\n        let mut cursor = receiver_list.walk();\n\n        for child in receiver_list.children(&mut cursor) {\n            if child.kind() == \"parameter_declaration\" {\n                let mut name = String::new();\n                let mut type_str = String::new();\n                let mut inner_cursor = child.walk();\n\n                for inner_child in child.children(&mut inner_cursor) {\n                    match inner_child.kind() {\n                        \"identifier\" => {\n                            name = self.node_text(source, inner_child);\n                        }\n                        \"pointer_type\" | \"type_identifier\" | \"generic_type\" => {\n                            type_str = self.node_text(source, inner_child);\n                        }\n                        _ => {}\n                    }\n                }\n\n                if !type_str.is_empty() {\n                    return Some((name, type_str));\n                }\n            }\n        }\n\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 7,
        "branches": 3,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 207
    },
    {
      "name": "(Go) build_go_cfg",
      "qualified_name": "src/lang/go.rs::(Go) build_go_cfg",
      "file": "src/lang/go.rs",
      "line": 197,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) build_go_cfg(&self, node: Node, source: &[u8], func_name: &str) -> CFGInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_go_cfg(&self, node: Node, source: &[u8], func_name: &str) -> CFGInfo {\n        let mut blocks = HashMap::new();\n        let mut edges = Vec::new();\n        let mut block_id = 0;\n        let mut exits = Vec::new();\n\n        // Entry block\n        let entry = BlockId(block_id);\n        blocks.insert(\n            entry,\n            CFGBlock {\n                id: entry,\n                label: \"entry\".to_string(),\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.start_position().row + 1,\n            },\n        );\n        block_id += 1;\n\n        // Find body block\n        if let Some(body) = self.child_by_field(node, \"body\") {\n            self.process_cfg_block(\n                body,\n                source,\n                &mut blocks,\n                &mut edges,\n                &mut block_id,\n                entry,\n                &mut exits,\n            );\n        }\n\n        // If no explicit exits, the entry block is also an exit\n        if exits.is_empty() {\n            exits.push(entry);\n        }\n\n        CFGInfo {\n            function_name: func_name.to_string(),\n            blocks,\n            edges,\n            entry,\n            exits,\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "database"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 268
    },
    {
      "name": "(Go) process_cfg_block",
      "qualified_name": "src/lang/go.rs::(Go) process_cfg_block",
      "file": "src/lang/go.rs",
      "line": 245,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) process_cfg_block(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, block_id: &mut usize, current_block: BlockId, exits: &mut Vec<BlockId>) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_cfg_block(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        block_id: &mut usize,\n        current_block: BlockId,\n        exits: &mut Vec<BlockId>,\n    ) -> BlockId {\n        let mut last_block = current_block;\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"return_statement\" => {\n                    // Create return block\n                    *block_id += 1;\n                    let ret_block = BlockId(*block_id);\n                    let stmt = self.node_text(source, child);\n\n                    blocks.insert(\n                        ret_block,\n                        CFGBlock {\n                            id: ret_block,\n                            label: format!(\"return: {}\", stmt.trim()),\n                            statements: vec![stmt],\n                            start_line: child.start_position().row + 1,\n                            end_line: child.end_position().row + 1,\n                        },\n                    );\n\n                    edges.push(CFGEdge {\n                        from: last_block,\n                        to: ret_block,\n                        label: None,\n                    });\n\n                    exits.push(ret_block);\n                    last_block = ret_block;\n                }\n                \"if_statement\" => {\n                    last_block = self\n                        .process_if_cfg(child, source, blocks, edges, block_id, last_block, exits);\n                }\n                \"for_statement\" => {\n                    last_block = self\n                        .process_for_cfg(child, source, blocks, edges, block_id, last_block, exits);\n                }\n                \"switch_statement\" | \"type_switch_statement\" => {\n                    last_block = self.process_switch_cfg(\n                        child, source, blocks, edges, block_id, last_block, exits,\n                    );\n                }\n                \"statement_list\" | \"block\" => {\n                    last_block = self.process_cfg_block(\n                        child, source, blocks, edges, block_id, last_block, exits,\n                    );\n                }\n                // Regular statements - add to current block\n                \"short_var_declaration\"\n                | \"assignment_statement\"\n                | \"expression_statement\"\n                | \"call_expression\"\n                | \"go_statement\"\n                | \"defer_statement\"\n                | \"send_statement\" => {\n                    if let Some(block) = blocks.get_mut(&last_block) {\n                        let stmt = self.node_text(source, child);\n                        block.statements.push(stmt);\n                        block.end_line = child.end_position().row + 1;\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        last_block\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 533
    },
    {
      "name": "(Go) process_if_cfg",
      "qualified_name": "src/lang/go.rs::(Go) process_if_cfg",
      "file": "src/lang/go.rs",
      "line": 326,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) process_if_cfg(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, block_id: &mut usize, current_block: BlockId, exits: &mut Vec<BlockId>) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_if_cfg(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        block_id: &mut usize,\n        current_block: BlockId,\n        exits: &mut Vec<BlockId>,\n    ) -> BlockId {\n        // Condition block\n        *block_id += 1;\n        let cond_block = BlockId(*block_id);\n        let condition = self\n            .child_by_field(node, \"condition\")\n            .map(|n| self.node_text(source, n))\n            .unwrap_or_else(|| \"condition\".to_string());\n\n        blocks.insert(\n            cond_block,\n            CFGBlock {\n                id: cond_block,\n                label: format!(\"if {}\", condition),\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.start_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: current_block,\n            to: cond_block,\n            label: None,\n        });\n\n        // True branch\n        *block_id += 1;\n        let true_block = BlockId(*block_id);\n        blocks.insert(\n            true_block,\n            CFGBlock {\n                id: true_block,\n                label: \"then\".to_string(),\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: cond_block,\n            to: true_block,\n            label: Some(\"true\".to_string()),\n        });\n\n        let true_end = if let Some(consequence) = self.child_by_field(node, \"consequence\") {\n            self.process_cfg_block(\n                consequence,\n                source,\n                blocks,\n                edges,\n                block_id,\n                true_block,\n                exits,\n            )\n        } else {\n            true_block\n        };\n\n        // False/else branch\n        let false_end = if let Some(alternative) = self.child_by_field(node, \"alternative\") {\n            *block_id += 1;\n            let false_block = BlockId(*block_id);\n            blocks.insert(\n                false_block,\n                CFGBlock {\n                    id: false_block,\n                    label: \"else\".to_string(),\n                    statements: Vec::new(),\n                    start_line: alternative.start_position().row + 1,\n                    end_line: alternative.end_position().row + 1,\n                },\n            );\n\n            edges.push(CFGEdge {\n                from: cond_block,\n                to: false_block,\n                label: Some(\"false\".to_string()),\n            });\n\n            self.process_cfg_block(\n                alternative,\n                source,\n                blocks,\n                edges,\n                block_id,\n                false_block,\n                exits,\n            )\n        } else {\n            cond_block\n        };\n\n        // Merge block\n        *block_id += 1;\n        let merge_block = BlockId(*block_id);\n        blocks.insert(\n            merge_block,\n            CFGBlock {\n                id: merge_block,\n                label: \"endif\".to_string(),\n                statements: Vec::new(),\n                start_line: node.end_position().row + 1,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: true_end,\n            to: merge_block,\n            label: None,\n        });\n        edges.push(CFGEdge {\n            from: false_end,\n            to: merge_block,\n            label: None,\n        });\n\n        merge_block\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 7,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 743
    },
    {
      "name": "(Go) process_for_cfg",
      "qualified_name": "src/lang/go.rs::(Go) process_for_cfg",
      "file": "src/lang/go.rs",
      "line": 458,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) process_for_cfg(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, block_id: &mut usize, current_block: BlockId, exits: &mut Vec<BlockId>) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_for_cfg(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        block_id: &mut usize,\n        current_block: BlockId,\n        exits: &mut Vec<BlockId>,\n    ) -> BlockId {\n        // Loop header\n        *block_id += 1;\n        let header_block = BlockId(*block_id);\n        let header_text = self\n            .node_text(source, node)\n            .lines()\n            .next()\n            .unwrap_or(\"for\")\n            .to_string();\n\n        blocks.insert(\n            header_block,\n            CFGBlock {\n                id: header_block,\n                label: header_text,\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.start_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: current_block,\n            to: header_block,\n            label: None,\n        });\n\n        // Loop body\n        *block_id += 1;\n        let body_block = BlockId(*block_id);\n        blocks.insert(\n            body_block,\n            CFGBlock {\n                id: body_block,\n                label: \"loop body\".to_string(),\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: header_block,\n            to: body_block,\n            label: Some(\"iterate\".to_string()),\n        });\n\n        let body_end = if let Some(body) = self.child_by_field(node, \"body\") {\n            self.process_cfg_block(body, source, blocks, edges, block_id, body_block, exits)\n        } else {\n            body_block\n        };\n\n        // Back edge\n        edges.push(CFGEdge {\n            from: body_end,\n            to: header_block,\n            label: Some(\"continue\".to_string()),\n        });\n\n        // Exit block\n        *block_id += 1;\n        let exit_block = BlockId(*block_id);\n        blocks.insert(\n            exit_block,\n            CFGBlock {\n                id: exit_block,\n                label: \"endfor\".to_string(),\n                statements: Vec::new(),\n                start_line: node.end_position().row + 1,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: header_block,\n            to: exit_block,\n            label: Some(\"done\".to_string()),\n        });\n\n        exit_block\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 554
    },
    {
      "name": "(Go) process_switch_cfg",
      "qualified_name": "src/lang/go.rs::(Go) process_switch_cfg",
      "file": "src/lang/go.rs",
      "line": 552,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) process_switch_cfg(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, block_id: &mut usize, current_block: BlockId, exits: &mut Vec<BlockId>) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_switch_cfg(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        block_id: &mut usize,\n        current_block: BlockId,\n        exits: &mut Vec<BlockId>,\n    ) -> BlockId {\n        // Switch header\n        *block_id += 1;\n        let switch_block = BlockId(*block_id);\n        let switch_text = self\n            .node_text(source, node)\n            .lines()\n            .next()\n            .unwrap_or(\"switch\")\n            .to_string();\n\n        blocks.insert(\n            switch_block,\n            CFGBlock {\n                id: switch_block,\n                label: switch_text,\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.start_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: current_block,\n            to: switch_block,\n            label: None,\n        });\n\n        // Merge block for after switch\n        *block_id += 1;\n        let merge_block = BlockId(*block_id);\n        blocks.insert(\n            merge_block,\n            CFGBlock {\n                id: merge_block,\n                label: \"endswitch\".to_string(),\n                statements: Vec::new(),\n                start_line: node.end_position().row + 1,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        // Process cases\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"expression_case\"\n                || child.kind() == \"default_case\"\n                || child.kind() == \"type_case\"\n            {\n                *block_id += 1;\n                let case_block = BlockId(*block_id);\n                let case_text = self\n                    .node_text(source, child)\n                    .lines()\n                    .next()\n                    .unwrap_or(\"case\")\n                    .to_string();\n\n                blocks.insert(\n                    case_block,\n                    CFGBlock {\n                        id: case_block,\n                        label: case_text,\n                        statements: Vec::new(),\n                        start_line: child.start_position().row + 1,\n                        end_line: child.end_position().row + 1,\n                    },\n                );\n\n                edges.push(CFGEdge {\n                    from: switch_block,\n                    to: case_block,\n                    label: None,\n                });\n\n                let case_end = self\n                    .process_cfg_block(child, source, blocks, edges, block_id, case_block, exits);\n\n                edges.push(CFGEdge {\n                    from: case_end,\n                    to: merge_block,\n                    label: None,\n                });\n            }\n        }\n\n        merge_block\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 4,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 573
    },
    {
      "name": "(Go) build_go_dfg",
      "qualified_name": "src/lang/go.rs::(Go) build_go_dfg",
      "file": "src/lang/go.rs",
      "line": 651,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) build_go_dfg(&self, node: Node, source: &[u8], func_name: &str) -> DFGInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_go_dfg(&self, node: Node, source: &[u8], func_name: &str) -> DFGInfo {\n        let mut edges = Vec::new();\n        let mut definitions: HashMap<String, Vec<usize>> = HashMap::new();\n        let mut uses: HashMap<String, Vec<usize>> = HashMap::new();\n\n        // Extract parameters as definitions\n        if let Some(params) = self.child_by_field(node, \"parameters\") {\n            let line = params.start_position().row + 1;\n            let mut cursor = params.walk();\n\n            for child in params.children(&mut cursor) {\n                if child.kind() == \"parameter_declaration\" {\n                    let mut inner_cursor = child.walk();\n                    for inner_child in child.children(&mut inner_cursor) {\n                        if inner_child.kind() == \"identifier\" {\n                            let name = self.node_text(source, inner_child);\n                            definitions.entry(name.clone()).or_default().push(line);\n                            edges.push(DataflowEdge {\n                                variable: name,\n                                from_line: line,\n                                to_line: line,\n                                kind: DataflowKind::Param,\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        // Process body\n        if let Some(body) = self.child_by_field(node, \"body\") {\n            self.extract_dfg_from_block(body, source, &mut edges, &mut definitions, &mut uses);\n        }\n\n        DFGInfo {\n            function_name: func_name.to_string(),\n            edges,\n            definitions,\n            uses,\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 8,
        "branches": 4,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 314
    },
    {
      "name": "(Go) extract_dfg_from_block",
      "qualified_name": "src/lang/go.rs::(Go) extract_dfg_from_block",
      "file": "src/lang/go.rs",
      "line": 694,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_dfg_from_block(&self, node: Node, source: &[u8], edges: &mut Vec<DataflowEdge>, definitions: &mut HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_dfg_from_block(\n        &self,\n        node: Node,\n        source: &[u8],\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &mut HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n    ) {\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            let line = child.start_position().row + 1;\n\n            match child.kind() {\n                \"short_var_declaration\" => {\n                    // x := value - defines x\n                    if let Some(left) = self.child_by_field(child, \"left\") {\n                        self.extract_definitions(left, source, line, edges, definitions);\n                    }\n                    if let Some(right) = self.child_by_field(child, \"right\") {\n                        self.extract_uses(right, source, line, edges, definitions, uses);\n                    }\n                }\n                \"assignment_statement\" => {\n                    // x = value or x += value etc.\n                    if let Some(left) = self.child_by_field(child, \"left\") {\n                        self.extract_definitions(left, source, line, edges, definitions);\n                    }\n                    if let Some(right) = self.child_by_field(child, \"right\") {\n                        self.extract_uses(right, source, line, edges, definitions, uses);\n                    }\n                }\n                \"var_declaration\" => {\n                    // var x type = value\n                    self.extract_var_declaration(child, source, line, edges, definitions, uses);\n                }\n                \"return_statement\" => {\n                    // Extract uses from return value\n                    let mut inner_cursor = child.walk();\n                    for inner_child in child.children(&mut inner_cursor) {\n                        if inner_child.kind() == \"expression_list\" {\n                            self.extract_uses(inner_child, source, line, edges, definitions, uses);\n                        }\n                    }\n                }\n                \"if_statement\"\n                | \"for_statement\"\n                | \"switch_statement\"\n                | \"type_switch_statement\"\n                | \"select_statement\" => {\n                    self.extract_dfg_from_block(child, source, edges, definitions, uses);\n                }\n                \"block\" | \"statement_list\" => {\n                    self.extract_dfg_from_block(child, source, edges, definitions, uses);\n                }\n                \"expression_statement\" | \"call_expression\" => {\n                    self.extract_uses(child, source, line, edges, definitions, uses);\n                }\n                _ => {}\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 6,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 503
    },
    {
      "name": "(Go) extract_definitions",
      "qualified_name": "src/lang/go.rs::(Go) extract_definitions",
      "file": "src/lang/go.rs",
      "line": 758,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_definitions(&self, node: Node, source: &[u8], line: usize, edges: &mut Vec<DataflowEdge>, definitions: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_definitions(\n        &self,\n        node: Node,\n        source: &[u8],\n        line: usize,\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &mut HashMap<String, Vec<usize>>,\n    ) {\n        match node.kind() {\n            \"identifier\" => {\n                let name = self.node_text(source, node);\n                if !name.is_empty() && name != \"_\" {\n                    definitions.entry(name.clone()).or_default().push(line);\n                    edges.push(DataflowEdge {\n                        variable: name,\n                        from_line: line,\n                        to_line: line,\n                        kind: DataflowKind::Definition,\n                    });\n                }\n            }\n            \"expression_list\" => {\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    self.extract_definitions(child, source, line, edges, definitions);\n                }\n            }\n            _ => {}\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 188
    },
    {
      "name": "(Go) extract_uses",
      "qualified_name": "src/lang/go.rs::(Go) extract_uses",
      "file": "src/lang/go.rs",
      "line": 790,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_uses(&self, node: Node, source: &[u8], line: usize, edges: &mut Vec<DataflowEdge>, definitions: &HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_uses(\n        &self,\n        node: Node,\n        source: &[u8],\n        line: usize,\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n    ) {\n        match node.kind() {\n            \"identifier\" => {\n                let name = self.node_text(source, node);\n                if !name.is_empty() && name != \"_\" {\n                    uses.entry(name.clone()).or_default().push(line);\n\n                    // Create edge from most recent definition\n                    if let Some(def_lines) = definitions.get(&name) {\n                        if let Some(&def_line) = def_lines.last() {\n                            edges.push(DataflowEdge {\n                                variable: name,\n                                from_line: def_line,\n                                to_line: line,\n                                kind: DataflowKind::Use,\n                            });\n                        }\n                    }\n                }\n            }\n            _ => {\n                // Recursively process children\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    self.extract_uses(child, source, line, edges, definitions, uses);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 8,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 244
    },
    {
      "name": "(Go) extract_var_declaration",
      "qualified_name": "src/lang/go.rs::(Go) extract_var_declaration",
      "file": "src/lang/go.rs",
      "line": 829,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_var_declaration(&self, node: Node, source: &[u8], line: usize, edges: &mut Vec<DataflowEdge>, definitions: &mut HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_var_declaration(\n        &self,\n        node: Node,\n        source: &[u8],\n        line: usize,\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &mut HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n    ) {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"var_spec\" {\n                // Extract name(s)\n                if let Some(name_node) = self.child_by_field(child, \"name\") {\n                    self.extract_definitions(name_node, source, line, edges, definitions);\n                }\n                // Extract value uses\n                if let Some(value_node) = self.child_by_field(child, \"value\") {\n                    self.extract_uses(value_node, source, line, edges, definitions, uses);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 183
    },
    {
      "name": "(Go) name",
      "qualified_name": "src/lang/go.rs::(Go) name",
      "file": "src/lang/go.rs",
      "line": 855,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) name(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn name(&self) -> &'static str {\n        \"go\"\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 17
    },
    {
      "name": "(Go) extensions",
      "qualified_name": "src/lang/go.rs::(Go) extensions",
      "file": "src/lang/go.rs",
      "line": 859,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extensions(&self) -> &[&'static str]",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extensions(&self) -> &[&'static str] {\n        &[\".go\"]\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 21
    },
    {
      "name": "(Go) parser",
      "qualified_name": "src/lang/go.rs::(Go) parser",
      "file": "src/lang/go.rs",
      "line": 863,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) parser(&self) -> Result<Parser>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parser(&self) -> Result<Parser> {\n        let mut parser = Parser::new();\n        parser\n            .set_language(&tree_sitter_go::LANGUAGE.into())\n            .map_err(|e| TldrError::TreeSitter(e.to_string()))?;\n        Ok(parser)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 62
    },
    {
      "name": "(Go) extract_function",
      "qualified_name": "src/lang/go.rs::(Go) extract_function",
      "file": "src/lang/go.rs",
      "line": 871,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo> {\n        match node.kind() {\n            \"function_declaration\" => {\n                // func Name(params) ReturnType\n                let name = self\n                    .child_by_field(node, \"name\")\n                    .map(|n| self.node_text(source, n))?;\n\n                let params = self\n                    .child_by_field(node, \"parameters\")\n                    .map(|n| self.extract_param_list(n, source))\n                    .unwrap_or_default();\n\n                let return_type = self\n                    .child_by_field(node, \"result\")\n                    .and_then(|n| self.extract_return_type(n, source));\n\n                let docstring = self.get_doc_comment(node, source);\n\n                Some(FunctionInfo {\n                    name,\n                    params,\n                    return_type,\n                    docstring,\n                    is_method: false,\n                    is_async: false,        // Go doesn't have async keyword\n                    decorators: Vec::new(), // Go doesn't have decorators\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"go\".to_string(),\n                })\n            }\n            \"method_declaration\" => {\n                // func (receiver Type) Name(params) ReturnType\n                let name = self\n                    .child_by_field(node, \"name\")\n                    .map(|n| self.node_text(source, n))?;\n\n                // Get parameters (second parameter_list, not receiver)\n                let params = self\n                    .child_by_field(node, \"parameters\")\n                    .map(|n| self.extract_param_list(n, source))\n                    .unwrap_or_default();\n\n                let return_type = self\n                    .child_by_field(node, \"result\")\n                    .and_then(|n| self.extract_return_type(n, source));\n\n                let docstring = self.get_doc_comment(node, source);\n\n                // Extract receiver info for decorators (to preserve receiver type info)\n                let mut decorators = Vec::new();\n                if let Some((recv_name, recv_type)) = self.extract_receiver(node, source) {\n                    let recv_str = if recv_name.is_empty() {\n                        recv_type\n                    } else {\n                        format!(\"{} {}\", recv_name, recv_type)\n                    };\n                    decorators.push(format!(\"receiver:{}\", recv_str));\n                }\n\n                Some(FunctionInfo {\n                    name,\n                    params,\n                    return_type,\n                    docstring,\n                    is_method: true,\n                    is_async: false,\n                    decorators,\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"go\".to_string(),\n                })\n            }\n            _ => None,\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "logging",
        "async_ops",
        "api_endpoint",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 6,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 566
    },
    {
      "name": "(Go) extract_class",
      "qualified_name": "src/lang/go.rs::(Go) extract_class",
      "file": "src/lang/go.rs",
      "line": 949,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo> {\n        // Go uses struct types - extract from type_declaration\n        if node.kind() != \"type_declaration\" {\n            return None;\n        }\n\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"type_spec\" {\n                let name = self\n                    .child_by_field(child, \"name\")\n                    .map(|n| self.node_text(source, n))?;\n\n                // Check if it's a struct type\n                let type_node = self.child_by_field(child, \"type\")?;\n                if type_node.kind() != \"struct_type\" && type_node.kind() != \"interface_type\" {\n                    return None;\n                }\n\n                let docstring = self.get_doc_comment(node, source);\n\n                // Extract interface methods if it's an interface type\n                let methods = if type_node.kind() == \"interface_type\" {\n                    self.extract_interface_methods(type_node, source)\n                } else {\n                    Vec::new()\n                };\n\n                // For interfaces, extract embedded types as bases\n                let bases = if type_node.kind() == \"interface_type\" {\n                    self.extract_embedded_interfaces(type_node, source)\n                } else {\n                    Vec::new()\n                };\n\n                return Some(ClassInfo {\n                    name,\n                    bases,\n                    docstring,\n                    methods,\n                    decorators: Vec::new(),\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"go\".to_string(),\n                });\n            }\n        }\n\n        None\n    }\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "config",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 5,
        "branches": 9,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 348
    },
    {
      "name": "(Go) extract_imports",
      "qualified_name": "src/lang/go.rs::(Go) extract_imports",
      "file": "src/lang/go.rs",
      "line": 1000,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo> {\n        let mut imports = Vec::new();\n        let root = tree.root_node();\n        let mut cursor = root.walk();\n\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"import_declaration\" {\n                self.extract_import_declaration(child, source, &mut imports);\n            }\n        }\n\n        imports\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 95
    },
    {
      "name": "(Go) function_query",
      "qualified_name": "src/lang/go.rs::(Go) function_query",
      "file": "src/lang/go.rs",
      "line": 1014,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) function_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn function_query(&self) -> &'static str {\n        r#\"[\n            (function_declaration name: (identifier) @name) @function\n            (method_declaration name: (field_identifier) @name) @function\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 53
    },
    {
      "name": "(Go) class_query",
      "qualified_name": "src/lang/go.rs::(Go) class_query",
      "file": "src/lang/go.rs",
      "line": 1021,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) class_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn class_query(&self) -> &'static str {\n        // Match both struct and interface type declarations\n        r#\"[\n            (type_declaration (type_spec name: (type_identifier) @name type: (struct_type))) @struct\n            (type_declaration (type_spec name: (type_identifier) @name type: (interface_type))) @interface\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 80
    },
    {
      "name": "(Go) call_query",
      "qualified_name": "src/lang/go.rs::(Go) call_query",
      "file": "src/lang/go.rs",
      "line": 1029,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) call_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn call_query(&self) -> &'static str {\n        r#\"[\n            (call_expression function: (identifier) @callee) @call\n            (call_expression function: (selector_expression field: (field_identifier) @callee)) @call\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 58
    },
    {
      "name": "(Go) build_cfg",
      "qualified_name": "src/lang/go.rs::(Go) build_cfg",
      "file": "src/lang/go.rs",
      "line": 1036,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo> {\n        let func_name = match node.kind() {\n            \"function_declaration\" => self\n                .child_by_field(node, \"name\")\n                .map(|n| self.node_text(source, n))\n                .unwrap_or_else(|| \"anonymous\".to_string()),\n            \"method_declaration\" => self\n                .child_by_field(node, \"name\")\n                .map(|n| self.node_text(source, n))\n                .unwrap_or_else(|| \"anonymous\".to_string()),\n            _ => {\n                return Err(TldrError::UnsupportedLanguage(\n                    \"Node is not a function or method\".to_string(),\n                ))\n            }\n        };\n\n        Ok(self.build_go_cfg(node, source, &func_name))\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 169
    },
    {
      "name": "(Go) build_dfg",
      "qualified_name": "src/lang/go.rs::(Go) build_dfg",
      "file": "src/lang/go.rs",
      "line": 1056,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo> {\n        let func_name = match node.kind() {\n            \"function_declaration\" => self\n                .child_by_field(node, \"name\")\n                .map(|n| self.node_text(source, n))\n                .unwrap_or_else(|| \"anonymous\".to_string()),\n            \"method_declaration\" => self\n                .child_by_field(node, \"name\")\n                .map(|n| self.node_text(source, n))\n                .unwrap_or_else(|| \"anonymous\".to_string()),\n            _ => {\n                return Err(TldrError::UnsupportedLanguage(\n                    \"Node is not a function or method\".to_string(),\n                ))\n            }\n        };\n\n        Ok(self.build_go_dfg(node, source, &func_name))\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 172
    },
    {
      "name": "(Go) extract_interface_methods",
      "qualified_name": "src/lang/go.rs::(Go) extract_interface_methods",
      "file": "src/lang/go.rs",
      "line": 1079,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_interface_methods(&self, node: Node, source: &[u8]) -> Vec<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_interface_methods(&self, node: Node, source: &[u8]) -> Vec<FunctionInfo> {\n        let mut methods = Vec::new();\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            // In Go interface, methods are defined as method_spec\n            if child.kind() == \"method_spec\" {\n                if let Some(method) = self.extract_interface_method(child, source) {\n                    methods.push(method);\n                }\n            }\n        }\n\n        methods\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 109
    },
    {
      "name": "(Go) extract_interface_method",
      "qualified_name": "src/lang/go.rs::(Go) extract_interface_method",
      "file": "src/lang/go.rs",
      "line": 1096,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_interface_method(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_interface_method(&self, node: Node, source: &[u8]) -> Option<FunctionInfo> {\n        let name = self\n            .child_by_field(node, \"name\")\n            .map(|n| self.node_text(source, n))?;\n\n        let params = self\n            .child_by_field(node, \"parameters\")\n            .map(|n| self.extract_param_list(n, source))\n            .unwrap_or_default();\n\n        let return_type = self\n            .child_by_field(node, \"result\")\n            .and_then(|n| self.extract_return_type(n, source));\n\n        Some(FunctionInfo {\n            name,\n            params,\n            return_type,\n            docstring: None,\n            is_method: true,\n            is_async: false,\n            decorators: Vec::new(),\n            line_number: node.start_position().row + 1,\n            end_line_number: Some(node.end_position().row + 1),\n            language: \"go\".to_string(),\n        })\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 204
    },
    {
      "name": "(Go) extract_embedded_interfaces",
      "qualified_name": "src/lang/go.rs::(Go) extract_embedded_interfaces",
      "file": "src/lang/go.rs",
      "line": 1125,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_embedded_interfaces(&self, node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_embedded_interfaces(&self, node: Node, source: &[u8]) -> Vec<String> {\n        let mut embedded = Vec::new();\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            // Embedded interfaces appear as type_identifier or qualified_type\n            if child.kind() == \"type_identifier\" || child.kind() == \"qualified_type\" {\n                embedded.push(self.node_text(source, child));\n            }\n        }\n\n        embedded\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 103
    },
    {
      "name": "(Go) extract_import_declaration",
      "qualified_name": "src/lang/go.rs::(Go) extract_import_declaration",
      "file": "src/lang/go.rs",
      "line": 1140,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_import_declaration(&self, node: Node, source: &[u8], imports: &mut Vec<ImportInfo>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_import_declaration(&self, node: Node, source: &[u8], imports: &mut Vec<ImportInfo>) {\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"import_spec\" => {\n                    if let Some(import) = self.extract_import_spec(child, source) {\n                        imports.push(import);\n                    }\n                }\n                \"import_spec_list\" => {\n                    // Grouped imports: import ( ... )\n                    let mut inner_cursor = child.walk();\n                    for inner_child in child.children(&mut inner_cursor) {\n                        if inner_child.kind() == \"import_spec\" {\n                            if let Some(import) = self.extract_import_spec(inner_child, source) {\n                                imports.push(import);\n                            }\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 8,
        "branches": 4,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 177
    },
    {
      "name": "(Go) extract_import_spec",
      "qualified_name": "src/lang/go.rs::(Go) extract_import_spec",
      "file": "src/lang/go.rs",
      "line": 1167,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Go) extract_import_spec(&self, node: Node, source: &[u8]) -> Option<ImportInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_import_spec(&self, node: Node, source: &[u8]) -> Option<ImportInfo> {\n        let mut alias_name: Option<String> = None;\n        let mut path: Option<String> = None;\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"package_identifier\" => {\n                    // Alias: import alias \"path\"\n                    alias_name = Some(self.node_text(source, child));\n                }\n                \"interpreted_string_literal\" => {\n                    // Path: \"github.com/user/pkg\"\n                    let text = self.node_text(source, child);\n                    // Remove quotes\n                    path = Some(text.trim_matches('\"').to_string());\n                }\n                \"blank_identifier\" => {\n                    // Blank import: import _ \"path\"\n                    alias_name = Some(\"_\".to_string());\n                }\n                \"dot\" => {\n                    // Dot import: import . \"path\"\n                    alias_name = Some(\".\".to_string());\n                }\n                _ => {}\n            }\n        }\n\n        let module = path?;\n        let mut aliases = HashMap::new();\n\n        if let Some(alias) = alias_name {\n            aliases.insert(module.clone(), alias);\n        }\n\n        Some(ImportInfo {\n            module,\n            names: Vec::new(), // Go imports whole packages\n            aliases,\n            is_from: false, // Go doesn't have \"from X import Y\" syntax\n            level: 0,       // Go doesn't have relative imports\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 314
    },
    {
      "name": "parse_go",
      "qualified_name": "src/lang/go.rs::parse_go",
      "file": "src/lang/go.rs",
      "line": 1217,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn parse_go(source: &str) -> (Tree, Vec<u8>)",
      "docstring": "",
      "calls": [
        "parser"
      ],
      "called_by": [
        "test_extract_named_returns",
        "test_extract_struct",
        "test_extract_method",
        "test_extract_imports",
        "test_extract_multiple_returns"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:6",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parse_go(source: &str) -> (Tree, Vec<u8>) {\n        let go = Go;\n        let mut parser = go.parser().unwrap();\n        let source_bytes = source.as_bytes().to_vec();\n        let tree = parser.parse(&source_bytes, None).unwrap();\n        (tree, source_bytes)\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 69
    },
    {
      "name": "test_extract_simple_function",
      "qualified_name": "src/lang/go.rs::test_extract_simple_function",
      "file": "src/lang/go.rs",
      "line": 1226,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_simple_function()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_python",
        "child_by_kind",
        "extract_function",
        "extract_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:23, def-use chains:8",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_simple_function() {\n        let source = r#\"\npackage main\n\n// SayHello greets someone\nfunc SayHello(name string) string {\n    return \"Hello, \" + name\n}\n\"#;\n\n        let (tree, source_bytes) = parse_go(source);\n        let go = Go;\n        let root = tree.root_node();\n\n        // Find function_declaration\n        let mut found = false;\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"function_declaration\" {\n                let func = go.extract_function(child, &source_bytes);\n                assert!(func.is_some());\n                let func = func.unwrap();\n                assert_eq!(func.name, \"SayHello\");\n                assert_eq!(func.params, vec![\"name string\"]);\n                assert_eq!(func.return_type, Some(\"string\".to_string()));\n                assert!(!func.is_method);\n                assert_eq!(func.language, \"go\");\n                found = true;\n            }\n        }\n        assert!(found, \"Function declaration not found\");\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 221
    },
    {
      "name": "test_extract_method",
      "qualified_name": "src/lang/go.rs::test_extract_method",
      "file": "src/lang/go.rs",
      "line": 1260,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_method()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_go"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:24, def-use chains:7",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_method() {\n        let source = r#\"\npackage main\n\nfunc (p *Person) Greet() string {\n    return \"Hi, I'm \" + p.Name\n}\n\"#;\n\n        let (tree, source_bytes) = parse_go(source);\n        let go = Go;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"method_declaration\" {\n                let func = go.extract_function(child, &source_bytes);\n                assert!(func.is_some());\n                let func = func.unwrap();\n                assert_eq!(func.name, \"Greet\");\n                assert!(func.is_method);\n                assert!(func.decorators.iter().any(|d| d.starts_with(\"receiver:\")));\n                assert_eq!(func.return_type, Some(\"string\".to_string()));\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 185
    },
    {
      "name": "test_extract_multiple_returns",
      "qualified_name": "src/lang/go.rs::test_extract_multiple_returns",
      "file": "src/lang/go.rs",
      "line": 1288,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_multiple_returns()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_go"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:18, def-use chains:7",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_multiple_returns() {\n        let source = r#\"\npackage main\n\nfunc MultiReturn() (int, error) {\n    return 42, nil\n}\n\"#;\n\n        let (tree, source_bytes) = parse_go(source);\n        let go = Go;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"function_declaration\" {\n                let func = go.extract_function(child, &source_bytes);\n                assert!(func.is_some());\n                let func = func.unwrap();\n                assert_eq!(func.name, \"MultiReturn\");\n                assert_eq!(func.return_type, Some(\"(int, error)\".to_string()));\n            }\n        }\n    }\n",
      "semantic_tags": [
        "validation",
        "logging",
        "error_handling",
        "iteration",
        "test"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 157
    },
    {
      "name": "test_extract_named_returns",
      "qualified_name": "src/lang/go.rs::test_extract_named_returns",
      "file": "src/lang/go.rs",
      "line": 1314,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_named_returns()",
      "docstring": "",
      "calls": [
        "parse_go",
        "extract_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:18, def-use chains:7",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_named_returns() {\n        let source = r#\"\npackage main\n\nfunc NamedReturn() (result string, err error) {\n    result = \"hello\"\n    return\n}\n\"#;\n\n        let (tree, source_bytes) = parse_go(source);\n        let go = Go;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"function_declaration\" {\n                let func = go.extract_function(child, &source_bytes);\n                assert!(func.is_some());\n                let func = func.unwrap();\n                assert_eq!(func.name, \"NamedReturn\");\n                assert_eq!(\n                    func.return_type,\n                    Some(\"(result string, err error)\".to_string())\n                );\n            }\n        }\n    }\n",
      "semantic_tags": [
        "validation",
        "logging",
        "error_handling",
        "iteration",
        "test"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 166
    },
    {
      "name": "test_extract_struct",
      "qualified_name": "src/lang/go.rs::test_extract_struct",
      "file": "src/lang/go.rs",
      "line": 1344,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_struct()",
      "docstring": "",
      "calls": [
        "extract_class",
        "parse_go",
        "extract_class",
        "parse_c",
        "extract_class"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:16, def-use chains:11",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_struct() {\n        let source = r#\"\npackage main\n\n// Person represents a human\ntype Person struct {\n    Name string\n    Age  int\n}\n\"#;\n\n        let (tree, source_bytes) = parse_go(source);\n        let go = Go;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"type_declaration\" {\n                let cls = go.extract_class(child, &source_bytes);\n                assert!(cls.is_some());\n                let cls = cls.unwrap();\n                assert_eq!(cls.name, \"Person\");\n                assert_eq!(cls.language, \"go\");\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 149
    },
    {
      "name": "test_extract_imports",
      "qualified_name": "src/lang/go.rs::test_extract_imports",
      "file": "src/lang/go.rs",
      "line": 1372,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_imports()",
      "docstring": "",
      "calls": [
        "extract_imports",
        "extract_imports",
        "extract_imports",
        "parse_java",
        "parse_python"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:20, def-use chains:10",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_imports() {\n        let source = r#\"\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nimport \"strings\"\nimport alias \"io\"\n\"#;\n\n        let (tree, source_bytes) = parse_go(source);\n        let go = Go;\n        let imports = go.extract_imports(&tree, &source_bytes);\n\n        assert_eq!(imports.len(), 4);\n\n        // Check grouped imports\n        assert!(imports.iter().any(|i| i.module == \"fmt\"));\n        assert!(imports.iter().any(|i| i.module == \"os\"));\n\n        // Check single import\n        assert!(imports.iter().any(|i| i.module == \"strings\"));\n\n        // Check aliased import\n        let alias_import = imports.iter().find(|i| i.module == \"io\").unwrap();\n        assert_eq!(alias_import.aliases.get(\"io\"), Some(&\"alias\".to_string()));\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 193
    },
    {
      "name": "test_function_signature",
      "qualified_name": "src/lang/go.rs::test_function_signature",
      "file": "src/lang/go.rs",
      "line": 1404,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_function_signature()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_function_signature() {\n        let func = FunctionInfo {\n            name: \"Process\".to_string(),\n            params: vec![\"ctx context.Context\".to_string(), \"data []byte\".to_string()],\n            return_type: Some(\"(int, error)\".to_string()),\n            docstring: None,\n            is_method: false,\n            is_async: false,\n            decorators: Vec::new(),\n            line_number: 1,\n            end_line_number: Some(5),\n            language: \"go\".to_string(),\n        };\n\n        assert_eq!(\n            func.signature(),\n            \"func Process(ctx context.Context, data []byte) (int, error)\"\n        );\n    }\n",
      "semantic_tags": [
        "logging",
        "error_handling"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 138
    },
    {
      "name": "Go",
      "qualified_name": "src/lang/go.rs::Go",
      "file": "src/lang/go.rs",
      "line": 25,
      "language": "rust",
      "unit_type": "class",
      "signature": "class Go",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "pub struct Go;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 0,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 4
    },
    {
      "name": "(Metric) to_usearch",
      "qualified_name": "src/embedding/index.rs::(Metric) to_usearch",
      "file": "src/embedding/index.rs",
      "line": 70,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Metric) to_usearch(self) -> MetricKind",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn to_usearch(self) -> MetricKind {\n        match self {\n            Self::InnerProduct => MetricKind::IP,\n            Self::Cosine => MetricKind::Cos,\n            Self::L2Squared => MetricKind::L2sq,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 55
    },
    {
      "name": "(Metric) as_str",
      "qualified_name": "src/embedding/index.rs::(Metric) as_str",
      "file": "src/embedding/index.rs",
      "line": 80,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Metric) as_str(self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn as_str(self) -> &'static str {\n        match self {\n            Self::InnerProduct => \"inner_product\",\n            Self::Cosine => \"cosine\",\n            Self::L2Squared => \"l2_squared\",\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 52
    },
    {
      "name": "(Metric) fmt",
      "qualified_name": "src/embedding/index.rs::(Metric) fmt",
      "file": "src/embedding/index.rs",
      "line": 90,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Metric) fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 38
    },
    {
      "name": "(Metric) from_str",
      "qualified_name": "src/embedding/index.rs::(Metric) from_str",
      "file": "src/embedding/index.rs",
      "line": 98,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Metric) from_str(s: &str) -> Result<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn from_str(s: &str) -> Result<Self> {\n        match s.to_lowercase().as_str() {\n            \"ip\" | \"inner_product\" | \"innerproduct\" => Ok(Self::InnerProduct),\n            \"cos\" | \"cosine\" => Ok(Self::Cosine),\n            \"l2\" | \"l2sq\" | \"l2_squared\" | \"euclidean\" => Ok(Self::L2Squared),\n            _ => bail!(\n                \"Unknown metric: {}. Valid options: inner_product, cosine, l2_squared\",\n                s\n            ),\n        }\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 123
    },
    {
      "name": "(Quantization) to_usearch",
      "qualified_name": "src/embedding/index.rs::(Quantization) to_usearch",
      "file": "src/embedding/index.rs",
      "line": 138,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Quantization) to_usearch(self) -> ScalarKind",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn to_usearch(self) -> ScalarKind {\n        match self {\n            Self::F32 => ScalarKind::F32,\n            Self::F16 => ScalarKind::F16,\n            Self::BF16 => ScalarKind::BF16,\n            Self::I8 => ScalarKind::I8,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 73
    },
    {
      "name": "(Quantization) bytes_per_element",
      "qualified_name": "src/embedding/index.rs::(Quantization) bytes_per_element",
      "file": "src/embedding/index.rs",
      "line": 149,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Quantization) bytes_per_element(self) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn bytes_per_element(self) -> usize {\n        match self {\n            Self::F32 => 4,\n            Self::F16 | Self::BF16 => 2,\n            Self::I8 => 1,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 54
    },
    {
      "name": "(IndexConfig) new",
      "qualified_name": "src/embedding/index.rs::(IndexConfig) new",
      "file": "src/embedding/index.rs",
      "line": 195,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (IndexConfig) new(dimensions: usize) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn new(dimensions: usize) -> Self {\n        Self {\n            dimensions,\n            metric: Metric::default(),\n            quantization: Quantization::default(),\n            connectivity: 0,\n            expansion_add: 0,\n            expansion_search: 0,\n            multi: false,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 63
    },
    {
      "name": "(IndexConfig) with_metric",
      "qualified_name": "src/embedding/index.rs::(IndexConfig) with_metric",
      "file": "src/embedding/index.rs",
      "line": 209,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (IndexConfig) with_metric(mut self, metric: Metric) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn with_metric(mut self, metric: Metric) -> Self {\n        self.metric = metric;\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 26
    },
    {
      "name": "(IndexConfig) with_quantization",
      "qualified_name": "src/embedding/index.rs::(IndexConfig) with_quantization",
      "file": "src/embedding/index.rs",
      "line": 216,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (IndexConfig) with_quantization(mut self, quantization: Quantization) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn with_quantization(mut self, quantization: Quantization) -> Self {\n        self.quantization = quantization;\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 31
    },
    {
      "name": "(IndexConfig) with_connectivity",
      "qualified_name": "src/embedding/index.rs::(IndexConfig) with_connectivity",
      "file": "src/embedding/index.rs",
      "line": 223,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (IndexConfig) with_connectivity(mut self, connectivity: usize) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn with_connectivity(mut self, connectivity: usize) -> Self {\n        self.connectivity = connectivity;\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 28
    },
    {
      "name": "(IndexConfig) with_expansion_add",
      "qualified_name": "src/embedding/index.rs::(IndexConfig) with_expansion_add",
      "file": "src/embedding/index.rs",
      "line": 230,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (IndexConfig) with_expansion_add(mut self, expansion: usize) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn with_expansion_add(mut self, expansion: usize) -> Self {\n        self.expansion_add = expansion;\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 30
    },
    {
      "name": "(IndexConfig) with_expansion_search",
      "qualified_name": "src/embedding/index.rs::(IndexConfig) with_expansion_search",
      "file": "src/embedding/index.rs",
      "line": 237,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (IndexConfig) with_expansion_search(mut self, expansion: usize) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn with_expansion_search(mut self, expansion: usize) -> Self {\n        self.expansion_search = expansion;\n        self\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 30
    },
    {
      "name": "(IndexConfig) to_usearch_options",
      "qualified_name": "src/embedding/index.rs::(IndexConfig) to_usearch_options",
      "file": "src/embedding/index.rs",
      "line": 243,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (IndexConfig) to_usearch_options(&self) -> IndexOptions",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn to_usearch_options(&self) -> IndexOptions {\n        IndexOptions {\n            dimensions: self.dimensions,\n            metric: self.metric.to_usearch(),\n            quantization: self.quantization.to_usearch(),\n            connectivity: self.connectivity,\n            expansion_add: self.expansion_add,\n            expansion_search: self.expansion_search,\n            multi: self.multi,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 78
    },
    {
      "name": "(IndexConfig) estimate_memory",
      "qualified_name": "src/embedding/index.rs::(IndexConfig) estimate_memory",
      "file": "src/embedding/index.rs",
      "line": 257,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (IndexConfig) estimate_memory(&self, vector_count: usize) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn estimate_memory(&self, vector_count: usize) -> usize {\n        let bytes_per_vector = self.dimensions * self.quantization.bytes_per_element();\n        // HNSW overhead is roughly 2x for graph structure\n        let overhead_factor = 2;\n        vector_count * bytes_per_vector * overhead_factor\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 68
    },
    {
      "name": "(IndexConfig) default",
      "qualified_name": "src/embedding/index.rs::(IndexConfig) default",
      "file": "src/embedding/index.rs",
      "line": 266,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (IndexConfig) default() -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn default() -> Self {\n        Self::new(768) // Default to MiniLM-like dimensions\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 26
    },
    {
      "name": "(VectorIndex) new",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) new",
      "file": "src/embedding/index.rs",
      "line": 322,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) new(dimensions: usize, metric: Metric) -> Result<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn new(dimensions: usize, metric: Metric) -> Result<Self> {\n        let config = IndexConfig::new(dimensions).with_metric(metric);\n        Self::with_config(config)\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 42
    },
    {
      "name": "(VectorIndex) with_config",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) with_config",
      "file": "src/embedding/index.rs",
      "line": 342,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) with_config(config: IndexConfig) -> Result<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn with_config(config: IndexConfig) -> Result<Self> {\n        let options = config.to_usearch_options();\n        let inner = Index::new(&options)\n            .map_err(|e| anyhow::anyhow!(\"Failed to create usearch index: {}\", e))?;\n\n        Ok(Self { inner, config })\n    }\n",
      "semantic_tags": [
        "crud",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 68
    },
    {
      "name": "(VectorIndex) config",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) config",
      "file": "src/embedding/index.rs",
      "line": 352,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) config(&self) -> &IndexConfig",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn config(&self) -> &IndexConfig {\n        &self.config\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 19
    },
    {
      "name": "(VectorIndex) dimensions",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) dimensions",
      "file": "src/embedding/index.rs",
      "line": 358,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) dimensions(&self) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn dimensions(&self) -> usize {\n        self.inner.dimensions()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 17
    },
    {
      "name": "(VectorIndex) len",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) len",
      "file": "src/embedding/index.rs",
      "line": 364,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) len(&self) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn len(&self) -> usize {\n        self.inner.size()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 17
    },
    {
      "name": "(VectorIndex) is_empty",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) is_empty",
      "file": "src/embedding/index.rs",
      "line": 370,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) is_empty(&self) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 21
    },
    {
      "name": "(VectorIndex) capacity",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) capacity",
      "file": "src/embedding/index.rs",
      "line": 376,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) capacity(&self) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn capacity(&self) -> usize {\n        self.inner.capacity()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 17
    },
    {
      "name": "(VectorIndex) memory_usage",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) memory_usage",
      "file": "src/embedding/index.rs",
      "line": 382,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) memory_usage(&self) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn memory_usage(&self) -> usize {\n        self.inner.memory_usage()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 19
    },
    {
      "name": "(VectorIndex) reserve",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) reserve",
      "file": "src/embedding/index.rs",
      "line": 397,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) reserve(&self, capacity: usize) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn reserve(&self, capacity: usize) -> Result<()> {\n        self.inner\n            .reserve(capacity)\n            .map_err(|e| anyhow::anyhow!(\"Failed to reserve capacity: {}\", e))\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 47
    },
    {
      "name": "(VectorIndex) contains",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) contains",
      "file": "src/embedding/index.rs",
      "line": 405,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) contains(&self, key: u64) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn contains(&self, key: u64) -> bool {\n        self.inner.contains(key)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 24
    },
    {
      "name": "(VectorIndex) add",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) add",
      "file": "src/embedding/index.rs",
      "line": 431,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) add(&self, key: u64, vector: &[f32]) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn add(&self, key: u64, vector: &[f32]) -> Result<()> {\n        self.validate_vector_dimensions(vector)?;\n\n        self.inner\n            .add(key, vector)\n            .map_err(|e| anyhow::anyhow!(\"Failed to add vector {}: {}\", key, e))\n    }\n",
      "semantic_tags": [
        "crud"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 66
    },
    {
      "name": "(VectorIndex) add_batch",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) add_batch",
      "file": "src/embedding/index.rs",
      "line": 473,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) add_batch(&self, keys: &[u64], vectors: &[Vec<f32>]) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn add_batch(&self, keys: &[u64], vectors: &[Vec<f32>]) -> Result<()> {\n        if keys.len() != vectors.len() {\n            bail!(\n                \"Keys and vectors length mismatch: {} keys, {} vectors\",\n                keys.len(),\n                vectors.len()\n            );\n        }\n\n        for (i, vector) in vectors.iter().enumerate() {\n            self.validate_vector_dimensions(vector)\n                .with_context(|| format!(\"Vector at index {}\", i))?;\n        }\n\n        // Add vectors sequentially (usearch handles internal parallelism)\n        for (key, vector) in keys.iter().zip(vectors.iter()) {\n            self.inner\n                .add(*key, vector)\n                .map_err(|e| anyhow::anyhow!(\"Failed to add vector {}: {}\", key, e))?;\n        }\n\n        Ok(())\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 176
    },
    {
      "name": "(VectorIndex) add_batch_flat",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) add_batch_flat",
      "file": "src/embedding/index.rs",
      "line": 507,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) add_batch_flat(&self, keys: &[u64], vectors_flat: &[f32]) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn add_batch_flat(&self, keys: &[u64], vectors_flat: &[f32]) -> Result<()> {\n        let expected_len = keys.len() * self.dimensions();\n        if vectors_flat.len() != expected_len {\n            bail!(\n                \"Flat vector array size mismatch: expected {} ({} keys * {} dims), got {}\",\n                expected_len,\n                keys.len(),\n                self.dimensions(),\n                vectors_flat.len()\n            );\n        }\n\n        let dims = self.dimensions();\n        for (i, key) in keys.iter().enumerate() {\n            let start = i * dims;\n            let end = start + dims;\n            let vector = &vectors_flat[start..end];\n\n            self.inner\n                .add(*key, vector)\n                .map_err(|e| anyhow::anyhow!(\"Failed to add vector {}: {}\", key, e))?;\n        }\n\n        Ok(())\n    }\n",
      "semantic_tags": [
        "crud",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 185
    },
    {
      "name": "(VectorIndex) search",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) search",
      "file": "src/embedding/index.rs",
      "line": 566,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) search(&self, query: &[f32], k: usize) -> Result<Vec<(u64, f32)>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn search(&self, query: &[f32], k: usize) -> Result<Vec<(u64, f32)>> {\n        self.validate_vector_dimensions(query)?;\n\n        if self.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        // Limit k to actual index size\n        let k = k.min(self.len());\n\n        let matches = self\n            .inner\n            .search(query, k)\n            .map_err(|e| anyhow::anyhow!(\"Search failed: {}\", e))?;\n\n        Ok(matches.keys.into_iter().zip(matches.distances).collect())\n    }\n",
      "semantic_tags": [
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 124
    },
    {
      "name": "(VectorIndex) search_exact",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) search_exact",
      "file": "src/embedding/index.rs",
      "line": 587,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) search_exact(&self, query: &[f32], k: usize) -> Result<Vec<(u64, f32)>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn search_exact(&self, query: &[f32], k: usize) -> Result<Vec<(u64, f32)>> {\n        self.validate_vector_dimensions(query)?;\n\n        if self.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        let k = k.min(self.len());\n\n        let matches = self\n            .inner\n            .exact_search(query, k)\n            .map_err(|e| anyhow::anyhow!(\"Exact search failed: {}\", e))?;\n\n        Ok(matches.keys.into_iter().zip(matches.distances).collect())\n    }\n",
      "semantic_tags": [
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 118
    },
    {
      "name": "(VectorIndex) search_filtered",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) search_filtered",
      "file": "src/embedding/index.rs",
      "line": 630,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) search_filtered(&self, query: &[f32], k: usize, filter: F) -> Result<Vec<(u64, f32)>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn search_filtered<F>(&self, query: &[f32], k: usize, filter: F) -> Result<Vec<(u64, f32)>>\n    where\n        F: Fn(u64) -> bool,\n    {\n        self.validate_vector_dimensions(query)?;\n\n        if self.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        let k = k.min(self.len());\n\n        let matches = self\n            .inner\n            .filtered_search(query, k, filter)\n            .map_err(|e| anyhow::anyhow!(\"Filtered search failed: {}\", e))?;\n\n        Ok(matches.keys.into_iter().zip(matches.distances).collect())\n    }\n",
      "semantic_tags": [
        "database",
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 141
    },
    {
      "name": "(VectorIndex) remove",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) remove",
      "file": "src/embedding/index.rs",
      "line": 655,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) remove(&self, key: u64) -> Result<usize>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn remove(&self, key: u64) -> Result<usize> {\n        self.inner\n            .remove(key)\n            .map_err(|e| anyhow::anyhow!(\"Failed to remove vector {}: {}\", key, e))\n    }\n",
      "semantic_tags": [
        "crud"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 51
    },
    {
      "name": "(VectorIndex) clear",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) clear",
      "file": "src/embedding/index.rs",
      "line": 664,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) clear(&self) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn clear(&self) -> Result<()> {\n        self.inner\n            .reset()\n            .map_err(|e| anyhow::anyhow!(\"Failed to clear index: {}\", e))\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 41
    },
    {
      "name": "(VectorIndex) save",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) save",
      "file": "src/embedding/index.rs",
      "line": 682,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) save(&self, path: impl AsRef<Path>) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn save(&self, path: impl AsRef<Path>) -> Result<()> {\n        let path_str = path.as_ref().to_string_lossy();\n        self.inner\n            .save(&path_str)\n            .map_err(|e| anyhow::anyhow!(\"Failed to save index to '{}': {}\", path_str, e))\n    }\n",
      "semantic_tags": [
        "crud"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 70
    },
    {
      "name": "(VectorIndex) load",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) load",
      "file": "src/embedding/index.rs",
      "line": 716,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) load(path: impl AsRef<Path>, config: IndexConfig) -> Result<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn load(path: impl AsRef<Path>, config: IndexConfig) -> Result<Self> {\n        let path = path.as_ref();\n\n        if !path.exists() {\n            bail!(\"Index file not found: {}\", path.display());\n        }\n\n        let index = Self::with_config(config)?;\n        let path_str = path.to_string_lossy();\n\n        index\n            .inner\n            .load(&path_str)\n            .map_err(|e| anyhow::anyhow!(\"Failed to load index from '{}': {}\", path_str, e))?;\n\n        // Validate dimensions match\n        if index.inner.dimensions() != index.config.dimensions {\n            bail!(\n                \"Dimension mismatch: config specifies {} but loaded index has {}\",\n                index.config.dimensions,\n                index.inner.dimensions()\n            );\n        }\n\n        Ok(index)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 165
    },
    {
      "name": "(VectorIndex) view",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) view",
      "file": "src/embedding/index.rs",
      "line": 756,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) view(path: impl AsRef<Path>, config: IndexConfig) -> Result<Self>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn view(path: impl AsRef<Path>, config: IndexConfig) -> Result<Self> {\n        let path = path.as_ref();\n\n        if !path.exists() {\n            bail!(\"Index file not found: {}\", path.display());\n        }\n\n        let index = Self::with_config(config)?;\n        let path_str = path.to_string_lossy();\n\n        index\n            .inner\n            .view(&path_str)\n            .map_err(|e| anyhow::anyhow!(\"Failed to view index from '{}': {}\", path_str, e))?;\n\n        Ok(index)\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 117
    },
    {
      "name": "(VectorIndex) hardware_acceleration",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) hardware_acceleration",
      "file": "src/embedding/index.rs",
      "line": 778,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) hardware_acceleration(&self) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn hardware_acceleration(&self) -> String {\n        self.inner.hardware_acceleration()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 21
    },
    {
      "name": "(VectorIndex) set_expansion_search",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) set_expansion_search",
      "file": "src/embedding/index.rs",
      "line": 786,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) set_expansion_search(&self, expansion: usize)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn set_expansion_search(&self, expansion: usize) {\n        self.inner.change_expansion_search(expansion);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 27
    },
    {
      "name": "(VectorIndex) expansion_search",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) expansion_search",
      "file": "src/embedding/index.rs",
      "line": 792,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) expansion_search(&self) -> usize",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    pub fn expansion_search(&self) -> usize {\n        self.inner.expansion_search()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 20
    },
    {
      "name": "(VectorIndex) validate_vector_dimensions",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) validate_vector_dimensions",
      "file": "src/embedding/index.rs",
      "line": 797,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) validate_vector_dimensions(&self, vector: &[f32]) -> Result<()>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn validate_vector_dimensions(&self, vector: &[f32]) -> Result<()> {\n        let expected = self.dimensions();\n        let actual = vector.len();\n\n        if actual != expected {\n            bail!(\n                \"Vector dimension mismatch: expected {}, got {}\",\n                expected,\n                actual\n            );\n        }\n\n        Ok(())\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 68
    },
    {
      "name": "(VectorIndex) fmt",
      "qualified_name": "src/embedding/index.rs::(VectorIndex) fmt",
      "file": "src/embedding/index.rs",
      "line": 814,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (VectorIndex) fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"VectorIndex\")\n            .field(\"dimensions\", &self.dimensions())\n            .field(\"metric\", &self.config.metric)\n            .field(\"quantization\", &self.config.quantization)\n            .field(\"size\", &self.len())\n            .field(\"capacity\", &self.capacity())\n            .field(\"memory_usage\", &self.memory_usage())\n            .finish()\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 105
    },
    {
      "name": "distances_to_scores",
      "qualified_name": "src/embedding/index.rs::distances_to_scores",
      "file": "src/embedding/index.rs",
      "line": 838,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn distances_to_scores(distances: &[f32]) -> Vec<f32>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_distances_to_scores"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:1",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "pub fn distances_to_scores(distances: &[f32]) -> Vec<f32> {\n    distances\n        .iter()\n        .map(|&d| (1.0 - d).clamp(0.0, 1.0))\n        .collect()\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 57
    },
    {
      "name": "normalize_vector",
      "qualified_name": "src/embedding/index.rs::normalize_vector",
      "file": "src/embedding/index.rs",
      "line": 849,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn normalize_vector(vector: &[f32]) -> Vec<f32>",
      "docstring": "",
      "calls": [],
      "called_by": [
        "test_normalize_vector"
      ],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:6, def-use chains:5",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "pub fn normalize_vector(vector: &[f32]) -> Vec<f32> {\n    let norm: f32 = vector.iter().map(|x| x * x).sum::<f32>().sqrt();\n\n    if norm < f32::EPSILON {\n        return vector.to_vec();\n    }\n\n    vector.iter().map(|x| x / norm).collect()\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 79
    },
    {
      "name": "is_normalized",
      "qualified_name": "src/embedding/index.rs::is_normalized",
      "file": "src/embedding/index.rs",
      "line": 861,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn is_normalized(vector: &[f32], epsilon: f32) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:3",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "pub fn is_normalized(vector: &[f32], epsilon: f32) -> bool {\n    let norm: f32 = vector.iter().map(|x| x * x).sum::<f32>().sqrt();\n    (norm - 1.0).abs() < epsilon\n}\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 62
    },
    {
      "name": "create_test_index",
      "qualified_name": "src/embedding/index.rs::create_test_index",
      "file": "src/embedding/index.rs",
      "line": 874,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn create_test_index() -> VectorIndex",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [
        "test_empty_search",
        "test_contains",
        "test_dimension_validation",
        "test_add_batch_flat",
        "test_search_k_larger_than_index"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn create_test_index() -> VectorIndex {\n        VectorIndex::new(4, Metric::InnerProduct).expect(\"Failed to create test index\")\n    }\n",
      "semantic_tags": [
        "crud",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 33
    },
    {
      "name": "test_create_index",
      "qualified_name": "src/embedding/index.rs::test_create_index",
      "file": "src/embedding/index.rs",
      "line": 879,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_create_index()",
      "docstring": "",
      "calls": [
        "create_test_index"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:3",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_create_index() {\n        let index = create_test_index();\n        assert_eq!(index.dimensions(), 4);\n        assert_eq!(index.len(), 0);\n        assert!(index.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 44
    },
    {
      "name": "test_add_and_search",
      "qualified_name": "src/embedding/index.rs::test_add_and_search",
      "file": "src/embedding/index.rs",
      "line": 887,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_add_and_search()",
      "docstring": "",
      "calls": [
        "reserve",
        "create_test_index",
        "search",
        "add"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:9",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_add_and_search() {\n        let index = create_test_index();\n        index.reserve(10).unwrap();\n\n        // Add some vectors\n        index.add(0, &[1.0, 0.0, 0.0, 0.0]).unwrap();\n        index.add(1, &[0.0, 1.0, 0.0, 0.0]).unwrap();\n        index.add(2, &[0.0, 0.0, 1.0, 0.0]).unwrap();\n\n        assert_eq!(index.len(), 3);\n        assert!(!index.is_empty());\n\n        // Search for exact match\n        let results = index.search(&[1.0, 0.0, 0.0, 0.0], 3).unwrap();\n        assert!(!results.is_empty());\n        assert_eq!(results[0].0, 0); // Should find key 0 first\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 203
    },
    {
      "name": "test_add_batch",
      "qualified_name": "src/embedding/index.rs::test_add_batch",
      "file": "src/embedding/index.rs",
      "line": 906,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_add_batch()",
      "docstring": "",
      "calls": [
        "add_batch",
        "reserve",
        "create_test_index"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:5",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_add_batch() {\n        let index = create_test_index();\n        index.reserve(3).unwrap();\n\n        let keys = vec![0, 1, 2];\n        let vectors = vec![\n            vec![1.0, 0.0, 0.0, 0.0],\n            vec![0.0, 1.0, 0.0, 0.0],\n            vec![0.0, 0.0, 1.0, 0.0],\n        ];\n\n        index.add_batch(&keys, &vectors).unwrap();\n        assert_eq!(index.len(), 3);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 136
    },
    {
      "name": "test_add_batch_flat",
      "qualified_name": "src/embedding/index.rs::test_add_batch_flat",
      "file": "src/embedding/index.rs",
      "line": 922,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_add_batch_flat()",
      "docstring": "",
      "calls": [
        "reserve",
        "create_test_index",
        "add_batch_flat"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:5",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_add_batch_flat() {\n        let index = create_test_index();\n        index.reserve(2).unwrap();\n\n        let keys = vec![0, 1];\n        let vectors_flat = vec![\n            1.0, 0.0, 0.0, 0.0, // Vector 0\n            0.0, 1.0, 0.0, 0.0, // Vector 1\n        ];\n\n        index.add_batch_flat(&keys, &vectors_flat).unwrap();\n        assert_eq!(index.len(), 2);\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 123
    },
    {
      "name": "test_dimension_validation",
      "qualified_name": "src/embedding/index.rs::test_dimension_validation",
      "file": "src/embedding/index.rs",
      "line": 937,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_dimension_validation()",
      "docstring": "",
      "calls": [
        "reserve",
        "create_test_index",
        "add"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:7",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_dimension_validation() {\n        let index = create_test_index();\n        index.reserve(10).unwrap();\n\n        // Wrong dimensions should fail\n        let result = index.add(0, &[1.0, 0.0, 0.0]); // Only 3 dimensions\n        assert!(result.is_err());\n\n        let result = index.add(0, &[1.0, 0.0, 0.0, 0.0, 0.0]); // 5 dimensions\n        assert!(result.is_err());\n\n        // Correct dimensions should succeed\n        let result = index.add(0, &[1.0, 0.0, 0.0, 0.0]);\n        assert!(result.is_ok());\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "test",
        "error_handling"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 159
    },
    {
      "name": "test_contains",
      "qualified_name": "src/embedding/index.rs::test_contains",
      "file": "src/embedding/index.rs",
      "line": 954,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_contains()",
      "docstring": "",
      "calls": [
        "create_test_index",
        "add",
        "reserve"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:5",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_contains() {\n        let index = create_test_index();\n        index.reserve(10).unwrap();\n\n        assert!(!index.contains(42));\n\n        index.add(42, &[1.0, 0.0, 0.0, 0.0]).unwrap();\n        assert!(index.contains(42));\n        assert!(!index.contains(43));\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 83
    },
    {
      "name": "test_remove",
      "qualified_name": "src/embedding/index.rs::test_remove",
      "file": "src/embedding/index.rs",
      "line": 966,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_remove()",
      "docstring": "",
      "calls": [
        "reserve",
        "create_test_index",
        "remove",
        "add"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:5",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_remove() {\n        let index = create_test_index();\n        index.reserve(10).unwrap();\n\n        index.add(0, &[1.0, 0.0, 0.0, 0.0]).unwrap();\n        assert!(index.contains(0));\n\n        let removed = index.remove(0).unwrap();\n        assert_eq!(removed, 1);\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 81
    },
    {
      "name": "test_filtered_search",
      "qualified_name": "src/embedding/index.rs::test_filtered_search",
      "file": "src/embedding/index.rs",
      "line": 978,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_filtered_search()",
      "docstring": "",
      "calls": [
        "search_filtered",
        "add",
        "create_test_index",
        "reserve"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:7",
      "dfg_summary": "vars:7, def-use chains:4",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_filtered_search() {\n        let index = create_test_index();\n        index.reserve(20).unwrap();\n\n        for i in 0..10 {\n            index.add(i, &[i as f32 * 0.1, 0.0, 0.0, 0.0]).unwrap();\n        }\n\n        // Only search even keys\n        let results = index\n            .search_filtered(&[0.5, 0.0, 0.0, 0.0], 10, |key| key % 2 == 0)\n            .unwrap();\n\n        for (key, _) in results {\n            assert_eq!(key % 2, 0);\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 152
    },
    {
      "name": "test_metric_parsing",
      "qualified_name": "src/embedding/index.rs::test_metric_parsing",
      "file": "src/embedding/index.rs",
      "line": 997,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_metric_parsing()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:10, def-use chains:0",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_metric_parsing() {\n        assert_eq!(\"ip\".parse::<Metric>().unwrap(), Metric::InnerProduct);\n        assert_eq!(\"cosine\".parse::<Metric>().unwrap(), Metric::Cosine);\n        assert_eq!(\"l2\".parse::<Metric>().unwrap(), Metric::L2Squared);\n        assert!(\"invalid\".parse::<Metric>().is_err());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 76
    },
    {
      "name": "test_normalize_vector",
      "qualified_name": "src/embedding/index.rs::test_normalize_vector",
      "file": "src/embedding/index.rs",
      "line": 1005,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_normalize_vector()",
      "docstring": "",
      "calls": [
        "normalize_vector"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:3",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_normalize_vector() {\n        let v = vec![3.0, 4.0];\n        let normalized = normalize_vector(&v);\n\n        let norm: f32 = normalized.iter().map(|x| x * x).sum::<f32>().sqrt();\n        assert!((norm - 1.0).abs() < 1e-6);\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 80
    },
    {
      "name": "test_is_normalized",
      "qualified_name": "src/embedding/index.rs::test_is_normalized",
      "file": "src/embedding/index.rs",
      "line": 1014,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_is_normalized()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_is_normalized() {\n        let normalized = vec![0.6, 0.8];\n        let not_normalized = vec![3.0, 4.0];\n\n        assert!(is_normalized(&normalized, 1e-6));\n        assert!(!is_normalized(&not_normalized, 1e-6));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 70
    },
    {
      "name": "test_distances_to_scores",
      "qualified_name": "src/embedding/index.rs::test_distances_to_scores",
      "file": "src/embedding/index.rs",
      "line": 1023,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_distances_to_scores()",
      "docstring": "",
      "calls": [
        "distances_to_scores"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:5",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_distances_to_scores() {\n        let distances = vec![0.0, 0.5, 1.0, 1.5];\n        let scores = distances_to_scores(&distances);\n\n        assert!((scores[0] - 1.0).abs() < 1e-6);\n        assert!((scores[1] - 0.5).abs() < 1e-6);\n        assert!((scores[2] - 0.0).abs() < 1e-6);\n        assert!((scores[3] - 0.0).abs() < 1e-6); // Clamped\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 142
    },
    {
      "name": "test_config_builder",
      "qualified_name": "src/embedding/index.rs::test_config_builder",
      "file": "src/embedding/index.rs",
      "line": 1034,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_config_builder()",
      "docstring": "",
      "calls": [
        "with_quantization",
        "with_expansion_add",
        "with_metric",
        "new",
        "with_connectivity"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:6",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_config_builder() {\n        let config = IndexConfig::new(768)\n            .with_metric(Metric::Cosine)\n            .with_quantization(Quantization::F16)\n            .with_connectivity(32)\n            .with_expansion_add(128)\n            .with_expansion_search(64);\n\n        assert_eq!(config.dimensions, 768);\n        assert_eq!(config.metric, Metric::Cosine);\n        assert_eq!(config.quantization, Quantization::F16);\n        assert_eq!(config.connectivity, 32);\n        assert_eq!(config.expansion_add, 128);\n        assert_eq!(config.expansion_search, 64);\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 153
    },
    {
      "name": "test_estimate_memory",
      "qualified_name": "src/embedding/index.rs::test_estimate_memory",
      "file": "src/embedding/index.rs",
      "line": 1051,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_estimate_memory()",
      "docstring": "",
      "calls": [
        "with_quantization",
        "new",
        "estimate_memory"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_estimate_memory() {\n        let config = IndexConfig::new(768).with_quantization(Quantization::F32);\n        let estimate = config.estimate_memory(10000);\n\n        // Should be roughly 10000 * 768 * 4 * 2 = ~61MB\n        assert!(estimate > 50_000_000);\n        assert!(estimate < 100_000_000);\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 111
    },
    {
      "name": "test_empty_search",
      "qualified_name": "src/embedding/index.rs::test_empty_search",
      "file": "src/embedding/index.rs",
      "line": 1061,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_empty_search()",
      "docstring": "",
      "calls": [
        "create_test_index",
        "search"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_empty_search() {\n        let index = create_test_index();\n        let results = index.search(&[1.0, 0.0, 0.0, 0.0], 10).unwrap();\n        assert!(results.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 57
    },
    {
      "name": "test_search_k_larger_than_index",
      "qualified_name": "src/embedding/index.rs::test_search_k_larger_than_index",
      "file": "src/embedding/index.rs",
      "line": 1068,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_search_k_larger_than_index()",
      "docstring": "",
      "calls": [
        "add",
        "create_test_index",
        "search",
        "reserve"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:5",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_search_k_larger_than_index() {\n        let index = create_test_index();\n        index.reserve(10).unwrap();\n        index.add(0, &[1.0, 0.0, 0.0, 0.0]).unwrap();\n        index.add(1, &[0.0, 1.0, 0.0, 0.0]).unwrap();\n\n        // Ask for more results than exist\n        let results = index.search(&[1.0, 0.0, 0.0, 0.0], 100).unwrap();\n        assert_eq!(results.len(), 2); // Should only return what exists\n    }\n",
      "semantic_tags": [
        "crud",
        "test",
        "iteration"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 146
    },
    {
      "name": "test_debug_format",
      "qualified_name": "src/embedding/index.rs::test_debug_format",
      "file": "src/embedding/index.rs",
      "line": 1080,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_debug_format()",
      "docstring": "",
      "calls": [
        "create_test_index"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "    fn test_debug_format() {\n        let index = create_test_index();\n        let debug_str = format!(\"{:?}\", index);\n\n        assert!(debug_str.contains(\"VectorIndex\"));\n        assert!(debug_str.contains(\"dimensions: 4\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 50
    },
    {
      "name": "IndexConfig",
      "qualified_name": "src/embedding/index.rs::IndexConfig",
      "file": "src/embedding/index.rs",
      "line": 166,
      "language": "rust",
      "unit_type": "class",
      "signature": "class IndexConfig",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "pub struct IndexConfig {\n    /// Vector dimensions (must match embedding model output).\n    pub dimensions: usize,\n\n    /// Distance metric for similarity computation.\n    pub metric: Metric,\n\n    /// Scalar quantization for storage optimization.\n    pub quantization: Quantization,\n\n    /// Connectivity parameter (M in HNSW). Higher = better recall, more memory.\n    /// Default: 0 (uses usearch default, typically 16).\n    pub connectivity: usize,\n\n    /// Expansion factor during index construction (ef_construction).\n    /// Higher = better quality index, slower build. Default: 0 (uses usearch default).\n    pub expansion_add: usize,\n\n    /// Expansion factor during search (ef_search).\n    /// Higher = better recall, slower search. Default: 0 (uses usearch default).\n    pub expansion_search: usize,\n\n    /// Allow multiple vectors with the same key.\n    pub multi: bool,\n}\n",
      "semantic_tags": [
        "database",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 1,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 189
    },
    {
      "name": "VectorIndex",
      "qualified_name": "src/embedding/index.rs::VectorIndex",
      "file": "src/embedding/index.rs",
      "line": 291,
      "language": "rust",
      "unit_type": "class",
      "signature": "class VectorIndex",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::path, anyhow, usearch, super",
      "code_preview": "pub struct VectorIndex {\n    inner: Index,\n    config: IndexConfig,\n}\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 17
    },
    {
      "name": "(Rust) node_text",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) node_text",
      "file": "src/lang/rust_lang.rs",
      "line": 26,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) node_text(&self, node: Node<'a>, source: &'a [u8]) -> &'a str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn node_text<'a>(&self, node: Node<'a>, source: &'a [u8]) -> &'a str {\n        node.utf8_text(source).unwrap_or(\"\")\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 40
    },
    {
      "name": "(Rust) extract_doc_comments",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_doc_comments",
      "file": "src/lang/rust_lang.rs",
      "line": 31,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_doc_comments(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_doc_comments(&self, node: Node, source: &[u8]) -> Option<String> {\n        let mut comments = Vec::new();\n        let mut sibling = node.prev_sibling();\n\n        // Walk backwards to collect consecutive doc comments\n        while let Some(prev) = sibling {\n            if prev.kind() == \"line_comment\" {\n                let text = self.node_text(prev, source);\n                // Check for /// doc comments\n                if text.starts_with(\"///\") {\n                    let doc_content = text.trim_start_matches('/').trim();\n                    comments.push(doc_content.to_string());\n                } else if text.starts_with(\"//!\") {\n                    // Module-level doc comment, stop here\n                    break;\n                } else {\n                    // Regular comment, stop collecting\n                    break;\n                }\n            } else if prev.kind() == \"attribute_item\" {\n                // Skip attributes when looking for doc comments\n                sibling = prev.prev_sibling();\n                continue;\n            } else {\n                break;\n            }\n            sibling = prev.prev_sibling();\n        }\n\n        if comments.is_empty() {\n            None\n        } else {\n            comments.reverse();\n            Some(comments.join(\"\\n\"))\n        }\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 10,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 244
    },
    {
      "name": "(Rust) extract_attributes",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_attributes",
      "file": "src/lang/rust_lang.rs",
      "line": 69,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_attributes(&self, node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_attributes(&self, node: Node, source: &[u8]) -> Vec<String> {\n        let mut attributes = Vec::new();\n        let mut sibling = node.prev_sibling();\n\n        while let Some(prev) = sibling {\n            if prev.kind() == \"attribute_item\" {\n                let text = self.node_text(prev, source).trim().to_string();\n                attributes.push(text);\n            } else if prev.kind() == \"line_comment\" {\n                // Skip doc comments when collecting attributes\n                sibling = prev.prev_sibling();\n                continue;\n            } else {\n                break;\n            }\n            sibling = prev.prev_sibling();\n        }\n\n        attributes.reverse();\n        attributes\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 140
    },
    {
      "name": "(Rust) extract_visibility",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_visibility",
      "file": "src/lang/rust_lang.rs",
      "line": 92,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_visibility(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_visibility(&self, node: Node, source: &[u8]) -> Option<String> {\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"visibility_modifier\" {\n                return Some(self.node_text(child, source).to_string());\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 67
    },
    {
      "name": "(Rust) is_async_fn",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) is_async_fn",
      "file": "src/lang/rust_lang.rs",
      "line": 102,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) is_async_fn(&self, node: Node) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn is_async_fn(&self, node: Node) -> bool {\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"function_modifiers\" {\n                for modifier in child.children(&mut child.walk()) {\n                    if modifier.kind() == \"async\" {\n                        return true;\n                    }\n                }\n            }\n        }\n        false\n    }\n",
      "semantic_tags": [
        "async_ops",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 78
    },
    {
      "name": "(Rust) extract_type_params",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_type_params",
      "file": "src/lang/rust_lang.rs",
      "line": 116,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_type_params(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_type_params(&self, node: Node, source: &[u8]) -> Option<String> {\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"type_parameters\" {\n                return Some(self.node_text(child, source).to_string());\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 68
    },
    {
      "name": "(Rust) extract_where_clause",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_where_clause",
      "file": "src/lang/rust_lang.rs",
      "line": 126,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_where_clause(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_where_clause(&self, node: Node, source: &[u8]) -> Option<String> {\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"where_clause\" {\n                return Some(self.node_text(child, source).to_string());\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 68
    },
    {
      "name": "(Rust) extract_parameters",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_parameters",
      "file": "src/lang/rust_lang.rs",
      "line": 136,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_parameters(&self, node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_parameters(&self, node: Node, source: &[u8]) -> Vec<String> {\n        let mut params = Vec::new();\n\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"parameters\" {\n                for param in child.children(&mut child.walk()) {\n                    match param.kind() {\n                        \"parameter\" => {\n                            let param_text = self.node_text(param, source).to_string();\n                            params.push(param_text);\n                        }\n                        \"self_parameter\" => {\n                            let self_text = self.node_text(param, source).to_string();\n                            params.push(self_text);\n                        }\n                        _ => {}\n                    }\n                }\n            }\n        }\n\n        params\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 7,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 147
    },
    {
      "name": "(Rust) extract_return_type",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_return_type",
      "file": "src/lang/rust_lang.rs",
      "line": 161,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_return_type(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_return_type(&self, node: Node, source: &[u8]) -> Option<String> {\n        // Look for -> followed by return_type\n        let mut found_arrow = false;\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"->\" {\n                found_arrow = true;\n            } else if found_arrow && child.kind() != \"where_clause\" && child.kind() != \"block\" {\n                return Some(self.node_text(child, source).to_string());\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 114
    },
    {
      "name": "(Rust) extract_struct_fields",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_struct_fields",
      "file": "src/lang/rust_lang.rs",
      "line": 175,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_struct_fields(&self, node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_struct_fields(&self, node: Node, source: &[u8]) -> Vec<String> {\n        let mut fields = Vec::new();\n\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"field_declaration_list\" {\n                for field in child.children(&mut child.walk()) {\n                    if field.kind() == \"field_declaration\" {\n                        let field_text = self.node_text(field, source).trim().to_string();\n                        fields.push(field_text);\n                    }\n                }\n            }\n        }\n\n        fields\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 115
    },
    {
      "name": "(Rust) extract_methods_from_body",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_methods_from_body",
      "file": "src/lang/rust_lang.rs",
      "line": 193,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_methods_from_body(&self, body_node: Node, source: &[u8]) -> Vec<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_methods_from_body(&self, body_node: Node, source: &[u8]) -> Vec<FunctionInfo> {\n        let mut methods = Vec::new();\n\n        for child in body_node.children(&mut body_node.walk()) {\n            match child.kind() {\n                \"function_item\" => {\n                    if let Some(mut func) = self.extract_function(child, source) {\n                        func.is_method = true;\n                        methods.push(func);\n                    }\n                }\n                \"function_signature_item\" => {\n                    // Trait method signatures (no body)\n                    if let Some(mut func) = self.extract_function_signature(child, source) {\n                        func.is_method = true;\n                        methods.push(func);\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        methods\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 158
    },
    {
      "name": "(Rust) extract_function_signature",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_function_signature",
      "file": "src/lang/rust_lang.rs",
      "line": 219,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_function_signature(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_function_signature(&self, node: Node, source: &[u8]) -> Option<FunctionInfo> {\n        let mut name = None;\n        let mut params = Vec::new();\n        let mut return_type = None;\n\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"identifier\" => {\n                    if name.is_none() {\n                        name = Some(self.node_text(child, source).to_string());\n                    }\n                }\n                \"parameters\" => {\n                    params = self.extract_parameters(node, source);\n                }\n                \"->\" => {}\n                _ if child.kind().contains(\"type\") || child.kind() == \"primitive_type\" => {\n                    if name.is_some() && return_type.is_none() {\n                        // Check if this is after ->\n                        let mut prev = child.prev_sibling();\n                        while let Some(p) = prev {\n                            if p.kind() == \"->\" {\n                                return_type = Some(self.node_text(child, source).to_string());\n                                break;\n                            }\n                            prev = p.prev_sibling();\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        let name = name?;\n        let docstring = self.extract_doc_comments(node, source);\n        let attributes = self.extract_attributes(node, source);\n        let visibility = self.extract_visibility(node, source);\n\n        // Add visibility to decorators if present\n        let mut decorators = attributes;\n        if let Some(vis) = visibility {\n            decorators.insert(0, vis);\n        }\n\n        Some(FunctionInfo {\n            name,\n            params,\n            return_type: self.extract_return_type(node, source),\n            docstring,\n            is_method: false,\n            is_async: false,\n            decorators,\n            line_number: node.start_position().row + 1,\n            end_line_number: Some(node.end_position().row + 1),\n            language: \"rust\".to_string(),\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "config",
        "database"
      ],
      "complexity": {
        "depth": 8,
        "branches": 8,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 390
    },
    {
      "name": "(Rust) extract_impl_type",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_impl_type",
      "file": "src/lang/rust_lang.rs",
      "line": 278,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_impl_type(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_impl_type(&self, node: Node, source: &[u8]) -> Option<String> {\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"type\"\n                || child.kind() == \"generic_type\"\n                || child.kind() == \"type_identifier\"\n            {\n                // Skip if this is after \"for\" keyword (trait impl)\n                let mut prev = child.prev_sibling();\n                let mut is_trait = false;\n                while let Some(p) = prev {\n                    if p.kind() == \"for\" {\n                        is_trait = false;\n                        break;\n                    }\n                    if p.kind() == \"trait\" || p.kind() == \"type_identifier\" {\n                        // Check if there's a \"for\" after the trait name\n                        if let Some(next) = p.next_sibling() {\n                            if next.kind() == \"for\" {\n                                is_trait = true;\n                            }\n                        }\n                    }\n                    prev = p.prev_sibling();\n                }\n\n                // For simple impl blocks, get the type directly after type_parameters or impl\n                let type_text = self.node_text(child, source);\n                if !is_trait && !type_text.is_empty() {\n                    // Extract just the type name without generics for matching\n                    let base_type = type_text.split('<').next().unwrap_or(type_text);\n                    return Some(base_type.to_string());\n                }\n            }\n        }\n\n        // Try a different approach: look for type after impl or type_parameters\n        let mut found_impl = false;\n        let mut found_type_params = false;\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"impl\" {\n                found_impl = true;\n            } else if child.kind() == \"type_parameters\" {\n                found_type_params = true;\n            } else if found_impl || found_type_params {\n                if child.kind() == \"generic_type\" || child.kind() == \"type_identifier\" {\n                    let type_text = self.node_text(child, source);\n                    let base_type = type_text.split('<').next().unwrap_or(type_text);\n                    return Some(base_type.to_string());\n                }\n            }\n        }\n\n        None\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "error_handling",
        "api_endpoint",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 8,
        "branches": 14,
        "loops": 9
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 450
    },
    {
      "name": "(Rust) extract_impl_trait",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_impl_trait",
      "file": "src/lang/rust_lang.rs",
      "line": 334,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_impl_trait(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_impl_trait(&self, node: Node, source: &[u8]) -> Option<String> {\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"type_identifier\" || child.kind() == \"generic_type\" {\n                // Check if next sibling is \"for\"\n                if let Some(next) = child.next_sibling() {\n                    if next.kind() == \"for\" {\n                        return Some(self.node_text(child, source).to_string());\n                    }\n                }\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 6,
        "branches": 4,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 113
    },
    {
      "name": "(Rust) parse_use_path",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) parse_use_path",
      "file": "src/lang/rust_lang.rs",
      "line": 349,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) parse_use_path(&self, node: Node, source: &[u8]) -> (String, Vec<String>, HashMap<String, String>, bool)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parse_use_path(\n        &self,\n        node: Node,\n        source: &[u8],\n    ) -> (String, Vec<String>, HashMap<String, String>, bool) {\n        let mut module_parts = Vec::new();\n        let mut names = Vec::new();\n        let mut aliases = HashMap::new();\n        let mut is_glob = false;\n\n        self.traverse_use_tree(\n            node,\n            source,\n            &mut module_parts,\n            &mut names,\n            &mut aliases,\n            &mut is_glob,\n        );\n\n        let module = module_parts.join(\"::\");\n        (module, names, aliases, is_glob)\n    }\n",
      "semantic_tags": [
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 135
    },
    {
      "name": "(Rust) traverse_use_tree",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) traverse_use_tree",
      "file": "src/lang/rust_lang.rs",
      "line": 373,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) traverse_use_tree(&self, node: Node, source: &[u8], module_parts: &mut Vec<String>, names: &mut Vec<String>, aliases: &mut HashMap<String, String>, is_glob: &mut bool)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn traverse_use_tree(\n        &self,\n        node: Node,\n        source: &[u8],\n        module_parts: &mut Vec<String>,\n        names: &mut Vec<String>,\n        aliases: &mut HashMap<String, String>,\n        is_glob: &mut bool,\n    ) {\n        match node.kind() {\n            \"identifier\" | \"crate\" | \"super\" | \"self\" => {\n                module_parts.push(self.node_text(node, source).to_string());\n            }\n            \"scoped_identifier\" => {\n                for child in node.children(&mut node.walk()) {\n                    self.traverse_use_tree(child, source, module_parts, names, aliases, is_glob);\n                }\n            }\n            \"scoped_use_list\" => {\n                // First get the path part\n                for child in node.children(&mut node.walk()) {\n                    if child.kind() == \"scoped_identifier\"\n                        || child.kind() == \"identifier\"\n                        || child.kind() == \"crate\"\n                        || child.kind() == \"super\"\n                        || child.kind() == \"self\"\n                    {\n                        self.traverse_use_tree(\n                            child,\n                            source,\n                            module_parts,\n                            names,\n                            aliases,\n                            is_glob,\n                        );\n                    } else if child.kind() == \"use_list\" {\n                        self.traverse_use_tree(\n                            child,\n                            source,\n                            module_parts,\n                            names,\n                            aliases,\n                            is_glob,\n                        );\n                    }\n                }\n            }\n            \"use_list\" => {\n                for child in node.children(&mut node.walk()) {\n                    if child.kind() == \"identifier\" {\n                        names.push(self.node_text(child, source).to_string());\n                    } else if child.kind() == \"use_as_clause\" {\n                        let (name, alias) = self.extract_use_as_clause(child, source);\n                        names.push(name.clone());\n                        if let Some(a) = alias {\n                            aliases.insert(name, a);\n                        }\n                    } else if child.kind() == \"scoped_identifier\"\n                        || child.kind() == \"scoped_use_list\"\n                    {\n                        // Nested use in list - simplified handling\n                        let text = self.node_text(child, source);\n                        names.push(text.to_string());\n                    }\n                }\n            }\n            \"use_wildcard\" => {\n                // Handle glob imports (use path::*)\n                for child in node.children(&mut node.walk()) {\n                    if child.kind() == \"scoped_identifier\" {\n                        self.traverse_use_tree(\n                            child,\n                            source,\n                            module_parts,\n                            names,\n                            aliases,\n                            is_glob,\n                        );\n                    }\n                }\n                *is_glob = true;\n                names.push(\"*\".to_string());\n            }\n            \"use_as_clause\" => {\n                let (name, alias) = self.extract_use_as_clause(node, source);\n                // Get the path part\n                for child in node.children(&mut node.walk()) {\n                    if child.kind() == \"scoped_identifier\" {\n                        self.traverse_use_tree(\n                            child,\n                            source,\n                            module_parts,\n                            names,\n                            aliases,\n                            is_glob,\n                        );\n                    }\n                }\n                names.push(name.clone());\n                if let Some(a) = alias {\n                    aliases.insert(name, a);\n                }\n            }\n            _ => {\n                // Recurse into children\n                for child in node.children(&mut node.walk()) {\n                    self.traverse_use_tree(child, source, module_parts, names, aliases, is_glob);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 13,
        "loops": 6
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 709
    },
    {
      "name": "(Rust) extract_single_import",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_single_import",
      "file": "src/lang/rust_lang.rs",
      "line": 486,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_single_import(&self, node: Node, source: &[u8]) -> Option<ImportInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_single_import(&self, node: Node, source: &[u8]) -> Option<ImportInfo> {\n        // Find the argument child (the actual use path)\n        let argument = node.children(&mut node.walk()).find(|c: &Node| {\n            c.kind() == \"scoped_identifier\"\n                || c.kind() == \"scoped_use_list\"\n                || c.kind() == \"use_wildcard\"\n                || c.kind() == \"use_as_clause\"\n                || c.kind() == \"identifier\"\n        })?;\n\n        let (module, names, aliases, is_glob) = self.parse_use_path(argument, source);\n\n        // Determine if this is a \"from\" style import (has specific names)\n        let is_from = !names.is_empty() && !is_glob;\n\n        // Calculate relative import level\n        let level = if module.starts_with(\"super\") {\n            module.matches(\"super\").count()\n        } else if module.starts_with(\"self\") {\n            1\n        } else {\n            0\n        };\n\n        Some(ImportInfo {\n            module,\n            names,\n            aliases,\n            is_from,\n            level,\n        })\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 5,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 244
    },
    {
      "name": "(Rust) extract_use_as_clause",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_use_as_clause",
      "file": "src/lang/rust_lang.rs",
      "line": 520,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_use_as_clause(&self, node: Node, source: &[u8]) -> (String, Option<String>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_use_as_clause(&self, node: Node, source: &[u8]) -> (String, Option<String>) {\n        let mut name = String::new();\n        let mut alias = None;\n        let mut found_as = false;\n\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"scoped_identifier\" {\n                // Get the last part of the scoped identifier\n                let text = self.node_text(child, source);\n                name = text.rsplit(\"::\").next().unwrap_or(text).to_string();\n            } else if child.kind() == \"identifier\" {\n                if found_as {\n                    alias = Some(self.node_text(child, source).to_string());\n                } else {\n                    name = self.node_text(child, source).to_string();\n                }\n            } else if child.kind() == \"as\" {\n                found_as = true;\n            }\n        }\n\n        (name, alias)\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 7,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 194
    },
    {
      "name": "(Rust) build_rust_cfg",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) build_rust_cfg",
      "file": "src/lang/rust_lang.rs",
      "line": 545,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) build_rust_cfg(&self, node: Node, source: &[u8], function_name: &str) -> CFGInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_rust_cfg(&self, node: Node, source: &[u8], function_name: &str) -> CFGInfo {\n        let mut blocks = HashMap::new();\n        let mut edges = Vec::new();\n        let mut block_counter = 0;\n\n        // Create entry block\n        let entry_id = BlockId(block_counter);\n        block_counter += 1;\n\n        blocks.insert(\n            entry_id,\n            CFGBlock {\n                id: entry_id,\n                label: \"entry\".to_string(),\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.start_position().row + 1,\n            },\n        );\n\n        // Find function body\n        let body_node = node\n            .children(&mut node.walk())\n            .find(|c| c.kind() == \"block\");\n\n        let mut exit_blocks = Vec::new();\n\n        if let Some(body) = body_node {\n            let (last_block, exits) = self.process_cfg_block(\n                body,\n                source,\n                &mut blocks,\n                &mut edges,\n                &mut block_counter,\n                entry_id,\n            );\n            exit_blocks = exits;\n            if exit_blocks.is_empty() {\n                exit_blocks.push(last_block);\n            }\n        } else {\n            exit_blocks.push(entry_id);\n        }\n\n        // Create exit block\n        let exit_id = BlockId(block_counter);\n        blocks.insert(\n            exit_id,\n            CFGBlock {\n                id: exit_id,\n                label: \"exit\".to_string(),\n                statements: Vec::new(),\n                start_line: node.end_position().row + 1,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        // Connect all exit blocks to the exit node\n        for exit_block in &exit_blocks {\n            edges.push(CFGEdge {\n                from: *exit_block,\n                to: exit_id,\n                label: None,\n            });\n        }\n\n        CFGInfo {\n            function_name: function_name.to_string(),\n            blocks,\n            edges,\n            entry: entry_id,\n            exits: vec![exit_id],\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 441
    },
    {
      "name": "(Rust) process_cfg_block",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) process_cfg_block",
      "file": "src/lang/rust_lang.rs",
      "line": 621,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) process_cfg_block(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, counter: &mut usize, entry: BlockId) -> (BlockId, Vec<BlockId>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_cfg_block(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        counter: &mut usize,\n        entry: BlockId,\n    ) -> (BlockId, Vec<BlockId>) {\n        let mut current_block = entry;\n        let mut statements = Vec::new();\n        let mut exits = Vec::new();\n\n        for child in node.children(&mut node.walk()) {\n            // Handle expression_statement by processing its inner expression\n            let effective_child = if child.kind() == \"expression_statement\" {\n                // Get the inner expression\n                child.child(0).unwrap_or(child)\n            } else {\n                child\n            };\n\n            match effective_child.kind() {\n                \"if_expression\" => {\n                    let child = effective_child; // Use the unwrapped expression\n                                                 // Create block for if condition\n                    let if_block = BlockId(*counter);\n                    *counter += 1;\n\n                    let condition = child\n                        .children(&mut child.walk())\n                        .find(|c| {\n                            c.kind() != \"if\" && c.kind() != \"block\" && c.kind() != \"else_clause\"\n                        })\n                        .map(|c| self.node_text(c, source).to_string())\n                        .unwrap_or_else(|| \"condition\".to_string());\n\n                    blocks.insert(\n                        if_block,\n                        CFGBlock {\n                            id: if_block,\n                            label: format!(\"if {}\", condition.chars().take(30).collect::<String>()),\n                            statements: statements.drain(..).collect(),\n                            start_line: child.start_position().row + 1,\n                            end_line: child.start_position().row + 1,\n                        },\n                    );\n\n                    edges.push(CFGEdge {\n                        from: current_block,\n                        to: if_block,\n                        label: None,\n                    });\n\n                    // Process then branch\n                    let then_block = child\n                        .children(&mut child.walk())\n                        .find(|c| c.kind() == \"block\");\n\n                    let (then_exit, then_exits) = if let Some(then_body) = then_block {\n                        let then_entry = BlockId(*counter);\n                        *counter += 1;\n                        blocks.insert(\n                            then_entry,\n                            CFGBlock {\n                                id: then_entry,\n                                label: \"then\".to_string(),\n                                statements: Vec::new(),\n                                start_line: then_body.start_position().row + 1,\n                                end_line: then_body.end_position().row + 1,\n                            },\n                        );\n                        edges.push(CFGEdge {\n                            from: if_block,\n                            to: then_entry,\n                            label: Some(\"true\".to_string()),\n                        });\n                        self.process_cfg_block(\n                            then_body, source, blocks, edges, counter, then_entry,\n                        )\n                    } else {\n                        (if_block, Vec::new())\n                    };\n\n                    // Process else branch\n                    let else_clause = child\n                        .children(&mut child.walk())\n                        .find(|c| c.kind() == \"else_clause\");\n\n                    let else_exits = if let Some(else_node) = else_clause {\n                        let else_body = else_node\n                            .children(&mut else_node.walk())\n                            .find(|c| c.kind() == \"block\" || c.kind() == \"if_expression\");\n\n                        if let Some(else_content) = else_body {\n                            let else_entry = BlockId(*counter);\n                            *counter += 1;\n                            blocks.insert(\n                                else_entry,\n                                CFGBlock {\n                                    id: else_entry,\n                                    label: \"else\".to_string(),\n                                    statements: Vec::new(),\n                                    start_line: else_content.start_position().row + 1,\n                                    end_line: else_content.end_position().row + 1,\n                                },\n                            );\n                            edges.push(CFGEdge {\n                                from: if_block,\n                                to: else_entry,\n                                label: Some(\"false\".to_string()),\n                            });\n\n                            let (_, exits) = self.process_cfg_block(\n                                else_content,\n                                source,\n                                blocks,\n                                edges,\n                                counter,\n                                else_entry,\n                            );\n                            if exits.is_empty() {\n                                vec![else_entry]\n                            } else {\n                                exits\n                            }\n                        } else {\n                            vec![if_block]\n                        }\n                    } else {\n                        // No else branch - if_block exits on false\n                        edges.push(CFGEdge {\n                            from: if_block,\n                            to: if_block, // Will be updated to merge block\n                            label: Some(\"false\".to_string()),\n                        });\n                        vec![if_block]\n                    };\n\n                    // Create merge block\n                    let merge_block = BlockId(*counter);\n                    *counter += 1;\n                    blocks.insert(\n                        merge_block,\n                        CFGBlock {\n                            id: merge_block,\n                            label: \"merge\".to_string(),\n                            statements: Vec::new(),\n                            start_line: child.end_position().row + 1,\n                            end_line: child.end_position().row + 1,\n                        },\n                    );\n\n                    // Connect branches to merge\n                    if then_exits.is_empty() {\n                        edges.push(CFGEdge {\n                            from: then_exit,\n                            to: merge_block,\n                            label: None,\n                        });\n                    } else {\n                        for exit in then_exits {\n                            edges.push(CFGEdge {\n                                from: exit,\n                                to: merge_block,\n                                label: None,\n                            });\n                        }\n                    }\n\n                    for exit in &else_exits {\n                        if *exit != if_block {\n                            edges.push(CFGEdge {\n                                from: *exit,\n                                to: merge_block,\n                                label: None,\n                            });\n                        }\n                    }\n\n                    // Update false edge if no else clause\n                    if else_clause.is_none() {\n                        if let Some(edge) = edges\n                            .iter_mut()\n                            .rev()\n                            .find(|e| e.from == if_block && e.label == Some(\"false\".to_string()))\n                        {\n                            edge.to = merge_block;\n                        }\n                    }\n\n                    current_block = merge_block;\n                }\n                \"loop_expression\" | \"while_expression\" | \"for_expression\" => {\n                    let child = effective_child;\n                    // Create loop header block\n                    let loop_header = BlockId(*counter);\n                    *counter += 1;\n\n                    let loop_label = match child.kind() {\n                        \"while_expression\" => {\n                            let cond = child\n                                .children(&mut child.walk())\n                                .find(|c| c.kind() != \"while\" && c.kind() != \"block\")\n                                .map(|c| self.node_text(c, source).to_string())\n                                .unwrap_or_default();\n                            format!(\"while {}\", cond.chars().take(20).collect::<String>())\n                        }\n                        \"for_expression\" => \"for loop\".to_string(),\n                        _ => \"loop\".to_string(),\n                    };\n\n                    blocks.insert(\n                        loop_header,\n                        CFGBlock {\n                            id: loop_header,\n                            label: loop_label,\n                            statements: statements.drain(..).collect(),\n                            start_line: child.start_position().row + 1,\n                            end_line: child.start_position().row + 1,\n                        },\n                    );\n\n                    edges.push(CFGEdge {\n                        from: current_block,\n                        to: loop_header,\n                        label: None,\n                    });\n\n                    // Process loop body\n                    let body = child\n                        .children(&mut child.walk())\n                        .find(|c| c.kind() == \"block\");\n\n                    if let Some(loop_body) = body {\n                        let body_entry = BlockId(*counter);\n                        *counter += 1;\n                        blocks.insert(\n                            body_entry,\n                            CFGBlock {\n                                id: body_entry,\n                                label: \"loop body\".to_string(),\n                                statements: Vec::new(),\n                                start_line: loop_body.start_position().row + 1,\n                                end_line: loop_body.end_position().row + 1,\n                            },\n                        );\n\n                        edges.push(CFGEdge {\n                            from: loop_header,\n                            to: body_entry,\n                            label: Some(\"continue\".to_string()),\n                        });\n\n                        let (body_exit, _) = self.process_cfg_block(\n                            loop_body, source, blocks, edges, counter, body_entry,\n                        );\n\n                        // Back edge to loop header\n                        edges.push(CFGEdge {\n                            from: body_exit,\n                            to: loop_header,\n                            label: Some(\"loop\".to_string()),\n                        });\n                    }\n\n                    // Loop exit block\n                    let loop_exit = BlockId(*counter);\n                    *counter += 1;\n                    blocks.insert(\n                        loop_exit,\n                        CFGBlock {\n                            id: loop_exit,\n                            label: \"loop exit\".to_string(),\n                            statements: Vec::new(),\n                            start_line: child.end_position().row + 1,\n                            end_line: child.end_position().row + 1,\n                        },\n                    );\n\n                    edges.push(CFGEdge {\n                        from: loop_header,\n                        to: loop_exit,\n                        label: Some(\"break\".to_string()),\n                    });\n\n                    current_block = loop_exit;\n                }\n                \"match_expression\" => {\n                    let child = effective_child;\n                    let match_block = BlockId(*counter);\n                    *counter += 1;\n\n                    blocks.insert(\n                        match_block,\n                        CFGBlock {\n                            id: match_block,\n                            label: \"match\".to_string(),\n                            statements: statements.drain(..).collect(),\n                            start_line: child.start_position().row + 1,\n                            end_line: child.start_position().row + 1,\n                        },\n                    );\n\n                    edges.push(CFGEdge {\n                        from: current_block,\n                        to: match_block,\n                        label: None,\n                    });\n\n                    // Find match arms\n                    let match_body = child\n                        .children(&mut child.walk())\n                        .find(|c| c.kind() == \"match_block\");\n\n                    let mut arm_exits = Vec::new();\n\n                    if let Some(body) = match_body {\n                        for arm in body.children(&mut body.walk()) {\n                            if arm.kind() == \"match_arm\" {\n                                let arm_block = BlockId(*counter);\n                                *counter += 1;\n\n                                let pattern = arm\n                                    .children(&mut arm.walk())\n                                    .find(|c| c.kind() == \"match_pattern\")\n                                    .map(|p| self.node_text(p, source).to_string())\n                                    .unwrap_or_else(|| \"pattern\".to_string());\n\n                                blocks.insert(\n                                    arm_block,\n                                    CFGBlock {\n                                        id: arm_block,\n                                        label: pattern.chars().take(30).collect(),\n                                        statements: Vec::new(),\n                                        start_line: arm.start_position().row + 1,\n                                        end_line: arm.end_position().row + 1,\n                                    },\n                                );\n\n                                edges.push(CFGEdge {\n                                    from: match_block,\n                                    to: arm_block,\n                                    label: None,\n                                });\n\n                                arm_exits.push(arm_block);\n                            }\n                        }\n                    }\n\n                    // Merge block after match\n                    let merge_block = BlockId(*counter);\n                    *counter += 1;\n                    blocks.insert(\n                        merge_block,\n                        CFGBlock {\n                            id: merge_block,\n                            label: \"match merge\".to_string(),\n                            statements: Vec::new(),\n                            start_line: child.end_position().row + 1,\n                            end_line: child.end_position().row + 1,\n                        },\n                    );\n\n                    for arm_exit in arm_exits {\n                        edges.push(CFGEdge {\n                            from: arm_exit,\n                            to: merge_block,\n                            label: None,\n                        });\n                    }\n\n                    current_block = merge_block;\n                }\n                \"return_expression\" => {\n                    let child = effective_child;\n                    let stmt = self.node_text(child, source).to_string();\n                    statements.push(stmt);\n\n                    // Create return block\n                    let return_block = BlockId(*counter);\n                    *counter += 1;\n                    blocks.insert(\n                        return_block,\n                        CFGBlock {\n                            id: return_block,\n                            label: \"return\".to_string(),\n                            statements: statements.drain(..).collect(),\n                            start_line: child.start_position().row + 1,\n                            end_line: child.end_position().row + 1,\n                        },\n                    );\n\n                    edges.push(CFGEdge {\n                        from: current_block,\n                        to: return_block,\n                        label: None,\n                    });\n\n                    exits.push(return_block);\n\n                    // Create a new current block (unreachable but needed for structure)\n                    current_block = BlockId(*counter);\n                    *counter += 1;\n                    blocks.insert(\n                        current_block,\n                        CFGBlock {\n                            id: current_block,\n                            label: \"unreachable\".to_string(),\n                            statements: Vec::new(),\n                            start_line: child.end_position().row + 1,\n                            end_line: child.end_position().row + 1,\n                        },\n                    );\n                }\n                \"let_declaration\" => {\n                    let stmt = self.node_text(child, source).to_string();\n                    statements.push(stmt);\n                }\n                \"{\" | \"}\" => {}\n                _ => {\n                    // For expression_statement that didn't match a control flow pattern,\n                    // or other statement types, add to statements\n                    let text = self.node_text(child, source).trim();\n                    if !text.is_empty() && text != \";\" {\n                        statements.push(text.to_string());\n                    }\n                }\n            }\n        }\n\n        // Add remaining statements to current block\n        if !statements.is_empty() {\n            if let Some(block) = blocks.get_mut(&current_block) {\n                block.statements.extend(statements);\n            }\n        }\n\n        (current_block, exits)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 12,
        "branches": 36,
        "loops": 18
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 2786
    },
    {
      "name": "(Rust) build_rust_dfg",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) build_rust_dfg",
      "file": "src/lang/rust_lang.rs",
      "line": 1064,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) build_rust_dfg(&self, node: Node, source: &[u8], function_name: &str) -> DFGInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_rust_dfg(&self, node: Node, source: &[u8], function_name: &str) -> DFGInfo {\n        let mut edges = Vec::new();\n        let mut definitions: HashMap<String, Vec<usize>> = HashMap::new();\n        let mut uses: HashMap<String, Vec<usize>> = HashMap::new();\n\n        // Extract parameters as definitions\n        let params = self.extract_parameters(node, source);\n        let param_line = node.start_position().row + 1;\n\n        for param in &params {\n            // Extract variable name from param (e.g., \"name: &str\" -> \"name\")\n            let var_name = param\n                .split(':')\n                .next()\n                .map(|s| {\n                    s.trim()\n                        .trim_start_matches('&')\n                        .trim_start_matches(\"mut \")\n                        .to_string()\n                })\n                .unwrap_or_default();\n\n            if !var_name.is_empty()\n                && var_name != \"self\"\n                && var_name != \"&self\"\n                && var_name != \"&mut self\"\n            {\n                definitions\n                    .entry(var_name.clone())\n                    .or_default()\n                    .push(param_line);\n                edges.push(DataflowEdge {\n                    variable: var_name,\n                    from_line: param_line,\n                    to_line: param_line,\n                    kind: DataflowKind::Param,\n                });\n            }\n        }\n\n        // Find function body and process it\n        if let Some(body) = node\n            .children(&mut node.walk())\n            .find(|c| c.kind() == \"block\")\n        {\n            self.process_dfg_node(body, source, &mut edges, &mut definitions, &mut uses);\n        }\n\n        DFGInfo {\n            function_name: function_name.to_string(),\n            edges,\n            definitions,\n            uses,\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 377
    },
    {
      "name": "(Rust) process_dfg_node",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) process_dfg_node",
      "file": "src/lang/rust_lang.rs",
      "line": 1121,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) process_dfg_node(&self, node: Node, source: &[u8], edges: &mut Vec<DataflowEdge>, definitions: &mut HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_dfg_node(\n        &self,\n        node: Node,\n        source: &[u8],\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &mut HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n    ) {\n        match node.kind() {\n            \"let_declaration\" => {\n                let line = node.start_position().row + 1;\n\n                // Find the pattern (variable name)\n                if let Some(pattern) = node\n                    .children(&mut node.walk())\n                    .find(|c| c.kind() == \"identifier\" || c.kind() == \"tuple_pattern\")\n                {\n                    let var_name = if pattern.kind() == \"identifier\" {\n                        self.node_text(pattern, source).to_string()\n                    } else {\n                        // For tuple patterns, get each identifier\n                        pattern\n                            .children(&mut pattern.walk())\n                            .filter(|c| c.kind() == \"identifier\")\n                            .map(|c| self.node_text(c, source))\n                            .collect::<Vec<_>>()\n                            .join(\", \")\n                    };\n\n                    if !var_name.is_empty() {\n                        definitions.entry(var_name.clone()).or_default().push(line);\n                        edges.push(DataflowEdge {\n                            variable: var_name,\n                            from_line: line,\n                            to_line: line,\n                            kind: DataflowKind::Definition,\n                        });\n                    }\n                }\n\n                // Process the value expression for uses\n                if let Some(value) = node.children(&mut node.walk()).find(|c| {\n                    c.kind() != \"let\"\n                        && c.kind() != \"identifier\"\n                        && c.kind() != \":\"\n                        && c.kind() != \"mut\"\n                }) {\n                    self.extract_uses_from_expr(value, source, edges, definitions, uses);\n                }\n            }\n            \"assignment_expression\" => {\n                let line = node.start_position().row + 1;\n\n                // Left side is mutation\n                if let Some(left) = node.child(0) {\n                    let var_name = self.node_text(left, source).to_string();\n                    if !var_name.is_empty() {\n                        definitions.entry(var_name.clone()).or_default().push(line);\n                        edges.push(DataflowEdge {\n                            variable: var_name,\n                            from_line: line,\n                            to_line: line,\n                            kind: DataflowKind::Mutation,\n                        });\n                    }\n                }\n\n                // Right side is use\n                if let Some(right) = node.child(2) {\n                    self.extract_uses_from_expr(right, source, edges, definitions, uses);\n                }\n            }\n            \"return_expression\" => {\n                let line = node.start_position().row + 1;\n\n                // Process return value\n                for child in node.children(&mut node.walk()) {\n                    if child.kind() != \"return\" {\n                        self.extract_uses_from_expr(child, source, edges, definitions, uses);\n\n                        // Add return edge\n                        if child.kind() == \"identifier\" {\n                            let var_name = self.node_text(child, source).to_string();\n                            edges.push(DataflowEdge {\n                                variable: var_name,\n                                from_line: line,\n                                to_line: line,\n                                kind: DataflowKind::Return,\n                            });\n                        }\n                    }\n                }\n            }\n            _ => {\n                // Recurse into children\n                for child in node.children(&mut node.walk()) {\n                    self.process_dfg_node(child, source, edges, definitions, uses);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 8,
        "branches": 11,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 718
    },
    {
      "name": "(Rust) extract_uses_from_expr",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_uses_from_expr",
      "file": "src/lang/rust_lang.rs",
      "line": 1224,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_uses_from_expr(&self, node: Node, source: &[u8], edges: &mut Vec<DataflowEdge>, definitions: &HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_uses_from_expr(\n        &self,\n        node: Node,\n        source: &[u8],\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n    ) {\n        let line = node.start_position().row + 1;\n\n        match node.kind() {\n            \"identifier\" => {\n                let var_name = self.node_text(node, source).to_string();\n                // Check if this is a known variable (not a function call)\n                if definitions.contains_key(&var_name) {\n                    uses.entry(var_name.clone()).or_default().push(line);\n\n                    // Find the most recent definition\n                    if let Some(def_lines) = definitions.get(&var_name) {\n                        if let Some(&def_line) = def_lines.iter().filter(|&&l| l <= line).last() {\n                            edges.push(DataflowEdge {\n                                variable: var_name,\n                                from_line: def_line,\n                                to_line: line,\n                                kind: DataflowKind::Use,\n                            });\n                        }\n                    }\n                }\n            }\n            \"field_expression\" => {\n                // For x.field, x is used\n                if let Some(obj) = node.child(0) {\n                    if obj.kind() == \"identifier\" {\n                        let var_name = self.node_text(obj, source).to_string();\n                        if definitions.contains_key(&var_name) {\n                            uses.entry(var_name.clone()).or_default().push(line);\n                            if let Some(def_lines) = definitions.get(&var_name) {\n                                if let Some(&def_line) =\n                                    def_lines.iter().filter(|&&l| l <= line).last()\n                                {\n                                    edges.push(DataflowEdge {\n                                        variable: var_name,\n                                        from_line: def_line,\n                                        to_line: line,\n                                        kind: DataflowKind::Use,\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            _ => {\n                // Recurse\n                for child in node.children(&mut node.walk()) {\n                    self.extract_uses_from_expr(child, source, edges, definitions, uses);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "iteration",
        "transform"
      ],
      "complexity": {
        "depth": 10,
        "branches": 10,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 444
    },
    {
      "name": "(Rust) name",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) name",
      "file": "src/lang/rust_lang.rs",
      "line": 1288,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) name(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn name(&self) -> &'static str {\n        \"rust\"\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 17
    },
    {
      "name": "(Rust) extensions",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extensions",
      "file": "src/lang/rust_lang.rs",
      "line": 1292,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extensions(&self) -> &[&'static str]",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extensions(&self) -> &[&'static str] {\n        &[\".rs\"]\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 21
    },
    {
      "name": "(Rust) parser",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) parser",
      "file": "src/lang/rust_lang.rs",
      "line": 1296,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) parser(&self) -> Result<Parser>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parser(&self) -> Result<Parser> {\n        let mut parser = Parser::new();\n        parser\n            .set_language(&tree_sitter_rust::LANGUAGE.into())\n            .map_err(|e| TldrError::TreeSitter(e.to_string()))?;\n        Ok(parser)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 63
    },
    {
      "name": "(Rust) extract_function",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_function",
      "file": "src/lang/rust_lang.rs",
      "line": 1304,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo> {\n        if node.kind() != \"function_item\" {\n            return None;\n        }\n\n        // Extract function name\n        let name = node\n            .children(&mut node.walk())\n            .find(|c| c.kind() == \"identifier\")\n            .map(|n| self.node_text(n, source).to_string())?;\n\n        let params = self.extract_parameters(node, source);\n        let return_type = self.extract_return_type(node, source);\n        let docstring = self.extract_doc_comments(node, source);\n        let attributes = self.extract_attributes(node, source);\n        let visibility = self.extract_visibility(node, source);\n        let is_async = self.is_async_fn(node);\n        let type_params = self.extract_type_params(node, source);\n        let where_clause = self.extract_where_clause(node, source);\n\n        // Build decorators list: visibility + attributes + type info\n        let mut decorators = attributes;\n        if let Some(vis) = visibility {\n            decorators.insert(0, vis);\n        }\n        if let Some(tp) = type_params {\n            decorators.push(format!(\"generics: {}\", tp));\n        }\n        if let Some(wc) = where_clause {\n            decorators.push(format!(\"where: {}\", wc));\n        }\n\n        // Check if this is a method (has self parameter)\n        let is_method = params.iter().any(|p| p.contains(\"self\"));\n\n        Some(FunctionInfo {\n            name,\n            params,\n            return_type,\n            docstring,\n            is_method,\n            is_async,\n            decorators,\n            line_number: node.start_position().row + 1,\n            end_line_number: Some(node.end_position().row + 1),\n            language: \"rust\".to_string(),\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "logging",
        "iteration",
        "config",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 5,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 373
    },
    {
      "name": "(Rust) extract_class",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_class",
      "file": "src/lang/rust_lang.rs",
      "line": 1353,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo> {\n        match node.kind() {\n            \"struct_item\" => {\n                // Extract struct name\n                let name = node\n                    .children(&mut node.walk())\n                    .find(|c| c.kind() == \"type_identifier\")\n                    .map(|n| self.node_text(n, source).to_string())?;\n\n                let docstring = self.extract_doc_comments(node, source);\n                let attributes = self.extract_attributes(node, source);\n                let visibility = self.extract_visibility(node, source);\n                let type_params = self.extract_type_params(node, source);\n                let fields = self.extract_struct_fields(node, source);\n\n                let mut decorators = attributes;\n                if let Some(vis) = visibility {\n                    decorators.insert(0, vis);\n                }\n                if let Some(tp) = type_params {\n                    decorators.push(format!(\"generics: {}\", tp));\n                }\n\n                // Store fields as bases (repurposing the field)\n                let bases: Vec<String> = fields;\n\n                Some(ClassInfo {\n                    name,\n                    bases,\n                    docstring,\n                    methods: Vec::new(), // Methods come from impl blocks\n                    decorators,\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"rust\".to_string(),\n                })\n            }\n            \"impl_item\" => {\n                // Extract type being implemented\n                let type_name = self.extract_impl_type(node, source)?;\n                let trait_name = self.extract_impl_trait(node, source);\n                let type_params = self.extract_type_params(node, source);\n\n                // Find the body (declaration_list)\n                let body = node\n                    .children(&mut node.walk())\n                    .find(|c| c.kind() == \"declaration_list\");\n\n                let methods = body\n                    .map(|b| self.extract_methods_from_body(b, source))\n                    .unwrap_or_default();\n\n                let mut decorators = Vec::new();\n                if let Some(tp) = type_params {\n                    decorators.push(format!(\"generics: {}\", tp));\n                }\n\n                // Use trait as base if implementing a trait\n                let bases = trait_name\n                    .map(|t| vec![format!(\"impl {}\", t)])\n                    .unwrap_or_default();\n\n                Some(ClassInfo {\n                    name: type_name,\n                    bases,\n                    docstring: None,\n                    methods,\n                    decorators,\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"rust\".to_string(),\n                })\n            }\n            \"trait_item\" => {\n                // Extract trait name\n                let name = node\n                    .children(&mut node.walk())\n                    .find(|c| c.kind() == \"type_identifier\")\n                    .map(|n| self.node_text(n, source).to_string())?;\n\n                let docstring = self.extract_doc_comments(node, source);\n                let attributes = self.extract_attributes(node, source);\n                let visibility = self.extract_visibility(node, source);\n                let type_params = self.extract_type_params(node, source);\n\n                // Find the body (declaration_list)\n                let body = node\n                    .children(&mut node.walk())\n                    .find(|c| c.kind() == \"declaration_list\");\n\n                let methods = body\n                    .map(|b| self.extract_methods_from_body(b, source))\n                    .unwrap_or_default();\n\n                let mut decorators = attributes;\n                decorators.insert(0, \"trait\".to_string());\n                if let Some(vis) = visibility {\n                    decorators.insert(0, vis);\n                }\n                if let Some(tp) = type_params {\n                    decorators.push(format!(\"generics: {}\", tp));\n                }\n\n                Some(ClassInfo {\n                    name,\n                    bases: Vec::new(),\n                    docstring,\n                    methods,\n                    decorators,\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"rust\".to_string(),\n                })\n            }\n            _ => None,\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "config",
        "transform",
        "cache",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 7,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 852
    },
    {
      "name": "(Rust) extract_imports",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) extract_imports",
      "file": "src/lang/rust_lang.rs",
      "line": 1471,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo> {\n        let mut imports = Vec::new();\n        let root = tree.root_node();\n\n        // Iterate over all children to find use_declaration nodes\n        for child in root.children(&mut root.walk()) {\n            if child.kind() == \"use_declaration\" {\n                if let Some(import) = self.extract_single_import(child, source) {\n                    imports.push(import);\n                }\n            }\n        }\n\n        imports\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 110
    },
    {
      "name": "(Rust) function_query",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) function_query",
      "file": "src/lang/rust_lang.rs",
      "line": 1487,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) function_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn function_query(&self) -> &'static str {\n        r#\"[\n            (function_item name: (identifier) @name) @function\n            (function_signature_item name: (identifier) @name) @function\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 53
    },
    {
      "name": "(Rust) class_query",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) class_query",
      "file": "src/lang/rust_lang.rs",
      "line": 1494,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) class_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn class_query(&self) -> &'static str {\n        r#\"[\n            (struct_item name: (type_identifier) @name) @class\n            (impl_item type: (_) @name) @class\n            (trait_item name: (type_identifier) @name) @class\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 67
    },
    {
      "name": "(Rust) call_query",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) call_query",
      "file": "src/lang/rust_lang.rs",
      "line": 1502,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) call_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn call_query(&self) -> &'static str {\n        r#\"[\n            (call_expression function: (identifier) @callee) @call\n            (call_expression function: (field_expression field: (field_identifier) @callee)) @call\n            (call_expression function: (scoped_identifier name: (identifier) @callee)) @call\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 78
    },
    {
      "name": "(Rust) build_cfg",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) build_cfg",
      "file": "src/lang/rust_lang.rs",
      "line": 1510,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo> {\n        if node.kind() != \"function_item\" {\n            return Err(TldrError::TreeSitter(\n                \"CFG building requires a function_item node\".to_string(),\n            ));\n        }\n\n        // Extract function name\n        let function_name = node\n            .children(&mut node.walk())\n            .find(|c| c.kind() == \"identifier\")\n            .map(|n| self.node_text(n, source).to_string())\n            .unwrap_or_else(|| \"unknown\".to_string());\n\n        Ok(self.build_rust_cfg(node, source, &function_name))\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 142
    },
    {
      "name": "(Rust) build_dfg",
      "qualified_name": "src/lang/rust_lang.rs::(Rust) build_dfg",
      "file": "src/lang/rust_lang.rs",
      "line": 1527,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Rust) build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo> {\n        if node.kind() != \"function_item\" {\n            return Err(TldrError::TreeSitter(\n                \"DFG building requires a function_item node\".to_string(),\n            ));\n        }\n\n        // Extract function name\n        let function_name = node\n            .children(&mut node.walk())\n            .find(|c| c.kind() == \"identifier\")\n            .map(|n| self.node_text(n, source).to_string())\n            .unwrap_or_else(|| \"unknown\".to_string());\n\n        Ok(self.build_rust_dfg(node, source, &function_name))\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 146
    },
    {
      "name": "parse_rust",
      "qualified_name": "src/lang/rust_lang.rs::parse_rust",
      "file": "src/lang/rust_lang.rs",
      "line": 1549,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn parse_rust(code: &str) -> Tree",
      "docstring": "",
      "calls": [
        "parser"
      ],
      "called_by": [
        "test_extract_generic_function",
        "test_extract_impl_block",
        "test_extract_imports",
        "test_extract_async_function",
        "test_extract_simple_function"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:3",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parse_rust(code: &str) -> Tree {\n        let rust = Rust;\n        let mut parser = rust.parser().unwrap();\n        parser.parse(code, None).unwrap()\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 40
    },
    {
      "name": "test_extract_simple_function",
      "qualified_name": "src/lang/rust_lang.rs::test_extract_simple_function",
      "file": "src/lang/rust_lang.rs",
      "line": 1556,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_simple_function() -> String",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_python",
        "child_by_kind",
        "extract_function",
        "extract_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:19, def-use chains:6",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_simple_function() {\n        let code = r#\"\nfn hello(name: &str) -> String {\n    format!(\"Hello, {}\", name)\n}\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        // Find function_item\n        let root = tree.root_node();\n        let func_node = root.child(0).unwrap();\n\n        let func = rust.extract_function(func_node, code.as_bytes()).unwrap();\n\n        assert_eq!(func.name, \"hello\");\n        assert_eq!(func.params, vec![\"name: &str\"]);\n        assert_eq!(func.return_type, Some(\"String\".to_string()));\n        assert!(!func.is_async);\n        assert!(!func.is_method);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 151
    },
    {
      "name": "test_extract_async_function",
      "qualified_name": "src/lang/rust_lang.rs::test_extract_async_function",
      "file": "src/lang/rust_lang.rs",
      "line": 1579,
      "language": "rust",
      "unit_type": "function",
      "signature": "async fn test_extract_async_function() -> Result<Data, Error>",
      "docstring": "",
      "calls": [
        "parse_python",
        "child_by_kind",
        "extract_function",
        "extract_function",
        "parse_rust"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:16, def-use chains:6",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_async_function() {\n        let code = r#\"\npub async fn fetch_data(url: &str) -> Result<Data, Error> {\n    // fetch\n}\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        let root = tree.root_node();\n        let func_node = root.child(0).unwrap();\n\n        let func = rust.extract_function(func_node, code.as_bytes()).unwrap();\n\n        assert_eq!(func.name, \"fetch_data\");\n        assert!(func.is_async);\n        assert!(func.decorators.contains(&\"pub\".to_string()));\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "logging",
        "error_handling",
        "async_ops",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 123
    },
    {
      "name": "test_extract_generic_function",
      "qualified_name": "src/lang/rust_lang.rs::test_extract_generic_function",
      "file": "src/lang/rust_lang.rs",
      "line": 1599,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_generic_function() -> U\nwhere\n    U: From<T>,",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_rust"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:17, def-use chains:6",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_generic_function() {\n        let code = r#\"\nfn transform<T: Clone, U>(input: T) -> U\nwhere\n    U: From<T>,\n{\n    input.into()\n}\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        let root = tree.root_node();\n        let func_node = root.child(0).unwrap();\n\n        let func = rust.extract_function(func_node, code.as_bytes()).unwrap();\n\n        assert_eq!(func.name, \"transform\");\n        assert!(func.decorators.iter().any(|d| d.contains(\"generics:\")));\n        assert!(func.decorators.iter().any(|d| d.contains(\"where:\")));\n    }\n",
      "semantic_tags": [
        "test",
        "transform",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 144
    },
    {
      "name": "test_extract_struct",
      "qualified_name": "src/lang/rust_lang.rs::test_extract_struct",
      "file": "src/lang/rust_lang.rs",
      "line": 1622,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_struct()",
      "docstring": "",
      "calls": [
        "extract_class",
        "parse_go",
        "extract_class",
        "parse_c",
        "extract_class"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:22, def-use chains:11",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_struct() {\n        let code = r#\"\n/// A point in 2D space.\n#[derive(Debug, Clone)]\npub struct Point {\n    pub x: f64,\n    pub y: f64,\n}\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        let root = tree.root_node();\n        // Skip doc comment and attribute to get struct\n        let struct_node = root\n            .children(&mut root.walk())\n            .find(|c| c.kind() == \"struct_item\")\n            .unwrap();\n\n        let class = rust.extract_class(struct_node, code.as_bytes()).unwrap();\n\n        assert_eq!(class.name, \"Point\");\n        assert!(class.docstring.is_some());\n        assert!(class.decorators.contains(&\"pub\".to_string()));\n        assert!(class.bases.iter().any(|f| f.contains(\"x: f64\")));\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "logging",
        "api_endpoint",
        "test"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 190
    },
    {
      "name": "test_extract_impl_block",
      "qualified_name": "src/lang/rust_lang.rs::test_extract_impl_block",
      "file": "src/lang/rust_lang.rs",
      "line": 1650,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_impl_block() -> Self",
      "docstring": "",
      "calls": [
        "extract_class",
        "parse_rust"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:11",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_impl_block() {\n        let code = r#\"\nimpl Point {\n    pub fn new(x: f64, y: f64) -> Self {\n        Self { x, y }\n    }\n\n    pub fn distance(&self, other: &Point) -> f64 {\n        ((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt()\n    }\n}\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        let root = tree.root_node();\n        let impl_node = root.child(0).unwrap();\n\n        let class = rust.extract_class(impl_node, code.as_bytes()).unwrap();\n\n        assert_eq!(class.name, \"Point\");\n        assert_eq!(class.methods.len(), 2);\n        assert_eq!(class.methods[0].name, \"new\");\n        assert_eq!(class.methods[1].name, \"distance\");\n        assert!(class.methods[1].is_method);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 210
    },
    {
      "name": "test_extract_trait",
      "qualified_name": "src/lang/rust_lang.rs::test_extract_trait",
      "file": "src/lang/rust_lang.rs",
      "line": 1678,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_trait() -> Rect;\n}\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        let root = tree.root_node();\n        let trait_node = root\n            .children(&mut root.walk())\n            .find(|c| c.kind() == \"trait_item\")\n            .unwrap();\n\n        let class = rust.extract_class(trait_node, code.as_bytes()).unwrap();\n\n        assert_eq!(class.name, \"Drawable\");\n        assert!(class.decorators.contains(&\"trait\".to_string()));\n        assert_eq!(class.methods.len(), 2);\n    }",
      "docstring": "",
      "calls": [
        "extract_class",
        "parse_rust"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:18, def-use chains:10",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_trait() {\n        let code = r#\"\n/// A drawable trait.\npub trait Drawable {\n    fn draw(&self);\n    fn bounds(&self) -> Rect;\n}\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        let root = tree.root_node();\n        let trait_node = root\n            .children(&mut root.walk())\n            .find(|c| c.kind() == \"trait_item\")\n            .unwrap();\n\n        let class = rust.extract_class(trait_node, code.as_bytes()).unwrap();\n\n        assert_eq!(class.name, \"Drawable\");\n        assert!(class.decorators.contains(&\"trait\".to_string()));\n        assert_eq!(class.methods.len(), 2);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 150
    },
    {
      "name": "test_extract_imports",
      "qualified_name": "src/lang/rust_lang.rs::test_extract_imports",
      "file": "src/lang/rust_lang.rs",
      "line": 1703,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_imports()",
      "docstring": "",
      "calls": [
        "extract_imports",
        "extract_imports",
        "extract_imports",
        "parse_java",
        "parse_python"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:19, def-use chains:13",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_imports() {\n        let code = r#\"\nuse std::collections::{HashMap, HashSet};\nuse crate::module::*;\nuse super::parent;\nuse self::sibling as sib;\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        let imports = rust.extract_imports(&tree, code.as_bytes());\n\n        assert_eq!(imports.len(), 4);\n\n        // Check scoped import\n        let scoped = &imports[0];\n        assert!(scoped.module.contains(\"std\"));\n        assert!(scoped.names.contains(&\"HashMap\".to_string()));\n        assert!(scoped.names.contains(&\"HashSet\".to_string()));\n\n        // Check glob import\n        let glob = &imports[1];\n        assert!(glob.names.contains(&\"*\".to_string()));\n\n        // Check aliased import\n        let aliased = &imports[3];\n        assert!(aliased.aliases.contains_key(\"sibling\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 194
    },
    {
      "name": "test_build_simple_cfg",
      "qualified_name": "src/lang/rust_lang.rs::test_build_simple_cfg",
      "file": "src/lang/rust_lang.rs",
      "line": 1733,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_simple_cfg() -> i32",
      "docstring": "",
      "calls": [
        "build_cfg",
        "parse_java",
        "build_cfg",
        "parse_rust"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:9",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_build_simple_cfg() {\n        let code = r#\"\nfn example(x: i32) -> i32 {\n    let y = x + 1;\n    y * 2\n}\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        let root = tree.root_node();\n        let func_node = root.child(0).unwrap();\n\n        let cfg = rust.build_cfg(func_node, code.as_bytes()).unwrap();\n\n        assert_eq!(cfg.function_name, \"example\");\n        assert!(!cfg.blocks.is_empty());\n        assert!(!cfg.exits.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 129
    },
    {
      "name": "test_build_cfg_with_if",
      "qualified_name": "src/lang/rust_lang.rs::test_build_cfg_with_if",
      "file": "src/lang/rust_lang.rs",
      "line": 1754,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_cfg_with_if() -> bool",
      "docstring": "",
      "calls": [
        "parse_rust",
        "build_cfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:19, def-use chains:9",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_build_cfg_with_if() {\n        let code = r#\"\nfn check(x: i32) -> bool {\n    if x > 0 {\n        true\n    } else {\n        false\n    }\n}\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        let root = tree.root_node();\n        let func_node = root.child(0).unwrap();\n\n        let cfg = rust.build_cfg(func_node, code.as_bytes()).unwrap();\n\n        // Should have entry, if, then, else, merge, exit blocks\n        assert!(cfg.blocks.len() >= 4);\n\n        // Should have edges for true/false branches\n        assert!(cfg\n            .edges\n            .iter()\n            .any(|e| e.label == Some(\"true\".to_string())));\n        assert!(cfg\n            .edges\n            .iter()\n            .any(|e| e.label == Some(\"false\".to_string())));\n    }\n",
      "semantic_tags": [
        "validation",
        "async_ops",
        "iteration",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 198
    },
    {
      "name": "test_build_simple_dfg",
      "qualified_name": "src/lang/rust_lang.rs::test_build_simple_dfg",
      "file": "src/lang/rust_lang.rs",
      "line": 1787,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_simple_dfg() -> i32",
      "docstring": "",
      "calls": [
        "parse_rust",
        "build_dfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:9",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_build_simple_dfg() {\n        let code = r#\"\nfn example(x: i32) -> i32 {\n    let y = x + 1;\n    y * 2\n}\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        let root = tree.root_node();\n        let func_node = root.child(0).unwrap();\n\n        let dfg = rust.build_dfg(func_node, code.as_bytes()).unwrap();\n\n        assert_eq!(dfg.function_name, \"example\");\n        assert!(dfg.definitions.contains_key(\"x\"));\n        assert!(dfg.definitions.contains_key(\"y\"));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 138
    },
    {
      "name": "test_cyclomatic_complexity",
      "qualified_name": "src/lang/rust_lang.rs::test_cyclomatic_complexity",
      "file": "src/lang/rust_lang.rs",
      "line": 1808,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_cyclomatic_complexity() -> i32",
      "docstring": "",
      "calls": [
        "extract_from_source",
        "parse_rust",
        "build_cfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:8",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_cyclomatic_complexity() {\n        let code = r#\"\nfn complex(x: i32) -> i32 {\n    if x > 0 {\n        if x > 10 {\n            100\n        } else {\n            10\n        }\n    } else {\n        0\n    }\n}\n\"#;\n        let tree = parse_rust(code);\n        let rust = Rust;\n\n        let root = tree.root_node();\n        let func_node = root.child(0).unwrap();\n\n        let cfg = rust.build_cfg(func_node, code.as_bytes()).unwrap();\n        let complexity = cfg.cyclomatic_complexity();\n\n        // With nested if-else, complexity should be > 1\n        assert!(complexity >= 2);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 6,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 163
    },
    {
      "name": "Rust",
      "qualified_name": "src/lang/rust_lang.rs::Rust",
      "file": "src/lang/rust_lang.rs",
      "line": 22,
      "language": "rust",
      "unit_type": "class",
      "signature": "class Rust",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "pub struct Rust;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 0,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 4
    },
    {
      "name": "(TypeScript) get_text",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) get_text",
      "file": "src/lang/typescript.rs",
      "line": 25,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) get_text(&self, node: Node, source: &'a [u8]) -> &'a str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn get_text<'a>(&self, node: Node, source: &'a [u8]) -> &'a str {\n        std::str::from_utf8(&source[node.start_byte()..node.end_byte()]).unwrap_or(\"\")\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 51
    },
    {
      "name": "(TypeScript) parse_jsdoc",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) parse_jsdoc",
      "file": "src/lang/typescript.rs",
      "line": 30,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) parse_jsdoc(&self, comment: &str) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parse_jsdoc(&self, comment: &str) -> String {\n        let mut cleaned = Vec::new();\n        for line in comment.lines() {\n            let line = line.trim();\n            let line = line.strip_prefix(\"/**\").unwrap_or(line);\n            let line = line.strip_suffix(\"*/\").unwrap_or(line);\n            let line = line.strip_prefix('*').unwrap_or(line).trim();\n            if !line.is_empty() {\n                cleaned.push(line);\n            }\n        }\n        cleaned.join(\" \")\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 107
    },
    {
      "name": "(TypeScript) find_jsdoc",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) find_jsdoc",
      "file": "src/lang/typescript.rs",
      "line": 45,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) find_jsdoc(&self, node: Node<'a>, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn find_jsdoc<'a>(&self, node: Node<'a>, source: &[u8]) -> Option<String> {\n        let mut prev = node.prev_sibling();\n        while let Some(sibling) = prev {\n            if sibling.kind() == \"comment\" {\n                let text = self.get_text(sibling, source);\n                if text.starts_with(\"/**\") {\n                    return Some(self.parse_jsdoc(text));\n                }\n                return None;\n            }\n            // Skip whitespace-only text nodes\n            if sibling.is_named() {\n                return None;\n            }\n            prev = sibling.prev_sibling();\n        }\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 130
    },
    {
      "name": "(TypeScript) extract_params",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) extract_params",
      "file": "src/lang/typescript.rs",
      "line": 65,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) extract_params(&self, params_node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_params(&self, params_node: Node, source: &[u8]) -> Vec<String> {\n        let mut params = Vec::new();\n        for child in params_node.children(&mut params_node.walk()) {\n            match child.kind() {\n                \"identifier\" => {\n                    params.push(self.get_text(child, source).to_string());\n                }\n                \"required_parameter\" | \"optional_parameter\" | \"rest_parameter\" => {\n                    params.push(self.get_text(child, source).to_string());\n                }\n                // Skip punctuation\n                \"(\" | \")\" | \",\" => {}\n                _ => {\n                    // For complex parameter types, include the full text\n                    if child.is_named() {\n                        params.push(self.get_text(child, source).to_string());\n                    }\n                }\n            }\n        }\n        params\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 167
    },
    {
      "name": "(TypeScript) is_async",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) is_async",
      "file": "src/lang/typescript.rs",
      "line": 89,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) is_async(&self, node: Node, source: &[u8]) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn is_async(&self, node: Node, source: &[u8]) -> bool {\n        let text = self.get_text(node, source);\n        text.trim_start().starts_with(\"async\")\n    }\n",
      "semantic_tags": [
        "async_ops"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 43
    },
    {
      "name": "(TypeScript) extract_function_name",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) extract_function_name",
      "file": "src/lang/typescript.rs",
      "line": 95,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) extract_function_name(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_function_name(&self, node: Node, source: &[u8]) -> Option<String> {\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"identifier\" | \"property_identifier\" => {\n                    return Some(self.get_text(child, source).to_string());\n                }\n                _ => {}\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 80
    },
    {
      "name": "(TypeScript) collect_imports",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) collect_imports",
      "file": "src/lang/typescript.rs",
      "line": 108,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) collect_imports(&self, node: Node, source: &[u8], imports: &mut Vec<ImportInfo>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn collect_imports(&self, node: Node, source: &[u8], imports: &mut Vec<ImportInfo>) {\n        if node.kind() == \"import_statement\" {\n            if let Some(import_info) = self.extract_single_import(node, source) {\n                imports.push(import_info);\n            }\n        }\n\n        // Recurse into children\n        for child in node.children(&mut node.walk()) {\n            self.collect_imports(child, source, imports);\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 100
    },
    {
      "name": "(TypeScript) extract_single_import",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) extract_single_import",
      "file": "src/lang/typescript.rs",
      "line": 122,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) extract_single_import(&self, node: Node, source: &[u8]) -> Option<ImportInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_single_import(&self, node: Node, source: &[u8]) -> Option<ImportInfo> {\n        let mut module_path = String::new();\n        let mut names = Vec::new();\n        let mut aliases = HashMap::new();\n        let mut is_from = false;\n\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"string\" => {\n                    let text = self.get_text(child, source);\n                    module_path = text.trim_matches('\"').trim_matches('\\'').to_string();\n                }\n                \"import_clause\" => {\n                    is_from = true;\n                    let (n, a, default, namespace) = self.extract_import_names(child, source);\n                    names = n;\n                    aliases = a;\n\n                    // Add default import as a name\n                    if let Some(def) = default {\n                        names.insert(0, format!(\"default as {}\", def));\n                    }\n\n                    // Add namespace import\n                    if let Some(ns) = namespace {\n                        names.push(format!(\"* as {}\", ns));\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        if module_path.is_empty() {\n            return None;\n        }\n\n        Some(ImportInfo {\n            module: module_path,\n            names,\n            aliases,\n            is_from,\n            level: 0,\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "config",
        "database"
      ],
      "complexity": {
        "depth": 6,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 274
    },
    {
      "name": "(TypeScript) extract_import_names",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) extract_import_names",
      "file": "src/lang/typescript.rs",
      "line": 168,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) extract_import_names(&self, node: Node, source: &[u8]) -> (\n        Vec<String>,\n        HashMap<String, String>,\n        Option<String>,\n        Option<String>,\n    )",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_import_names(\n        &self,\n        node: Node,\n        source: &[u8],\n    ) -> (\n        Vec<String>,\n        HashMap<String, String>,\n        Option<String>,\n        Option<String>,\n    ) {\n        let mut names = Vec::new();\n        let mut aliases = HashMap::new();\n        let mut default_import = None;\n        let mut namespace_import = None;\n\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"identifier\" => {\n                    // Default import\n                    default_import = Some(self.get_text(child, source).to_string());\n                }\n                \"namespace_import\" => {\n                    // import * as name\n                    for grandchild in child.children(&mut child.walk()) {\n                        if grandchild.kind() == \"identifier\" {\n                            namespace_import = Some(self.get_text(grandchild, source).to_string());\n                        }\n                    }\n                }\n                \"named_imports\" => {\n                    // { a, b, c as d }\n                    for spec in child.children(&mut child.walk()) {\n                        if spec.kind() == \"import_specifier\" {\n                            let mut name = None;\n                            let mut alias = None;\n                            for part in spec.children(&mut spec.walk()) {\n                                if part.kind() == \"identifier\" {\n                                    if name.is_none() {\n                                        name = Some(self.get_text(part, source).to_string());\n                                    } else {\n                                        alias = Some(self.get_text(part, source).to_string());\n                                    }\n                                }\n                            }\n                            if let Some(n) = name {\n                                if let Some(a) = alias {\n                                    aliases.insert(n.clone(), a);\n                                }\n                                names.push(n);\n                            }\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        (names, aliases, default_import, namespace_import)\n    }\n",
      "semantic_tags": [
        "crud",
        "iteration",
        "config",
        "test",
        "database"
      ],
      "complexity": {
        "depth": 10,
        "branches": 8,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 375
    },
    {
      "name": "(TypeScript) name",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) name",
      "file": "src/lang/typescript.rs",
      "line": 230,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) name(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn name(&self) -> &'static str {\n        \"typescript\"\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 17
    },
    {
      "name": "(TypeScript) extensions",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) extensions",
      "file": "src/lang/typescript.rs",
      "line": 234,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) extensions(&self) -> &[&'static str]",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extensions(&self) -> &[&'static str] {\n        &[\".ts\", \".tsx\", \".js\", \".jsx\", \".mjs\", \".cjs\"]\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 38
    },
    {
      "name": "(TypeScript) parser",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) parser",
      "file": "src/lang/typescript.rs",
      "line": 238,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) parser(&self) -> Result<Parser>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parser(&self) -> Result<Parser> {\n        let mut parser = Parser::new();\n        parser\n            .set_language(&tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into())\n            .map_err(|e| TldrError::TreeSitter(e.to_string()))?;\n        Ok(parser)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 66
    },
    {
      "name": "(TypeScript) extract_function",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) extract_function",
      "file": "src/lang/typescript.rs",
      "line": 246,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo> {\n        let kind = node.kind();\n\n        // Handle different function types\n        match kind {\n            \"function_declaration\" | \"function_expression\" | \"generator_function_declaration\" => {\n                let name = self.extract_function_name(node, source)?;\n                let mut params = Vec::new();\n                let mut return_type = None;\n                let is_async = self.is_async(node, source);\n                let docstring = self.find_jsdoc(node, source);\n\n                for child in node.children(&mut node.walk()) {\n                    if child.kind() == \"formal_parameters\" {\n                        params = self.extract_params(child, source);\n                    } else if child.kind() == \"type_annotation\" {\n                        let text = self.get_text(child, source);\n                        return_type = Some(text.trim_start_matches(':').trim().to_string());\n                    }\n                }\n\n                Some(FunctionInfo {\n                    name,\n                    params,\n                    return_type,\n                    docstring,\n                    is_method: false,\n                    is_async,\n                    decorators: Vec::new(),\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"typescript\".to_string(),\n                })\n            }\n            \"method_definition\" => {\n                let name = self.extract_function_name(node, source)?;\n                let mut params = Vec::new();\n                let mut return_type = None;\n                let is_async = self.is_async(node, source);\n                let docstring = self.find_jsdoc(node, source);\n                let mut decorators = Vec::new();\n\n                // Check for static, private, public, protected modifiers\n                for child in node.children(&mut node.walk()) {\n                    match child.kind() {\n                        \"formal_parameters\" => {\n                            params = self.extract_params(child, source);\n                        }\n                        \"type_annotation\" => {\n                            let text = self.get_text(child, source);\n                            return_type = Some(text.trim_start_matches(':').trim().to_string());\n                        }\n                        \"accessibility_modifier\" => {\n                            decorators.push(self.get_text(child, source).to_string());\n                        }\n                        \"static\" => {\n                            decorators.push(\"static\".to_string());\n                        }\n                        _ => {}\n                    }\n                }\n\n                Some(FunctionInfo {\n                    name,\n                    params,\n                    return_type,\n                    docstring,\n                    is_method: true,\n                    is_async,\n                    decorators,\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"typescript\".to_string(),\n                })\n            }\n            \"arrow_function\" => {\n                // Arrow functions may not have names (they're often assigned)\n                // Try to get name from parent if it's a variable declarator\n                let name = if let Some(parent) = node.parent() {\n                    if parent.kind() == \"variable_declarator\" {\n                        parent\n                            .child_by_field_name(\"name\")\n                            .map(|n| self.get_text(n, source).to_string())\n                    } else if parent.kind() == \"pair\" || parent.kind() == \"property\" {\n                        // Object property: { key: () => {} }\n                        parent\n                            .child_by_field_name(\"key\")\n                            .map(|n| self.get_text(n, source).to_string())\n                    } else {\n                        None\n                    }\n                } else {\n                    None\n                };\n\n                let name = name.unwrap_or_else(|| \"<anonymous>\".to_string());\n                let mut params = Vec::new();\n                let mut return_type = None;\n                let is_async = self.is_async(node, source);\n                let docstring = self.find_jsdoc(node, source);\n\n                for child in node.children(&mut node.walk()) {\n                    match child.kind() {\n                        \"formal_parameters\" => {\n                            params = self.extract_params(child, source);\n                        }\n                        \"identifier\" => {\n                            // Single parameter without parentheses\n                            if params.is_empty() {\n                                params.push(self.get_text(child, source).to_string());\n                            }\n                        }\n                        \"type_annotation\" => {\n                            let text = self.get_text(child, source);\n                            return_type = Some(text.trim_start_matches(':').trim().to_string());\n                        }\n                        _ => {}\n                    }\n                }\n\n                Some(FunctionInfo {\n                    name,\n                    params,\n                    return_type,\n                    docstring,\n                    is_method: false,\n                    is_async,\n                    decorators: Vec::new(),\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"typescript\".to_string(),\n                })\n            }\n            _ => None,\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "error_handling",
        "api_endpoint",
        "iteration",
        "config",
        "test",
        "transform"
      ],
      "complexity": {
        "depth": 8,
        "branches": 14,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 979
    },
    {
      "name": "(TypeScript) extract_class",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) extract_class",
      "file": "src/lang/typescript.rs",
      "line": 383,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo> {\n        if node.kind() != \"class_declaration\" && node.kind() != \"class\" {\n            return None;\n        }\n\n        let mut name = String::new();\n        let mut bases = Vec::new();\n        let mut methods = Vec::new();\n        let docstring = self.find_jsdoc(node, source);\n        let mut decorators = Vec::new();\n\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"type_identifier\" | \"identifier\" => {\n                    if name.is_empty() {\n                        name = self.get_text(child, source).to_string();\n                    }\n                }\n                \"class_heritage\" => {\n                    // TypeScript class heritage contains extends and implements\n                    for heritage_child in child.children(&mut child.walk()) {\n                        match heritage_child.kind() {\n                            \"extends_clause\" => {\n                                for ext_child in heritage_child.children(&mut heritage_child.walk())\n                                {\n                                    if ext_child.kind() == \"identifier\"\n                                        || ext_child.kind() == \"type_identifier\"\n                                    {\n                                        bases.push(self.get_text(ext_child, source).to_string());\n                                    }\n                                }\n                            }\n                            \"implements_clause\" => {\n                                for impl_child in\n                                    heritage_child.children(&mut heritage_child.walk())\n                                {\n                                    if impl_child.kind() == \"type_identifier\"\n                                        || impl_child.kind() == \"identifier\"\n                                    {\n                                        bases.push(format!(\n                                            \"implements {}\",\n                                            self.get_text(impl_child, source)\n                                        ));\n                                    }\n                                }\n                            }\n                            _ => {}\n                        }\n                    }\n                }\n                \"extends_clause\" => {\n                    // Direct extends clause (JavaScript style)\n                    for ext_child in child.children(&mut child.walk()) {\n                        if ext_child.kind() == \"identifier\" {\n                            bases.push(self.get_text(ext_child, source).to_string());\n                        }\n                    }\n                }\n                \"implements_clause\" => {\n                    // Direct implements clause\n                    for impl_child in child.children(&mut child.walk()) {\n                        if impl_child.kind() == \"type_identifier\"\n                            || impl_child.kind() == \"identifier\"\n                        {\n                            bases.push(format!(\"implements {}\", self.get_text(impl_child, source)));\n                        }\n                    }\n                }\n                \"class_body\" => {\n                    for body_child in child.children(&mut child.walk()) {\n                        if body_child.kind() == \"method_definition\" {\n                            if let Some(method) = self.extract_function(body_child, source) {\n                                methods.push(method);\n                            }\n                        }\n                    }\n                }\n                \"decorator\" => {\n                    decorators.push(self.get_text(child, source).to_string());\n                }\n                _ => {}\n            }\n        }\n\n        if name.is_empty() {\n            return None;\n        }\n\n        Some(ClassInfo {\n            name,\n            bases,\n            docstring,\n            methods,\n            decorators,\n            line_number: node.start_position().row + 1,\n            end_line_number: Some(node.end_position().row + 1),\n            language: \"typescript\".to_string(),\n        })\n    }\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 11,
        "branches": 11,
        "loops": 7
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 638
    },
    {
      "name": "(TypeScript) extract_imports",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) extract_imports",
      "file": "src/lang/typescript.rs",
      "line": 483,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo> {\n        let mut imports = Vec::new();\n\n        // Walk the tree to find import statements directly\n        self.collect_imports(tree.root_node(), source, &mut imports);\n\n        imports\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 66
    },
    {
      "name": "(TypeScript) function_query",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) function_query",
      "file": "src/lang/typescript.rs",
      "line": 492,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) function_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn function_query(&self) -> &'static str {\n        r#\"[\n            (function_declaration name: (identifier) @name) @function\n            (method_definition name: (property_identifier) @name) @function\n            (arrow_function) @function\n            (function_expression) @function\n            (generator_function_declaration name: (identifier) @name) @function\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 85
    },
    {
      "name": "(TypeScript) class_query",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) class_query",
      "file": "src/lang/typescript.rs",
      "line": 502,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) class_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn class_query(&self) -> &'static str {\n        \"(class_declaration name: (type_identifier) @name) @class\"\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 30
    },
    {
      "name": "(TypeScript) call_query",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) call_query",
      "file": "src/lang/typescript.rs",
      "line": 506,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) call_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn call_query(&self) -> &'static str {\n        r#\"[\n            (call_expression function: (identifier) @callee) @call\n            (call_expression function: (member_expression property: (property_identifier) @callee)) @call\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 58
    },
    {
      "name": "(TypeScript) build_cfg",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) build_cfg",
      "file": "src/lang/typescript.rs",
      "line": 513,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo> {\n        let func_name = self\n            .extract_function_name(node, source)\n            .unwrap_or_else(|| \"<anonymous>\".to_string());\n\n        let mut builder = TypeScriptCFGBuilder::new(source);\n        builder.build(node, &func_name)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 75
    },
    {
      "name": "(TypeScript) build_dfg",
      "qualified_name": "src/lang/typescript.rs::(TypeScript) build_dfg",
      "file": "src/lang/typescript.rs",
      "line": 522,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScript) build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo> {\n        let func_name = self\n            .extract_function_name(node, source)\n            .unwrap_or_else(|| \"<anonymous>\".to_string());\n\n        let mut builder = TypeScriptDFGBuilder::new(source);\n        builder.build(node, &func_name)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 78
    },
    {
      "name": "tsx_parser",
      "qualified_name": "src/lang/typescript.rs::tsx_parser",
      "file": "src/lang/typescript.rs",
      "line": 533,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn tsx_parser() -> Result<Parser>",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:2",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "pub fn tsx_parser() -> Result<Parser> {\n    let mut parser = Parser::new();\n    parser\n        .set_language(&tree_sitter_typescript::LANGUAGE_TSX.into())\n        .map_err(|e| TldrError::TreeSitter(e.to_string()))?;\n    Ok(parser)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 64
    },
    {
      "name": "parser_for_extension",
      "qualified_name": "src/lang/typescript.rs::parser_for_extension",
      "file": "src/lang/typescript.rs",
      "line": 542,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn parser_for_extension(ext: &str) -> Result<Parser>",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:12, def-use chains:4",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "pub fn parser_for_extension(ext: &str) -> Result<Parser> {\n    let mut parser = Parser::new();\n    let lang = match ext {\n        \".tsx\" | \".jsx\" => &tree_sitter_typescript::LANGUAGE_TSX,\n        _ => &tree_sitter_typescript::LANGUAGE_TYPESCRIPT,\n    };\n    parser\n        .set_language(&(*lang).into())\n        .map_err(|e| TldrError::TreeSitter(e.to_string()))?;\n    Ok(parser)\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 106
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) new",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) new",
      "file": "src/lang/typescript.rs",
      "line": 577,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) new(source: &'a [u8]) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn new(source: &'a [u8]) -> Self {\n        Self {\n            source,\n            blocks: HashMap::new(),\n            edges: Vec::new(),\n            next_block_id: 0,\n            current_block: None,\n            entry: None,\n            exits: Vec::new(),\n            loop_guard_stack: Vec::new(),\n            after_loop_stack: Vec::new(),\n            decision_points: 0,\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 89
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) get_text",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) get_text",
      "file": "src/lang/typescript.rs",
      "line": 592,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) get_text(&self, node: Node) -> &str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn get_text(&self, node: Node) -> &str {\n        std::str::from_utf8(&self.source[node.start_byte()..node.end_byte()]).unwrap_or(\"\")\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 41
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) new_block",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) new_block",
      "file": "src/lang/typescript.rs",
      "line": 596,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) new_block(&mut self, label: String, start_line: usize, end_line: usize) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn new_block(&mut self, label: String, start_line: usize, end_line: usize) -> BlockId {\n        let id = BlockId(self.next_block_id);\n        self.next_block_id += 1;\n\n        let block = CFGBlock {\n            id,\n            label,\n            statements: Vec::new(),\n            start_line,\n            end_line,\n        };\n\n        self.blocks.insert(id, block);\n        id\n    }\n",
      "semantic_tags": [
        "crud",
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 89
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) add_edge",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) add_edge",
      "file": "src/lang/typescript.rs",
      "line": 612,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) add_edge(&mut self, from: BlockId, to: BlockId, label: Option<String>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn add_edge(&mut self, from: BlockId, to: BlockId, label: Option<String>) {\n        self.edges.push(CFGEdge { from, to, label });\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 40
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) build",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) build",
      "file": "src/lang/typescript.rs",
      "line": 616,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) build(&mut self, node: Node, func_name: &str) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build(&mut self, node: Node, func_name: &str) -> Result<CFGInfo> {\n        // Create entry block\n        let entry = self.new_block(\n            \"entry\".to_string(),\n            node.start_position().row + 1,\n            node.start_position().row + 1,\n        );\n        self.entry = Some(entry);\n        self.current_block = Some(entry);\n\n        // Find function body - find it first before mutable borrow\n        let body_node = {\n            let mut result = None;\n            for child in node.children(&mut node.walk()) {\n                match child.kind() {\n                    \"statement_block\" | \"block\" => {\n                        result = Some(child);\n                        break;\n                    }\n                    _ if child.kind().contains(\"expression\") && node.kind() == \"arrow_function\" => {\n                        result = Some(child);\n                        break;\n                    }\n                    _ => {}\n                }\n            }\n            result\n        };\n        if let Some(body) = body_node {\n            self.visit_node(body);\n        }\n\n        // Mark final block as exit if not already\n        if let Some(current) = self.current_block {\n            if !self.exits.contains(&current) {\n                self.exits.push(current);\n                if let Some(block) = self.blocks.get_mut(&current) {\n                    block.label = \"exit\".to_string();\n                }\n            }\n        }\n\n        Ok(CFGInfo {\n            function_name: func_name.to_string(),\n            blocks: self.blocks.clone(),\n            edges: self.edges.clone(),\n            entry: self.entry.unwrap_or(BlockId(0)),\n            exits: self.exits.clone(),\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "test",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 7,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 335
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) visit_node",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) visit_node",
      "file": "src/lang/typescript.rs",
      "line": 667,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) visit_node(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_node(&mut self, node: Node) {\n        match node.kind() {\n            \"if_statement\" => self.visit_if(node),\n            \"while_statement\" => self.visit_while(node),\n            \"do_statement\" => self.visit_do_while(node),\n            \"for_statement\" | \"for_in_statement\" => self.visit_for(node),\n            \"switch_statement\" => self.visit_switch(node),\n            \"try_statement\" => self.visit_try(node),\n            \"return_statement\" => self.visit_return(node),\n            \"break_statement\" => self.visit_break(node),\n            \"continue_statement\" => self.visit_continue(node),\n            \"throw_statement\" => self.visit_throw(node),\n            _ => {\n                // Visit children for compound nodes\n                for child in node.children(&mut node.walk()) {\n                    if child.is_named() {\n                        self.visit_node(child);\n                    }\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 183
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) visit_if",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) visit_if",
      "file": "src/lang/typescript.rs",
      "line": 690,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) visit_if(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_if(&mut self, node: Node) {\n        self.decision_points += 1;\n\n        let current = match self.current_block {\n            Some(id) => id,\n            None => return,\n        };\n\n        // Update current block to branch type\n        if let Some(block) = self.blocks.get_mut(&current) {\n            block.label = \"branch\".to_string();\n            block.end_line = node.start_position().row + 1;\n        }\n\n        // Get condition text\n        let condition = node\n            .child_by_field_name(\"condition\")\n            .map(|n| self.get_text(n).to_string())\n            .unwrap_or_else(|| \"<condition>\".to_string());\n\n        // Create after-if block\n        let after_if = self.new_block(\n            \"body\".to_string(),\n            node.end_position().row + 1,\n            node.end_position().row + 1,\n        );\n\n        // Process consequence (then branch)\n        if let Some(consequence) = node.child_by_field_name(\"consequence\") {\n            let true_block = self.new_block(\n                \"body\".to_string(),\n                consequence.start_position().row + 1,\n                consequence.end_position().row + 1,\n            );\n            self.add_edge(current, true_block, Some(format!(\"true: {}\", condition)));\n\n            self.current_block = Some(true_block);\n            self.visit_node(consequence);\n\n            if let Some(curr) = self.current_block {\n                if !self.exits.contains(&curr) {\n                    self.add_edge(curr, after_if, None);\n                }\n            }\n        }\n\n        // Process alternative (else branch)\n        if let Some(alternative) = node.child_by_field_name(\"alternative\") {\n            let false_block = self.new_block(\n                \"body\".to_string(),\n                alternative.start_position().row + 1,\n                alternative.end_position().row + 1,\n            );\n            self.add_edge(\n                current,\n                false_block,\n                Some(format!(\"false: not ({})\", condition)),\n            );\n\n            self.current_block = Some(false_block);\n            self.visit_node(alternative);\n\n            if let Some(curr) = self.current_block {\n                if !self.exits.contains(&curr) {\n                    self.add_edge(curr, after_if, None);\n                }\n            }\n        } else {\n            // No else branch\n            self.add_edge(\n                current,\n                after_if,\n                Some(format!(\"false: not ({})\", condition)),\n            );\n        }\n\n        self.current_block = Some(after_if);\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 12,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 514
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) visit_while",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) visit_while",
      "file": "src/lang/typescript.rs",
      "line": 769,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) visit_while(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_while(&mut self, node: Node) {\n        self.decision_points += 1;\n\n        // Create loop header\n        let guard = self.new_block(\n            \"loop_header\".to_string(),\n            node.start_position().row + 1,\n            node.start_position().row + 1,\n        );\n\n        if let Some(current) = self.current_block {\n            self.add_edge(current, guard, None);\n        }\n\n        let condition = node\n            .child_by_field_name(\"condition\")\n            .map(|n| self.get_text(n).to_string())\n            .unwrap_or_else(|| \"<condition>\".to_string());\n\n        let after_loop = self.new_block(\n            \"body\".to_string(),\n            node.end_position().row + 1,\n            node.end_position().row + 1,\n        );\n\n        self.loop_guard_stack.push(guard);\n        self.after_loop_stack.push(after_loop);\n\n        // Process body\n        if let Some(body) = node.child_by_field_name(\"body\") {\n            let loop_body = self.new_block(\n                \"loop_body\".to_string(),\n                body.start_position().row + 1,\n                body.end_position().row + 1,\n            );\n            self.add_edge(guard, loop_body, Some(format!(\"true: {}\", condition)));\n            self.add_edge(\n                guard,\n                after_loop,\n                Some(format!(\"false: not ({})\", condition)),\n            );\n\n            self.current_block = Some(loop_body);\n            self.visit_node(body);\n\n            if let Some(curr) = self.current_block {\n                if !self.exits.contains(&curr) {\n                    self.add_edge(curr, guard, Some(\"back_edge\".to_string()));\n                }\n            }\n        }\n\n        self.loop_guard_stack.pop();\n        self.after_loop_stack.pop();\n        self.current_block = Some(after_loop);\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 373
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) visit_do_while",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) visit_do_while",
      "file": "src/lang/typescript.rs",
      "line": 826,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) visit_do_while(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_do_while(&mut self, node: Node) {\n        self.decision_points += 1;\n\n        let current = self.current_block;\n\n        // Find body and condition\n        let mut body_node = None;\n        let mut condition_text = \"<condition>\".to_string();\n\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"statement_block\" {\n                body_node = Some(child);\n            } else if child.kind() == \"parenthesized_expression\" {\n                condition_text = self.get_text(child).to_string();\n            }\n        }\n\n        // Create loop body block\n        let loop_body = self.new_block(\n            \"loop_body\".to_string(),\n            body_node.map(|n| n.start_position().row + 1).unwrap_or(1),\n            body_node.map(|n| n.end_position().row + 1).unwrap_or(1),\n        );\n\n        if let Some(curr) = current {\n            self.add_edge(curr, loop_body, None);\n        }\n\n        // Create guard block (at the end)\n        let guard = self.new_block(\n            \"loop_header\".to_string(),\n            node.end_position().row,\n            node.end_position().row + 1,\n        );\n\n        let after_loop = self.new_block(\n            \"body\".to_string(),\n            node.end_position().row + 1,\n            node.end_position().row + 1,\n        );\n\n        self.loop_guard_stack.push(guard);\n        self.after_loop_stack.push(after_loop);\n\n        // Process body\n        self.current_block = Some(loop_body);\n        if let Some(body) = body_node {\n            self.visit_node(body);\n        }\n\n        if let Some(curr) = self.current_block {\n            if !self.exits.contains(&curr) {\n                self.add_edge(curr, guard, None);\n            }\n        }\n\n        // Guard edges\n        self.add_edge(guard, loop_body, Some(format!(\"true: {}\", condition_text)));\n        self.add_edge(\n            guard,\n            after_loop,\n            Some(format!(\"false: not ({})\", condition_text)),\n        );\n\n        self.loop_guard_stack.pop();\n        self.after_loop_stack.pop();\n        self.current_block = Some(after_loop);\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 7,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 452
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) visit_for",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) visit_for",
      "file": "src/lang/typescript.rs",
      "line": 895,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) visit_for(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_for(&mut self, node: Node) {\n        self.decision_points += 1;\n\n        let guard = self.new_block(\n            \"loop_header\".to_string(),\n            node.start_position().row + 1,\n            node.start_position().row + 1,\n        );\n\n        if let Some(current) = self.current_block {\n            self.add_edge(current, guard, None);\n        }\n\n        let after_loop = self.new_block(\n            \"body\".to_string(),\n            node.end_position().row + 1,\n            node.end_position().row + 1,\n        );\n\n        self.loop_guard_stack.push(guard);\n        self.after_loop_stack.push(after_loop);\n\n        // Find body\n        let body = node.child_by_field_name(\"body\");\n        if let Some(body) = body {\n            let loop_body = self.new_block(\n                \"loop_body\".to_string(),\n                body.start_position().row + 1,\n                body.end_position().row + 1,\n            );\n            self.add_edge(guard, loop_body, Some(\"iterate\".to_string()));\n            self.add_edge(guard, after_loop, Some(\"exhausted\".to_string()));\n\n            self.current_block = Some(loop_body);\n            self.visit_node(body);\n\n            if let Some(curr) = self.current_block {\n                if !self.exits.contains(&curr) {\n                    self.add_edge(curr, guard, Some(\"back_edge\".to_string()));\n                }\n            }\n        }\n\n        self.loop_guard_stack.pop();\n        self.after_loop_stack.pop();\n        self.current_block = Some(after_loop);\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 324
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) visit_switch",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) visit_switch",
      "file": "src/lang/typescript.rs",
      "line": 943,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) visit_switch(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_switch(&mut self, node: Node) {\n        let current = match self.current_block {\n            Some(id) => id,\n            None => return,\n        };\n\n        if let Some(block) = self.blocks.get_mut(&current) {\n            block.label = \"branch\".to_string();\n        }\n\n        let after_switch = self.new_block(\n            \"body\".to_string(),\n            node.end_position().row + 1,\n            node.end_position().row + 1,\n        );\n\n        // Find switch body\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"switch_body\" {\n                for case in child.children(&mut child.walk()) {\n                    if case.kind() == \"switch_case\" || case.kind() == \"switch_default\" {\n                        self.decision_points += 1;\n\n                        let case_block = self.new_block(\n                            \"case\".to_string(),\n                            case.start_position().row + 1,\n                            case.end_position().row + 1,\n                        );\n                        self.add_edge(current, case_block, None);\n\n                        self.current_block = Some(case_block);\n\n                        // Visit case body\n                        for case_child in case.children(&mut case.walk()) {\n                            if case_child.is_named()\n                                && case_child.kind() != \"case\"\n                                && case_child.kind() != \"default\"\n                            {\n                                self.visit_node(case_child);\n                            }\n                        }\n\n                        if let Some(curr) = self.current_block {\n                            if !self.exits.contains(&curr) {\n                                self.add_edge(curr, after_switch, None);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        self.current_block = Some(after_switch);\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 8,
        "branches": 18,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 344
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) visit_try",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) visit_try",
      "file": "src/lang/typescript.rs",
      "line": 998,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) visit_try(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_try(&mut self, node: Node) {\n        let current = match self.current_block {\n            Some(id) => id,\n            None => return,\n        };\n\n        let after_try = self.new_block(\n            \"body\".to_string(),\n            node.end_position().row + 1,\n            node.end_position().row + 1,\n        );\n\n        // Process try body\n        if let Some(body) = node.child_by_field_name(\"body\") {\n            let try_block = self.new_block(\n                \"try\".to_string(),\n                body.start_position().row + 1,\n                body.end_position().row + 1,\n            );\n            self.add_edge(current, try_block, None);\n            self.current_block = Some(try_block);\n            self.visit_node(body);\n\n            if let Some(curr) = self.current_block {\n                if !self.exits.contains(&curr) {\n                    self.add_edge(curr, after_try, None);\n                }\n            }\n        }\n\n        // Process catch clause\n        if let Some(handler) = node.child_by_field_name(\"handler\") {\n            self.decision_points += 1;\n            let catch_block = self.new_block(\n                \"catch\".to_string(),\n                handler.start_position().row + 1,\n                handler.end_position().row + 1,\n            );\n            self.add_edge(current, catch_block, Some(\"exception\".to_string()));\n            self.current_block = Some(catch_block);\n            self.visit_node(handler);\n\n            if let Some(curr) = self.current_block {\n                if !self.exits.contains(&curr) {\n                    self.add_edge(curr, after_try, None);\n                }\n            }\n        }\n\n        // Process finally clause\n        if let Some(finalizer) = node.child_by_field_name(\"finalizer\") {\n            let finally_block = self.new_block(\n                \"finally\".to_string(),\n                finalizer.start_position().row + 1,\n                finalizer.end_position().row + 1,\n            );\n            // Finally is reached from both normal and exceptional paths\n            // This is simplified - real CFG would be more complex\n            self.add_edge(after_try, finally_block, None);\n\n            self.current_block = Some(finally_block);\n            self.visit_node(finalizer);\n        }\n\n        self.current_block = Some(after_try);\n    }\n",
      "semantic_tags": [
        "api_endpoint",
        "error_handling"
      ],
      "complexity": {
        "depth": 5,
        "branches": 8,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 471
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) visit_return",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) visit_return",
      "file": "src/lang/typescript.rs",
      "line": 1065,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) visit_return(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_return(&mut self, node: Node) {\n        if let Some(current) = self.current_block {\n            if let Some(block) = self.blocks.get_mut(&current) {\n                block.label = \"return\".to_string();\n                block.end_line = node.end_position().row + 1;\n            }\n            self.exits.push(current);\n        }\n        self.current_block = None;\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 83
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) visit_throw",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) visit_throw",
      "file": "src/lang/typescript.rs",
      "line": 1076,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) visit_throw(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_throw(&mut self, node: Node) {\n        if let Some(current) = self.current_block {\n            if let Some(block) = self.blocks.get_mut(&current) {\n                block.label = \"throw\".to_string();\n                block.end_line = node.end_position().row + 1;\n            }\n            self.exits.push(current);\n        }\n        self.current_block = None;\n    }\n",
      "semantic_tags": [
        "error_handling"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 83
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) visit_break",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) visit_break",
      "file": "src/lang/typescript.rs",
      "line": 1087,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) visit_break(&mut self, _node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_break(&mut self, _node: Node) {\n        if let Some(current) = self.current_block {\n            if let Some(&after_loop) = self.after_loop_stack.last() {\n                self.add_edge(current, after_loop, Some(\"break\".to_string()));\n            }\n        }\n        self.current_block = None;\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 70
    },
    {
      "name": "(TypeScriptCFGBuilder<'a>) visit_continue",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptCFGBuilder<'a>) visit_continue",
      "file": "src/lang/typescript.rs",
      "line": 1096,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptCFGBuilder<'a>) visit_continue(&mut self, _node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_continue(&mut self, _node: Node) {\n        if let Some(current) = self.current_block {\n            if let Some(&guard) = self.loop_guard_stack.last() {\n                self.add_edge(current, guard, Some(\"continue\".to_string()));\n            }\n        }\n        self.current_block = None;\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 68
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) new",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) new",
      "file": "src/lang/typescript.rs",
      "line": 1120,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) new(source: &'a [u8]) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn new(source: &'a [u8]) -> Self {\n        Self {\n            source,\n            edges: Vec::new(),\n            definitions: HashMap::new(),\n            uses: HashMap::new(),\n            current_defs: HashMap::new(),\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 53
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) get_text",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) get_text",
      "file": "src/lang/typescript.rs",
      "line": 1130,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) get_text(&self, node: Node) -> &str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn get_text(&self, node: Node) -> &str {\n        std::str::from_utf8(&self.source[node.start_byte()..node.end_byte()]).unwrap_or(\"\")\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 41
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) build",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) build",
      "file": "src/lang/typescript.rs",
      "line": 1134,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) build(&mut self, node: Node, func_name: &str) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build(&mut self, node: Node, func_name: &str) -> Result<DFGInfo> {\n        // Extract parameters as initial definitions\n        self.extract_params(node);\n\n        // Find function body first before mutable borrow\n        let body_node = {\n            let mut result = None;\n            for child in node.children(&mut node.walk()) {\n                match child.kind() {\n                    \"statement_block\" | \"block\" => {\n                        result = Some(child);\n                        break;\n                    }\n                    _ => {}\n                }\n            }\n            result\n        };\n\n        // Analyze function body\n        if let Some(body) = body_node {\n            self.visit_node(body);\n        }\n\n        Ok(DFGInfo {\n            function_name: func_name.to_string(),\n            edges: self.edges.clone(),\n            definitions: self.definitions.clone(),\n            uses: self.uses.clone(),\n        })\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 183
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) extract_params",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) extract_params",
      "file": "src/lang/typescript.rs",
      "line": 1166,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) extract_params(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_params(&mut self, node: Node) {\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"formal_parameters\" {\n                let line = node.start_position().row + 1;\n                for param in child.children(&mut child.walk()) {\n                    match param.kind() {\n                        \"identifier\" => {\n                            let name = self.get_text(param).to_string();\n                            self.add_definition(&name, line, DataflowKind::Param);\n                        }\n                        \"required_parameter\" | \"optional_parameter\" => {\n                            // Find identifier within parameter\n                            for p_child in param.children(&mut param.walk()) {\n                                if p_child.kind() == \"identifier\" {\n                                    let name = self.get_text(p_child).to_string();\n                                    self.add_definition(&name, line, DataflowKind::Param);\n                                    break;\n                                }\n                            }\n                        }\n                        _ => {}\n                    }\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 9,
        "branches": 3,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 197
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) add_definition",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) add_definition",
      "file": "src/lang/typescript.rs",
      "line": 1193,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) add_definition(&mut self, var: &str, line: usize, kind: DataflowKind)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn add_definition(&mut self, var: &str, line: usize, kind: DataflowKind) {\n        self.definitions\n            .entry(var.to_string())\n            .or_default()\n            .push(line);\n        self.current_defs.insert(var.to_string(), line);\n\n        self.edges.push(DataflowEdge {\n            variable: var.to_string(),\n            from_line: line,\n            to_line: line,\n            kind,\n        });\n    }\n",
      "semantic_tags": [
        "crud",
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 91
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) add_use",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) add_use",
      "file": "src/lang/typescript.rs",
      "line": 1208,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) add_use(&mut self, var: &str, line: usize)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn add_use(&mut self, var: &str, line: usize) {\n        self.uses.entry(var.to_string()).or_default().push(line);\n\n        // Create edge from definition to use\n        if let Some(&def_line) = self.current_defs.get(var) {\n            self.edges.push(DataflowEdge {\n                variable: var.to_string(),\n                from_line: def_line,\n                to_line: line,\n                kind: DataflowKind::Use,\n            });\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 101
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) visit_node",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) visit_node",
      "file": "src/lang/typescript.rs",
      "line": 1222,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) visit_node(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_node(&mut self, node: Node) {\n        match node.kind() {\n            \"variable_declaration\" | \"lexical_declaration\" => {\n                self.visit_variable_declaration(node);\n            }\n            \"assignment_expression\" => {\n                self.visit_assignment(node);\n            }\n            \"update_expression\" => {\n                self.visit_update(node);\n            }\n            \"return_statement\" => {\n                self.visit_return(node);\n            }\n            \"identifier\" => {\n                // This is a use of a variable\n                let name = self.get_text(node).to_string();\n                let line = node.start_position().row + 1;\n                self.add_use(&name, line);\n            }\n            _ => {\n                // Recursively visit children\n                for child in node.children(&mut node.walk()) {\n                    if child.is_named() {\n                        self.visit_node(child);\n                    }\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 183
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) visit_variable_declaration",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) visit_variable_declaration",
      "file": "src/lang/typescript.rs",
      "line": 1253,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) visit_variable_declaration(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_variable_declaration(&mut self, node: Node) {\n        let line = node.start_position().row + 1;\n\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"variable_declarator\" {\n                // Get the name\n                if let Some(name_node) = child.child_by_field_name(\"name\") {\n                    let name = self.get_text(name_node).to_string();\n                    self.add_definition(&name, line, DataflowKind::Definition);\n\n                    // Process the value (if any) for uses\n                    if let Some(value) = child.child_by_field_name(\"value\") {\n                        self.visit_node(value);\n                    }\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 4,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 147
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) visit_assignment",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) visit_assignment",
      "file": "src/lang/typescript.rs",
      "line": 1272,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) visit_assignment(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_assignment(&mut self, node: Node) {\n        let line = node.start_position().row + 1;\n\n        // Process right side first (uses)\n        if let Some(right) = node.child_by_field_name(\"right\") {\n            self.visit_node(right);\n        }\n\n        // Then process left side (definition/mutation)\n        if let Some(left) = node.child_by_field_name(\"left\") {\n            if left.kind() == \"identifier\" {\n                let name = self.get_text(left).to_string();\n                self.add_definition(&name, line, DataflowKind::Mutation);\n            } else {\n                // Complex assignment (e.g., obj.prop = value)\n                self.visit_node(left);\n            }\n        }\n    }\n",
      "semantic_tags": [
        "async_ops"
      ],
      "complexity": {
        "depth": 4,
        "branches": 4,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 152
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) visit_update",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) visit_update",
      "file": "src/lang/typescript.rs",
      "line": 1292,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) visit_update(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_update(&mut self, node: Node) {\n        let line = node.start_position().row + 1;\n\n        // Find the identifier being updated\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"identifier\" {\n                let name = self.get_text(child).to_string();\n                // Update is both a use and a mutation\n                self.add_use(&name, line);\n                self.add_definition(&name, line, DataflowKind::Mutation);\n                break;\n            }\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 112
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) visit_return",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) visit_return",
      "file": "src/lang/typescript.rs",
      "line": 1307,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) visit_return(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_return(&mut self, node: Node) {\n        let line = node.start_position().row + 1;\n\n        // Visit the returned expression\n        for child in node.children(&mut node.walk()) {\n            if child.is_named() && child.kind() != \"return\" {\n                // Record any identifiers as uses\n                self.visit_return_expr(child, line);\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 83
    },
    {
      "name": "(TypeScriptDFGBuilder<'a>) visit_return_expr",
      "qualified_name": "src/lang/typescript.rs::(TypeScriptDFGBuilder<'a>) visit_return_expr",
      "file": "src/lang/typescript.rs",
      "line": 1319,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (TypeScriptDFGBuilder<'a>) visit_return_expr(&mut self, node: Node, line: usize)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn visit_return_expr(&mut self, node: Node, line: usize) {\n        if node.kind() == \"identifier\" {\n            let name = self.get_text(node).to_string();\n            self.add_use(&name, line);\n\n            // Add return edge\n            if let Some(&def_line) = self.current_defs.get(&name) {\n                self.edges.push(DataflowEdge {\n                    variable: name,\n                    from_line: def_line,\n                    to_line: line,\n                    kind: DataflowKind::Return,\n                });\n            }\n        } else {\n            for child in node.children(&mut node.walk()) {\n                if child.is_named() {\n                    self.visit_return_expr(child, line);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 151
    },
    {
      "name": "parse_ts",
      "qualified_name": "src/lang/typescript.rs::parse_ts",
      "file": "src/lang/typescript.rs",
      "line": 1347,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn parse_ts(source: &str) -> Tree",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [
        "test_extract_function_declaration",
        "test_extract_class",
        "test_extract_async_arrow_function",
        "test_extract_class_with_inheritance",
        "test_extract_imports"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parse_ts(source: &str) -> Tree {\n        let mut parser = Parser::new();\n        parser\n            .set_language(&tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into())\n            .unwrap();\n        parser.parse(source, None).unwrap()\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 56
    },
    {
      "name": "test_extract_function_declaration",
      "qualified_name": "src/lang/typescript.rs::test_extract_function_declaration",
      "file": "src/lang/typescript.rs",
      "line": 1356,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_function_declaration()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_c",
        "parse_ts",
        "extract_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:19, def-use chains:6",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_function_declaration() {\n        let source = r#\"\nfunction greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\"#;\n        let tree = parse_ts(source);\n        let ts = TypeScript;\n\n        // Find function node\n        let root = tree.root_node();\n        let func_node = root.child(0).unwrap();\n\n        let func = ts.extract_function(func_node, source.as_bytes()).unwrap();\n        assert_eq!(func.name, \"greet\");\n        assert_eq!(func.params.len(), 1);\n        assert!(func.params[0].contains(\"name\"));\n        assert_eq!(func.return_type, Some(\"string\".to_string()));\n        assert!(!func.is_async);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 150
    },
    {
      "name": "test_extract_async_arrow_function",
      "qualified_name": "src/lang/typescript.rs::test_extract_async_arrow_function",
      "file": "src/lang/typescript.rs",
      "line": 1378,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_async_arrow_function() -> variable_declarator",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_ts"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:8",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_async_arrow_function() {\n        let source = r#\"\nconst fetchData = async (url: string): Promise<Response> => {\n    return fetch(url);\n};\n\"#;\n        let tree = parse_ts(source);\n        let ts = TypeScript;\n\n        // Find arrow function node\n        let root = tree.root_node();\n        // Navigate: lexical_declaration -> variable_declarator -> arrow_function\n        let lexical = root.child(0).unwrap();\n        let declarator = lexical.child(1).unwrap();\n        let arrow = declarator.child(2).unwrap();\n\n        let func = ts.extract_function(arrow, source.as_bytes()).unwrap();\n        assert_eq!(func.name, \"fetchData\");\n        assert!(func.is_async);\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "api_endpoint",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 153
    },
    {
      "name": "test_extract_class",
      "qualified_name": "src/lang/typescript.rs::test_extract_class",
      "file": "src/lang/typescript.rs",
      "line": 1400,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_class()",
      "docstring": "",
      "calls": [
        "extract_class",
        "extract_class",
        "parse_java",
        "extract_class",
        "parse_ts"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:13, def-use chains:8",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_class() {\n        let source = r#\"\nclass Animal {\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    speak(): void {\n        console.log(this.name);\n    }\n}\n\"#;\n        let tree = parse_ts(source);\n        let ts = TypeScript;\n\n        let root = tree.root_node();\n        let class_node = root.child(0).unwrap();\n\n        let class_info = ts.extract_class(class_node, source.as_bytes()).unwrap();\n        assert_eq!(class_info.name, \"Animal\");\n        assert_eq!(class_info.methods.len(), 2); // constructor + speak\n    }\n",
      "semantic_tags": [
        "logging"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 129
    },
    {
      "name": "test_extract_class_with_inheritance",
      "qualified_name": "src/lang/typescript.rs::test_extract_class_with_inheritance",
      "file": "src/lang/typescript.rs",
      "line": 1424,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_class_with_inheritance()",
      "docstring": "",
      "calls": [
        "extract_class",
        "parse_ts"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:17, def-use chains:9",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_class_with_inheritance() {\n        let source = r#\"\nclass Dog extends Animal implements Pet {\n    bark(): void {\n        console.log(\"Woof!\");\n    }\n}\n\"#;\n        let tree = parse_ts(source);\n        let ts = TypeScript;\n\n        let root = tree.root_node();\n        let class_node = root.child(0).unwrap();\n\n        let class_info = ts.extract_class(class_node, source.as_bytes()).unwrap();\n        assert_eq!(class_info.name, \"Dog\");\n        assert!(class_info.bases.iter().any(|b| b == \"Animal\"));\n        assert!(class_info.bases.iter().any(|b| b.contains(\"Pet\")));\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "logging"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 141
    },
    {
      "name": "test_extract_imports",
      "qualified_name": "src/lang/typescript.rs::test_extract_imports",
      "file": "src/lang/typescript.rs",
      "line": 1445,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_imports()",
      "docstring": "",
      "calls": [
        "extract_imports",
        "extract_imports",
        "extract_imports",
        "parse_java",
        "parse_python"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:19, def-use chains:12",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_imports() {\n        let source = r#\"\nimport { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport * as fs from 'fs';\n\"#;\n        let tree = parse_ts(source);\n        let ts = TypeScript;\n\n        let imports = ts.extract_imports(&tree, source.as_bytes());\n        assert_eq!(imports.len(), 3);\n\n        // Check named imports\n        let react_import = imports.iter().find(|i| i.module == \"react\").unwrap();\n        assert!(react_import.names.iter().any(|n| n == \"useState\"));\n        assert!(react_import.names.iter().any(|n| n == \"useEffect\"));\n\n        // Check default import\n        let axios_import = imports.iter().find(|i| i.module == \"axios\").unwrap();\n        assert!(axios_import\n            .names\n            .iter()\n            .any(|n| n.contains(\"default as axios\")));\n\n        // Check namespace import\n        let fs_import = imports.iter().find(|i| i.module == \"fs\").unwrap();\n        assert!(fs_import.names.iter().any(|n| n.contains(\"* as fs\")));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 240
    },
    {
      "name": "TypeScript",
      "qualified_name": "src/lang/typescript.rs::TypeScript",
      "file": "src/lang/typescript.rs",
      "line": 21,
      "language": "rust",
      "unit_type": "class",
      "signature": "class TypeScript",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "pub struct TypeScript;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 0,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 4
    },
    {
      "name": "TypeScriptCFGBuilder",
      "qualified_name": "src/lang/typescript.rs::TypeScriptCFGBuilder",
      "file": "src/lang/typescript.rs",
      "line": 559,
      "language": "rust",
      "unit_type": "class",
      "signature": "class TypeScriptCFGBuilder",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "struct TypeScriptCFGBuilder<'a> {\n    source: &'a [u8],\n    blocks: HashMap<BlockId, CFGBlock>,\n    edges: Vec<CFGEdge>,\n    next_block_id: usize,\n    current_block: Option<BlockId>,\n    entry: Option<BlockId>,\n    exits: Vec<BlockId>,\n\n    // Loop context for break/continue\n    loop_guard_stack: Vec<BlockId>,\n    after_loop_stack: Vec<BlockId>,\n\n    // Decision points for cyclomatic complexity\n    decision_points: usize,\n}\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 109
    },
    {
      "name": "TypeScriptDFGBuilder",
      "qualified_name": "src/lang/typescript.rs::TypeScriptDFGBuilder",
      "file": "src/lang/typescript.rs",
      "line": 1111,
      "language": "rust",
      "unit_type": "class",
      "signature": "class TypeScriptDFGBuilder",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "struct TypeScriptDFGBuilder<'a> {\n    source: &'a [u8],\n    edges: Vec<DataflowEdge>,\n    definitions: HashMap<String, Vec<usize>>,\n    uses: HashMap<String, Vec<usize>>,\n    current_defs: HashMap<String, usize>, // Variable -> definition line\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 60
    },
    {
      "name": "(Java) node_text",
      "qualified_name": "src/lang/java.rs::(Java) node_text",
      "file": "src/lang/java.rs",
      "line": 26,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) node_text(&self, node: Node<'a>, source: &'a [u8]) -> &'a str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn node_text<'a>(&self, node: Node<'a>, source: &'a [u8]) -> &'a str {\n        node.utf8_text(source).unwrap_or(\"\")\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 40
    },
    {
      "name": "(Java) child_by_field",
      "qualified_name": "src/lang/java.rs::(Java) child_by_field",
      "file": "src/lang/java.rs",
      "line": 31,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) child_by_field(&self, node: Node<'a>, field: &str) -> Option<Node<'a>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn child_by_field<'a>(&self, node: Node<'a>, field: &str) -> Option<Node<'a>> {\n        node.child_by_field_name(field)\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 38
    },
    {
      "name": "(Java) extract_modifiers",
      "qualified_name": "src/lang/java.rs::(Java) extract_modifiers",
      "file": "src/lang/java.rs",
      "line": 37,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_modifiers(&self, node: Node, source: &[u8]) -> (Option<String>, bool, bool, bool, bool, bool, Vec<String>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_modifiers(\n        &self,\n        node: Node,\n        source: &[u8],\n    ) -> (Option<String>, bool, bool, bool, bool, bool, Vec<String>) {\n        let mut visibility = None;\n        let mut is_static = false;\n        let mut is_final = false;\n        let mut is_abstract = false;\n        let mut is_synchronized = false;\n        let mut is_default = false;\n        let mut annotations = Vec::new();\n\n        // Find the modifiers node\n        let modifiers_node = node\n            .children(&mut node.walk())\n            .find(|n| n.kind() == \"modifiers\");\n\n        if let Some(mods) = modifiers_node {\n            let mut cursor = mods.walk();\n            for child in mods.children(&mut cursor) {\n                match child.kind() {\n                    \"public\" => visibility = Some(\"public\".to_string()),\n                    \"private\" => visibility = Some(\"private\".to_string()),\n                    \"protected\" => visibility = Some(\"protected\".to_string()),\n                    \"static\" => is_static = true,\n                    \"final\" => is_final = true,\n                    \"abstract\" => is_abstract = true,\n                    \"synchronized\" => is_synchronized = true,\n                    \"default\" => is_default = true,\n                    \"marker_annotation\" | \"annotation\" => {\n                        annotations.push(self.extract_annotation(child, source));\n                    }\n                    _ => {}\n                }\n            }\n        }\n\n        (\n            visibility,\n            is_static,\n            is_final,\n            is_abstract,\n            is_synchronized,\n            is_default,\n            annotations,\n        )\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 331
    },
    {
      "name": "(Java) extract_annotation",
      "qualified_name": "src/lang/java.rs::(Java) extract_annotation",
      "file": "src/lang/java.rs",
      "line": 87,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_annotation(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_annotation(&self, node: Node, source: &[u8]) -> String {\n        self.node_text(node, source).to_string()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 33
    },
    {
      "name": "(Java) extract_type",
      "qualified_name": "src/lang/java.rs::(Java) extract_type",
      "file": "src/lang/java.rs",
      "line": 92,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_type(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_type(&self, node: Node, source: &[u8]) -> String {\n        match node.kind() {\n            \"void_type\" => \"void\".to_string(),\n            \"type_identifier\" => self.node_text(node, source).to_string(),\n            \"integral_type\" | \"floating_point_type\" | \"boolean_type\" => {\n                self.node_text(node, source).to_string()\n            }\n            \"generic_type\" => self.extract_generic_type(node, source),\n            \"array_type\" => self.extract_array_type(node, source),\n            \"scoped_type_identifier\" => self.extract_scoped_type(node, source),\n            _ => self.node_text(node, source).to_string(),\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 146
    },
    {
      "name": "(Java) extract_generic_type",
      "qualified_name": "src/lang/java.rs::(Java) extract_generic_type",
      "file": "src/lang/java.rs",
      "line": 107,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_generic_type(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_generic_type(&self, node: Node, source: &[u8]) -> String {\n        let mut result = String::new();\n\n        // Get the base type\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"type_identifier\" | \"scoped_type_identifier\" => {\n                    result.push_str(self.node_text(child, source));\n                }\n                \"type_arguments\" => {\n                    result.push_str(self.extract_type_arguments(child, source).as_str());\n                }\n                _ => {}\n            }\n        }\n\n        result\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 118
    },
    {
      "name": "(Java) extract_type_arguments",
      "qualified_name": "src/lang/java.rs::(Java) extract_type_arguments",
      "file": "src/lang/java.rs",
      "line": 127,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_type_arguments(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_type_arguments(&self, node: Node, source: &[u8]) -> String {\n        let mut args = Vec::new();\n\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"type_identifier\" | \"generic_type\" | \"wildcard\" | \"scoped_type_identifier\" => {\n                    args.push(self.extract_type(child, source));\n                }\n                _ => {}\n            }\n        }\n\n        if args.is_empty() {\n            \"<>\".to_string()\n        } else {\n            format!(\"<{}>\", args.join(\", \"))\n        }\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 122
    },
    {
      "name": "(Java) extract_array_type",
      "qualified_name": "src/lang/java.rs::(Java) extract_array_type",
      "file": "src/lang/java.rs",
      "line": 147,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_array_type(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_array_type(&self, node: Node, source: &[u8]) -> String {\n        let mut base_type = String::new();\n        let mut dimensions = 0;\n\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"type_identifier\"\n                | \"integral_type\"\n                | \"floating_point_type\"\n                | \"boolean_type\"\n                | \"generic_type\" => {\n                    base_type = self.extract_type(child, source);\n                }\n                \"dimensions\" => {\n                    dimensions = child.child_count() / 2; // Count [ ] pairs\n                    if dimensions == 0 {\n                        dimensions = 1;\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        format!(\"{}{}\", base_type, \"[]\".repeat(dimensions.max(1)))\n    }\n",
      "semantic_tags": [
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 170
    },
    {
      "name": "(Java) extract_scoped_type",
      "qualified_name": "src/lang/java.rs::(Java) extract_scoped_type",
      "file": "src/lang/java.rs",
      "line": 174,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_scoped_type(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_scoped_type(&self, node: Node, source: &[u8]) -> String {\n        self.node_text(node, source).to_string()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 35
    },
    {
      "name": "(Java) extract_parameters",
      "qualified_name": "src/lang/java.rs::(Java) extract_parameters",
      "file": "src/lang/java.rs",
      "line": 179,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_parameters(&self, node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_parameters(&self, node: Node, source: &[u8]) -> Vec<String> {\n        let mut params = Vec::new();\n\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"formal_parameter\" | \"spread_parameter\" => {\n                    params.push(self.extract_single_parameter(child, source));\n                }\n                \"receiver_parameter\" => {\n                    // Java receiver parameter (Type this) - skip for signature\n                }\n                _ => {}\n            }\n        }\n\n        params\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 111
    },
    {
      "name": "(Java) extract_single_parameter",
      "qualified_name": "src/lang/java.rs::(Java) extract_single_parameter",
      "file": "src/lang/java.rs",
      "line": 198,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_single_parameter(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_single_parameter(&self, node: Node, source: &[u8]) -> String {\n        let mut param_type = String::new();\n        let mut param_name = String::new();\n        let mut is_vararg = false;\n\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"type_identifier\"\n                | \"integral_type\"\n                | \"floating_point_type\"\n                | \"boolean_type\"\n                | \"generic_type\"\n                | \"array_type\"\n                | \"scoped_type_identifier\"\n                | \"void_type\" => {\n                    param_type = self.extract_type(child, source);\n                }\n                \"identifier\" => {\n                    param_name = self.node_text(child, source).to_string();\n                }\n                \"...\" => {\n                    is_vararg = true;\n                }\n                \"modifiers\" => {\n                    // Parameter modifiers like final - skip for signature\n                }\n                \"dimensions\" => {\n                    // Array dimensions after parameter name\n                    param_type.push_str(\"[]\");\n                }\n                _ => {}\n            }\n        }\n\n        if is_vararg {\n            format!(\"{}... {}\", param_type, param_name)\n        } else if param_name.is_empty() {\n            param_type\n        } else {\n            format!(\"{} {}\", param_type, param_name)\n        }\n    }\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 5,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 270
    },
    {
      "name": "(Java) extract_type_parameters",
      "qualified_name": "src/lang/java.rs::(Java) extract_type_parameters",
      "file": "src/lang/java.rs",
      "line": 242,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_type_parameters(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_type_parameters(&self, node: Node, source: &[u8]) -> Option<String> {\n        let type_params = self.child_by_field(node, \"type_parameters\")?;\n        let mut params = Vec::new();\n\n        for child in type_params.children(&mut type_params.walk()) {\n            if child.kind() == \"type_parameter\" {\n                params.push(self.extract_type_parameter(child, source));\n            }\n        }\n\n        if params.is_empty() {\n            None\n        } else {\n            Some(format!(\"<{}>\", params.join(\", \")))\n        }\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 118
    },
    {
      "name": "(Java) extract_type_parameter",
      "qualified_name": "src/lang/java.rs::(Java) extract_type_parameter",
      "file": "src/lang/java.rs",
      "line": 260,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_type_parameter(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_type_parameter(&self, node: Node, source: &[u8]) -> String {\n        let mut result = String::new();\n\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"type_identifier\" => {\n                    result.push_str(self.node_text(child, source));\n                }\n                \"type_bound\" => {\n                    result.push_str(\" extends \");\n                    result.push_str(self.extract_type_bound(child, source).as_str());\n                }\n                _ => {}\n            }\n        }\n\n        result\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 112
    },
    {
      "name": "(Java) extract_type_bound",
      "qualified_name": "src/lang/java.rs::(Java) extract_type_bound",
      "file": "src/lang/java.rs",
      "line": 280,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_type_bound(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_type_bound(&self, node: Node, source: &[u8]) -> String {\n        let mut bounds = Vec::new();\n\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"type_identifier\" | \"generic_type\" | \"scoped_type_identifier\" => {\n                    bounds.push(self.extract_type(child, source));\n                }\n                _ => {}\n            }\n        }\n\n        bounds.join(\" & \")\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 94
    },
    {
      "name": "(Java) extract_javadoc",
      "qualified_name": "src/lang/java.rs::(Java) extract_javadoc",
      "file": "src/lang/java.rs",
      "line": 296,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_javadoc(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_javadoc(&self, node: Node, source: &[u8]) -> Option<String> {\n        // Look for block_comment immediately before the declaration\n        let mut prev = node.prev_sibling();\n        while let Some(sibling) = prev {\n            match sibling.kind() {\n                \"block_comment\" => {\n                    let comment = self.node_text(sibling, source);\n                    // Check if it's a Javadoc comment (starts with /**)\n                    if comment.starts_with(\"/**\") {\n                        return Some(self.parse_javadoc(comment));\n                    }\n                    return None;\n                }\n                \"line_comment\" => {\n                    // Skip line comments, they're not Javadoc\n                    prev = sibling.prev_sibling();\n                }\n                _ => {\n                    // Stop at any non-comment node\n                    return None;\n                }\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 6,
        "branches": 3,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 176
    },
    {
      "name": "(Java) parse_javadoc",
      "qualified_name": "src/lang/java.rs::(Java) parse_javadoc",
      "file": "src/lang/java.rs",
      "line": 323,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) parse_javadoc(&self, comment: &str) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parse_javadoc(&self, comment: &str) -> String {\n        // Remove /** and */ markers\n        let content = comment\n            .trim_start_matches(\"/**\")\n            .trim_end_matches(\"*/\")\n            .trim();\n\n        // Process each line\n        let lines: Vec<&str> = content\n            .lines()\n            .map(|line| {\n                // Remove leading asterisks and whitespace\n                line.trim().trim_start_matches('*').trim()\n            })\n            .filter(|line| !line.is_empty())\n            .collect();\n\n        lines.join(\"\\n\")\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 123
    },
    {
      "name": "(Java) extract_superclass",
      "qualified_name": "src/lang/java.rs::(Java) extract_superclass",
      "file": "src/lang/java.rs",
      "line": 344,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_superclass(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_superclass(&self, node: Node, source: &[u8]) -> Option<String> {\n        let superclass_node = self.child_by_field(node, \"superclass\")?;\n\n        // Find the type identifier in the superclass node\n        for child in superclass_node.children(&mut superclass_node.walk()) {\n            match child.kind() {\n                \"type_identifier\" | \"generic_type\" | \"scoped_type_identifier\" => {\n                    return Some(self.extract_type(child, source));\n                }\n                _ => {}\n            }\n        }\n\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 113
    },
    {
      "name": "(Java) extract_interfaces",
      "qualified_name": "src/lang/java.rs::(Java) extract_interfaces",
      "file": "src/lang/java.rs",
      "line": 361,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_interfaces(&self, node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_interfaces(&self, node: Node, source: &[u8]) -> Vec<String> {\n        let interfaces_node = match self.child_by_field(node, \"interfaces\") {\n            Some(n) => n,\n            None => return Vec::new(),\n        };\n\n        let mut interfaces = Vec::new();\n\n        // Look for type_list inside super_interfaces\n        for child in interfaces_node.children(&mut interfaces_node.walk()) {\n            if child.kind() == \"type_list\" {\n                for type_child in child.children(&mut child.walk()) {\n                    match type_child.kind() {\n                        \"type_identifier\" | \"generic_type\" | \"scoped_type_identifier\" => {\n                            interfaces.push(self.extract_type(type_child, source));\n                        }\n                        _ => {}\n                    }\n                }\n            }\n        }\n\n        interfaces\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 3,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 167
    },
    {
      "name": "(Java) extract_extends_interfaces",
      "qualified_name": "src/lang/java.rs::(Java) extract_extends_interfaces",
      "file": "src/lang/java.rs",
      "line": 387,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_extends_interfaces(&self, node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_extends_interfaces(&self, node: Node, source: &[u8]) -> Vec<String> {\n        let mut interfaces = Vec::new();\n\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"extends_interfaces\" {\n                for type_list_child in child.children(&mut child.walk()) {\n                    if type_list_child.kind() == \"type_list\" {\n                        for type_child in type_list_child.children(&mut type_list_child.walk()) {\n                            match type_child.kind() {\n                                \"type_identifier\" | \"generic_type\" | \"scoped_type_identifier\" => {\n                                    interfaces.push(self.extract_type(type_child, source));\n                                }\n                                _ => {}\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        interfaces\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 9,
        "branches": 3,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 159
    },
    {
      "name": "(Java) extract_methods",
      "qualified_name": "src/lang/java.rs::(Java) extract_methods",
      "file": "src/lang/java.rs",
      "line": 411,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_methods(&self, body_node: Node, source: &[u8]) -> Vec<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_methods(&self, body_node: Node, source: &[u8]) -> Vec<FunctionInfo> {\n        let mut methods = Vec::new();\n\n        for child in body_node.children(&mut body_node.walk()) {\n            match child.kind() {\n                \"method_declaration\" => {\n                    if let Some(func) = self.extract_method(child, source) {\n                        methods.push(func);\n                    }\n                }\n                \"constructor_declaration\" => {\n                    if let Some(func) = self.extract_constructor(child, source) {\n                        methods.push(func);\n                    }\n                }\n                \"enum_body_declarations\" => {\n                    // Enum can have methods inside enum_body_declarations\n                    methods.extend(self.extract_methods(child, source));\n                }\n                _ => {}\n            }\n        }\n\n        methods\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 162
    },
    {
      "name": "(Java) extract_method",
      "qualified_name": "src/lang/java.rs::(Java) extract_method",
      "file": "src/lang/java.rs",
      "line": 438,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_method(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_method(&self, node: Node, source: &[u8]) -> Option<FunctionInfo> {\n        let name_node = self.child_by_field(node, \"name\")?;\n        let name = self.node_text(name_node, source).to_string();\n\n        // Extract modifiers\n        let (\n            visibility,\n            is_static,\n            is_final,\n            is_abstract,\n            is_synchronized,\n            is_default,\n            annotations,\n        ) = self.extract_modifiers(node, source);\n\n        // Build decorators list from modifiers\n        let mut decorators = annotations.clone();\n        if let Some(vis) = &visibility {\n            decorators.insert(0, vis.clone());\n        }\n        if is_static {\n            decorators.push(\"static\".to_string());\n        }\n        if is_final {\n            decorators.push(\"final\".to_string());\n        }\n        if is_abstract {\n            decorators.push(\"abstract\".to_string());\n        }\n        if is_synchronized {\n            decorators.push(\"synchronized\".to_string());\n        }\n        if is_default {\n            decorators.push(\"default\".to_string());\n        }\n\n        // Extract type parameters (generics)\n        let type_params = self.extract_type_parameters(node, source);\n        if let Some(tp) = type_params {\n            decorators.push(format!(\"generic:{}\", tp));\n        }\n\n        // Extract return type\n        let return_type = self\n            .child_by_field(node, \"type\")\n            .map(|n| self.extract_type(n, source));\n\n        // Extract parameters\n        let params_node = self.child_by_field(node, \"parameters\")?;\n        let params = self.extract_parameters(params_node, source);\n\n        // Extract Javadoc\n        let docstring = self.extract_javadoc(node, source);\n\n        // Line numbers\n        let line_number = node.start_position().row + 1;\n        let end_line_number = Some(node.end_position().row + 1);\n\n        Some(FunctionInfo {\n            name,\n            params,\n            return_type,\n            docstring,\n            is_method: true,\n            is_async: false, // Java doesn't have async keyword\n            decorators,\n            line_number,\n            end_line_number,\n            language: \"java\".to_string(),\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "iteration",
        "config",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 7,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 449
    },
    {
      "name": "(Java) extract_constructor",
      "qualified_name": "src/lang/java.rs::(Java) extract_constructor",
      "file": "src/lang/java.rs",
      "line": 511,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_constructor(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_constructor(&self, node: Node, source: &[u8]) -> Option<FunctionInfo> {\n        let name_node = self.child_by_field(node, \"name\")?;\n        let name = self.node_text(name_node, source).to_string();\n\n        // Extract modifiers\n        let (visibility, _, _, _, _, _, annotations) = self.extract_modifiers(node, source);\n\n        // Build decorators list\n        let mut decorators = vec![\"constructor\".to_string()];\n        decorators.extend(annotations);\n        if let Some(vis) = visibility {\n            decorators.insert(1, vis);\n        }\n\n        // Extract parameters\n        let params_node = self.child_by_field(node, \"parameters\")?;\n        let params = self.extract_parameters(params_node, source);\n\n        // Extract Javadoc\n        let docstring = self.extract_javadoc(node, source);\n\n        // Line numbers\n        let line_number = node.start_position().row + 1;\n        let end_line_number = Some(node.end_position().row + 1);\n\n        Some(FunctionInfo {\n            name,\n            params,\n            return_type: None, // Constructors don't have return type\n            docstring,\n            is_method: true,\n            is_async: false,\n            decorators,\n            line_number,\n            end_line_number,\n            language: \"java\".to_string(),\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 276
    },
    {
      "name": "(Java) extract_scoped_identifier",
      "qualified_name": "src/lang/java.rs::(Java) extract_scoped_identifier",
      "file": "src/lang/java.rs",
      "line": 551,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_scoped_identifier(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_scoped_identifier(&self, node: Node, source: &[u8]) -> String {\n        let mut parts = Vec::new();\n        self.collect_identifier_parts(node, source, &mut parts);\n        parts.join(\".\")\n    }\n",
      "semantic_tags": [
        "transform"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 51
    },
    {
      "name": "(Java) collect_identifier_parts",
      "qualified_name": "src/lang/java.rs::(Java) collect_identifier_parts",
      "file": "src/lang/java.rs",
      "line": 558,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) collect_identifier_parts(&self, node: Node, source: &[u8], parts: &mut Vec<String>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn collect_identifier_parts(&self, node: Node, source: &[u8], parts: &mut Vec<String>) {\n        match node.kind() {\n            \"identifier\" => {\n                parts.push(self.node_text(node, source).to_string());\n            }\n            \"scoped_identifier\" => {\n                if let Some(scope) = self.child_by_field(node, \"scope\") {\n                    self.collect_identifier_parts(scope, source, parts);\n                }\n                if let Some(name) = self.child_by_field(node, \"name\") {\n                    parts.push(self.node_text(name, source).to_string());\n                }\n            }\n            _ => {}\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 132
    },
    {
      "name": "(Java) build_cfg_from_body",
      "qualified_name": "src/lang/java.rs::(Java) build_cfg_from_body",
      "file": "src/lang/java.rs",
      "line": 576,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) build_cfg_from_body(&self, body: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, next_id: &mut usize) -> (BlockId, Vec<BlockId>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_cfg_from_body(\n        &self,\n        body: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        next_id: &mut usize,\n    ) -> (BlockId, Vec<BlockId>) {\n        let entry_id = BlockId(*next_id);\n        *next_id += 1;\n\n        let mut statements = Vec::new();\n        let mut exits = Vec::new();\n\n        // Process statements in the body\n        for child in body.children(&mut body.walk()) {\n            match child.kind() {\n                \"if_statement\" => {\n                    // Create current block with statements so far\n                    if !statements.is_empty() {\n                        let block = CFGBlock {\n                            id: entry_id,\n                            label: statements.join(\"; \"),\n                            statements: statements.clone(),\n                            start_line: body.start_position().row + 1,\n                            end_line: child.start_position().row + 1,\n                        };\n                        blocks.insert(entry_id, block);\n                        statements.clear();\n                    }\n\n                    // Process if statement branches\n                    let (if_entry, if_exits) =\n                        self.build_cfg_for_if(child, source, blocks, edges, next_id);\n                    edges.push(CFGEdge {\n                        from: entry_id,\n                        to: if_entry,\n                        label: None,\n                    });\n                    exits.extend(if_exits);\n                }\n                \"while_statement\" | \"for_statement\" | \"enhanced_for_statement\" => {\n                    let (loop_entry, loop_exits) =\n                        self.build_cfg_for_loop(child, source, blocks, edges, next_id);\n                    if !statements.is_empty() {\n                        let block = CFGBlock {\n                            id: entry_id,\n                            label: statements.join(\"; \"),\n                            statements: statements.clone(),\n                            start_line: body.start_position().row + 1,\n                            end_line: child.start_position().row + 1,\n                        };\n                        blocks.insert(entry_id, block);\n                        statements.clear();\n                        edges.push(CFGEdge {\n                            from: entry_id,\n                            to: loop_entry,\n                            label: None,\n                        });\n                    }\n                    exits.extend(loop_exits);\n                }\n                \"return_statement\" => {\n                    statements.push(self.node_text(child, source).trim().to_string());\n                    // Return statement is an exit\n                    let return_id = BlockId(*next_id);\n                    *next_id += 1;\n                    let block = CFGBlock {\n                        id: return_id,\n                        label: statements.join(\"; \"),\n                        statements: statements.clone(),\n                        start_line: child.start_position().row + 1,\n                        end_line: child.end_position().row + 1,\n                    };\n                    blocks.insert(return_id, block);\n                    exits.push(return_id);\n                    statements.clear();\n                }\n                \"throw_statement\" => {\n                    statements.push(self.node_text(child, source).trim().to_string());\n                    let throw_id = BlockId(*next_id);\n                    *next_id += 1;\n                    let block = CFGBlock {\n                        id: throw_id,\n                        label: statements.join(\"; \"),\n                        statements: statements.clone(),\n                        start_line: child.start_position().row + 1,\n                        end_line: child.end_position().row + 1,\n                    };\n                    blocks.insert(throw_id, block);\n                    exits.push(throw_id);\n                    statements.clear();\n                }\n                \"try_statement\" => {\n                    let (try_entry, try_exits) =\n                        self.build_cfg_for_try(child, source, blocks, edges, next_id);\n                    if !statements.is_empty() {\n                        let block = CFGBlock {\n                            id: entry_id,\n                            label: statements.join(\"; \"),\n                            statements: statements.clone(),\n                            start_line: body.start_position().row + 1,\n                            end_line: child.start_position().row + 1,\n                        };\n                        blocks.insert(entry_id, block);\n                        statements.clear();\n                        edges.push(CFGEdge {\n                            from: entry_id,\n                            to: try_entry,\n                            label: None,\n                        });\n                    }\n                    exits.extend(try_exits);\n                }\n                \"switch_expression\" | \"switch_statement\" => {\n                    let (switch_entry, switch_exits) =\n                        self.build_cfg_for_switch(child, source, blocks, edges, next_id);\n                    if !statements.is_empty() {\n                        let block = CFGBlock {\n                            id: entry_id,\n                            label: statements.join(\"; \"),\n                            statements: statements.clone(),\n                            start_line: body.start_position().row + 1,\n                            end_line: child.start_position().row + 1,\n                        };\n                        blocks.insert(entry_id, block);\n                        statements.clear();\n                        edges.push(CFGEdge {\n                            from: entry_id,\n                            to: switch_entry,\n                            label: None,\n                        });\n                    }\n                    exits.extend(switch_exits);\n                }\n                \"{\" | \"}\" => {\n                    // Skip braces\n                }\n                _ if !child.is_named() => {\n                    // Skip unnamed nodes\n                }\n                _ => {\n                    // Regular statement\n                    let stmt_text = self.node_text(child, source).trim().to_string();\n                    if !stmt_text.is_empty() {\n                        statements.push(stmt_text);\n                    }\n                }\n            }\n        }\n\n        // Create final block if there are remaining statements\n        if !statements.is_empty() || blocks.get(&entry_id).is_none() {\n            let block = CFGBlock {\n                id: entry_id,\n                label: if statements.is_empty() {\n                    \"entry\".to_string()\n                } else {\n                    statements.join(\"; \")\n                },\n                statements,\n                start_line: body.start_position().row + 1,\n                end_line: body.end_position().row + 1,\n            };\n            blocks.insert(entry_id, block);\n            if exits.is_empty() {\n                exits.push(entry_id);\n            }\n        }\n\n        (entry_id, exits)\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 7,
        "branches": 13,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 1203
    },
    {
      "name": "(Java) build_cfg_for_if",
      "qualified_name": "src/lang/java.rs::(Java) build_cfg_for_if",
      "file": "src/lang/java.rs",
      "line": 750,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) build_cfg_for_if(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, next_id: &mut usize) -> (BlockId, Vec<BlockId>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_cfg_for_if(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        next_id: &mut usize,\n    ) -> (BlockId, Vec<BlockId>) {\n        let condition_id = BlockId(*next_id);\n        *next_id += 1;\n\n        // Extract condition\n        let condition_text = self\n            .child_by_field(node, \"condition\")\n            .map(|n| self.node_text(n, source).to_string())\n            .unwrap_or_else(|| \"condition\".to_string());\n\n        let block = CFGBlock {\n            id: condition_id,\n            label: format!(\"if ({})\", condition_text),\n            statements: vec![format!(\"if ({})\", condition_text)],\n            start_line: node.start_position().row + 1,\n            end_line: node.start_position().row + 1,\n        };\n        blocks.insert(condition_id, block);\n\n        let mut exits = Vec::new();\n\n        // Process consequence (then branch)\n        if let Some(consequence) = self.child_by_field(node, \"consequence\") {\n            let (then_entry, then_exits) =\n                self.build_cfg_from_body(consequence, source, blocks, edges, next_id);\n            edges.push(CFGEdge {\n                from: condition_id,\n                to: then_entry,\n                label: Some(\"true\".to_string()),\n            });\n            exits.extend(then_exits);\n        }\n\n        // Process alternative (else branch)\n        if let Some(alternative) = self.child_by_field(node, \"alternative\") {\n            let (else_entry, else_exits) =\n                self.build_cfg_from_body(alternative, source, blocks, edges, next_id);\n            edges.push(CFGEdge {\n                from: condition_id,\n                to: else_entry,\n                label: Some(\"false\".to_string()),\n            });\n            exits.extend(else_exits);\n        } else {\n            // No else branch - condition itself is an exit for false case\n            exits.push(condition_id);\n        }\n\n        (condition_id, exits)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 4,
        "branches": 8,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 445
    },
    {
      "name": "(Java) build_cfg_for_loop",
      "qualified_name": "src/lang/java.rs::(Java) build_cfg_for_loop",
      "file": "src/lang/java.rs",
      "line": 809,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) build_cfg_for_loop(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, next_id: &mut usize) -> (BlockId, Vec<BlockId>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_cfg_for_loop(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        next_id: &mut usize,\n    ) -> (BlockId, Vec<BlockId>) {\n        let loop_id = BlockId(*next_id);\n        *next_id += 1;\n\n        let label = match node.kind() {\n            \"while_statement\" => {\n                let cond = self\n                    .child_by_field(node, \"condition\")\n                    .map(|n| self.node_text(n, source).to_string())\n                    .unwrap_or_default();\n                format!(\"while ({})\", cond)\n            }\n            \"for_statement\" => \"for loop\".to_string(),\n            \"enhanced_for_statement\" => \"for-each loop\".to_string(),\n            _ => \"loop\".to_string(),\n        };\n\n        let block = CFGBlock {\n            id: loop_id,\n            label: label.clone(),\n            statements: vec![label],\n            start_line: node.start_position().row + 1,\n            end_line: node.start_position().row + 1,\n        };\n        blocks.insert(loop_id, block);\n\n        // Process loop body\n        if let Some(body) = self.child_by_field(node, \"body\") {\n            let (body_entry, body_exits) =\n                self.build_cfg_from_body(body, source, blocks, edges, next_id);\n            edges.push(CFGEdge {\n                from: loop_id,\n                to: body_entry,\n                label: Some(\"true\".to_string()),\n            });\n            // Back edge from body to loop condition\n            for exit in &body_exits {\n                edges.push(CFGEdge {\n                    from: *exit,\n                    to: loop_id,\n                    label: None,\n                });\n            }\n        }\n\n        // Exit from loop (false condition)\n        let exit_id = BlockId(*next_id);\n        *next_id += 1;\n        let exit_block = CFGBlock {\n            id: exit_id,\n            label: \"loop exit\".to_string(),\n            statements: vec![],\n            start_line: node.end_position().row + 1,\n            end_line: node.end_position().row + 1,\n        };\n        blocks.insert(exit_id, exit_block);\n        edges.push(CFGEdge {\n            from: loop_id,\n            to: exit_id,\n            label: Some(\"false\".to_string()),\n        });\n\n        (loop_id, vec![exit_id])\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 11
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 520
    },
    {
      "name": "(Java) build_cfg_for_try",
      "qualified_name": "src/lang/java.rs::(Java) build_cfg_for_try",
      "file": "src/lang/java.rs",
      "line": 882,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) build_cfg_for_try(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, next_id: &mut usize) -> (BlockId, Vec<BlockId>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_cfg_for_try(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        next_id: &mut usize,\n    ) -> (BlockId, Vec<BlockId>) {\n        let try_id = BlockId(*next_id);\n        *next_id += 1;\n\n        let block = CFGBlock {\n            id: try_id,\n            label: \"try\".to_string(),\n            statements: vec![\"try\".to_string()],\n            start_line: node.start_position().row + 1,\n            end_line: node.start_position().row + 1,\n        };\n        blocks.insert(try_id, block);\n\n        let mut exits = Vec::new();\n\n        // Process try body\n        if let Some(body) = self.child_by_field(node, \"body\") {\n            let (body_entry, body_exits) =\n                self.build_cfg_from_body(body, source, blocks, edges, next_id);\n            edges.push(CFGEdge {\n                from: try_id,\n                to: body_entry,\n                label: None,\n            });\n            exits.extend(body_exits);\n        }\n\n        // Process catch clauses\n        for child in node.children(&mut node.walk()) {\n            if child.kind() == \"catch_clause\" {\n                if let Some(catch_body) = self.child_by_field(child, \"body\") {\n                    let (catch_entry, catch_exits) =\n                        self.build_cfg_from_body(catch_body, source, blocks, edges, next_id);\n                    edges.push(CFGEdge {\n                        from: try_id,\n                        to: catch_entry,\n                        label: Some(\"exception\".to_string()),\n                    });\n                    exits.extend(catch_exits);\n                }\n            }\n        }\n\n        // Process finally block\n        if let Some(finally_clause) = node\n            .children(&mut node.walk())\n            .find(|n| n.kind() == \"finally_clause\")\n        {\n            if let Some(finally_body) = self.child_by_field(finally_clause, \"body\") {\n                let (finally_entry, finally_exits) =\n                    self.build_cfg_from_body(finally_body, source, blocks, edges, next_id);\n                // All exits flow through finally\n                for exit in &exits {\n                    edges.push(CFGEdge {\n                        from: *exit,\n                        to: finally_entry,\n                        label: None,\n                    });\n                }\n                exits = finally_exits;\n            }\n        }\n\n        (try_id, exits)\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration",
        "error_handling"
      ],
      "complexity": {
        "depth": 6,
        "branches": 5,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 528
    },
    {
      "name": "(Java) build_cfg_for_switch",
      "qualified_name": "src/lang/java.rs::(Java) build_cfg_for_switch",
      "file": "src/lang/java.rs",
      "line": 956,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) build_cfg_for_switch(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, next_id: &mut usize) -> (BlockId, Vec<BlockId>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_cfg_for_switch(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        next_id: &mut usize,\n    ) -> (BlockId, Vec<BlockId>) {\n        let switch_id = BlockId(*next_id);\n        *next_id += 1;\n\n        let condition = self\n            .child_by_field(node, \"condition\")\n            .map(|n| self.node_text(n, source).to_string())\n            .unwrap_or_else(|| \"expr\".to_string());\n\n        let block = CFGBlock {\n            id: switch_id,\n            label: format!(\"switch ({})\", condition),\n            statements: vec![format!(\"switch ({})\", condition)],\n            start_line: node.start_position().row + 1,\n            end_line: node.start_position().row + 1,\n        };\n        blocks.insert(switch_id, block);\n\n        let mut exits = Vec::new();\n\n        // Process switch body\n        if let Some(body) = self.child_by_field(node, \"body\") {\n            for child in body.children(&mut body.walk()) {\n                if child.kind() == \"switch_block_statement_group\" || child.kind() == \"switch_rule\" {\n                    let case_id = BlockId(*next_id);\n                    *next_id += 1;\n\n                    let case_label = self\n                        .node_text(child, source)\n                        .lines()\n                        .next()\n                        .unwrap_or(\"case\")\n                        .to_string();\n                    let case_block = CFGBlock {\n                        id: case_id,\n                        label: case_label.clone(),\n                        statements: vec![case_label],\n                        start_line: child.start_position().row + 1,\n                        end_line: child.end_position().row + 1,\n                    };\n                    blocks.insert(case_id, case_block);\n\n                    edges.push(CFGEdge {\n                        from: switch_id,\n                        to: case_id,\n                        label: None,\n                    });\n                    exits.push(case_id);\n                }\n            }\n        }\n\n        if exits.is_empty() {\n            exits.push(switch_id);\n        }\n\n        (switch_id, exits)\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 6,
        "branches": 7,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 449
    },
    {
      "name": "(Java) extract_definitions",
      "qualified_name": "src/lang/java.rs::(Java) extract_definitions",
      "file": "src/lang/java.rs",
      "line": 1023,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_definitions(&self, node: Node, source: &[u8], definitions: &mut HashMap<String, Vec<usize>>, edges: &mut Vec<DataflowEdge>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_definitions(\n        &self,\n        node: Node,\n        source: &[u8],\n        definitions: &mut HashMap<String, Vec<usize>>,\n        edges: &mut Vec<DataflowEdge>,\n    ) {\n        match node.kind() {\n            \"local_variable_declaration\" | \"field_declaration\" => {\n                for child in node.children(&mut node.walk()) {\n                    if child.kind() == \"variable_declarator\" {\n                        if let Some(name_node) = self.child_by_field(child, \"name\") {\n                            let var_name = self.node_text(name_node, source).to_string();\n                            let line = node.start_position().row + 1;\n                            definitions.entry(var_name.clone()).or_default().push(line);\n                            edges.push(DataflowEdge {\n                                variable: var_name,\n                                from_line: line,\n                                to_line: line,\n                                kind: DataflowKind::Definition,\n                            });\n                        }\n                    }\n                }\n            }\n            \"assignment_expression\" => {\n                if let Some(left) = self.child_by_field(node, \"left\") {\n                    let var_name = self.node_text(left, source).to_string();\n                    let line = node.start_position().row + 1;\n                    definitions.entry(var_name.clone()).or_default().push(line);\n                    edges.push(DataflowEdge {\n                        variable: var_name,\n                        from_line: line,\n                        to_line: line,\n                        kind: DataflowKind::Mutation,\n                    });\n                }\n            }\n            _ => {}\n        }\n\n        // Recurse into children\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            self.extract_definitions(child, source, definitions, edges);\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 8,
        "branches": 4,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 346
    },
    {
      "name": "(Java) extract_uses",
      "qualified_name": "src/lang/java.rs::(Java) extract_uses",
      "file": "src/lang/java.rs",
      "line": 1072,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_uses(&self, node: Node, source: &[u8], definitions: &HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>, edges: &mut Vec<DataflowEdge>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_uses(\n        &self,\n        node: Node,\n        source: &[u8],\n        definitions: &HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n        edges: &mut Vec<DataflowEdge>,\n    ) {\n        match node.kind() {\n            \"identifier\" => {\n                // Check if this identifier is a use (not a definition)\n                let parent = node.parent();\n                let is_definition = parent.is_some_and(|p| {\n                    matches!(p.kind(), \"variable_declarator\" | \"formal_parameter\")\n                        && self.child_by_field(p, \"name\") == Some(node)\n                });\n\n                if !is_definition {\n                    let var_name = self.node_text(node, source).to_string();\n                    if definitions.contains_key(&var_name) {\n                        let line = node.start_position().row + 1;\n                        uses.entry(var_name.clone()).or_default().push(line);\n\n                        // Find the most recent definition\n                        if let Some(def_lines) = definitions.get(&var_name) {\n                            if let Some(&def_line) = def_lines.iter().filter(|&&l| l <= line).max()\n                            {\n                                edges.push(DataflowEdge {\n                                    variable: var_name,\n                                    from_line: def_line,\n                                    to_line: line,\n                                    kind: DataflowKind::Use,\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            \"return_statement\" => {\n                let line = node.start_position().row + 1;\n                // Find identifiers in return statement\n                for child in node.children(&mut node.walk()) {\n                    if child.kind() == \"identifier\" {\n                        let var_name = self.node_text(child, source).to_string();\n                        if definitions.contains_key(&var_name) {\n                            edges.push(DataflowEdge {\n                                variable: var_name,\n                                from_line: line,\n                                to_line: line,\n                                kind: DataflowKind::Return,\n                            });\n                        }\n                    }\n                }\n            }\n            _ => {}\n        }\n\n        // Recurse into children\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            self.extract_uses(child, source, definitions, uses, edges);\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "iteration",
        "transform"
      ],
      "complexity": {
        "depth": 9,
        "branches": 8,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 460
    },
    {
      "name": "(Java) name",
      "qualified_name": "src/lang/java.rs::(Java) name",
      "file": "src/lang/java.rs",
      "line": 1139,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) name(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn name(&self) -> &'static str {\n        \"java\"\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 17
    },
    {
      "name": "(Java) extensions",
      "qualified_name": "src/lang/java.rs::(Java) extensions",
      "file": "src/lang/java.rs",
      "line": 1143,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extensions(&self) -> &[&'static str]",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extensions(&self) -> &[&'static str] {\n        &[\".java\"]\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 21
    },
    {
      "name": "(Java) parser",
      "qualified_name": "src/lang/java.rs::(Java) parser",
      "file": "src/lang/java.rs",
      "line": 1147,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) parser(&self) -> Result<Parser>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parser(&self) -> Result<Parser> {\n        let mut parser = Parser::new();\n        parser\n            .set_language(&tree_sitter_java::LANGUAGE.into())\n            .map_err(|e| TldrError::TreeSitter(e.to_string()))?;\n        Ok(parser)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 62
    },
    {
      "name": "(Java) extract_function",
      "qualified_name": "src/lang/java.rs::(Java) extract_function",
      "file": "src/lang/java.rs",
      "line": 1155,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo> {\n        match node.kind() {\n            \"method_declaration\" => self.extract_method(node, source),\n            \"constructor_declaration\" => self.extract_constructor(node, source),\n            _ => None,\n        }\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 65
    },
    {
      "name": "(Java) extract_class",
      "qualified_name": "src/lang/java.rs::(Java) extract_class",
      "file": "src/lang/java.rs",
      "line": 1163,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo> {\n        match node.kind() {\n            \"class_declaration\" => self.extract_class_declaration(node, source),\n            \"interface_declaration\" => self.extract_interface_declaration(node, source),\n            \"enum_declaration\" => self.extract_enum_declaration(node, source),\n            _ => None,\n        }\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 80
    },
    {
      "name": "(Java) extract_imports",
      "qualified_name": "src/lang/java.rs::(Java) extract_imports",
      "file": "src/lang/java.rs",
      "line": 1172,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo> {\n        let mut imports = Vec::new();\n        let root = tree.root_node();\n\n        for child in root.children(&mut root.walk()) {\n            if child.kind() == \"import_declaration\" {\n                if let Some(import) = self.extract_import(child, source) {\n                    imports.push(import);\n                }\n            }\n        }\n\n        imports\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 97
    },
    {
      "name": "(Java) function_query",
      "qualified_name": "src/lang/java.rs::(Java) function_query",
      "file": "src/lang/java.rs",
      "line": 1187,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) function_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn function_query(&self) -> &'static str {\n        r#\"[\n            (method_declaration name: (identifier) @name) @method\n            (constructor_declaration name: (identifier) @name) @constructor\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 52
    },
    {
      "name": "(Java) class_query",
      "qualified_name": "src/lang/java.rs::(Java) class_query",
      "file": "src/lang/java.rs",
      "line": 1194,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) class_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn class_query(&self) -> &'static str {\n        r#\"[\n            (class_declaration name: (identifier) @name) @class\n            (interface_declaration name: (identifier) @name) @interface\n            (enum_declaration name: (identifier) @name) @enum\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 67
    },
    {
      "name": "(Java) call_query",
      "qualified_name": "src/lang/java.rs::(Java) call_query",
      "file": "src/lang/java.rs",
      "line": 1202,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) call_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn call_query(&self) -> &'static str {\n        r#\"[\n            (method_invocation name: (identifier) @callee) @call\n            (object_creation_expression type: (type_identifier) @callee) @call\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 55
    },
    {
      "name": "(Java) build_cfg",
      "qualified_name": "src/lang/java.rs::(Java) build_cfg",
      "file": "src/lang/java.rs",
      "line": 1209,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo> {\n        // Get function name\n        let function_name = self\n            .child_by_field(node, \"name\")\n            .map(|n| self.node_text(n, source).to_string())\n            .unwrap_or_else(|| \"unknown\".to_string());\n\n        let mut blocks = HashMap::new();\n        let mut edges = Vec::new();\n        let mut next_id = 0usize;\n\n        // Find the method body\n        let body = match node.kind() {\n            \"method_declaration\" => self.child_by_field(node, \"body\"),\n            \"constructor_declaration\" => self.child_by_field(node, \"body\"),\n            _ => None,\n        };\n\n        let (entry, exits) = if let Some(body_node) = body {\n            self.build_cfg_from_body(body_node, source, &mut blocks, &mut edges, &mut next_id)\n        } else {\n            // Abstract method or no body - create single entry/exit block\n            let id = BlockId(0);\n            let block = CFGBlock {\n                id,\n                label: \"abstract\".to_string(),\n                statements: vec![],\n                start_line: node.start_position().row + 1,\n                end_line: node.end_position().row + 1,\n            };\n            blocks.insert(id, block);\n            (id, vec![id])\n        };\n\n        Ok(CFGInfo {\n            function_name,\n            blocks,\n            edges,\n            entry,\n            exits,\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 321
    },
    {
      "name": "(Java) build_dfg",
      "qualified_name": "src/lang/java.rs::(Java) build_dfg",
      "file": "src/lang/java.rs",
      "line": 1252,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo> {\n        let function_name = self\n            .child_by_field(node, \"name\")\n            .map(|n| self.node_text(n, source).to_string())\n            .unwrap_or_else(|| \"unknown\".to_string());\n\n        let mut definitions = HashMap::new();\n        let mut uses = HashMap::new();\n        let mut edges = Vec::new();\n\n        // Extract parameters as definitions\n        if let Some(params) = self.child_by_field(node, \"parameters\") {\n            for child in params.children(&mut params.walk()) {\n                if child.kind() == \"formal_parameter\" {\n                    if let Some(name_node) = self.child_by_field(child, \"name\") {\n                        let var_name = self.node_text(name_node, source).to_string();\n                        let line = child.start_position().row + 1;\n                        definitions\n                            .entry(var_name.clone())\n                            .or_insert_with(Vec::new)\n                            .push(line);\n                        edges.push(DataflowEdge {\n                            variable: var_name,\n                            from_line: line,\n                            to_line: line,\n                            kind: DataflowKind::Param,\n                        });\n                    }\n                }\n            }\n        }\n\n        // Extract definitions from body\n        if let Some(body) = self.child_by_field(node, \"body\") {\n            self.extract_definitions(body, source, &mut definitions, &mut edges);\n            self.extract_uses(body, source, &definitions, &mut uses, &mut edges);\n        }\n\n        Ok(DFGInfo {\n            function_name,\n            edges,\n            definitions,\n            uses,\n        })\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 347
    },
    {
      "name": "(Java) extract_class_declaration",
      "qualified_name": "src/lang/java.rs::(Java) extract_class_declaration",
      "file": "src/lang/java.rs",
      "line": 1301,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_class_declaration(&self, node: Node, source: &[u8]) -> Option<ClassInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_class_declaration(&self, node: Node, source: &[u8]) -> Option<ClassInfo> {\n        let name_node = self.child_by_field(node, \"name\")?;\n        let name = self.node_text(name_node, source).to_string();\n\n        // Extract modifiers\n        let (visibility, is_static, is_final, is_abstract, _, _, annotations) =\n            self.extract_modifiers(node, source);\n\n        // Build decorators\n        let mut decorators = annotations;\n        if let Some(vis) = visibility {\n            decorators.insert(0, vis);\n        }\n        if is_static {\n            decorators.push(\"static\".to_string());\n        }\n        if is_final {\n            decorators.push(\"final\".to_string());\n        }\n        if is_abstract {\n            decorators.push(\"abstract\".to_string());\n        }\n\n        // Extract type parameters\n        if let Some(tp) = self.extract_type_parameters(node, source) {\n            decorators.push(format!(\"generic:{}\", tp));\n        }\n\n        // Build bases list\n        let mut bases = Vec::new();\n\n        // Add superclass if present\n        if let Some(superclass) = self.extract_superclass(node, source) {\n            bases.push(format!(\"extends {}\", superclass));\n        }\n\n        // Add interfaces\n        for interface in self.extract_interfaces(node, source) {\n            bases.push(format!(\"implements {}\", interface));\n        }\n\n        // Extract Javadoc\n        let docstring = self.extract_javadoc(node, source);\n\n        // Extract methods from class body\n        let methods = if let Some(body) = self.child_by_field(node, \"body\") {\n            self.extract_methods(body, source)\n        } else {\n            Vec::new()\n        };\n\n        // Line numbers\n        let line_number = node.start_position().row + 1;\n        let end_line_number = Some(node.end_position().row + 1);\n\n        Some(ClassInfo {\n            name,\n            bases,\n            docstring,\n            methods,\n            decorators,\n            line_number,\n            end_line_number,\n            language: \"java\".to_string(),\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "config",
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 9,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 422
    },
    {
      "name": "(Java) extract_interface_declaration",
      "qualified_name": "src/lang/java.rs::(Java) extract_interface_declaration",
      "file": "src/lang/java.rs",
      "line": 1369,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_interface_declaration(&self, node: Node, source: &[u8]) -> Option<ClassInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_interface_declaration(&self, node: Node, source: &[u8]) -> Option<ClassInfo> {\n        let name_node = self.child_by_field(node, \"name\")?;\n        let name = self.node_text(name_node, source).to_string();\n\n        // Extract modifiers\n        let (visibility, _, _, _, _, _, annotations) = self.extract_modifiers(node, source);\n\n        // Build decorators\n        let mut decorators = vec![\"interface\".to_string()];\n        decorators.extend(annotations);\n        if let Some(vis) = visibility {\n            decorators.insert(1, vis);\n        }\n\n        // Extract type parameters\n        if let Some(tp) = self.extract_type_parameters(node, source) {\n            decorators.push(format!(\"generic:{}\", tp));\n        }\n\n        // Build bases list (extended interfaces)\n        let bases: Vec<String> = self\n            .extract_extends_interfaces(node, source)\n            .into_iter()\n            .map(|i| format!(\"extends {}\", i))\n            .collect();\n\n        // Extract Javadoc\n        let docstring = self.extract_javadoc(node, source);\n\n        // Extract methods from interface body\n        let methods = if let Some(body) = self.child_by_field(node, \"body\") {\n            self.extract_methods(body, source)\n        } else {\n            Vec::new()\n        };\n\n        // Line numbers\n        let line_number = node.start_position().row + 1;\n        let end_line_number = Some(node.end_position().row + 1);\n\n        Some(ClassInfo {\n            name,\n            bases,\n            docstring,\n            methods,\n            decorators,\n            line_number,\n            end_line_number,\n            language: \"java\".to_string(),\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "config",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 4,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 351
    },
    {
      "name": "(Java) extract_enum_declaration",
      "qualified_name": "src/lang/java.rs::(Java) extract_enum_declaration",
      "file": "src/lang/java.rs",
      "line": 1422,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_enum_declaration(&self, node: Node, source: &[u8]) -> Option<ClassInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_enum_declaration(&self, node: Node, source: &[u8]) -> Option<ClassInfo> {\n        let name_node = self.child_by_field(node, \"name\")?;\n        let name = self.node_text(name_node, source).to_string();\n\n        // Extract modifiers\n        let (visibility, _, _, _, _, _, annotations) = self.extract_modifiers(node, source);\n\n        // Build decorators\n        let mut decorators = vec![\"enum\".to_string()];\n        decorators.extend(annotations);\n        if let Some(vis) = visibility {\n            decorators.insert(1, vis);\n        }\n\n        // Extract implemented interfaces\n        let bases: Vec<String> = self\n            .extract_interfaces(node, source)\n            .into_iter()\n            .map(|i| format!(\"implements {}\", i))\n            .collect();\n\n        // Extract Javadoc\n        let docstring = self.extract_javadoc(node, source);\n\n        // Extract methods from enum body\n        let methods = if let Some(body) = self.child_by_field(node, \"body\") {\n            self.extract_methods(body, source)\n        } else {\n            Vec::new()\n        };\n\n        // Line numbers\n        let line_number = node.start_position().row + 1;\n        let end_line_number = Some(node.end_position().row + 1);\n\n        Some(ClassInfo {\n            name,\n            bases,\n            docstring,\n            methods,\n            decorators,\n            line_number,\n            end_line_number,\n            language: \"java\".to_string(),\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "config",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 312
    },
    {
      "name": "(Java) extract_import",
      "qualified_name": "src/lang/java.rs::(Java) extract_import",
      "file": "src/lang/java.rs",
      "line": 1470,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Java) extract_import(&self, node: Node, source: &[u8]) -> Option<ImportInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_import(&self, node: Node, source: &[u8]) -> Option<ImportInfo> {\n        let mut is_static = false;\n        let mut path_parts = Vec::new();\n\n        for child in node.children(&mut node.walk()) {\n            match child.kind() {\n                \"static\" => {\n                    is_static = true;\n                }\n                \"scoped_identifier\" | \"identifier\" => {\n                    path_parts.push(self.extract_scoped_identifier(child, source));\n                }\n                \"asterisk\" => {\n                    path_parts.push(\"*\".to_string());\n                }\n                _ => {}\n            }\n        }\n\n        if path_parts.is_empty() {\n            return None;\n        }\n\n        let full_path = path_parts.join(\".\");\n\n        // Determine module and names\n        let (module, names) = if full_path.ends_with(\".*\") {\n            // Wildcard import: import java.util.*\n            let module = full_path.trim_end_matches(\".*\").to_string();\n            (module, vec![\"*\".to_string()])\n        } else if is_static {\n            // Static import: import static java.lang.Math.PI\n            // Module is everything except the last part\n            let parts: Vec<&str> = full_path.rsplitn(2, '.').collect();\n            if parts.len() == 2 {\n                (parts[1].to_string(), vec![parts[0].to_string()])\n            } else {\n                (full_path.clone(), vec![])\n            }\n        } else {\n            // Regular import: import java.util.List\n            (full_path, vec![])\n        };\n\n        let mut aliases = HashMap::new();\n        if is_static {\n            aliases.insert(\"static\".to_string(), \"true\".to_string());\n        }\n\n        let is_from = is_static || !names.is_empty();\n\n        Some(ImportInfo {\n            module,\n            names,\n            aliases,\n            is_from,\n            level: 0, // Java doesn't have relative imports\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "error_handling",
        "iteration",
        "config",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 9,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 408
    },
    {
      "name": "parse_java",
      "qualified_name": "src/lang/java.rs::parse_java",
      "file": "src/lang/java.rs",
      "line": 1535,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn parse_java(code: &str) -> Tree",
      "docstring": "",
      "calls": [
        "parser"
      ],
      "called_by": [
        "test_extract_imports",
        "test_build_dfg",
        "test_extract_class",
        "test_extract_method_with_params",
        "test_build_simple_cfg"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:3",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parse_java(code: &str) -> Tree {\n        let java = Java;\n        let mut parser = java.parser().unwrap();\n        parser.parse(code, None).unwrap()\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 39
    },
    {
      "name": "test_extract_simple_method",
      "qualified_name": "src/lang/java.rs::test_extract_simple_method",
      "file": "src/lang/java.rs",
      "line": 1542,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_simple_method()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_java"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:20, def-use chains:7",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_simple_method() {\n        let code = r#\"\npublic class Test {\n    public String getName() {\n        return name;\n    }\n}\n\"#;\n        let tree = parse_java(code);\n        let java = Java;\n\n        // Find method node\n        let root = tree.root_node();\n        let class_body = root.child(0).unwrap().child_by_field_name(\"body\").unwrap();\n\n        for child in class_body.children(&mut class_body.walk()) {\n            if child.kind() == \"method_declaration\" {\n                let func = java.extract_function(child, code.as_bytes()).unwrap();\n                assert_eq!(func.name, \"getName\");\n                assert_eq!(func.return_type, Some(\"String\".to_string()));\n                assert!(func.params.is_empty());\n                assert!(func.decorators.contains(&\"public\".to_string()));\n                break;\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 178
    },
    {
      "name": "test_extract_method_with_params",
      "qualified_name": "src/lang/java.rs::test_extract_method_with_params",
      "file": "src/lang/java.rs",
      "line": 1570,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_method_with_params()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_java"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:17, def-use chains:7",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_method_with_params() {\n        let code = r#\"\npublic class Test {\n    public void setName(String name, int age) {\n        this.name = name;\n    }\n}\n\"#;\n        let tree = parse_java(code);\n        let java = Java;\n\n        let root = tree.root_node();\n        let class_body = root.child(0).unwrap().child_by_field_name(\"body\").unwrap();\n\n        for child in class_body.children(&mut class_body.walk()) {\n            if child.kind() == \"method_declaration\" {\n                let func = java.extract_function(child, code.as_bytes()).unwrap();\n                assert_eq!(func.name, \"setName\");\n                assert_eq!(func.return_type, Some(\"void\".to_string()));\n                assert_eq!(func.params.len(), 2);\n                assert_eq!(func.params[0], \"String name\");\n                assert_eq!(func.params[1], \"int age\");\n                break;\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 196
    },
    {
      "name": "test_extract_generic_method",
      "qualified_name": "src/lang/java.rs::test_extract_generic_method",
      "file": "src/lang/java.rs",
      "line": 1598,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_generic_method()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_java"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:20, def-use chains:7",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_generic_method() {\n        let code = r#\"\npublic class Test {\n    public static <T> List<T> process(List<T> items) {\n        return items;\n    }\n}\n\"#;\n        let tree = parse_java(code);\n        let java = Java;\n\n        let root = tree.root_node();\n        let class_body = root.child(0).unwrap().child_by_field_name(\"body\").unwrap();\n\n        for child in class_body.children(&mut class_body.walk()) {\n            if child.kind() == \"method_declaration\" {\n                let func = java.extract_function(child, code.as_bytes()).unwrap();\n                assert_eq!(func.name, \"process\");\n                assert!(func.decorators.contains(&\"static\".to_string()));\n                assert!(func.decorators.iter().any(|d| d.starts_with(\"generic:\")));\n                break;\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 178
    },
    {
      "name": "test_extract_class",
      "qualified_name": "src/lang/java.rs::test_extract_class",
      "file": "src/lang/java.rs",
      "line": 1624,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_class()",
      "docstring": "",
      "calls": [
        "extract_class",
        "extract_class",
        "parse_java",
        "extract_class",
        "parse_ts"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:21, def-use chains:11",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_class() {\n        let code = r#\"\n/**\n * User class.\n */\npublic class User extends BaseEntity implements Serializable {\n    public String getName() { return name; }\n}\n\"#;\n        let tree = parse_java(code);\n        let java = Java;\n\n        let root = tree.root_node();\n        for child in root.children(&mut root.walk()) {\n            if child.kind() == \"class_declaration\" {\n                let class = java.extract_class(child, code.as_bytes()).unwrap();\n                assert_eq!(class.name, \"User\");\n                assert!(class.bases.iter().any(|b| b.contains(\"BaseEntity\")));\n                assert!(class.bases.iter().any(|b| b.contains(\"Serializable\")));\n                assert!(class.docstring.is_some());\n                assert_eq!(class.methods.len(), 1);\n                break;\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 175
    },
    {
      "name": "test_extract_interface",
      "qualified_name": "src/lang/java.rs::test_extract_interface",
      "file": "src/lang/java.rs",
      "line": 1651,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_interface()",
      "docstring": "",
      "calls": [
        "extract_class",
        "parse_java"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:21, def-use chains:10",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_interface() {\n        let code = r#\"\npublic interface Processor<T> extends Runnable {\n    void process(T item);\n}\n\"#;\n        let tree = parse_java(code);\n        let java = Java;\n\n        let root = tree.root_node();\n        for child in root.children(&mut root.walk()) {\n            if child.kind() == \"interface_declaration\" {\n                let class = java.extract_class(child, code.as_bytes()).unwrap();\n                assert_eq!(class.name, \"Processor\");\n                assert!(class.decorators.contains(&\"interface\".to_string()));\n                assert!(class.bases.iter().any(|b| b.contains(\"Runnable\")));\n                assert_eq!(class.methods.len(), 1);\n                break;\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 151
    },
    {
      "name": "test_extract_enum",
      "qualified_name": "src/lang/java.rs::test_extract_enum",
      "file": "src/lang/java.rs",
      "line": 1674,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_enum()",
      "docstring": "",
      "calls": [
        "extract_class",
        "extract_class",
        "parse_java",
        "parse_c"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:17, def-use chains:9",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_enum() {\n        let code = r#\"\npublic enum Status {\n    ACTIVE, INACTIVE;\n\n    public String getCode() { return \"\"; }\n}\n\"#;\n        let tree = parse_java(code);\n        let java = Java;\n\n        let root = tree.root_node();\n        for child in root.children(&mut root.walk()) {\n            if child.kind() == \"enum_declaration\" {\n                let class = java.extract_class(child, code.as_bytes()).unwrap();\n                assert_eq!(class.name, \"Status\");\n                assert!(class.decorators.contains(&\"enum\".to_string()));\n                assert_eq!(class.methods.len(), 1);\n                break;\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 139
    },
    {
      "name": "test_extract_imports",
      "qualified_name": "src/lang/java.rs::test_extract_imports",
      "file": "src/lang/java.rs",
      "line": 1698,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_imports()",
      "docstring": "",
      "calls": [
        "extract_imports",
        "extract_imports",
        "extract_imports",
        "parse_java",
        "parse_python"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:15, def-use chains:14",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_imports() {\n        let code = r#\"\nimport java.util.List;\nimport java.util.*;\nimport static java.lang.Math.PI;\nimport static java.lang.Math.*;\n\npublic class Test {}\n\"#;\n        let tree = parse_java(code);\n        let java = Java;\n\n        let imports = java.extract_imports(&tree, code.as_bytes());\n        assert_eq!(imports.len(), 4);\n\n        // Regular import\n        assert_eq!(imports[0].module, \"java.util.List\");\n        assert!(imports[0].names.is_empty());\n\n        // Wildcard import\n        assert_eq!(imports[1].module, \"java.util\");\n        assert_eq!(imports[1].names, vec![\"*\"]);\n\n        // Static import\n        assert_eq!(imports[2].module, \"java.lang.Math\");\n        assert_eq!(imports[2].names, vec![\"PI\"]);\n        assert!(imports[2].is_from);\n\n        // Static wildcard import\n        assert_eq!(imports[3].module, \"java.lang.Math\");\n        assert_eq!(imports[3].names, vec![\"*\"]);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 231
    },
    {
      "name": "test_extract_constructor",
      "qualified_name": "src/lang/java.rs::test_extract_constructor",
      "file": "src/lang/java.rs",
      "line": 1732,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_constructor()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_java"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:22, def-use chains:7",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_constructor() {\n        let code = r#\"\npublic class User {\n    /**\n     * Creates a new user.\n     */\n    public User(String name, int age) {\n        this.name = name;\n    }\n}\n\"#;\n        let tree = parse_java(code);\n        let java = Java;\n\n        let root = tree.root_node();\n        let class_body = root.child(0).unwrap().child_by_field_name(\"body\").unwrap();\n\n        for child in class_body.children(&mut class_body.walk()) {\n            if child.kind() == \"constructor_declaration\" {\n                let func = java.extract_function(child, code.as_bytes()).unwrap();\n                assert_eq!(func.name, \"User\");\n                assert!(func.return_type.is_none());\n                assert!(func.decorators.contains(&\"constructor\".to_string()));\n                assert_eq!(func.params.len(), 2);\n                assert!(func.docstring.is_some());\n                break;\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 194
    },
    {
      "name": "test_extract_annotations",
      "qualified_name": "src/lang/java.rs::test_extract_annotations",
      "file": "src/lang/java.rs",
      "line": 1763,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_annotations()",
      "docstring": "",
      "calls": [
        "parse_java",
        "extract_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:16, def-use chains:7",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_annotations() {\n        let code = r#\"\npublic class Test {\n    @Override\n    @Deprecated\n    public String toString() {\n        return \"\";\n    }\n}\n\"#;\n        let tree = parse_java(code);\n        let java = Java;\n\n        let root = tree.root_node();\n        let class_body = root.child(0).unwrap().child_by_field_name(\"body\").unwrap();\n\n        for child in class_body.children(&mut class_body.walk()) {\n            if child.kind() == \"method_declaration\" {\n                let func = java.extract_function(child, code.as_bytes()).unwrap();\n                assert!(func.decorators.iter().any(|d| d.contains(\"Override\")));\n                assert!(func.decorators.iter().any(|d| d.contains(\"Deprecated\")));\n                break;\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 164
    },
    {
      "name": "test_build_simple_cfg",
      "qualified_name": "src/lang/java.rs::test_build_simple_cfg",
      "file": "src/lang/java.rs",
      "line": 1790,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_simple_cfg()",
      "docstring": "",
      "calls": [
        "build_cfg",
        "parse_java",
        "build_cfg",
        "parse_rust"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:16, def-use chains:10",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_build_simple_cfg() {\n        let code = r#\"\npublic class Test {\n    public int add(int a, int b) {\n        int sum = a + b;\n        return sum;\n    }\n}\n\"#;\n        let tree = parse_java(code);\n        let java = Java;\n\n        let root = tree.root_node();\n        let class_body = root.child(0).unwrap().child_by_field_name(\"body\").unwrap();\n\n        for child in class_body.children(&mut class_body.walk()) {\n            if child.kind() == \"method_declaration\" {\n                let cfg = java.build_cfg(child, code.as_bytes()).unwrap();\n                assert_eq!(cfg.function_name, \"add\");\n                assert!(!cfg.blocks.is_empty());\n                assert!(!cfg.exits.is_empty());\n                break;\n            }\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "test"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 169
    },
    {
      "name": "test_build_dfg",
      "qualified_name": "src/lang/java.rs::test_build_dfg",
      "file": "src/lang/java.rs",
      "line": 1817,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_dfg()",
      "docstring": "",
      "calls": [
        "parse_c",
        "build_dfg",
        "parse_java",
        "build_dfg",
        "build_dfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:17, def-use chains:12",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_build_dfg() {\n        let code = r#\"\npublic class Test {\n    public int compute(int x) {\n        int y = x + 1;\n        int z = y * 2;\n        return z;\n    }\n}\n\"#;\n        let tree = parse_java(code);\n        let java = Java;\n\n        let root = tree.root_node();\n        let class_body = root.child(0).unwrap().child_by_field_name(\"body\").unwrap();\n\n        for child in class_body.children(&mut class_body.walk()) {\n            if child.kind() == \"method_declaration\" {\n                let dfg = java.build_dfg(child, code.as_bytes()).unwrap();\n                assert_eq!(dfg.function_name, \"compute\");\n                assert!(dfg.definitions.contains_key(\"x\"));\n                assert!(dfg.definitions.contains_key(\"y\"));\n                assert!(dfg.definitions.contains_key(\"z\"));\n                assert!(!dfg.edges.is_empty());\n                break;\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 206
    },
    {
      "name": "Java",
      "qualified_name": "src/lang/java.rs::Java",
      "file": "src/lang/java.rs",
      "line": 22,
      "language": "rust",
      "unit_type": "class",
      "signature": "class Java",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "pub struct Java;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 0,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 4
    },
    {
      "name": "(C) get_text",
      "qualified_name": "src/lang/c.rs::(C) get_text",
      "file": "src/lang/c.rs",
      "line": 32,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) get_text(&self, node: Node, source: &'a [u8]) -> &'a str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn get_text<'a>(&self, node: Node, source: &'a [u8]) -> &'a str {\n        std::str::from_utf8(&source[node.start_byte()..node.end_byte()]).unwrap_or(\"\")\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 51
    },
    {
      "name": "(C) node_text",
      "qualified_name": "src/lang/c.rs::(C) node_text",
      "file": "src/lang/c.rs",
      "line": 37,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) node_text(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn node_text(&self, node: Node, source: &[u8]) -> String {\n        self.get_text(node, source).to_string()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 33
    },
    {
      "name": "(C) child_by_field",
      "qualified_name": "src/lang/c.rs::(C) child_by_field",
      "file": "src/lang/c.rs",
      "line": 42,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) child_by_field(&self, node: Node<'a>, field: &str) -> Option<Node<'a>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn child_by_field<'a>(&self, node: Node<'a>, field: &str) -> Option<Node<'a>> {\n        node.child_by_field_name(field)\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 38
    },
    {
      "name": "(C) get_doc_comment",
      "qualified_name": "src/lang/c.rs::(C) get_doc_comment",
      "file": "src/lang/c.rs",
      "line": 48,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) get_doc_comment(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn get_doc_comment(&self, node: Node, source: &[u8]) -> Option<String> {\n        let mut comments = Vec::new();\n        let start_row = node.start_position().row;\n\n        // Walk backwards through siblings to find comments\n        if let Some(parent) = node.parent() {\n            let mut found_self = false;\n            let child_count = parent.child_count();\n\n            for i in (0..child_count).rev() {\n                if let Some(sibling) = parent.child(i as u32) {\n                    if sibling.id() == node.id() {\n                        found_self = true;\n                        continue;\n                    }\n\n                    if found_self && sibling.kind() == \"comment\" {\n                        let comment_end_row = sibling.end_position().row;\n                        // Check if comment is adjacent (within 1 line)\n                        if start_row.saturating_sub(1) <= comment_end_row + comments.len() {\n                            let text = self.get_text(sibling, source);\n                            let cleaned = self.clean_comment(text);\n                            if !cleaned.is_empty() {\n                                comments.push(cleaned);\n                            }\n                        } else {\n                            break;\n                        }\n                    } else if found_self && sibling.kind() != \"comment\" {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if comments.is_empty() {\n            None\n        } else {\n            comments.reverse();\n            Some(comments.join(\"\\n\"))\n        }\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 8,
        "branches": 12,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 293
    },
    {
      "name": "(C) clean_comment",
      "qualified_name": "src/lang/c.rs::(C) clean_comment",
      "file": "src/lang/c.rs",
      "line": 92,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) clean_comment(&self, text: &str) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn clean_comment(&self, text: &str) -> String {\n        let text = text.trim();\n\n        // Block comment: /* ... */ or /** ... */\n        if text.starts_with(\"/*\") {\n            let inner = text\n                .strip_prefix(\"/**\")\n                .or_else(|| text.strip_prefix(\"/*\"))\n                .unwrap_or(text);\n            let inner = inner.strip_suffix(\"*/\").unwrap_or(inner);\n\n            return inner\n                .lines()\n                .map(|line| {\n                    let line = line.trim();\n                    line.strip_prefix('*').unwrap_or(line).trim()\n                })\n                .filter(|line| !line.is_empty())\n                .collect::<Vec<_>>()\n                .join(\" \");\n        }\n\n        // Line comment: // ...\n        if text.starts_with(\"//\") {\n            return text.strip_prefix(\"//\").unwrap_or(text).trim().to_string();\n        }\n\n        text.to_string()\n    }\n",
      "semantic_tags": [
        "transform",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 191
    },
    {
      "name": "(C) extract_type",
      "qualified_name": "src/lang/c.rs::(C) extract_type",
      "file": "src/lang/c.rs",
      "line": 125,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_type(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_type(&self, node: Node, source: &[u8]) -> String {\n        let mut parts = Vec::new();\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"type_qualifier\" => {\n                    parts.push(self.node_text(child, source));\n                }\n                \"primitive_type\" | \"type_identifier\" | \"sized_type_specifier\" => {\n                    parts.push(self.node_text(child, source));\n                }\n                \"struct_specifier\" => {\n                    // Handle struct Type\n                    if let Some(name) = self.child_by_field(child, \"name\") {\n                        parts.push(format!(\"struct {}\", self.node_text(name, source)));\n                    } else {\n                        parts.push(\"struct\".to_string());\n                    }\n                }\n                \"enum_specifier\" => {\n                    if let Some(name) = self.child_by_field(child, \"name\") {\n                        parts.push(format!(\"enum {}\", self.node_text(name, source)));\n                    } else {\n                        parts.push(\"enum\".to_string());\n                    }\n                }\n                \"union_specifier\" => {\n                    if let Some(name) = self.child_by_field(child, \"name\") {\n                        parts.push(format!(\"union {}\", self.node_text(name, source)));\n                    } else {\n                        parts.push(\"union\".to_string());\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        // If no children matched, use the node text directly\n        if parts.is_empty() {\n            return self.node_text(node, source);\n        }\n\n        parts.join(\" \")\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 8,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 326
    },
    {
      "name": "(C) extract_params",
      "qualified_name": "src/lang/c.rs::(C) extract_params",
      "file": "src/lang/c.rs",
      "line": 172,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_params(&self, node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_params(&self, node: Node, source: &[u8]) -> Vec<String> {\n        let mut params = Vec::new();\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"parameter_declaration\" {\n                let param = self.extract_parameter(child, source);\n                if !param.is_empty() {\n                    params.push(param);\n                }\n            } else if child.kind() == \"variadic_parameter\" {\n                params.push(\"...\".to_string());\n            }\n        }\n\n        params\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 119
    },
    {
      "name": "(C) extract_parameter",
      "qualified_name": "src/lang/c.rs::(C) extract_parameter",
      "file": "src/lang/c.rs",
      "line": 191,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_parameter(&self, node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_parameter(&self, node: Node, source: &[u8]) -> String {\n        let mut type_parts = Vec::new();\n        let mut name = String::new();\n        let mut pointer_count = 0;\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"type_qualifier\" => {\n                    type_parts.push(self.node_text(child, source));\n                }\n                \"primitive_type\" | \"type_identifier\" | \"sized_type_specifier\" => {\n                    type_parts.push(self.node_text(child, source));\n                }\n                \"struct_specifier\" => {\n                    if let Some(n) = self.child_by_field(child, \"name\") {\n                        type_parts.push(format!(\"struct {}\", self.node_text(n, source)));\n                    }\n                }\n                \"pointer_declarator\" => {\n                    let (n, ptrs) = self.extract_pointer_declarator(child, source);\n                    name = n;\n                    pointer_count = ptrs;\n                }\n                \"identifier\" => {\n                    name = self.node_text(child, source);\n                }\n                \"array_declarator\" => {\n                    // Handle array parameters like int arr[]\n                    let (n, suffix) = self.extract_array_declarator(child, source);\n                    name = format!(\"{}{}\", n, suffix);\n                }\n                _ => {}\n            }\n        }\n\n        let type_str = type_parts.join(\" \");\n        let pointers = \"*\".repeat(pointer_count);\n\n        if name.is_empty() {\n            // Unnamed parameter (just type)\n            format!(\"{}{}\", type_str, pointers)\n        } else {\n            format!(\"{}{} {}\", type_str, pointers, name)\n        }\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 6,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 355
    },
    {
      "name": "(C) extract_pointer_declarator",
      "qualified_name": "src/lang/c.rs::(C) extract_pointer_declarator",
      "file": "src/lang/c.rs",
      "line": 239,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_pointer_declarator(&self, node: Node, source: &[u8]) -> (String, usize)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_pointer_declarator(&self, node: Node, source: &[u8]) -> (String, usize) {\n        let mut pointer_count = 0;\n        let mut current = node;\n\n        loop {\n            if current.kind() == \"pointer_declarator\" {\n                pointer_count += 1;\n                if let Some(declarator) = self.child_by_field(current, \"declarator\") {\n                    current = declarator;\n                } else {\n                    // Find the declarator child manually\n                    let mut found = false;\n                    let mut cursor = current.walk();\n                    for child in current.children(&mut cursor) {\n                        if child.kind() != \"*\" {\n                            current = child;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if !found {\n                        break;\n                    }\n                }\n            } else if current.kind() == \"identifier\" || current.kind() == \"field_identifier\" {\n                return (self.node_text(current, source), pointer_count);\n            } else if current.kind() == \"function_declarator\" {\n                // Function pointer - extract the identifier from it\n                if let Some(decl) = self.child_by_field(current, \"declarator\") {\n                    return self.extract_pointer_declarator(decl, source);\n                }\n                break;\n            } else {\n                break;\n            }\n        }\n\n        (String::new(), pointer_count)\n    }\n",
      "semantic_tags": [
        "test",
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 11,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 287
    },
    {
      "name": "(C) extract_array_declarator",
      "qualified_name": "src/lang/c.rs::(C) extract_array_declarator",
      "file": "src/lang/c.rs",
      "line": 280,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_array_declarator(&self, node: Node, source: &[u8]) -> (String, String)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_array_declarator(&self, node: Node, source: &[u8]) -> (String, String) {\n        let mut name = String::new();\n        let mut suffix = String::new();\n\n        if let Some(declarator) = self.child_by_field(node, \"declarator\") {\n            name = self.node_text(declarator, source);\n        }\n\n        // Build array suffix\n        if let Some(size) = self.child_by_field(node, \"size\") {\n            suffix = format!(\"[{}]\", self.node_text(size, source));\n        } else {\n            suffix = \"[]\".to_string();\n        }\n\n        (name, suffix)\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 140
    },
    {
      "name": "(C) extract_return_type",
      "qualified_name": "src/lang/c.rs::(C) extract_return_type",
      "file": "src/lang/c.rs",
      "line": 299,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_return_type(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_return_type(&self, node: Node, source: &[u8]) -> Option<String> {\n        let mut type_parts = Vec::new();\n        let mut pointer_count = 0;\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"storage_class_specifier\" => {\n                    // Skip storage class (static, extern, etc.) for return type\n                }\n                \"type_qualifier\" => {\n                    type_parts.push(self.node_text(child, source));\n                }\n                \"primitive_type\" | \"type_identifier\" | \"sized_type_specifier\" => {\n                    type_parts.push(self.node_text(child, source));\n                }\n                \"struct_specifier\" => {\n                    if let Some(name) = self.child_by_field(child, \"name\") {\n                        type_parts.push(format!(\"struct {}\", self.node_text(name, source)));\n                    }\n                }\n                \"pointer_declarator\" => {\n                    // Return type with pointer: int* func()\n                    // Count asterisks at the start of the declarator chain\n                    let mut current = child;\n                    while current.kind() == \"pointer_declarator\" {\n                        pointer_count += 1;\n                        if let Some(decl) = self.child_by_field(current, \"declarator\") {\n                            current = decl;\n                        } else {\n                            let mut c = current.walk();\n                            let mut found = false;\n                            for ch in current.children(&mut c) {\n                                if ch.kind() != \"*\" {\n                                    current = ch;\n                                    found = true;\n                                    break;\n                                }\n                            }\n                            if !found {\n                                break;\n                            }\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        if type_parts.is_empty() {\n            return None;\n        }\n\n        let pointers = \"*\".repeat(pointer_count);\n        Some(format!(\"{}{}\", type_parts.join(\" \"), pointers))\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 9,
        "branches": 7,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 395
    },
    {
      "name": "(C) has_storage_class",
      "qualified_name": "src/lang/c.rs::(C) has_storage_class",
      "file": "src/lang/c.rs",
      "line": 357,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) has_storage_class(&self, node: Node, source: &[u8], specifier: &str) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn has_storage_class(&self, node: Node, source: &[u8], specifier: &str) -> bool {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"storage_class_specifier\" {\n                if self.get_text(child, source).trim() == specifier {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 87
    },
    {
      "name": "(C) extract_function_name",
      "qualified_name": "src/lang/c.rs::(C) extract_function_name",
      "file": "src/lang/c.rs",
      "line": 370,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_function_name(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_function_name(&self, node: Node, source: &[u8]) -> Option<String> {\n        // The declarator field contains the actual identifier (possibly wrapped in pointer_declarator)\n        if let Some(declarator) = self.child_by_field(node, \"declarator\") {\n            return self.extract_name_from_declarator(declarator, source);\n        }\n\n        // Fallback: search children\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"identifier\" {\n                return Some(self.node_text(child, source));\n            }\n            if child.kind() == \"pointer_declarator\" {\n                let (name, _) = self.extract_pointer_declarator(child, source);\n                if !name.is_empty() {\n                    return Some(name);\n                }\n            }\n        }\n\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 182
    },
    {
      "name": "(C) extract_name_from_declarator",
      "qualified_name": "src/lang/c.rs::(C) extract_name_from_declarator",
      "file": "src/lang/c.rs",
      "line": 394,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_name_from_declarator(&self, node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_name_from_declarator(&self, node: Node, source: &[u8]) -> Option<String> {\n        match node.kind() {\n            \"identifier\" => Some(self.node_text(node, source)),\n            \"pointer_declarator\" => {\n                let (name, _) = self.extract_pointer_declarator(node, source);\n                if name.is_empty() {\n                    None\n                } else {\n                    Some(name)\n                }\n            }\n            \"function_declarator\" => self.extract_function_name(node, source),\n            _ => None,\n        }\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 118
    },
    {
      "name": "(C) build_c_cfg",
      "qualified_name": "src/lang/c.rs::(C) build_c_cfg",
      "file": "src/lang/c.rs",
      "line": 411,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) build_c_cfg(&self, node: Node, source: &[u8], func_name: &str) -> CFGInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_c_cfg(&self, node: Node, source: &[u8], func_name: &str) -> CFGInfo {\n        let mut blocks = HashMap::new();\n        let mut edges = Vec::new();\n        let mut block_id = 0;\n        let mut exits = Vec::new();\n\n        // Entry block\n        let entry = BlockId(block_id);\n        blocks.insert(\n            entry,\n            CFGBlock {\n                id: entry,\n                label: \"entry\".to_string(),\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.start_position().row + 1,\n            },\n        );\n        block_id += 1;\n\n        // Find body (compound_statement)\n        if let Some(body) = self.child_by_field(node, \"body\") {\n            self.process_cfg_block(\n                body,\n                source,\n                &mut blocks,\n                &mut edges,\n                &mut block_id,\n                entry,\n                &mut exits,\n                &mut Vec::new(),\n                &mut Vec::new(),\n            );\n        }\n\n        // If no explicit exits, the entry block is also an exit\n        if exits.is_empty() {\n            exits.push(entry);\n        }\n\n        CFGInfo {\n            function_name: func_name.to_string(),\n            blocks,\n            edges,\n            entry,\n            exits,\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "database"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 284
    },
    {
      "name": "(C) process_cfg_block",
      "qualified_name": "src/lang/c.rs::(C) process_cfg_block",
      "file": "src/lang/c.rs",
      "line": 462,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) process_cfg_block(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, block_id: &mut usize, current_block: BlockId, exits: &mut Vec<BlockId>, loop_headers: &mut Vec<BlockId>, loop_exits: &mut Vec<BlockId>) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_cfg_block(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        block_id: &mut usize,\n        current_block: BlockId,\n        exits: &mut Vec<BlockId>,\n        loop_headers: &mut Vec<BlockId>,\n        loop_exits: &mut Vec<BlockId>,\n    ) -> BlockId {\n        let mut last_block = current_block;\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"return_statement\" => {\n                    *block_id += 1;\n                    let ret_block = BlockId(*block_id);\n                    let stmt = self.node_text(child, source);\n\n                    blocks.insert(\n                        ret_block,\n                        CFGBlock {\n                            id: ret_block,\n                            label: \"return\".to_string(),\n                            statements: vec![stmt],\n                            start_line: child.start_position().row + 1,\n                            end_line: child.end_position().row + 1,\n                        },\n                    );\n\n                    edges.push(CFGEdge {\n                        from: last_block,\n                        to: ret_block,\n                        label: None,\n                    });\n\n                    exits.push(ret_block);\n                    last_block = ret_block;\n                }\n                \"if_statement\" => {\n                    last_block = self.process_if_cfg(\n                        child,\n                        source,\n                        blocks,\n                        edges,\n                        block_id,\n                        last_block,\n                        exits,\n                        loop_headers,\n                        loop_exits,\n                    );\n                }\n                \"while_statement\" => {\n                    last_block = self.process_while_cfg(\n                        child,\n                        source,\n                        blocks,\n                        edges,\n                        block_id,\n                        last_block,\n                        exits,\n                        loop_headers,\n                        loop_exits,\n                    );\n                }\n                \"for_statement\" => {\n                    last_block = self.process_for_cfg(\n                        child,\n                        source,\n                        blocks,\n                        edges,\n                        block_id,\n                        last_block,\n                        exits,\n                        loop_headers,\n                        loop_exits,\n                    );\n                }\n                \"do_statement\" => {\n                    last_block = self.process_do_while_cfg(\n                        child,\n                        source,\n                        blocks,\n                        edges,\n                        block_id,\n                        last_block,\n                        exits,\n                        loop_headers,\n                        loop_exits,\n                    );\n                }\n                \"switch_statement\" => {\n                    last_block = self.process_switch_cfg(\n                        child,\n                        source,\n                        blocks,\n                        edges,\n                        block_id,\n                        last_block,\n                        exits,\n                        loop_headers,\n                        loop_exits,\n                    );\n                }\n                \"break_statement\" => {\n                    if let Some(&exit_block) = loop_exits.last() {\n                        edges.push(CFGEdge {\n                            from: last_block,\n                            to: exit_block,\n                            label: Some(\"break\".to_string()),\n                        });\n                    }\n                }\n                \"continue_statement\" => {\n                    if let Some(&header) = loop_headers.last() {\n                        edges.push(CFGEdge {\n                            from: last_block,\n                            to: header,\n                            label: Some(\"continue\".to_string()),\n                        });\n                    }\n                }\n                \"compound_statement\" => {\n                    last_block = self.process_cfg_block(\n                        child,\n                        source,\n                        blocks,\n                        edges,\n                        block_id,\n                        last_block,\n                        exits,\n                        loop_headers,\n                        loop_exits,\n                    );\n                }\n                // Regular statements\n                \"declaration\" | \"expression_statement\" | \"labeled_statement\" | \"goto_statement\" => {\n                    if let Some(block) = blocks.get_mut(&last_block) {\n                        let stmt = self.node_text(child, source);\n                        block.statements.push(stmt);\n                        block.end_line = child.end_position().row + 1;\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        last_block\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 787
    },
    {
      "name": "(C) process_if_cfg",
      "qualified_name": "src/lang/c.rs::(C) process_if_cfg",
      "file": "src/lang/c.rs",
      "line": 617,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) process_if_cfg(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, block_id: &mut usize, current_block: BlockId, exits: &mut Vec<BlockId>, loop_headers: &mut Vec<BlockId>, loop_exits: &mut Vec<BlockId>) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_if_cfg(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        block_id: &mut usize,\n        current_block: BlockId,\n        exits: &mut Vec<BlockId>,\n        loop_headers: &mut Vec<BlockId>,\n        loop_exits: &mut Vec<BlockId>,\n    ) -> BlockId {\n        *block_id += 1;\n        let cond_block = BlockId(*block_id);\n        let condition = self\n            .child_by_field(node, \"condition\")\n            .map(|n| self.node_text(n, source))\n            .unwrap_or_else(|| \"condition\".to_string());\n\n        blocks.insert(\n            cond_block,\n            CFGBlock {\n                id: cond_block,\n                label: format!(\"if {}\", condition),\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.start_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: current_block,\n            to: cond_block,\n            label: None,\n        });\n\n        // Merge block after if\n        *block_id += 1;\n        let merge_block = BlockId(*block_id);\n        blocks.insert(\n            merge_block,\n            CFGBlock {\n                id: merge_block,\n                label: \"endif\".to_string(),\n                statements: Vec::new(),\n                start_line: node.end_position().row + 1,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        // True branch (consequence)\n        if let Some(consequence) = self.child_by_field(node, \"consequence\") {\n            *block_id += 1;\n            let true_block = BlockId(*block_id);\n            blocks.insert(\n                true_block,\n                CFGBlock {\n                    id: true_block,\n                    label: \"then\".to_string(),\n                    statements: Vec::new(),\n                    start_line: consequence.start_position().row + 1,\n                    end_line: consequence.end_position().row + 1,\n                },\n            );\n\n            edges.push(CFGEdge {\n                from: cond_block,\n                to: true_block,\n                label: Some(\"true\".to_string()),\n            });\n\n            let true_end = self.process_cfg_block(\n                consequence,\n                source,\n                blocks,\n                edges,\n                block_id,\n                true_block,\n                exits,\n                loop_headers,\n                loop_exits,\n            );\n\n            if !exits.contains(&true_end) {\n                edges.push(CFGEdge {\n                    from: true_end,\n                    to: merge_block,\n                    label: None,\n                });\n            }\n        }\n\n        // False branch (alternative)\n        if let Some(alternative) = self.child_by_field(node, \"alternative\") {\n            *block_id += 1;\n            let false_block = BlockId(*block_id);\n            blocks.insert(\n                false_block,\n                CFGBlock {\n                    id: false_block,\n                    label: \"else\".to_string(),\n                    statements: Vec::new(),\n                    start_line: alternative.start_position().row + 1,\n                    end_line: alternative.end_position().row + 1,\n                },\n            );\n\n            edges.push(CFGEdge {\n                from: cond_block,\n                to: false_block,\n                label: Some(\"false\".to_string()),\n            });\n\n            let false_end = self.process_cfg_block(\n                alternative,\n                source,\n                blocks,\n                edges,\n                block_id,\n                false_block,\n                exits,\n                loop_headers,\n                loop_exits,\n            );\n\n            if !exits.contains(&false_end) {\n                edges.push(CFGEdge {\n                    from: false_end,\n                    to: merge_block,\n                    label: None,\n                });\n            }\n        } else {\n            // No else branch\n            edges.push(CFGEdge {\n                from: cond_block,\n                to: merge_block,\n                label: Some(\"false\".to_string()),\n            });\n        }\n\n        merge_block\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 9,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 833
    },
    {
      "name": "(C) process_while_cfg",
      "qualified_name": "src/lang/c.rs::(C) process_while_cfg",
      "file": "src/lang/c.rs",
      "line": 763,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) process_while_cfg(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, block_id: &mut usize, current_block: BlockId, exits: &mut Vec<BlockId>, loop_headers: &mut Vec<BlockId>, loop_exits: &mut Vec<BlockId>) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_while_cfg(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        block_id: &mut usize,\n        current_block: BlockId,\n        exits: &mut Vec<BlockId>,\n        loop_headers: &mut Vec<BlockId>,\n        loop_exits: &mut Vec<BlockId>,\n    ) -> BlockId {\n        *block_id += 1;\n        let header_block = BlockId(*block_id);\n        let condition = self\n            .child_by_field(node, \"condition\")\n            .map(|n| self.node_text(n, source))\n            .unwrap_or_else(|| \"condition\".to_string());\n\n        blocks.insert(\n            header_block,\n            CFGBlock {\n                id: header_block,\n                label: format!(\"while {}\", condition),\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.start_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: current_block,\n            to: header_block,\n            label: None,\n        });\n\n        // Exit block\n        *block_id += 1;\n        let exit_block = BlockId(*block_id);\n        blocks.insert(\n            exit_block,\n            CFGBlock {\n                id: exit_block,\n                label: \"endwhile\".to_string(),\n                statements: Vec::new(),\n                start_line: node.end_position().row + 1,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        loop_headers.push(header_block);\n        loop_exits.push(exit_block);\n\n        // Body\n        if let Some(body) = self.child_by_field(node, \"body\") {\n            *block_id += 1;\n            let body_block = BlockId(*block_id);\n            blocks.insert(\n                body_block,\n                CFGBlock {\n                    id: body_block,\n                    label: \"loop_body\".to_string(),\n                    statements: Vec::new(),\n                    start_line: body.start_position().row + 1,\n                    end_line: body.end_position().row + 1,\n                },\n            );\n\n            edges.push(CFGEdge {\n                from: header_block,\n                to: body_block,\n                label: Some(\"true\".to_string()),\n            });\n\n            let body_end = self.process_cfg_block(\n                body,\n                source,\n                blocks,\n                edges,\n                block_id,\n                body_block,\n                exits,\n                loop_headers,\n                loop_exits,\n            );\n\n            if !exits.contains(&body_end) {\n                edges.push(CFGEdge {\n                    from: body_end,\n                    to: header_block,\n                    label: Some(\"back_edge\".to_string()),\n                });\n            }\n        }\n\n        edges.push(CFGEdge {\n            from: header_block,\n            to: exit_block,\n            label: Some(\"false\".to_string()),\n        });\n\n        loop_headers.pop();\n        loop_exits.pop();\n\n        exit_block\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 624
    },
    {
      "name": "(C) process_for_cfg",
      "qualified_name": "src/lang/c.rs::(C) process_for_cfg",
      "file": "src/lang/c.rs",
      "line": 872,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) process_for_cfg(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, block_id: &mut usize, current_block: BlockId, exits: &mut Vec<BlockId>, loop_headers: &mut Vec<BlockId>, loop_exits: &mut Vec<BlockId>) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_for_cfg(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        block_id: &mut usize,\n        current_block: BlockId,\n        exits: &mut Vec<BlockId>,\n        loop_headers: &mut Vec<BlockId>,\n        loop_exits: &mut Vec<BlockId>,\n    ) -> BlockId {\n        // For loop: for (init; cond; update) body\n        *block_id += 1;\n        let header_block = BlockId(*block_id);\n        let header_text = self\n            .node_text(node, source)\n            .lines()\n            .next()\n            .unwrap_or(\"for\")\n            .to_string();\n\n        blocks.insert(\n            header_block,\n            CFGBlock {\n                id: header_block,\n                label: header_text,\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.start_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: current_block,\n            to: header_block,\n            label: None,\n        });\n\n        // Exit block\n        *block_id += 1;\n        let exit_block = BlockId(*block_id);\n        blocks.insert(\n            exit_block,\n            CFGBlock {\n                id: exit_block,\n                label: \"endfor\".to_string(),\n                statements: Vec::new(),\n                start_line: node.end_position().row + 1,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        loop_headers.push(header_block);\n        loop_exits.push(exit_block);\n\n        // Find body\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"compound_statement\" {\n                *block_id += 1;\n                let body_block = BlockId(*block_id);\n                blocks.insert(\n                    body_block,\n                    CFGBlock {\n                        id: body_block,\n                        label: \"loop_body\".to_string(),\n                        statements: Vec::new(),\n                        start_line: child.start_position().row + 1,\n                        end_line: child.end_position().row + 1,\n                    },\n                );\n\n                edges.push(CFGEdge {\n                    from: header_block,\n                    to: body_block,\n                    label: Some(\"iterate\".to_string()),\n                });\n\n                let body_end = self.process_cfg_block(\n                    child,\n                    source,\n                    blocks,\n                    edges,\n                    block_id,\n                    body_block,\n                    exits,\n                    loop_headers,\n                    loop_exits,\n                );\n\n                if !exits.contains(&body_end) {\n                    edges.push(CFGEdge {\n                        from: body_end,\n                        to: header_block,\n                        label: Some(\"back_edge\".to_string()),\n                    });\n                }\n                break;\n            }\n        }\n\n        edges.push(CFGEdge {\n            from: header_block,\n            to: exit_block,\n            label: Some(\"done\".to_string()),\n        });\n\n        loop_headers.pop();\n        loop_exits.pop();\n\n        exit_block\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 649
    },
    {
      "name": "(C) process_do_while_cfg",
      "qualified_name": "src/lang/c.rs::(C) process_do_while_cfg",
      "file": "src/lang/c.rs",
      "line": 988,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) process_do_while_cfg(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, block_id: &mut usize, current_block: BlockId, exits: &mut Vec<BlockId>, loop_headers: &mut Vec<BlockId>, loop_exits: &mut Vec<BlockId>) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_do_while_cfg(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        block_id: &mut usize,\n        current_block: BlockId,\n        exits: &mut Vec<BlockId>,\n        loop_headers: &mut Vec<BlockId>,\n        loop_exits: &mut Vec<BlockId>,\n    ) -> BlockId {\n        // Body block (executes at least once)\n        *block_id += 1;\n        let body_block = BlockId(*block_id);\n        blocks.insert(\n            body_block,\n            CFGBlock {\n                id: body_block,\n                label: \"do\".to_string(),\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.start_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: current_block,\n            to: body_block,\n            label: None,\n        });\n\n        // Condition block (at the end)\n        *block_id += 1;\n        let cond_block = BlockId(*block_id);\n        let condition = self\n            .child_by_field(node, \"condition\")\n            .map(|n| self.node_text(n, source))\n            .unwrap_or_else(|| \"condition\".to_string());\n\n        blocks.insert(\n            cond_block,\n            CFGBlock {\n                id: cond_block,\n                label: format!(\"while {}\", condition),\n                statements: Vec::new(),\n                start_line: node.end_position().row,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        // Exit block\n        *block_id += 1;\n        let exit_block = BlockId(*block_id);\n        blocks.insert(\n            exit_block,\n            CFGBlock {\n                id: exit_block,\n                label: \"enddo\".to_string(),\n                statements: Vec::new(),\n                start_line: node.end_position().row + 1,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        loop_headers.push(cond_block);\n        loop_exits.push(exit_block);\n\n        // Process body\n        if let Some(body) = self.child_by_field(node, \"body\") {\n            let body_end = self.process_cfg_block(\n                body,\n                source,\n                blocks,\n                edges,\n                block_id,\n                body_block,\n                exits,\n                loop_headers,\n                loop_exits,\n            );\n\n            if !exits.contains(&body_end) {\n                edges.push(CFGEdge {\n                    from: body_end,\n                    to: cond_block,\n                    label: None,\n                });\n            }\n        }\n\n        // Condition edges\n        edges.push(CFGEdge {\n            from: cond_block,\n            to: body_block,\n            label: Some(\"true\".to_string()),\n        });\n        edges.push(CFGEdge {\n            from: cond_block,\n            to: exit_block,\n            label: Some(\"false\".to_string()),\n        });\n\n        loop_headers.pop();\n        loop_exits.pop();\n\n        exit_block\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 641
    },
    {
      "name": "(C) process_switch_cfg",
      "qualified_name": "src/lang/c.rs::(C) process_switch_cfg",
      "file": "src/lang/c.rs",
      "line": 1099,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) process_switch_cfg(&self, node: Node, source: &[u8], blocks: &mut HashMap<BlockId, CFGBlock>, edges: &mut Vec<CFGEdge>, block_id: &mut usize, current_block: BlockId, exits: &mut Vec<BlockId>, loop_headers: &mut Vec<BlockId>, loop_exits: &mut Vec<BlockId>) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_switch_cfg(\n        &self,\n        node: Node,\n        source: &[u8],\n        blocks: &mut HashMap<BlockId, CFGBlock>,\n        edges: &mut Vec<CFGEdge>,\n        block_id: &mut usize,\n        current_block: BlockId,\n        exits: &mut Vec<BlockId>,\n        loop_headers: &mut Vec<BlockId>,\n        loop_exits: &mut Vec<BlockId>,\n    ) -> BlockId {\n        *block_id += 1;\n        let switch_block = BlockId(*block_id);\n        let expr = self\n            .child_by_field(node, \"condition\")\n            .map(|n| self.node_text(n, source))\n            .unwrap_or_else(|| \"expr\".to_string());\n\n        blocks.insert(\n            switch_block,\n            CFGBlock {\n                id: switch_block,\n                label: format!(\"switch {}\", expr),\n                statements: Vec::new(),\n                start_line: node.start_position().row + 1,\n                end_line: node.start_position().row + 1,\n            },\n        );\n\n        edges.push(CFGEdge {\n            from: current_block,\n            to: switch_block,\n            label: None,\n        });\n\n        // Exit block\n        *block_id += 1;\n        let exit_block = BlockId(*block_id);\n        blocks.insert(\n            exit_block,\n            CFGBlock {\n                id: exit_block,\n                label: \"endswitch\".to_string(),\n                statements: Vec::new(),\n                start_line: node.end_position().row + 1,\n                end_line: node.end_position().row + 1,\n            },\n        );\n\n        // Push exit for break statements\n        loop_exits.push(exit_block);\n\n        // Find body and process cases\n        if let Some(body) = self.child_by_field(node, \"body\") {\n            let mut cursor = body.walk();\n            for child in body.children(&mut cursor) {\n                if child.kind() == \"case_statement\" {\n                    *block_id += 1;\n                    let case_block = BlockId(*block_id);\n                    let case_label = self\n                        .node_text(child, source)\n                        .lines()\n                        .next()\n                        .unwrap_or(\"case\")\n                        .to_string();\n\n                    blocks.insert(\n                        case_block,\n                        CFGBlock {\n                            id: case_block,\n                            label: case_label,\n                            statements: Vec::new(),\n                            start_line: child.start_position().row + 1,\n                            end_line: child.end_position().row + 1,\n                        },\n                    );\n\n                    edges.push(CFGEdge {\n                        from: switch_block,\n                        to: case_block,\n                        label: None,\n                    });\n\n                    let case_end = self.process_cfg_block(\n                        child,\n                        source,\n                        blocks,\n                        edges,\n                        block_id,\n                        case_block,\n                        exits,\n                        loop_headers,\n                        loop_exits,\n                    );\n\n                    if !exits.contains(&case_end) {\n                        edges.push(CFGEdge {\n                            from: case_end,\n                            to: exit_block,\n                            label: None,\n                        });\n                    }\n                }\n            }\n        }\n\n        loop_exits.pop();\n\n        exit_block\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 7,
        "branches": 5,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 647
    },
    {
      "name": "(C) build_c_dfg",
      "qualified_name": "src/lang/c.rs::(C) build_c_dfg",
      "file": "src/lang/c.rs",
      "line": 1212,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) build_c_dfg(&self, node: Node, source: &[u8], func_name: &str) -> DFGInfo",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_c_dfg(&self, node: Node, source: &[u8], func_name: &str) -> DFGInfo {\n        let mut edges = Vec::new();\n        let mut definitions: HashMap<String, Vec<usize>> = HashMap::new();\n        let mut uses: HashMap<String, Vec<usize>> = HashMap::new();\n\n        // Extract parameters as initial definitions\n        if let Some(declarator) = self.child_by_field(node, \"declarator\") {\n            if let Some(params) = self.child_by_field(declarator, \"parameters\") {\n                let line = params.start_position().row + 1;\n                let mut cursor = params.walk();\n\n                for child in params.children(&mut cursor) {\n                    if child.kind() == \"parameter_declaration\" {\n                        self.extract_param_definition(\n                            child,\n                            source,\n                            line,\n                            &mut edges,\n                            &mut definitions,\n                        );\n                    }\n                }\n            }\n        }\n\n        // Process body\n        if let Some(body) = self.child_by_field(node, \"body\") {\n            self.extract_dfg_from_block(body, source, &mut edges, &mut definitions, &mut uses);\n        }\n\n        DFGInfo {\n            function_name: func_name.to_string(),\n            edges,\n            definitions,\n            uses,\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 270
    },
    {
      "name": "(C) extract_param_definition",
      "qualified_name": "src/lang/c.rs::(C) extract_param_definition",
      "file": "src/lang/c.rs",
      "line": 1251,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_param_definition(&self, node: Node, source: &[u8], line: usize, edges: &mut Vec<DataflowEdge>, definitions: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_param_definition(\n        &self,\n        node: Node,\n        source: &[u8],\n        line: usize,\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &mut HashMap<String, Vec<usize>>,\n    ) {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"identifier\" => {\n                    let name = self.node_text(child, source);\n                    if !name.is_empty() {\n                        definitions.entry(name.clone()).or_default().push(line);\n                        edges.push(DataflowEdge {\n                            variable: name,\n                            from_line: line,\n                            to_line: line,\n                            kind: DataflowKind::Param,\n                        });\n                    }\n                }\n                \"pointer_declarator\" => {\n                    let (name, _) = self.extract_pointer_declarator(child, source);\n                    if !name.is_empty() {\n                        definitions.entry(name.clone()).or_default().push(line);\n                        edges.push(DataflowEdge {\n                            variable: name,\n                            from_line: line,\n                            to_line: line,\n                            kind: DataflowKind::Param,\n                        });\n                    }\n                }\n                _ => {}\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 247
    },
    {
      "name": "(C) extract_dfg_from_block",
      "qualified_name": "src/lang/c.rs::(C) extract_dfg_from_block",
      "file": "src/lang/c.rs",
      "line": 1292,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_dfg_from_block(&self, node: Node, source: &[u8], edges: &mut Vec<DataflowEdge>, definitions: &mut HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_dfg_from_block(\n        &self,\n        node: Node,\n        source: &[u8],\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &mut HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n    ) {\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            let line = child.start_position().row + 1;\n\n            match child.kind() {\n                \"declaration\" => {\n                    self.extract_declaration_dfg(child, source, line, edges, definitions, uses);\n                }\n                \"expression_statement\" => {\n                    self.extract_expression_dfg(child, source, line, edges, definitions, uses);\n                }\n                \"return_statement\" => {\n                    self.extract_return_dfg(child, source, line, edges, definitions, uses);\n                }\n                \"if_statement\" | \"while_statement\" | \"for_statement\" | \"do_statement\"\n                | \"switch_statement\" => {\n                    self.extract_dfg_from_block(child, source, edges, definitions, uses);\n                }\n                \"compound_statement\" => {\n                    self.extract_dfg_from_block(child, source, edges, definitions, uses);\n                }\n                _ => {}\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 260
    },
    {
      "name": "(C) extract_declaration_dfg",
      "qualified_name": "src/lang/c.rs::(C) extract_declaration_dfg",
      "file": "src/lang/c.rs",
      "line": 1328,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_declaration_dfg(&self, node: Node, source: &[u8], line: usize, edges: &mut Vec<DataflowEdge>, definitions: &mut HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_declaration_dfg(\n        &self,\n        node: Node,\n        source: &[u8],\n        line: usize,\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &mut HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n    ) {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"init_declarator\" {\n                // Variable with initialization\n                if let Some(declarator) = self.child_by_field(child, \"declarator\") {\n                    let name = self.extract_name_from_declarator(declarator, source);\n                    if let Some(name) = name {\n                        definitions.entry(name.clone()).or_default().push(line);\n                        edges.push(DataflowEdge {\n                            variable: name,\n                            from_line: line,\n                            to_line: line,\n                            kind: DataflowKind::Definition,\n                        });\n                    }\n                }\n                // Extract uses from value\n                if let Some(value) = self.child_by_field(child, \"value\") {\n                    self.extract_uses_from_expr(value, source, line, edges, definitions, uses);\n                }\n            } else if child.kind() == \"identifier\" || child.kind() == \"pointer_declarator\" {\n                // Declaration without initialization\n                let name = self.extract_name_from_declarator(child, source);\n                if let Some(name) = name {\n                    definitions.entry(name.clone()).or_default().push(line);\n                    edges.push(DataflowEdge {\n                        variable: name,\n                        from_line: line,\n                        to_line: line,\n                        kind: DataflowKind::Definition,\n                    });\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 7,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 351
    },
    {
      "name": "(C) extract_expression_dfg",
      "qualified_name": "src/lang/c.rs::(C) extract_expression_dfg",
      "file": "src/lang/c.rs",
      "line": 1374,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_expression_dfg(&self, node: Node, source: &[u8], line: usize, edges: &mut Vec<DataflowEdge>, definitions: &mut HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_expression_dfg(\n        &self,\n        node: Node,\n        source: &[u8],\n        line: usize,\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &mut HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n    ) {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"assignment_expression\" {\n                // Left side is definition/mutation\n                if let Some(left) = self.child_by_field(child, \"left\") {\n                    let name = self.extract_name_from_declarator(left, source);\n                    if let Some(name) = name {\n                        definitions.entry(name.clone()).or_default().push(line);\n                        edges.push(DataflowEdge {\n                            variable: name,\n                            from_line: line,\n                            to_line: line,\n                            kind: DataflowKind::Mutation,\n                        });\n                    }\n                }\n                // Right side has uses\n                if let Some(right) = self.child_by_field(child, \"right\") {\n                    self.extract_uses_from_expr(right, source, line, edges, definitions, uses);\n                }\n            } else if child.kind() == \"update_expression\" {\n                // x++ or ++x is both use and mutation\n                self.extract_uses_from_expr(child, source, line, edges, definitions, uses);\n            } else if child.kind() == \"call_expression\" {\n                self.extract_uses_from_expr(child, source, line, edges, definitions, uses);\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 8,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 322
    },
    {
      "name": "(C) extract_return_dfg",
      "qualified_name": "src/lang/c.rs::(C) extract_return_dfg",
      "file": "src/lang/c.rs",
      "line": 1413,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_return_dfg(&self, node: Node, source: &[u8], line: usize, edges: &mut Vec<DataflowEdge>, definitions: &HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_return_dfg(\n        &self,\n        node: Node,\n        source: &[u8],\n        line: usize,\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n    ) {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.is_named() && child.kind() != \"return\" {\n                self.extract_return_uses(child, source, line, edges, definitions, uses);\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 120
    },
    {
      "name": "(C) extract_return_uses",
      "qualified_name": "src/lang/c.rs::(C) extract_return_uses",
      "file": "src/lang/c.rs",
      "line": 1431,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_return_uses(&self, node: Node, source: &[u8], line: usize, edges: &mut Vec<DataflowEdge>, definitions: &HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_return_uses(\n        &self,\n        node: Node,\n        source: &[u8],\n        line: usize,\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n    ) {\n        if node.kind() == \"identifier\" {\n            let name = self.node_text(node, source);\n            uses.entry(name.clone()).or_default().push(line);\n\n            // Create return edge\n            if let Some(def_lines) = definitions.get(&name) {\n                if let Some(&def_line) = def_lines.last() {\n                    edges.push(DataflowEdge {\n                        variable: name,\n                        from_line: def_line,\n                        to_line: line,\n                        kind: DataflowKind::Return,\n                    });\n                }\n            }\n        } else {\n            let mut cursor = node.walk();\n            for child in node.children(&mut cursor) {\n                if child.is_named() {\n                    self.extract_return_uses(child, source, line, edges, definitions, uses);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 5,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 225
    },
    {
      "name": "(C) extract_uses_from_expr",
      "qualified_name": "src/lang/c.rs::(C) extract_uses_from_expr",
      "file": "src/lang/c.rs",
      "line": 1466,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_uses_from_expr(&self, node: Node, source: &[u8], line: usize, edges: &mut Vec<DataflowEdge>, definitions: &HashMap<String, Vec<usize>>, uses: &mut HashMap<String, Vec<usize>>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_uses_from_expr(\n        &self,\n        node: Node,\n        source: &[u8],\n        line: usize,\n        edges: &mut Vec<DataflowEdge>,\n        definitions: &HashMap<String, Vec<usize>>,\n        uses: &mut HashMap<String, Vec<usize>>,\n    ) {\n        if node.kind() == \"identifier\" {\n            let name = self.node_text(node, source);\n            uses.entry(name.clone()).or_default().push(line);\n\n            // Create use edge from most recent definition\n            if let Some(def_lines) = definitions.get(&name) {\n                if let Some(&def_line) = def_lines.last() {\n                    edges.push(DataflowEdge {\n                        variable: name,\n                        from_line: def_line,\n                        to_line: line,\n                        kind: DataflowKind::Use,\n                    });\n                }\n            }\n        } else {\n            let mut cursor = node.walk();\n            for child in node.children(&mut cursor) {\n                if child.is_named() {\n                    self.extract_uses_from_expr(child, source, line, edges, definitions, uses);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 5,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 231
    },
    {
      "name": "(C) name",
      "qualified_name": "src/lang/c.rs::(C) name",
      "file": "src/lang/c.rs",
      "line": 1502,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) name(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn name(&self) -> &'static str {\n        \"c\"\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 17
    },
    {
      "name": "(C) extensions",
      "qualified_name": "src/lang/c.rs::(C) extensions",
      "file": "src/lang/c.rs",
      "line": 1506,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extensions(&self) -> &[&'static str]",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extensions(&self) -> &[&'static str] {\n        &[\".c\", \".h\"]\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 24
    },
    {
      "name": "(C) parser",
      "qualified_name": "src/lang/c.rs::(C) parser",
      "file": "src/lang/c.rs",
      "line": 1510,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) parser(&self) -> Result<Parser>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parser(&self) -> Result<Parser> {\n        let mut parser = Parser::new();\n        parser\n            .set_language(&tree_sitter_c::LANGUAGE.into())\n            .map_err(|e| TldrError::TreeSitter(e.to_string()))?;\n        Ok(parser)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 62
    },
    {
      "name": "(C) extract_function",
      "qualified_name": "src/lang/c.rs::(C) extract_function",
      "file": "src/lang/c.rs",
      "line": 1518,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo> {\n        match node.kind() {\n            \"function_definition\" => {\n                // func_definition has type, declarator, body\n                let declarator = self.child_by_field(node, \"declarator\")?;\n                let name = self.extract_function_name(declarator, source)?;\n\n                // Extract parameters\n                let params = self\n                    .child_by_field(declarator, \"parameters\")\n                    .map(|p| self.extract_params(p, source))\n                    .unwrap_or_default();\n\n                // Extract return type\n                let return_type = self.extract_return_type(node, source);\n\n                // Extract doc comment\n                let docstring = self.get_doc_comment(node, source);\n\n                // Check for static\n                let mut decorators = Vec::new();\n                if self.has_storage_class(node, source, \"static\") {\n                    decorators.push(\"static\".to_string());\n                }\n                if self.has_storage_class(node, source, \"inline\") {\n                    decorators.push(\"inline\".to_string());\n                }\n                if self.has_storage_class(node, source, \"extern\") {\n                    decorators.push(\"extern\".to_string());\n                }\n\n                Some(FunctionInfo {\n                    name,\n                    params,\n                    return_type,\n                    docstring,\n                    is_method: false,\n                    is_async: false,\n                    decorators,\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"c\".to_string(),\n                })\n            }\n            \"declaration\" => {\n                // Function declaration (prototype): int foo(int x);\n                // Check if this is a function declaration\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    if child.kind() == \"function_declarator\" {\n                        let name = self.extract_function_name(child, source)?;\n                        let params = self\n                            .child_by_field(child, \"parameters\")\n                            .map(|p| self.extract_params(p, source))\n                            .unwrap_or_default();\n                        let return_type = self.extract_return_type(node, source);\n                        let docstring = self.get_doc_comment(node, source);\n\n                        let mut decorators = vec![\"declaration\".to_string()];\n                        if self.has_storage_class(node, source, \"static\") {\n                            decorators.push(\"static\".to_string());\n                        }\n                        if self.has_storage_class(node, source, \"extern\") {\n                            decorators.push(\"extern\".to_string());\n                        }\n\n                        return Some(FunctionInfo {\n                            name,\n                            params,\n                            return_type,\n                            docstring,\n                            is_method: false,\n                            is_async: false,\n                            decorators,\n                            line_number: node.start_position().row + 1,\n                            end_line_number: Some(node.end_position().row + 1),\n                            language: \"c\".to_string(),\n                        });\n                    }\n                    // Also handle pointer return type: int* foo()\n                    if child.kind() == \"pointer_declarator\" {\n                        let mut current = child;\n                        while current.kind() == \"pointer_declarator\" {\n                            if let Some(decl) = self.child_by_field(current, \"declarator\") {\n                                current = decl;\n                            } else {\n                                let mut c = current.walk();\n                                let mut found = false;\n                                for ch in current.children(&mut c) {\n                                    if ch.kind() != \"*\" {\n                                        current = ch;\n                                        found = true;\n                                        break;\n                                    }\n                                }\n                                if !found {\n                                    break;\n                                }\n                            }\n                        }\n\n                        if current.kind() == \"function_declarator\" {\n                            let name = self.extract_function_name(current, source)?;\n                            let params = self\n                                .child_by_field(current, \"parameters\")\n                                .map(|p| self.extract_params(p, source))\n                                .unwrap_or_default();\n                            let return_type = self.extract_return_type(node, source);\n                            let docstring = self.get_doc_comment(node, source);\n\n                            let mut decorators = vec![\"declaration\".to_string()];\n                            if self.has_storage_class(node, source, \"static\") {\n                                decorators.push(\"static\".to_string());\n                            }\n\n                            return Some(FunctionInfo {\n                                name,\n                                params,\n                                return_type,\n                                docstring,\n                                is_method: false,\n                                is_async: false,\n                                decorators,\n                                line_number: node.start_position().row + 1,\n                                end_line_number: Some(node.end_position().row + 1),\n                                language: \"c\".to_string(),\n                            });\n                        }\n                    }\n                }\n                None\n            }\n            _ => None,\n        }\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 10,
        "branches": 15,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 952
    },
    {
      "name": "(C) extract_class",
      "qualified_name": "src/lang/c.rs::(C) extract_class",
      "file": "src/lang/c.rs",
      "line": 1654,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo> {\n        match node.kind() {\n            \"struct_specifier\" => {\n                // Struct definition: struct Name { ... }\n                let name = self\n                    .child_by_field(node, \"name\")\n                    .map(|n| self.node_text(n, source))?;\n\n                let docstring = self.get_doc_comment(node, source);\n\n                // C structs don't have methods or bases in the traditional sense\n                Some(ClassInfo {\n                    name,\n                    bases: Vec::new(),\n                    docstring,\n                    methods: Vec::new(),\n                    decorators: Vec::new(),\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"c\".to_string(),\n                })\n            }\n            \"type_definition\" => {\n                // typedef struct X X; or typedef struct { ... } Name;\n                let mut struct_name = None;\n                let mut typedef_name = None;\n                let mut cursor = node.walk();\n\n                for child in node.children(&mut cursor) {\n                    if child.kind() == \"struct_specifier\" {\n                        struct_name = self\n                            .child_by_field(child, \"name\")\n                            .map(|n| self.node_text(n, source));\n                    } else if child.kind() == \"type_identifier\" {\n                        typedef_name = Some(self.node_text(child, source));\n                    }\n                }\n\n                // Check for alias before consuming the values\n                let mut decorators = vec![\"typedef\".to_string()];\n                if struct_name.is_some() && typedef_name.is_some() && struct_name != typedef_name {\n                    decorators.push(format!(\n                        \"alias:{}\",\n                        struct_name.as_ref().unwrap_or(&String::new())\n                    ));\n                }\n\n                let name = typedef_name.or(struct_name)?;\n                let docstring = self.get_doc_comment(node, source);\n\n                Some(ClassInfo {\n                    name,\n                    bases: Vec::new(),\n                    docstring,\n                    methods: Vec::new(),\n                    decorators,\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"c\".to_string(),\n                })\n            }\n            \"enum_specifier\" => {\n                // enum Name { ... }\n                let name = self\n                    .child_by_field(node, \"name\")\n                    .map(|n| self.node_text(n, source))?;\n\n                let docstring = self.get_doc_comment(node, source);\n\n                Some(ClassInfo {\n                    name,\n                    bases: Vec::new(),\n                    docstring,\n                    methods: Vec::new(),\n                    decorators: vec![\"enum\".to_string()],\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"c\".to_string(),\n                })\n            }\n            \"union_specifier\" => {\n                // union Name { ... }\n                let name = self\n                    .child_by_field(node, \"name\")\n                    .map(|n| self.node_text(n, source))?;\n\n                let docstring = self.get_doc_comment(node, source);\n\n                Some(ClassInfo {\n                    name,\n                    bases: Vec::new(),\n                    docstring,\n                    methods: Vec::new(),\n                    decorators: vec![\"union\".to_string()],\n                    line_number: node.start_position().row + 1,\n                    end_line_number: Some(node.end_position().row + 1),\n                    language: \"c\".to_string(),\n                })\n            }\n            _ => None,\n        }\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 7,
        "branches": 5,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 750
    },
    {
      "name": "(C) extract_imports",
      "qualified_name": "src/lang/c.rs::(C) extract_imports",
      "file": "src/lang/c.rs",
      "line": 1757,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo> {\n        let mut imports = Vec::new();\n        let root = tree.root_node();\n        let mut cursor = root.walk();\n\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"preproc_include\" {\n                if let Some(import) = self.extract_include(child, source) {\n                    imports.push(import);\n                }\n            }\n        }\n\n        imports\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 105
    },
    {
      "name": "(C) function_query",
      "qualified_name": "src/lang/c.rs::(C) function_query",
      "file": "src/lang/c.rs",
      "line": 1773,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) function_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn function_query(&self) -> &'static str {\n        r#\"[\n            (function_definition\n                declarator: (function_declarator\n                    declarator: (identifier) @name)) @function\n            (function_definition\n                declarator: (pointer_declarator\n                    declarator: (function_declarator\n                        declarator: (identifier) @name))) @function\n            (declaration\n                declarator: (function_declarator\n                    declarator: (identifier) @name)) @function\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 6,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 115
    },
    {
      "name": "(C) class_query",
      "qualified_name": "src/lang/c.rs::(C) class_query",
      "file": "src/lang/c.rs",
      "line": 1788,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) class_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn class_query(&self) -> &'static str {\n        r#\"[\n            (struct_specifier name: (type_identifier) @name) @struct\n            (enum_specifier name: (type_identifier) @name) @enum\n            (union_specifier name: (type_identifier) @name) @union\n            (type_definition declarator: (type_identifier) @name) @typedef\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 90
    },
    {
      "name": "(C) call_query",
      "qualified_name": "src/lang/c.rs::(C) call_query",
      "file": "src/lang/c.rs",
      "line": 1797,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) call_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn call_query(&self) -> &'static str {\n        \"(call_expression function: (identifier) @callee) @call\"\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 29
    },
    {
      "name": "(C) build_cfg",
      "qualified_name": "src/lang/c.rs::(C) build_cfg",
      "file": "src/lang/c.rs",
      "line": 1801,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo> {\n        if node.kind() != \"function_definition\" {\n            return Err(TldrError::UnsupportedLanguage(\n                \"Node is not a function definition\".to_string(),\n            ));\n        }\n\n        let func_name = self\n            .child_by_field(node, \"declarator\")\n            .and_then(|d| self.extract_function_name(d, source))\n            .unwrap_or_else(|| \"anonymous\".to_string());\n\n        Ok(self.build_c_cfg(node, source, &func_name))\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 122
    },
    {
      "name": "(C) build_dfg",
      "qualified_name": "src/lang/c.rs::(C) build_dfg",
      "file": "src/lang/c.rs",
      "line": 1816,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo> {\n        if node.kind() != \"function_definition\" {\n            return Err(TldrError::UnsupportedLanguage(\n                \"Node is not a function definition\".to_string(),\n            ));\n        }\n\n        let func_name = self\n            .child_by_field(node, \"declarator\")\n            .and_then(|d| self.extract_function_name(d, source))\n            .unwrap_or_else(|| \"anonymous\".to_string());\n\n        Ok(self.build_c_dfg(node, source, &func_name))\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 125
    },
    {
      "name": "(C) extract_include",
      "qualified_name": "src/lang/c.rs::(C) extract_include",
      "file": "src/lang/c.rs",
      "line": 1834,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (C) extract_include(&self, node: Node, source: &[u8]) -> Option<ImportInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_include(&self, node: Node, source: &[u8]) -> Option<ImportInfo> {\n        let mut path = String::new();\n        let mut is_system = false;\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"system_lib_string\" => {\n                    // #include <stdio.h>\n                    path = self.node_text(child, source);\n                    // Remove < and >\n                    path = path\n                        .trim_start_matches('<')\n                        .trim_end_matches('>')\n                        .to_string();\n                    is_system = true;\n                }\n                \"string_literal\" => {\n                    // #include \"myheader.h\"\n                    path = self.node_text(child, source);\n                    // Remove quotes\n                    path = path.trim_matches('\"').to_string();\n                    is_system = false;\n                }\n                _ => {}\n            }\n        }\n\n        if path.is_empty() {\n            return None;\n        }\n\n        let mut aliases = HashMap::new();\n        if is_system {\n            aliases.insert(path.clone(), \"system\".to_string());\n        } else {\n            aliases.insert(path.clone(), \"local\".to_string());\n        }\n\n        Some(ImportInfo {\n            module: path,\n            names: Vec::new(),\n            aliases,\n            is_from: false, // C doesn't have \"from X import Y\"\n            level: 0,       // C doesn't have relative imports\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 6,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 302
    },
    {
      "name": "parse_c",
      "qualified_name": "src/lang/c.rs::parse_c",
      "file": "src/lang/c.rs",
      "line": 1887,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn parse_c(source: &str) -> (Tree, Vec<u8>)",
      "docstring": "",
      "calls": [
        "parser"
      ],
      "called_by": [
        "test_extract_includes",
        "test_build_dfg",
        "test_extract_typedef",
        "test_extract_function_declaration",
        "test_extract_struct"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:8, def-use chains:6",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parse_c(source: &str) -> (Tree, Vec<u8>) {\n        let c = C;\n        let mut parser = c.parser().unwrap();\n        let source_bytes = source.as_bytes().to_vec();\n        let tree = parser.parse(&source_bytes, None).unwrap();\n        (tree, source_bytes)\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 69
    },
    {
      "name": "test_extract_simple_function",
      "qualified_name": "src/lang/c.rs::test_extract_simple_function",
      "file": "src/lang/c.rs",
      "line": 1896,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_simple_function()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_python",
        "child_by_kind",
        "extract_function",
        "extract_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:25, def-use chains:8",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_simple_function() {\n        let source = r#\"\n/* Adds two integers */\nint add(int a, int b) {\n    return a + b;\n}\n\"#;\n\n        let (tree, source_bytes) = parse_c(source);\n        let c = C;\n        let root = tree.root_node();\n\n        let mut found = false;\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"function_definition\" {\n                let func = c.extract_function(child, &source_bytes);\n                assert!(func.is_some());\n                let func = func.unwrap();\n                assert_eq!(func.name, \"add\");\n                assert_eq!(func.params.len(), 2);\n                assert!(func.params[0].contains(\"int\"));\n                assert!(func.params[0].contains(\"a\"));\n                assert_eq!(func.return_type, Some(\"int\".to_string()));\n                assert!(func.docstring.is_some());\n                assert!(func.docstring.unwrap().contains(\"Adds two integers\"));\n                assert_eq!(func.language, \"c\");\n                found = true;\n            }\n        }\n        assert!(found, \"Function definition not found\");\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "iteration",
        "test"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 244
    },
    {
      "name": "test_extract_static_function",
      "qualified_name": "src/lang/c.rs::test_extract_static_function",
      "file": "src/lang/c.rs",
      "line": 1930,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_static_function()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_c"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:17, def-use chains:7",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_static_function() {\n        let source = r#\"\nstatic int helper(void) {\n    return 42;\n}\n\"#;\n\n        let (tree, source_bytes) = parse_c(source);\n        let c = C;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"function_definition\" {\n                let func = c.extract_function(child, &source_bytes).unwrap();\n                assert_eq!(func.name, \"helper\");\n                assert!(func.decorators.contains(&\"static\".to_string()));\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 131
    },
    {
      "name": "test_extract_pointer_return",
      "qualified_name": "src/lang/c.rs::test_extract_pointer_return",
      "file": "src/lang/c.rs",
      "line": 1952,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_pointer_return()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_c"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:16, def-use chains:7",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_pointer_return() {\n        let source = r#\"\nint* create_array(size_t len) {\n    return malloc(len * sizeof(int));\n}\n\"#;\n\n        let (tree, source_bytes) = parse_c(source);\n        let c = C;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"function_definition\" {\n                let func = c.extract_function(child, &source_bytes).unwrap();\n                assert_eq!(func.name, \"create_array\");\n                assert_eq!(func.return_type, Some(\"int*\".to_string()));\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 140
    },
    {
      "name": "test_extract_struct",
      "qualified_name": "src/lang/c.rs::test_extract_struct",
      "file": "src/lang/c.rs",
      "line": 1974,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_struct()",
      "docstring": "",
      "calls": [
        "extract_class",
        "parse_go",
        "extract_class",
        "parse_c",
        "extract_class"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:17, def-use chains:12",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_struct() {\n        let source = r#\"\n/* Person structure */\nstruct Person {\n    char* name;\n    int age;\n};\n\"#;\n\n        let (tree, source_bytes) = parse_c(source);\n        let c = C;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"struct_specifier\" {\n                let cls = c.extract_class(child, &source_bytes);\n                assert!(cls.is_some());\n                let cls = cls.unwrap();\n                assert_eq!(cls.name, \"Person\");\n                assert_eq!(cls.language, \"c\");\n                assert!(cls.docstring.is_some());\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 153
    },
    {
      "name": "test_extract_typedef",
      "qualified_name": "src/lang/c.rs::test_extract_typedef",
      "file": "src/lang/c.rs",
      "line": 2001,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_typedef()",
      "docstring": "",
      "calls": [
        "parse_c",
        "extract_class"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:18, def-use chains:11",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_typedef() {\n        let source = r#\"\ntypedef struct Node {\n    int value;\n    struct Node* next;\n} Node;\n\"#;\n\n        let (tree, source_bytes) = parse_c(source);\n        let c = C;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"type_definition\" {\n                let cls = c.extract_class(child, &source_bytes);\n                assert!(cls.is_some());\n                let cls = cls.unwrap();\n                assert_eq!(cls.name, \"Node\");\n                assert!(cls.decorators.contains(&\"typedef\".to_string()));\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 147
    },
    {
      "name": "test_extract_includes",
      "qualified_name": "src/lang/c.rs::test_extract_includes",
      "file": "src/lang/c.rs",
      "line": 2026,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_includes()",
      "docstring": "",
      "calls": [
        "parse_c",
        "extract_imports"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:18, def-use chains:11",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_includes() {\n        let source = r#\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"myheader.h\"\n\"#;\n\n        let (tree, source_bytes) = parse_c(source);\n        let c = C;\n        let imports = c.extract_imports(&tree, &source_bytes);\n\n        assert_eq!(imports.len(), 3);\n\n        // System includes\n        let stdio = imports.iter().find(|i| i.module == \"stdio.h\").unwrap();\n        assert_eq!(stdio.aliases.get(\"stdio.h\"), Some(&\"system\".to_string()));\n\n        let stdlib = imports.iter().find(|i| i.module == \"stdlib.h\").unwrap();\n        assert_eq!(stdlib.aliases.get(\"stdlib.h\"), Some(&\"system\".to_string()));\n\n        // Local include\n        let myheader = imports.iter().find(|i| i.module == \"myheader.h\").unwrap();\n        assert_eq!(\n            myheader.aliases.get(\"myheader.h\"),\n            Some(&\"local\".to_string())\n        );\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 219
    },
    {
      "name": "test_extract_function_declaration",
      "qualified_name": "src/lang/c.rs::test_extract_function_declaration",
      "file": "src/lang/c.rs",
      "line": 2055,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_function_declaration()",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_c",
        "parse_ts",
        "extract_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:4, blocks:8",
      "dfg_summary": "vars:20, def-use chains:7",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_function_declaration() {\n        let source = r#\"\nint process(const char* data, size_t len);\n\"#;\n\n        let (tree, source_bytes) = parse_c(source);\n        let c = C;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"declaration\" {\n                let func = c.extract_function(child, &source_bytes);\n                if let Some(func) = func {\n                    assert_eq!(func.name, \"process\");\n                    assert!(func.decorators.contains(&\"declaration\".to_string()));\n                    assert_eq!(func.params.len(), 2);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 148
    },
    {
      "name": "test_function_signature",
      "qualified_name": "src/lang/c.rs::test_function_signature",
      "file": "src/lang/c.rs",
      "line": 2078,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_function_signature()",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:9, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_function_signature() {\n        let func = FunctionInfo {\n            name: \"process\".to_string(),\n            params: vec![\"const char* data\".to_string(), \"size_t len\".to_string()],\n            return_type: Some(\"int*\".to_string()),\n            docstring: None,\n            is_method: false,\n            is_async: false,\n            decorators: Vec::new(),\n            line_number: 1,\n            end_line_number: Some(5),\n            language: \"c\".to_string(),\n        };\n\n        assert_eq!(\n            func.signature(),\n            \"int* process(const char* data, size_t len)\"\n        );\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 135
    },
    {
      "name": "test_extract_enum",
      "qualified_name": "src/lang/c.rs::test_extract_enum",
      "file": "src/lang/c.rs",
      "line": 2099,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_enum()",
      "docstring": "",
      "calls": [
        "extract_class",
        "extract_class",
        "parse_java",
        "parse_c"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:18, def-use chains:11",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_enum() {\n        let source = r#\"\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n};\n\"#;\n\n        let (tree, source_bytes) = parse_c(source);\n        let c = C;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"enum_specifier\" {\n                let cls = c.extract_class(child, &source_bytes);\n                assert!(cls.is_some());\n                let cls = cls.unwrap();\n                assert_eq!(cls.name, \"Color\");\n                assert!(cls.decorators.contains(&\"enum\".to_string()));\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 143
    },
    {
      "name": "test_build_cfg",
      "qualified_name": "src/lang/c.rs::test_build_cfg",
      "file": "src/lang/c.rs",
      "line": 2125,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_cfg()",
      "docstring": "",
      "calls": [
        "build_cfg",
        "build_cfg",
        "parse_python",
        "child_by_kind",
        "parse_c"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:18, def-use chains:12",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_build_cfg() {\n        let source = r#\"\nint factorial(int n) {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\"#;\n\n        let (tree, source_bytes) = parse_c(source);\n        let c = C;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"function_definition\" {\n                let cfg = c.build_cfg(child, &source_bytes);\n                assert!(cfg.is_ok());\n                let cfg = cfg.unwrap();\n                assert_eq!(cfg.function_name, \"factorial\");\n                assert!(!cfg.blocks.is_empty());\n                assert!(!cfg.edges.is_empty());\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 169
    },
    {
      "name": "test_build_dfg",
      "qualified_name": "src/lang/c.rs::test_build_dfg",
      "file": "src/lang/c.rs",
      "line": 2153,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_dfg()",
      "docstring": "",
      "calls": [
        "parse_c",
        "build_dfg",
        "parse_java",
        "build_dfg",
        "build_dfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:17, def-use chains:13",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_build_dfg() {\n        let source = r#\"\nint sum(int a, int b) {\n    int result = a + b;\n    return result;\n}\n\"#;\n\n        let (tree, source_bytes) = parse_c(source);\n        let c = C;\n        let root = tree.root_node();\n\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            if child.kind() == \"function_definition\" {\n                let dfg = c.build_dfg(child, &source_bytes);\n                assert!(dfg.is_ok());\n                let dfg = dfg.unwrap();\n                assert_eq!(dfg.function_name, \"sum\");\n                // Should have definitions for a, b, result\n                assert!(dfg.definitions.contains_key(\"a\"));\n                assert!(dfg.definitions.contains_key(\"b\"));\n                assert!(dfg.definitions.contains_key(\"result\"));\n            }\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 194
    },
    {
      "name": "C",
      "qualified_name": "src/lang/c.rs::C",
      "file": "src/lang/c.rs",
      "line": 27,
      "language": "rust",
      "unit_type": "class",
      "signature": "class C",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "pub struct C;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 0,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 4
    },
    {
      "name": "(Python) node_text",
      "qualified_name": "src/lang/python.rs::(Python) node_text",
      "file": "src/lang/python.rs",
      "line": 21,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) node_text(node: Node<'a>, source: &'a [u8]) -> &'a str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn node_text<'a>(node: Node<'a>, source: &'a [u8]) -> &'a str {\n        std::str::from_utf8(&source[node.start_byte()..node.end_byte()]).unwrap_or(\"\")\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 51
    },
    {
      "name": "(Python) child_by_kind",
      "qualified_name": "src/lang/python.rs::(Python) child_by_kind",
      "file": "src/lang/python.rs",
      "line": 26,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) child_by_kind(node: Node<'a>, kind: &str) -> Option<Node<'a>>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn child_by_kind<'a>(node: Node<'a>, kind: &str) -> Option<Node<'a>> {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == kind {\n                return Some(child);\n            }\n        }\n        None\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 4,
        "branches": 1,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 67
    },
    {
      "name": "(Python) extract_type",
      "qualified_name": "src/lang/python.rs::(Python) extract_type",
      "file": "src/lang/python.rs",
      "line": 37,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_type(node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_type(node: Node, source: &[u8]) -> String {\n        // Handle complex type expressions (generics, unions, etc.)\n        Self::node_text(node, source).to_string()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 45
    },
    {
      "name": "(Python) extract_decorators",
      "qualified_name": "src/lang/python.rs::(Python) extract_decorators",
      "file": "src/lang/python.rs",
      "line": 43,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_decorators(node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_decorators(node: Node, source: &[u8]) -> Vec<String> {\n        let mut decorators = Vec::new();\n\n        // If this is a decorated_definition, extract decorators from it\n        if node.kind() == \"decorated_definition\" {\n            let mut cursor = node.walk();\n            for child in node.children(&mut cursor) {\n                if child.kind() == \"decorator\" {\n                    // Skip the @ symbol and get the rest\n                    let dec_text = Self::node_text(child, source);\n                    let dec_name = dec_text.trim_start_matches('@').trim();\n                    decorators.push(dec_name.to_string());\n                }\n            }\n        }\n\n        decorators\n    }\n",
      "semantic_tags": [
        "crud",
        "test",
        "api_endpoint",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 142
    },
    {
      "name": "(Python) extract_parameters",
      "qualified_name": "src/lang/python.rs::(Python) extract_parameters",
      "file": "src/lang/python.rs",
      "line": 63,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_parameters(params_node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_parameters(params_node: Node, source: &[u8]) -> Vec<String> {\n        let mut params = Vec::new();\n        let mut cursor = params_node.walk();\n\n        for child in params_node.children(&mut cursor) {\n            match child.kind() {\n                \"identifier\" => {\n                    // Simple parameter without type annotation\n                    params.push(Self::node_text(child, source).to_string());\n                }\n                \"typed_parameter\" => {\n                    // Parameter with type annotation: name: type\n                    let name = Self::child_by_kind(child, \"identifier\")\n                        .map(|n| Self::node_text(n, source))\n                        .unwrap_or(\"\");\n                    let type_ann = Self::child_by_kind(child, \"type\")\n                        .map(|n| Self::extract_type(n, source))\n                        .unwrap_or_default();\n\n                    if type_ann.is_empty() {\n                        params.push(name.to_string());\n                    } else {\n                        params.push(format!(\"{}: {}\", name, type_ann));\n                    }\n                }\n                \"default_parameter\" => {\n                    // Parameter with default: name = value\n                    let name = Self::child_by_kind(child, \"identifier\")\n                        .map(|n| Self::node_text(n, source))\n                        .unwrap_or(\"\");\n                    // We just record the name, not the default value for signature\n                    params.push(format!(\"{} = ...\", name));\n                }\n                \"typed_default_parameter\" => {\n                    // Parameter with type and default: name: type = value\n                    let name = Self::child_by_kind(child, \"identifier\")\n                        .map(|n| Self::node_text(n, source))\n                        .unwrap_or(\"\");\n                    let type_ann = Self::child_by_kind(child, \"type\")\n                        .map(|n| Self::extract_type(n, source))\n                        .unwrap_or_default();\n\n                    if type_ann.is_empty() {\n                        params.push(format!(\"{} = ...\", name));\n                    } else {\n                        params.push(format!(\"{}: {} = ...\", name, type_ann));\n                    }\n                }\n                \"list_splat_pattern\" | \"dictionary_splat_pattern\" => {\n                    // *args or **kwargs in pattern form\n                    let text = Self::node_text(child, source);\n                    params.push(text.to_string());\n                }\n                \"*\" => {\n                    // Separator for keyword-only params\n                    params.push(\"*\".to_string());\n                }\n                \"/\" => {\n                    // Separator for positional-only params\n                    params.push(\"/\".to_string());\n                }\n                _ => {}\n            }\n        }\n\n        params\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 6,
        "branches": 5,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 524
    },
    {
      "name": "(Python) extract_docstring",
      "qualified_name": "src/lang/python.rs::(Python) extract_docstring",
      "file": "src/lang/python.rs",
      "line": 132,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_docstring(block_node: Node, source: &[u8]) -> Option<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_docstring(block_node: Node, source: &[u8]) -> Option<String> {\n        // Docstring is the first expression_statement containing a string\n        let mut cursor = block_node.walk();\n        for child in block_node.children(&mut cursor) {\n            if child.kind() == \"expression_statement\" {\n                // Check if this expression is a string (docstring)\n                let mut inner_cursor = child.walk();\n                for inner in child.children(&mut inner_cursor) {\n                    if inner.kind() == \"string\" {\n                        let text = Self::node_text(inner, source);\n                        // Strip quotes (\"\"\" or \" or ')\n                        let content = text\n                            .trim_start_matches(\"\\\"\\\"\\\"\")\n                            .trim_start_matches(\"'''\")\n                            .trim_start_matches('\"')\n                            .trim_start_matches('\\'')\n                            .trim_end_matches(\"\\\"\\\"\\\"\")\n                            .trim_end_matches(\"'''\")\n                            .trim_end_matches('\"')\n                            .trim_end_matches('\\'')\n                            .trim();\n                        return Some(content.to_string());\n                    }\n                }\n            }\n            // Docstring must be first statement\n            break;\n        }\n        None\n    }\n",
      "semantic_tags": [
        "validation",
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 7,
        "branches": 3,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 238
    },
    {
      "name": "(Python) is_async_function",
      "qualified_name": "src/lang/python.rs::(Python) is_async_function",
      "file": "src/lang/python.rs",
      "line": 164,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) is_async_function(node: Node) -> bool",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn is_async_function(node: Node) -> bool {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"async\" {\n                return true;\n            }\n            // Stop checking after we've passed the beginning\n            if child.kind() == \"def\" {\n                break;\n            }\n        }\n        false\n    }\n",
      "semantic_tags": [
        "async_ops",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 80
    },
    {
      "name": "(Python) extract_bases",
      "qualified_name": "src/lang/python.rs::(Python) extract_bases",
      "file": "src/lang/python.rs",
      "line": 179,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_bases(node: Node, source: &[u8]) -> Vec<String>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_bases(node: Node, source: &[u8]) -> Vec<String> {\n        let mut bases = Vec::new();\n\n        // Find argument_list (contains base classes)\n        if let Some(arg_list) = Self::child_by_kind(node, \"argument_list\") {\n            let mut cursor = arg_list.walk();\n            for child in arg_list.children(&mut cursor) {\n                match child.kind() {\n                    \"identifier\" | \"attribute\" => {\n                        bases.push(Self::node_text(child, source).to_string());\n                    }\n                    \"keyword_argument\" => {\n                        // metaclass=X or other keyword args in class definition\n                        bases.push(Self::node_text(child, source).to_string());\n                    }\n                    _ => {}\n                }\n            }\n        }\n\n        bases\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 162
    },
    {
      "name": "(Python) extract_methods",
      "qualified_name": "src/lang/python.rs::(Python) extract_methods",
      "file": "src/lang/python.rs",
      "line": 203,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_methods(block_node: Node, source: &[u8]) -> Vec<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_methods(block_node: Node, source: &[u8]) -> Vec<FunctionInfo> {\n        let mut methods = Vec::new();\n        let mut cursor = block_node.walk();\n\n        for child in block_node.children(&mut cursor) {\n            match child.kind() {\n                \"function_definition\" => {\n                    if let Some(mut func) = Self::extract_function_impl(child, source, true) {\n                        func.is_method = true;\n                        methods.push(func);\n                    }\n                }\n                \"decorated_definition\" => {\n                    // Look for function_definition inside\n                    let decorators = Self::extract_decorators(child, source);\n                    let mut inner_cursor = child.walk();\n                    for inner in child.children(&mut inner_cursor) {\n                        if inner.kind() == \"function_definition\" {\n                            if let Some(mut func) = Self::extract_function_impl(inner, source, true)\n                            {\n                                func.is_method = true;\n                                func.decorators = decorators.clone();\n                                methods.push(func);\n                            }\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        methods\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 8,
        "branches": 4,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 223
    },
    {
      "name": "(Python) extract_function_impl",
      "qualified_name": "src/lang/python.rs::(Python) extract_function_impl",
      "file": "src/lang/python.rs",
      "line": 238,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_function_impl(node: Node, source: &[u8], is_method: bool) -> Option<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_function_impl(node: Node, source: &[u8], is_method: bool) -> Option<FunctionInfo> {\n        if node.kind() != \"function_definition\" {\n            return None;\n        }\n\n        // Get function name\n        let name = Self::child_by_kind(node, \"identifier\")\n            .map(|n| Self::node_text(n, source).to_string())?;\n\n        // Get parameters\n        let params = Self::child_by_kind(node, \"parameters\")\n            .map(|n| Self::extract_parameters(n, source))\n            .unwrap_or_default();\n\n        // Get return type annotation\n        let return_type = Self::child_by_kind(node, \"type\").map(|n| Self::extract_type(n, source));\n\n        // Get docstring from block\n        let docstring = Self::child_by_kind(node, \"block\")\n            .and_then(|block| Self::extract_docstring(block, source));\n\n        // Check for async\n        let is_async = Self::is_async_function(node);\n\n        Some(FunctionInfo {\n            name,\n            params,\n            return_type,\n            docstring,\n            is_method,\n            is_async,\n            decorators: Vec::new(), // Will be filled by caller if in decorated_definition\n            line_number: node.start_position().row + 1,\n            end_line_number: Some(node.end_position().row + 1),\n            language: \"python\".to_string(),\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "api_endpoint",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 298
    },
    {
      "name": "(Python) extract_class_impl",
      "qualified_name": "src/lang/python.rs::(Python) extract_class_impl",
      "file": "src/lang/python.rs",
      "line": 277,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_class_impl(node: Node, source: &[u8]) -> Option<ClassInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_class_impl(node: Node, source: &[u8]) -> Option<ClassInfo> {\n        if node.kind() != \"class_definition\" {\n            return None;\n        }\n\n        // Get class name\n        let name = Self::child_by_kind(node, \"identifier\")\n            .map(|n| Self::node_text(n, source).to_string())?;\n\n        // Get base classes\n        let bases = Self::extract_bases(node, source);\n\n        // Get docstring and methods from block\n        let block = Self::child_by_kind(node, \"block\");\n        let docstring = block.and_then(|b| Self::extract_docstring(b, source));\n        let methods = block\n            .map(|b| Self::extract_methods(b, source))\n            .unwrap_or_default();\n\n        Some(ClassInfo {\n            name,\n            bases,\n            docstring,\n            methods,\n            decorators: Vec::new(), // Will be filled by caller if in decorated_definition\n            line_number: node.start_position().row + 1,\n            end_line_number: Some(node.end_position().row + 1),\n            language: \"python\".to_string(),\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration",
        "config",
        "transform"
      ],
      "complexity": {
        "depth": 3,
        "branches": 2,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 241
    },
    {
      "name": "(Python) extract_dotted_name",
      "qualified_name": "src/lang/python.rs::(Python) extract_dotted_name",
      "file": "src/lang/python.rs",
      "line": 309,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_dotted_name(node: Node, source: &[u8]) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_dotted_name(node: Node, source: &[u8]) -> String {\n        Self::node_text(node, source).to_string()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 33
    },
    {
      "name": "(Python) name",
      "qualified_name": "src/lang/python.rs::(Python) name",
      "file": "src/lang/python.rs",
      "line": 315,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) name(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn name(&self) -> &'static str {\n        \"python\"\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 17
    },
    {
      "name": "(Python) extensions",
      "qualified_name": "src/lang/python.rs::(Python) extensions",
      "file": "src/lang/python.rs",
      "line": 319,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extensions(&self) -> &[&'static str]",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extensions(&self) -> &[&'static str] {\n        &[\".py\", \".pyi\", \".pyx\"]\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 28
    },
    {
      "name": "(Python) parser",
      "qualified_name": "src/lang/python.rs::(Python) parser",
      "file": "src/lang/python.rs",
      "line": 323,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) parser(&self) -> Result<Parser>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parser(&self) -> Result<Parser> {\n        let mut parser = Parser::new();\n        parser\n            .set_language(&tree_sitter_python::LANGUAGE.into())\n            .map_err(|e| TldrError::TreeSitter(e.to_string()))?;\n        Ok(parser)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 62
    },
    {
      "name": "(Python) extract_function",
      "qualified_name": "src/lang/python.rs::(Python) extract_function",
      "file": "src/lang/python.rs",
      "line": 331,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_function(&self, node: Node, source: &[u8]) -> Option<FunctionInfo> {\n        match node.kind() {\n            \"function_definition\" => Self::extract_function_impl(node, source, false),\n            \"decorated_definition\" => {\n                // Extract decorators first\n                let decorators = Self::extract_decorators(node, source);\n\n                // Find the function_definition inside\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    if child.kind() == \"function_definition\" {\n                        if let Some(mut func) = Self::extract_function_impl(child, source, false) {\n                            func.decorators = decorators;\n                            return Some(func);\n                        }\n                    }\n                }\n                None\n            }\n            _ => None,\n        }\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 7,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 163
    },
    {
      "name": "(Python) extract_class",
      "qualified_name": "src/lang/python.rs::(Python) extract_class",
      "file": "src/lang/python.rs",
      "line": 354,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_class(&self, node: Node, source: &[u8]) -> Option<ClassInfo> {\n        match node.kind() {\n            \"class_definition\" => Self::extract_class_impl(node, source),\n            \"decorated_definition\" => {\n                // Extract decorators first\n                let decorators = Self::extract_decorators(node, source);\n\n                // Find the class_definition inside\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    if child.kind() == \"class_definition\" {\n                        if let Some(mut class) = Self::extract_class_impl(child, source) {\n                            class.decorators = decorators;\n                            return Some(class);\n                        }\n                    }\n                }\n                None\n            }\n            _ => None,\n        }\n    }\n",
      "semantic_tags": [
        "iteration",
        "config"
      ],
      "complexity": {
        "depth": 7,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 158
    },
    {
      "name": "(Python) extract_imports",
      "qualified_name": "src/lang/python.rs::(Python) extract_imports",
      "file": "src/lang/python.rs",
      "line": 377,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_imports(&self, tree: &Tree, source: &[u8]) -> Vec<ImportInfo> {\n        let mut imports = Vec::new();\n        let root = tree.root_node();\n\n        // Walk all top-level import statements\n        let mut cursor = root.walk();\n        for child in root.children(&mut cursor) {\n            match child.kind() {\n                \"import_statement\" => {\n                    // import foo, bar, baz or import foo.bar\n                    let mut inner_cursor = child.walk();\n                    for inner in child.children(&mut inner_cursor) {\n                        match inner.kind() {\n                            \"dotted_name\" => {\n                                let module = Self::extract_dotted_name(inner, source);\n                                imports.push(ImportInfo {\n                                    module,\n                                    names: Vec::new(),\n                                    aliases: HashMap::new(),\n                                    is_from: false,\n                                    level: 0,\n                                });\n                            }\n                            \"aliased_import\" => {\n                                // import foo as bar\n                                let mut alias_cursor = inner.walk();\n                                let mut module = String::new();\n                                let mut alias_name = String::new();\n\n                                for alias_child in inner.children(&mut alias_cursor) {\n                                    match alias_child.kind() {\n                                        \"dotted_name\" => {\n                                            module = Self::extract_dotted_name(alias_child, source);\n                                        }\n                                        \"identifier\" => {\n                                            // This is the alias (comes after \"as\")\n                                            alias_name =\n                                                Self::node_text(alias_child, source).to_string();\n                                        }\n                                        _ => {}\n                                    }\n                                }\n\n                                let mut aliases = HashMap::new();\n                                if !alias_name.is_empty() {\n                                    aliases.insert(module.clone(), alias_name);\n                                }\n\n                                imports.push(ImportInfo {\n                                    module,\n                                    names: Vec::new(),\n                                    aliases,\n                                    is_from: false,\n                                    level: 0,\n                                });\n                            }\n                            _ => {}\n                        }\n                    }\n                }\n                \"import_from_statement\" => {\n                    // from foo import bar, baz\n                    // from . import foo\n                    // from ..foo import bar\n                    let mut module = String::new();\n                    let mut names = Vec::new();\n                    let mut aliases = HashMap::new();\n                    let mut level = 0usize;\n\n                    let mut inner_cursor = child.walk();\n                    let mut after_import = false;\n\n                    for inner in child.children(&mut inner_cursor) {\n                        match inner.kind() {\n                            \"import\" => {\n                                after_import = true;\n                            }\n                            \"relative_import\" => {\n                                // Handle relative imports: from . import X or from ..parent import X\n                                let mut rel_cursor = inner.walk();\n                                for rel_child in inner.children(&mut rel_cursor) {\n                                    match rel_child.kind() {\n                                        \"import_prefix\" => {\n                                            // Count dots in import_prefix\n                                            let mut prefix_cursor = rel_child.walk();\n                                            for prefix_child in\n                                                rel_child.children(&mut prefix_cursor)\n                                            {\n                                                if prefix_child.kind() == \".\" {\n                                                    level += 1;\n                                                }\n                                            }\n                                        }\n                                        \"dotted_name\" => {\n                                            // Module name after dots (e.g., \"parent\" in from ..parent)\n                                            module = Self::extract_dotted_name(rel_child, source);\n                                        }\n                                        _ => {}\n                                    }\n                                }\n                            }\n                            \"dotted_name\" => {\n                                if !after_import {\n                                    // Regular module (non-relative import)\n                                    module = Self::extract_dotted_name(inner, source);\n                                } else {\n                                    // Imported name\n                                    let name = Self::extract_dotted_name(inner, source);\n                                    names.push(name);\n                                }\n                            }\n                            \"identifier\" => {\n                                if after_import {\n                                    names.push(Self::node_text(inner, source).to_string());\n                                }\n                            }\n                            \"aliased_import\" => {\n                                // from foo import bar as baz\n                                let mut import_name = String::new();\n                                let mut alias_name = String::new();\n\n                                let mut alias_cursor = inner.walk();\n                                for alias_child in inner.children(&mut alias_cursor) {\n                                    match alias_child.kind() {\n                                        \"dotted_name\" | \"identifier\" => {\n                                            if import_name.is_empty() {\n                                                import_name = Self::node_text(alias_child, source)\n                                                    .to_string();\n                                            } else {\n                                                alias_name = Self::node_text(alias_child, source)\n                                                    .to_string();\n                                            }\n                                        }\n                                        _ => {}\n                                    }\n                                }\n\n                                names.push(import_name.clone());\n                                if !alias_name.is_empty() {\n                                    aliases.insert(import_name, alias_name);\n                                }\n                            }\n                            \"wildcard_import\" => {\n                                // from foo import *\n                                names.push(\"*\".to_string());\n                            }\n                            _ => {}\n                        }\n                    }\n\n                    imports.push(ImportInfo {\n                        module,\n                        names,\n                        aliases,\n                        is_from: true,\n                        level,\n                    });\n                }\n                _ => {}\n            }\n        }\n\n        imports\n    }\n",
      "semantic_tags": [
        "crud",
        "database",
        "iteration"
      ],
      "complexity": {
        "depth": 13,
        "branches": 14,
        "loops": 7
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 1016
    },
    {
      "name": "(Python) function_query",
      "qualified_name": "src/lang/python.rs::(Python) function_query",
      "file": "src/lang/python.rs",
      "line": 542,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) function_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn function_query(&self) -> &'static str {\n        r#\"[\n            (function_definition name: (identifier) @name) @function\n            (decorated_definition\n                (function_definition name: (identifier) @name)) @function\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 58
    },
    {
      "name": "(Python) class_query",
      "qualified_name": "src/lang/python.rs::(Python) class_query",
      "file": "src/lang/python.rs",
      "line": 550,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) class_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn class_query(&self) -> &'static str {\n        r#\"[\n            (class_definition name: (identifier) @name) @class\n            (decorated_definition\n                (class_definition name: (identifier) @name)) @class\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 4,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 58
    },
    {
      "name": "(Python) call_query",
      "qualified_name": "src/lang/python.rs::(Python) call_query",
      "file": "src/lang/python.rs",
      "line": 558,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) call_query(&self) -> &'static str",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn call_query(&self) -> &'static str {\n        r#\"[\n            (call function: (identifier) @callee) @call\n            (call function: (attribute attribute: (identifier) @callee)) @call\n        ]\"#\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 54
    },
    {
      "name": "(Python) build_cfg",
      "qualified_name": "src/lang/python.rs::(Python) build_cfg",
      "file": "src/lang/python.rs",
      "line": 565,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_cfg(&self, node: Node, source: &[u8]) -> Result<CFGInfo> {\n        PythonCFGBuilder::build(node, source)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 36
    },
    {
      "name": "(Python) build_dfg",
      "qualified_name": "src/lang/python.rs::(Python) build_dfg",
      "file": "src/lang/python.rs",
      "line": 569,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (Python) build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build_dfg(&self, node: Node, source: &[u8]) -> Result<DFGInfo> {\n        PythonDFGBuilder::build(node, source)\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 39
    },
    {
      "name": "(PythonCFGBuilder<'a>) new",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) new",
      "file": "src/lang/python.rs",
      "line": 592,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) new(source: &'a [u8]) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn new(source: &'a [u8]) -> Self {\n        Self {\n            source,\n            blocks: HashMap::new(),\n            edges: Vec::new(),\n            next_block_id: 0,\n            exits: Vec::new(),\n            loop_headers: Vec::new(),\n            loop_exits: Vec::new(),\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 70
    },
    {
      "name": "(PythonCFGBuilder<'a>) build",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) build",
      "file": "src/lang/python.rs",
      "line": 604,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) build(node: Node, source: &[u8]) -> Result<CFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build(node: Node, source: &[u8]) -> Result<CFGInfo> {\n        if node.kind() != \"function_definition\" {\n            return Err(TldrError::Parse {\n                file: String::new(),\n                message: format!(\"Expected function_definition, got {}\", node.kind()),\n            });\n        }\n\n        let function_name = Python::child_by_kind(node, \"identifier\")\n            .map(|n| Python::node_text(n, source).to_string())\n            .unwrap_or_else(|| \"<unknown>\".to_string());\n\n        let mut builder = PythonCFGBuilder::new(source);\n\n        // Create entry block\n        let entry = builder.new_block(\"entry\".to_string(), node.start_position().row + 1);\n\n        // Find the block (function body)\n        let body_block = Python::child_by_kind(node, \"block\");\n\n        // Process function body\n        let current = if let Some(block) = body_block {\n            builder.process_block(block, entry)\n        } else {\n            entry\n        };\n\n        // Mark the final block as exit if not already\n        if !builder.exits.contains(&current) {\n            builder.exits.push(current);\n        }\n\n        Ok(CFGInfo {\n            function_name,\n            blocks: builder.blocks,\n            edges: builder.edges,\n            entry,\n            exits: builder.exits,\n        })\n    }\n",
      "semantic_tags": [
        "crud",
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 5,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 277
    },
    {
      "name": "(PythonCFGBuilder<'a>) new_block",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) new_block",
      "file": "src/lang/python.rs",
      "line": 645,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) new_block(&mut self, label: String, line: usize) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn new_block(&mut self, label: String, line: usize) -> BlockId {\n        let id = BlockId(self.next_block_id);\n        self.next_block_id += 1;\n\n        let block = CFGBlock {\n            id,\n            label,\n            statements: Vec::new(),\n            start_line: line,\n            end_line: line,\n        };\n\n        self.blocks.insert(id, block);\n        id\n    }\n",
      "semantic_tags": [
        "crud",
        "database"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 87
    },
    {
      "name": "(PythonCFGBuilder<'a>) add_edge",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) add_edge",
      "file": "src/lang/python.rs",
      "line": 661,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) add_edge(&mut self, from: BlockId, to: BlockId, label: Option<String>)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn add_edge(&mut self, from: BlockId, to: BlockId, label: Option<String>) {\n        self.edges.push(CFGEdge { from, to, label });\n    }\n",
      "semantic_tags": [
        "config"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 40
    },
    {
      "name": "(PythonCFGBuilder<'a>) node_text",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) node_text",
      "file": "src/lang/python.rs",
      "line": 665,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) node_text(&self, node: Node) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn node_text(&self, node: Node) -> String {\n        Python::node_text(node, self.source).to_string()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 29
    },
    {
      "name": "(PythonCFGBuilder<'a>) process_block",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) process_block",
      "file": "src/lang/python.rs",
      "line": 670,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) process_block(&mut self, block: Node, entry: BlockId) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_block(&mut self, block: Node, entry: BlockId) -> BlockId {\n        let mut current = entry;\n\n        let mut cursor = block.walk();\n        for stmt in block.children(&mut cursor) {\n            current = self.process_statement(stmt, current);\n        }\n\n        current\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 64
    },
    {
      "name": "(PythonCFGBuilder<'a>) process_statement",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) process_statement",
      "file": "src/lang/python.rs",
      "line": 682,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) process_statement(&mut self, stmt: Node, current: BlockId) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_statement(&mut self, stmt: Node, current: BlockId) -> BlockId {\n        match stmt.kind() {\n            \"if_statement\" => self.process_if(stmt, current),\n            \"for_statement\" => self.process_for(stmt, current),\n            \"while_statement\" => self.process_while(stmt, current),\n            \"try_statement\" => self.process_try(stmt, current),\n            \"with_statement\" => self.process_with(stmt, current),\n            \"match_statement\" => self.process_match(stmt, current),\n            \"return_statement\" => {\n                // Extract text before getting mutable reference\n                let stmt_text = self.node_text(stmt);\n                let end_line = stmt.end_position().row + 1;\n\n                if let Some(block) = self.blocks.get_mut(&current) {\n                    block.statements.push(stmt_text);\n                    block.end_line = end_line;\n                }\n                self.exits.push(current);\n                self.new_block(\"unreachable\".to_string(), end_line)\n            }\n            \"raise_statement\" => {\n                let stmt_text = self.node_text(stmt);\n                let end_line = stmt.end_position().row + 1;\n\n                if let Some(block) = self.blocks.get_mut(&current) {\n                    block.statements.push(stmt_text);\n                    block.end_line = end_line;\n                }\n                self.exits.push(current);\n                self.new_block(\"unreachable\".to_string(), end_line)\n            }\n            \"break_statement\" => {\n                if let Some(&exit_block) = self.loop_exits.last() {\n                    self.add_edge(current, exit_block, Some(\"break\".to_string()));\n                }\n                self.new_block(\"unreachable\".to_string(), stmt.end_position().row + 1)\n            }\n            \"continue_statement\" => {\n                if let Some(&header) = self.loop_headers.last() {\n                    self.add_edge(current, header, Some(\"continue\".to_string()));\n                }\n                self.new_block(\"unreachable\".to_string(), stmt.end_position().row + 1)\n            }\n            \"pass_statement\"\n            | \"expression_statement\"\n            | \"assignment\"\n            | \"augmented_assignment\"\n            | \"assert_statement\"\n            | \"import_statement\"\n            | \"import_from_statement\"\n            | \"global_statement\"\n            | \"nonlocal_statement\"\n            | \"delete_statement\" => {\n                let stmt_text = self.node_text(stmt);\n                let end_line = stmt.end_position().row + 1;\n\n                if let Some(block) = self.blocks.get_mut(&current) {\n                    block.statements.push(stmt_text);\n                    block.end_line = end_line;\n                }\n                current\n            }\n            \"function_definition\" | \"class_definition\" | \"decorated_definition\" => {\n                // Extract name before getting mutable reference\n                let name = Python::child_by_kind(stmt, \"identifier\")\n                    .map(|n| Python::node_text(n, self.source).to_string())\n                    .unwrap_or_else(|| \"<def>\".to_string());\n                let end_line = stmt.end_position().row + 1;\n\n                if let Some(block) = self.blocks.get_mut(&current) {\n                    block.statements.push(format!(\"def {}\", name));\n                    block.end_line = end_line;\n                }\n                current\n            }\n            _ => {\n                let stmt_text = self.node_text(stmt);\n                let end_line = stmt.end_position().row + 1;\n\n                if let Some(block) = self.blocks.get_mut(&current) {\n                    block.statements.push(stmt_text);\n                    block.end_line = end_line;\n                }\n                current\n            }\n        }\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 8,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 732
    },
    {
      "name": "(PythonCFGBuilder<'a>) process_if",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) process_if",
      "file": "src/lang/python.rs",
      "line": 770,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) process_if(&mut self, node: Node, current: BlockId) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_if(&mut self, node: Node, current: BlockId) -> BlockId {\n        // Get condition text before any mutable borrows\n        let condition = Python::child_by_kind(node, \"comparison_operator\")\n            .or_else(|| Python::child_by_kind(node, \"boolean_operator\"))\n            .or_else(|| Python::child_by_kind(node, \"identifier\"))\n            .or_else(|| Python::child_by_kind(node, \"not_operator\"))\n            .map(|n| Python::node_text(n, self.source).to_string())\n            .unwrap_or_else(|| \"condition\".to_string());\n\n        // Update current block as branch\n        if let Some(block) = self.blocks.get_mut(&current) {\n            block.label = format!(\"if {}\", condition);\n            block.end_line = node.start_position().row + 1;\n        }\n\n        // Create merge block for after the if\n        let merge = self.new_block(\"merge\".to_string(), node.end_position().row + 1);\n\n        // Process true branch (first block child)\n        let true_block = self.new_block(\"then\".to_string(), node.start_position().row + 2);\n        self.add_edge(current, true_block, Some(\"true\".to_string()));\n\n        let true_exit = if let Some(block) = Python::child_by_kind(node, \"block\") {\n            self.process_block(block, true_block)\n        } else {\n            true_block\n        };\n\n        if !self.exits.contains(&true_exit) {\n            self.add_edge(true_exit, merge, None);\n        }\n\n        // Process elif/else clauses\n        let mut cursor = node.walk();\n        let mut has_else = false;\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"elif_clause\" => {\n                    let elif_cond = Python::child_by_kind(child, \"comparison_operator\")\n                        .or_else(|| Python::child_by_kind(child, \"boolean_operator\"))\n                        .or_else(|| Python::child_by_kind(child, \"identifier\"))\n                        .map(|n| Python::node_text(n, self.source).to_string())\n                        .unwrap_or_else(|| \"condition\".to_string());\n\n                    let elif_block = self.new_block(\n                        format!(\"elif {}\", elif_cond),\n                        child.start_position().row + 1,\n                    );\n\n                    // Previous false branch goes to this elif\n                    self.add_edge(current, elif_block, Some(\"false\".to_string()));\n\n                    // Process elif body\n                    let elif_body =\n                        self.new_block(\"elif_body\".to_string(), child.start_position().row + 2);\n                    self.add_edge(elif_block, elif_body, Some(\"true\".to_string()));\n\n                    let elif_exit = if let Some(block) = Python::child_by_kind(child, \"block\") {\n                        self.process_block(block, elif_body)\n                    } else {\n                        elif_body\n                    };\n\n                    if !self.exits.contains(&elif_exit) {\n                        self.add_edge(elif_exit, merge, None);\n                    }\n                }\n                \"else_clause\" => {\n                    has_else = true;\n                    let else_block =\n                        self.new_block(\"else\".to_string(), child.start_position().row + 1);\n                    self.add_edge(current, else_block, Some(\"false\".to_string()));\n\n                    let else_exit = if let Some(block) = Python::child_by_kind(child, \"block\") {\n                        self.process_block(block, else_block)\n                    } else {\n                        else_block\n                    };\n\n                    if !self.exits.contains(&else_exit) {\n                        self.add_edge(else_exit, merge, None);\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        // If no else clause, false branch goes directly to merge\n        if !has_else {\n            self.add_edge(current, merge, Some(\"false\".to_string()));\n        }\n\n        merge\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "async_ops",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 6,
        "branches": 21,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 790
    },
    {
      "name": "(PythonCFGBuilder<'a>) process_for",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) process_for",
      "file": "src/lang/python.rs",
      "line": 866,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) process_for(&mut self, node: Node, current: BlockId) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_for(&mut self, node: Node, current: BlockId) -> BlockId {\n        // Create loop header\n        let header = self.new_block(\"for_loop\".to_string(), node.start_position().row + 1);\n        self.add_edge(current, header, None);\n\n        // Create after-loop block\n        let after_loop = self.new_block(\"after_for\".to_string(), node.end_position().row + 1);\n\n        // Track loop for break/continue\n        self.loop_headers.push(header);\n        self.loop_exits.push(after_loop);\n\n        // Create and process loop body\n        let body_block = self.new_block(\"for_body\".to_string(), node.start_position().row + 2);\n        self.add_edge(header, body_block, Some(\"iterate\".to_string()));\n\n        let body_exit = if let Some(block) = Python::child_by_kind(node, \"block\") {\n            self.process_block(block, body_block)\n        } else {\n            body_block\n        };\n\n        // Back edge from body end to header\n        if !self.exits.contains(&body_exit) {\n            self.add_edge(body_exit, header, Some(\"next\".to_string()));\n        }\n\n        // Pop loop tracking\n        self.loop_headers.pop();\n        self.loop_exits.pop();\n\n        // Handle else clause (executes when loop completes normally)\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"else_clause\" {\n                let else_block =\n                    self.new_block(\"for_else\".to_string(), child.start_position().row + 1);\n                self.add_edge(header, else_block, Some(\"exhausted\".to_string()));\n\n                let else_exit = if let Some(block) = Python::child_by_kind(child, \"block\") {\n                    self.process_block(block, else_block)\n                } else {\n                    else_block\n                };\n\n                if !self.exits.contains(&else_exit) {\n                    self.add_edge(else_exit, after_loop, None);\n                }\n\n                return after_loop;\n            }\n        }\n\n        // No else clause - header goes directly to after_loop when exhausted\n        self.add_edge(header, after_loop, Some(\"exhausted\".to_string()));\n        after_loop\n    }\n",
      "semantic_tags": [
        "crud",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 9,
        "loops": 8
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 466
    },
    {
      "name": "(PythonCFGBuilder<'a>) process_while",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) process_while",
      "file": "src/lang/python.rs",
      "line": 924,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) process_while(&mut self, node: Node, current: BlockId) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_while(&mut self, node: Node, current: BlockId) -> BlockId {\n        // Get condition text before any mutable borrows\n        let condition = Python::child_by_kind(node, \"comparison_operator\")\n            .or_else(|| Python::child_by_kind(node, \"boolean_operator\"))\n            .or_else(|| Python::child_by_kind(node, \"identifier\"))\n            .map(|n| Python::node_text(n, self.source).to_string())\n            .unwrap_or_else(|| \"condition\".to_string());\n\n        // Create loop header\n        let header = self.new_block(\n            format!(\"while {}\", condition),\n            node.start_position().row + 1,\n        );\n        self.add_edge(current, header, None);\n\n        // Create after-loop block\n        let after_loop = self.new_block(\"after_while\".to_string(), node.end_position().row + 1);\n\n        // Track loop for break/continue\n        self.loop_headers.push(header);\n        self.loop_exits.push(after_loop);\n\n        // Create and process loop body\n        let body_block = self.new_block(\"while_body\".to_string(), node.start_position().row + 2);\n        self.add_edge(header, body_block, Some(\"true\".to_string()));\n\n        let body_exit = if let Some(block) = Python::child_by_kind(node, \"block\") {\n            self.process_block(block, body_block)\n        } else {\n            body_block\n        };\n\n        // Back edge from body end to header\n        if !self.exits.contains(&body_exit) {\n            self.add_edge(body_exit, header, Some(\"next\".to_string()));\n        }\n\n        // Pop loop tracking\n        self.loop_headers.pop();\n        self.loop_exits.pop();\n\n        // Handle else clause\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"else_clause\" {\n                let else_block =\n                    self.new_block(\"while_else\".to_string(), child.start_position().row + 1);\n                self.add_edge(header, else_block, Some(\"false\".to_string()));\n\n                let else_exit = if let Some(block) = Python::child_by_kind(child, \"block\") {\n                    self.process_block(block, else_block)\n                } else {\n                    else_block\n                };\n\n                if !self.exits.contains(&else_exit) {\n                    self.add_edge(else_exit, after_loop, None);\n                }\n\n                return after_loop;\n            }\n        }\n\n        // No else clause - header goes directly to after_loop when false\n        self.add_edge(header, after_loop, Some(\"false\".to_string()));\n        after_loop\n    }\n",
      "semantic_tags": [
        "crud",
        "validation",
        "api_endpoint",
        "iteration",
        "transform"
      ],
      "complexity": {
        "depth": 5,
        "branches": 9,
        "loops": 8
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 546
    },
    {
      "name": "(PythonCFGBuilder<'a>) process_try",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) process_try",
      "file": "src/lang/python.rs",
      "line": 992,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) process_try(&mut self, node: Node, current: BlockId) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_try(&mut self, node: Node, current: BlockId) -> BlockId {\n        // Create try block\n        let try_block = self.new_block(\"try\".to_string(), node.start_position().row + 1);\n        self.add_edge(current, try_block, None);\n\n        // Create after-try block for merging\n        let after_try = self.new_block(\"after_try\".to_string(), node.end_position().row + 1);\n\n        // Process try body\n        let try_exit = if let Some(block) = Python::child_by_kind(node, \"block\") {\n            self.process_block(block, try_block)\n        } else {\n            try_block\n        };\n\n        let mut cursor = node.walk();\n        let mut has_finally = false;\n        let mut finally_block_id = None;\n\n        // First pass: find finally clause\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"finally_clause\" {\n                has_finally = true;\n                let finally_block =\n                    self.new_block(\"finally\".to_string(), child.start_position().row + 1);\n                finally_block_id = Some(finally_block);\n\n                // Process finally body\n                let finally_exit = if let Some(block) = Python::child_by_kind(child, \"block\") {\n                    self.process_block(block, finally_block)\n                } else {\n                    finally_block\n                };\n\n                if !self.exits.contains(&finally_exit) {\n                    self.add_edge(finally_exit, after_try, None);\n                }\n            }\n        }\n\n        // Reset cursor\n        cursor = node.walk();\n\n        // Second pass: process except and else clauses\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"except_clause\" => {\n                    let except_block =\n                        self.new_block(\"except\".to_string(), child.start_position().row + 1);\n\n                    // Try block can raise exception\n                    self.add_edge(try_block, except_block, Some(\"exception\".to_string()));\n\n                    let except_exit = if let Some(block) = Python::child_by_kind(child, \"block\") {\n                        self.process_block(block, except_block)\n                    } else {\n                        except_block\n                    };\n\n                    // Connect to finally or after_try\n                    if !self.exits.contains(&except_exit) {\n                        if let Some(finally_id) = finally_block_id {\n                            self.add_edge(except_exit, finally_id, None);\n                        } else {\n                            self.add_edge(except_exit, after_try, None);\n                        }\n                    }\n                }\n                \"else_clause\" => {\n                    let else_block =\n                        self.new_block(\"try_else\".to_string(), child.start_position().row + 1);\n\n                    // Try success goes to else\n                    if !self.exits.contains(&try_exit) {\n                        self.add_edge(try_exit, else_block, Some(\"no_exception\".to_string()));\n                    }\n\n                    let else_exit = if let Some(block) = Python::child_by_kind(child, \"block\") {\n                        self.process_block(block, else_block)\n                    } else {\n                        else_block\n                    };\n\n                    if !self.exits.contains(&else_exit) {\n                        if let Some(finally_id) = finally_block_id {\n                            self.add_edge(else_exit, finally_id, None);\n                        } else {\n                            self.add_edge(else_exit, after_try, None);\n                        }\n                    }\n\n                    // We've handled try_exit, return early if no finally\n                    if !has_finally && !self.exits.contains(&try_exit) {\n                        return after_try;\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        // If no else clause, try success goes to finally or after_try\n        if !self.exits.contains(&try_exit) {\n            if let Some(finally_id) = finally_block_id {\n                self.add_edge(try_exit, finally_id, None);\n            } else {\n                self.add_edge(try_exit, after_try, None);\n            }\n        }\n\n        after_try\n    }\n",
      "semantic_tags": [
        "crud",
        "iteration",
        "error_handling"
      ],
      "complexity": {
        "depth": 7,
        "branches": 26,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 827
    },
    {
      "name": "(PythonCFGBuilder<'a>) process_with",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) process_with",
      "file": "src/lang/python.rs",
      "line": 1104,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) process_with(&mut self, node: Node, current: BlockId) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_with(&mut self, node: Node, current: BlockId) -> BlockId {\n        // With statement has implicit try/finally semantics\n        let with_block = self.new_block(\"with\".to_string(), node.start_position().row + 1);\n        self.add_edge(current, with_block, None);\n\n        // Process body\n        let with_exit = if let Some(block) = Python::child_by_kind(node, \"block\") {\n            self.process_block(block, with_block)\n        } else {\n            with_block\n        };\n\n        // After with block\n        let after_with = self.new_block(\"after_with\".to_string(), node.end_position().row + 1);\n\n        if !self.exits.contains(&with_exit) {\n            self.add_edge(with_exit, after_with, None);\n        }\n\n        after_with\n    }\n",
      "semantic_tags": [
        "error_handling"
      ],
      "complexity": {
        "depth": 3,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 174
    },
    {
      "name": "(PythonCFGBuilder<'a>) process_match",
      "qualified_name": "src/lang/python.rs::(PythonCFGBuilder<'a>) process_match",
      "file": "src/lang/python.rs",
      "line": 1126,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonCFGBuilder<'a>) process_match(&mut self, node: Node, current: BlockId) -> BlockId",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_match(&mut self, node: Node, current: BlockId) -> BlockId {\n        // Create match branch block\n        let match_block = self.new_block(\"match\".to_string(), node.start_position().row + 1);\n        self.add_edge(current, match_block, None);\n\n        // Create after-match block for merging\n        let after_match = self.new_block(\"after_match\".to_string(), node.end_position().row + 1);\n\n        // Process each case\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"case_clause\" {\n                let case_block = self.new_block(\"case\".to_string(), child.start_position().row + 1);\n                self.add_edge(match_block, case_block, Some(\"case\".to_string()));\n\n                let case_exit = if let Some(block) = Python::child_by_kind(child, \"block\") {\n                    self.process_block(block, case_block)\n                } else {\n                    case_block\n                };\n\n                if !self.exits.contains(&case_exit) {\n                    self.add_edge(case_exit, after_match, None);\n                }\n            }\n        }\n\n        after_match\n    }\n",
      "semantic_tags": [
        "crud",
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 10,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 248
    },
    {
      "name": "(PythonDFGBuilder<'a>) new",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) new",
      "file": "src/lang/python.rs",
      "line": 1175,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) new(source: &'a [u8]) -> Self",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn new(source: &'a [u8]) -> Self {\n        Self {\n            source,\n            refs: Vec::new(),\n        }\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 31
    },
    {
      "name": "(PythonDFGBuilder<'a>) build",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) build",
      "file": "src/lang/python.rs",
      "line": 1182,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) build(node: Node, source: &[u8]) -> Result<DFGInfo>",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn build(node: Node, source: &[u8]) -> Result<DFGInfo> {\n        if node.kind() != \"function_definition\" {\n            return Err(TldrError::Parse {\n                file: String::new(),\n                message: format!(\"Expected function_definition, got {}\", node.kind()),\n            });\n        }\n\n        let function_name = Python::child_by_kind(node, \"identifier\")\n            .map(|n| Python::node_text(n, source).to_string())\n            .unwrap_or_else(|| \"<unknown>\".to_string());\n\n        let mut builder = PythonDFGBuilder::new(source);\n\n        // Extract parameters as definitions\n        if let Some(params) = Python::child_by_kind(node, \"parameters\") {\n            builder.extract_params(params);\n        }\n\n        // Process function body\n        if let Some(block) = Python::child_by_kind(node, \"block\") {\n            builder.process_block(block);\n        }\n\n        // Build def-use chains\n        let (edges, definitions, uses) = builder.compute_def_use_chains();\n\n        Ok(DFGInfo {\n            function_name,\n            edges,\n            definitions,\n            uses,\n        })\n    }\n",
      "semantic_tags": [
        "transform",
        "validation",
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 236
    },
    {
      "name": "(PythonDFGBuilder<'a>) node_text",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) node_text",
      "file": "src/lang/python.rs",
      "line": 1217,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) node_text(&self, node: Node) -> String",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn node_text(&self, node: Node) -> String {\n        Python::node_text(node, self.source).to_string()\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 29
    },
    {
      "name": "(PythonDFGBuilder<'a>) add_ref",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) add_ref",
      "file": "src/lang/python.rs",
      "line": 1221,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) add_ref(&mut self, name: String, line: usize, kind: DataflowKind)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn add_ref(&mut self, name: String, line: usize, kind: DataflowKind) {\n        // Skip special names\n        if name == \"_\" || name == \"__\" {\n            return;\n        }\n        self.refs.push(VarRef { name, line, kind });\n    }\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 3,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 61
    },
    {
      "name": "(PythonDFGBuilder<'a>) extract_params",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) extract_params",
      "file": "src/lang/python.rs",
      "line": 1229,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) extract_params(&mut self, params: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn extract_params(&mut self, params: Node) {\n        let mut cursor = params.walk();\n        for child in params.children(&mut cursor) {\n            match child.kind() {\n                \"identifier\" => {\n                    let name = self.node_text(child);\n                    self.add_ref(name, child.start_position().row + 1, DataflowKind::Param);\n                }\n                \"typed_parameter\" | \"default_parameter\" | \"typed_default_parameter\" => {\n                    if let Some(id) = Python::child_by_kind(child, \"identifier\") {\n                        let name = self.node_text(id);\n                        self.add_ref(name, id.start_position().row + 1, DataflowKind::Param);\n                    }\n                }\n                \"list_splat_pattern\" => {\n                    // *args\n                    if let Some(id) = Python::child_by_kind(child, \"identifier\") {\n                        let name = self.node_text(id);\n                        self.add_ref(name, id.start_position().row + 1, DataflowKind::Param);\n                    }\n                }\n                \"dictionary_splat_pattern\" => {\n                    // **kwargs\n                    if let Some(id) = Python::child_by_kind(child, \"identifier\") {\n                        let name = self.node_text(id);\n                        self.add_ref(name, id.start_position().row + 1, DataflowKind::Param);\n                    }\n                }\n                _ => {}\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 288
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_block",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_block",
      "file": "src/lang/python.rs",
      "line": 1262,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_block(&mut self, block: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_block(&mut self, block: Node) {\n        let mut cursor = block.walk();\n        for stmt in block.children(&mut cursor) {\n            self.process_statement(stmt);\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 42
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_statement",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_statement",
      "file": "src/lang/python.rs",
      "line": 1269,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_statement(&mut self, stmt: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_statement(&mut self, stmt: Node) {\n        match stmt.kind() {\n            \"expression_statement\" => {\n                let mut cursor = stmt.walk();\n                for child in stmt.children(&mut cursor) {\n                    match child.kind() {\n                        \"assignment\" => self.process_assignment(child),\n                        \"augmented_assignment\" => self.process_augmented_assignment(child),\n                        _ => self.process_expression(child),\n                    }\n                }\n            }\n            \"assignment\" => self.process_assignment(stmt),\n            \"augmented_assignment\" => self.process_augmented_assignment(stmt),\n            \"if_statement\" => self.process_if(stmt),\n            \"for_statement\" => self.process_for(stmt),\n            \"while_statement\" => self.process_while(stmt),\n            \"try_statement\" => self.process_try(stmt),\n            \"with_statement\" => self.process_with(stmt),\n            \"match_statement\" => self.process_match(stmt),\n            \"return_statement\" => {\n                // Process returned expression\n                let mut cursor = stmt.walk();\n                for child in stmt.children(&mut cursor) {\n                    if child.kind() != \"return\" {\n                        self.process_expression(child);\n\n                        // If it's a simple identifier, mark as Return\n                        if child.kind() == \"identifier\" {\n                            let name = self.node_text(child);\n                            self.add_ref(\n                                name,\n                                child.start_position().row + 1,\n                                DataflowKind::Return,\n                            );\n                        }\n                    }\n                }\n            }\n            \"function_definition\" | \"class_definition\" | \"decorated_definition\" => {\n                // Nested definitions - skip for now (they have their own scope)\n            }\n            _ => {}\n        }\n    }\n",
      "semantic_tags": [
        "test",
        "iteration"
      ],
      "complexity": {
        "depth": 8,
        "branches": 4,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 337
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_assignment",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_assignment",
      "file": "src/lang/python.rs",
      "line": 1315,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_assignment(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_assignment(&mut self, node: Node) {\n        // Process RHS first (uses)\n        let mut cursor = node.walk();\n        let mut saw_equals = false;\n\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"=\" {\n                saw_equals = true;\n                continue;\n            }\n            if saw_equals {\n                // RHS - extract uses\n                self.process_expression(child);\n            }\n        }\n\n        // Process LHS (definitions)\n        cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"=\" {\n                break;\n            }\n            self.process_target(child);\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 3,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 137
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_augmented_assignment",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_augmented_assignment",
      "file": "src/lang/python.rs",
      "line": 1341,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_augmented_assignment(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_augmented_assignment(&mut self, node: Node) {\n        // x += y means x is both used and mutated\n        let mut cursor = node.walk();\n        let mut target_node = None;\n\n        for child in node.children(&mut cursor) {\n            if child.kind() == \"identifier\" && target_node.is_none() {\n                target_node = Some(child);\n            } else if child.kind() != \"+=\" && child.kind() != \"-=\" && child.kind() != \"*=\" {\n                // Process RHS\n                self.process_expression(child);\n            }\n        }\n\n        if let Some(target) = target_node {\n            let name = self.node_text(target);\n            let line = target.start_position().row + 1;\n            self.add_ref(name.clone(), line, DataflowKind::Use);\n            self.add_ref(name, line, DataflowKind::Mutation);\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 4,
        "branches": 4,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 183
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_target",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_target",
      "file": "src/lang/python.rs",
      "line": 1363,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_target(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_target(&mut self, node: Node) {\n        match node.kind() {\n            \"identifier\" => {\n                let name = self.node_text(node);\n                self.add_ref(\n                    name,\n                    node.start_position().row + 1,\n                    DataflowKind::Definition,\n                );\n            }\n            \"tuple\" | \"list\" | \"pattern_list\" | \"tuple_pattern\" => {\n                // Unpacking\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    self.process_target(child);\n                }\n            }\n            \"subscript\" | \"attribute\" => {\n                // x[i] = ... or x.attr = ... - this mutates x\n                // Find the base identifier\n                if let Some(id) = Python::child_by_kind(node, \"identifier\") {\n                    let name = self.node_text(id);\n                    self.add_ref(name, id.start_position().row + 1, DataflowKind::Mutation);\n                }\n            }\n            \"starred_expression\" => {\n                // *x in unpacking\n                if let Some(id) = Python::child_by_kind(node, \"identifier\") {\n                    let name = self.node_text(id);\n                    self.add_ref(name, id.start_position().row + 1, DataflowKind::Definition);\n                }\n            }\n            _ => {}\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 5,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 281
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_expression",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_expression",
      "file": "src/lang/python.rs",
      "line": 1399,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_expression(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_expression(&mut self, node: Node) {\n        match node.kind() {\n            \"identifier\" => {\n                let name = self.node_text(node);\n                self.add_ref(name, node.start_position().row + 1, DataflowKind::Use);\n            }\n            \"binary_operator\"\n            | \"boolean_operator\"\n            | \"comparison_operator\"\n            | \"not_operator\"\n            | \"unary_operator\" => {\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    self.process_expression(child);\n                }\n            }\n            \"call\" => {\n                // Process function and arguments\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    self.process_expression(child);\n                }\n            }\n            \"attribute\" => {\n                // x.attr - x is used\n                if let Some(id) = Python::child_by_kind(node, \"identifier\") {\n                    let name = self.node_text(id);\n                    self.add_ref(name, id.start_position().row + 1, DataflowKind::Use);\n                }\n            }\n            \"subscript\" => {\n                // x[i] - x and i are used\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    self.process_expression(child);\n                }\n            }\n            \"list\" | \"tuple\" | \"set\" | \"dictionary\" | \"expression_list\" => {\n                // expression_list is used for return statements like \"return a, b\"\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    self.process_expression(child);\n                }\n            }\n            \"list_comprehension\"\n            | \"set_comprehension\"\n            | \"dictionary_comprehension\"\n            | \"generator_expression\" => {\n                self.process_comprehension(node);\n            }\n            \"conditional_expression\" => {\n                // a if b else c\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    self.process_expression(child);\n                }\n            }\n            \"lambda\" => {\n                // Lambda has its own scope - process params and body\n                // For simplicity, we'll just extract uses from the body\n                if let Some(body) = Python::child_by_kind(node, \"expression\") {\n                    self.process_expression(body);\n                }\n            }\n            \"parenthesized_expression\" => {\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    self.process_expression(child);\n                }\n            }\n            \"await\" => {\n                // await expr\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    if child.kind() != \"await\" {\n                        self.process_expression(child);\n                    }\n                }\n            }\n            \"keyword_argument\" | \"pair\" => {\n                // key=value or key: value\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    self.process_expression(child);\n                }\n            }\n            \"string\" | \"integer\" | \"float\" | \"true\" | \"false\" | \"none\" => {\n                // Literals - no variables\n            }\n            _ => {}\n        }\n    }\n",
      "semantic_tags": [
        "crud",
        "async_ops",
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 6,
        "loops": 9
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 671
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_comprehension",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_comprehension",
      "file": "src/lang/python.rs",
      "line": 1492,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_comprehension(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_comprehension(&mut self, node: Node) {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"for_in_clause\" => {\n                    // for x in iter\n                    let mut inner_cursor = child.walk();\n                    let mut after_in = false;\n\n                    for inner in child.children(&mut inner_cursor) {\n                        if inner.kind() == \"in\" {\n                            after_in = true;\n                            continue;\n                        }\n                        if after_in {\n                            self.process_expression(inner);\n                        } else if inner.kind() == \"identifier\" {\n                            // Loop variable - definition\n                            let name = self.node_text(inner);\n                            self.add_ref(\n                                name,\n                                inner.start_position().row + 1,\n                                DataflowKind::Definition,\n                            );\n                        }\n                    }\n                }\n                \"if_clause\" => {\n                    // if condition\n                    let mut inner_cursor = child.walk();\n                    for inner in child.children(&mut inner_cursor) {\n                        if inner.kind() != \"if\" {\n                            self.process_expression(inner);\n                        }\n                    }\n                }\n                _ => {\n                    // The element expression\n                    self.process_expression(child);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 8,
        "branches": 8,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 256
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_if",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_if",
      "file": "src/lang/python.rs",
      "line": 1536,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_if(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_if(&mut self, node: Node) {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"block\" => self.process_block(child),\n                \"elif_clause\" | \"else_clause\" => {\n                    // Process condition and block\n                    let mut inner_cursor = child.walk();\n                    for inner in child.children(&mut inner_cursor) {\n                        if inner.kind() == \"block\" {\n                            self.process_block(inner);\n                        } else if inner.kind() != \"elif\" && inner.kind() != \"else\" {\n                            self.process_expression(inner);\n                        }\n                    }\n                }\n                \"comparison_operator\" | \"boolean_operator\" | \"identifier\" | \"not_operator\" => {\n                    self.process_expression(child);\n                }\n                _ => {}\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 6,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 175
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_for",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_for",
      "file": "src/lang/python.rs",
      "line": 1560,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_for(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_for(&mut self, node: Node) {\n        let mut cursor = node.walk();\n        let mut after_in = false;\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"in\" => {\n                    after_in = true;\n                }\n                \"block\" => {\n                    self.process_block(child);\n                }\n                \"else_clause\" => {\n                    if let Some(block) = Python::child_by_kind(child, \"block\") {\n                        self.process_block(block);\n                    }\n                }\n                \"identifier\" if !after_in => {\n                    // Loop variable\n                    let name = self.node_text(child);\n                    self.add_ref(\n                        name,\n                        child.start_position().row + 1,\n                        DataflowKind::Definition,\n                    );\n                }\n                \"tuple\" | \"list\" | \"pattern_list\" if !after_in => {\n                    // Unpacking in for loop\n                    self.process_target(child);\n                }\n                _ if after_in && child.kind() != \":\" => {\n                    // Iterator expression\n                    self.process_expression(child);\n                }\n                _ => {}\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 5,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 233
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_while",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_while",
      "file": "src/lang/python.rs",
      "line": 1599,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_while(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_while(&mut self, node: Node) {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"block\" => self.process_block(child),\n                \"else_clause\" => {\n                    if let Some(block) = Python::child_by_kind(child, \"block\") {\n                        self.process_block(block);\n                    }\n                }\n                \"comparison_operator\" | \"boolean_operator\" | \"identifier\" | \"not_operator\" => {\n                    self.process_expression(child);\n                }\n                _ => {}\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 2,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 122
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_try",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_try",
      "file": "src/lang/python.rs",
      "line": 1617,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_try(&mut self, node: Node) -> as_pattern",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_try(&mut self, node: Node) {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"block\" => self.process_block(child),\n                \"except_clause\" => {\n                    // Exception variable binding: except ValueError as e\n                    // Structure: except_clause -> as_pattern -> as_pattern_target -> identifier\n                    if let Some(as_pattern) = Python::child_by_kind(child, \"as_pattern\") {\n                        if let Some(target) = Python::child_by_kind(as_pattern, \"as_pattern_target\")\n                        {\n                            if let Some(id) = Python::child_by_kind(target, \"identifier\") {\n                                let name = self.node_text(id);\n                                self.add_ref(\n                                    name,\n                                    id.start_position().row + 1,\n                                    DataflowKind::Definition,\n                                );\n                            }\n                        }\n                    }\n                    if let Some(block) = Python::child_by_kind(child, \"block\") {\n                        self.process_block(block);\n                    }\n                }\n                \"else_clause\" | \"finally_clause\" => {\n                    if let Some(block) = Python::child_by_kind(child, \"block\") {\n                        self.process_block(block);\n                    }\n                }\n                _ => {}\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration",
        "error_handling"
      ],
      "complexity": {
        "depth": 9,
        "branches": 6,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 262
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_with",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_with",
      "file": "src/lang/python.rs",
      "line": 1652,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_with(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_with(&mut self, node: Node) {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"with_clause\" => {\n                    // with_item nodes\n                    let mut inner_cursor = child.walk();\n                    for inner in child.children(&mut inner_cursor) {\n                        if inner.kind() == \"with_item\" {\n                            self.process_with_item(inner);\n                        }\n                    }\n                }\n                \"with_item\" => {\n                    self.process_with_item(child);\n                }\n                \"block\" => self.process_block(child),\n                _ => {}\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 7,
        "branches": 2,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 132
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_with_item",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_with_item",
      "file": "src/lang/python.rs",
      "line": 1674,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_with_item(&mut self, node: Node) -> as_pattern",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_with_item(&mut self, node: Node) {\n        // With item structure: with_item -> as_pattern -> [call, as, as_pattern_target -> identifier]\n        // Or without \"as\": with_item -> call\n        let mut cursor = node.walk();\n\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"as_pattern\" => {\n                    // Process context expression (first non-\"as\" child)\n                    let mut inner_cursor = child.walk();\n                    for inner in child.children(&mut inner_cursor) {\n                        match inner.kind() {\n                            \"as_pattern_target\" => {\n                                // Variable being bound\n                                if let Some(id) = Python::child_by_kind(inner, \"identifier\") {\n                                    let name = self.node_text(id);\n                                    self.add_ref(\n                                        name,\n                                        id.start_position().row + 1,\n                                        DataflowKind::Definition,\n                                    );\n                                } else {\n                                    // Could be a tuple pattern\n                                    self.process_target(inner);\n                                }\n                            }\n                            \"as\" => {}\n                            _ => {\n                                // Context expression (e.g., open(path))\n                                self.process_expression(inner);\n                            }\n                        }\n                    }\n                }\n                _ => {\n                    // No \"as\" binding, just context expression\n                    self.process_expression(child);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 10,
        "branches": 4,
        "loops": 2
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 276
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_match",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_match",
      "file": "src/lang/python.rs",
      "line": 1716,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_match(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_match(&mut self, node: Node) {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            match child.kind() {\n                \"case_clause\" => {\n                    // Process pattern (defines variables) and body\n                    let mut inner_cursor = child.walk();\n                    for inner in child.children(&mut inner_cursor) {\n                        match inner.kind() {\n                            \"case_pattern\" => self.process_pattern(inner),\n                            \"block\" => self.process_block(inner),\n                            \"guard\" => {\n                                // if condition in case\n                                let mut guard_cursor = inner.walk();\n                                for guard_child in inner.children(&mut guard_cursor) {\n                                    if guard_child.kind() != \"if\" {\n                                        self.process_expression(guard_child);\n                                    }\n                                }\n                            }\n                            _ => {}\n                        }\n                    }\n                }\n                _ => {\n                    // Subject expression\n                    self.process_expression(child);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 10,
        "branches": 6,
        "loops": 3
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 197
    },
    {
      "name": "(PythonDFGBuilder<'a>) process_pattern",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) process_pattern",
      "file": "src/lang/python.rs",
      "line": 1748,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) process_pattern(&mut self, node: Node)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn process_pattern(&mut self, node: Node) {\n        match node.kind() {\n            \"as_pattern\" => {\n                // pattern as name\n                if let Some(id) = Python::child_by_kind(node, \"identifier\") {\n                    let name = self.node_text(id);\n                    self.add_ref(name, id.start_position().row + 1, DataflowKind::Definition);\n                }\n            }\n            \"capture_pattern\" | \"identifier\" => {\n                let name = self.node_text(node);\n                if name != \"_\" {\n                    self.add_ref(\n                        name,\n                        node.start_position().row + 1,\n                        DataflowKind::Definition,\n                    );\n                }\n            }\n            _ => {\n                // Recurse into pattern\n                let mut cursor = node.walk();\n                for child in node.children(&mut cursor) {\n                    self.process_pattern(child);\n                }\n            }\n        }\n    }\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 6,
        "branches": 3,
        "loops": 1
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 185
    },
    {
      "name": "(PythonDFGBuilder<'a>) compute_def_use_chains",
      "qualified_name": "src/lang/python.rs::(PythonDFGBuilder<'a>) compute_def_use_chains",
      "file": "src/lang/python.rs",
      "line": 1778,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn (PythonDFGBuilder<'a>) compute_def_use_chains(&self) -> (\n        Vec<DataflowEdge>,\n        HashMap<String, Vec<usize>>,\n        HashMap<String, Vec<usize>>,\n    )",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn compute_def_use_chains(\n        &self,\n    ) -> (\n        Vec<DataflowEdge>,\n        HashMap<String, Vec<usize>>,\n        HashMap<String, Vec<usize>>,\n    ) {\n        let mut edges = Vec::new();\n        let mut definitions: HashMap<String, Vec<usize>> = HashMap::new();\n        let mut uses: HashMap<String, Vec<usize>> = HashMap::new();\n\n        // Active definitions: variable name -> (line where defined, kind)\n        let mut active_defs: HashMap<String, Vec<usize>> = HashMap::new();\n\n        // Sort refs by line for proper processing order\n        let mut sorted_refs: Vec<&VarRef> = self.refs.iter().collect();\n        sorted_refs.sort_by_key(|r| r.line);\n\n        for var_ref in sorted_refs {\n            match var_ref.kind {\n                DataflowKind::Param | DataflowKind::Definition => {\n                    // Record definition\n                    definitions\n                        .entry(var_ref.name.clone())\n                        .or_default()\n                        .push(var_ref.line);\n\n                    // New definition kills previous definitions\n                    active_defs.insert(var_ref.name.clone(), vec![var_ref.line]);\n                }\n                DataflowKind::Use | DataflowKind::Return => {\n                    // Record use\n                    uses.entry(var_ref.name.clone())\n                        .or_default()\n                        .push(var_ref.line);\n\n                    // Create edges from active definitions to this use\n                    if let Some(def_lines) = active_defs.get(&var_ref.name) {\n                        for &def_line in def_lines {\n                            edges.push(DataflowEdge {\n                                variable: var_ref.name.clone(),\n                                from_line: def_line,\n                                to_line: var_ref.line,\n                                kind: var_ref.kind,\n                            });\n                        }\n                    }\n                }\n                DataflowKind::Mutation => {\n                    // Mutation is both use and definition\n                    uses.entry(var_ref.name.clone())\n                        .or_default()\n                        .push(var_ref.line);\n                    definitions\n                        .entry(var_ref.name.clone())\n                        .or_default()\n                        .push(var_ref.line);\n\n                    // Create edges from active definitions\n                    if let Some(def_lines) = active_defs.get(&var_ref.name) {\n                        for &def_line in def_lines {\n                            edges.push(DataflowEdge {\n                                variable: var_ref.name.clone(),\n                                from_line: def_line,\n                                to_line: var_ref.line,\n                                kind: DataflowKind::Mutation,\n                            });\n                        }\n                    }\n\n                    // Update active definition\n                    active_defs.insert(var_ref.name.clone(), vec![var_ref.line]);\n                }\n            }\n        }\n\n        (edges, definitions, uses)\n    }\n",
      "semantic_tags": [
        "crud",
        "api_endpoint",
        "iteration",
        "transform",
        "database"
      ],
      "complexity": {
        "depth": 8,
        "branches": 3,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 531
    },
    {
      "name": "parse_python",
      "qualified_name": "src/lang/python.rs::parse_python",
      "file": "src/lang/python.rs",
      "line": 1862,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn parse_python(code: &str) -> Tree",
      "docstring": "",
      "calls": [
        "new"
      ],
      "called_by": [
        "test_extract_async_function",
        "test_extract_imports",
        "test_extract_simple_function",
        "test_build_dfg",
        "test_build_cfg"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:3",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn parse_python(code: &str) -> Tree {\n        let mut parser = Parser::new();\n        parser\n            .set_language(&tree_sitter_python::LANGUAGE.into())\n            .unwrap();\n        parser.parse(code, None).unwrap()\n    }\n",
      "semantic_tags": [
        "validation"
      ],
      "complexity": {
        "depth": 3,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 52
    },
    {
      "name": "test_extract_simple_function",
      "qualified_name": "src/lang/python.rs::test_extract_simple_function",
      "file": "src/lang/python.rs",
      "line": 1871,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_simple_function() -> str:\n    \"\"\"Say hello.\"\"\"\n    return f\"Hello,",
      "docstring": "",
      "calls": [
        "extract_function",
        "parse_python",
        "child_by_kind",
        "extract_function",
        "extract_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:23, def-use chains:6",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_simple_function() {\n        let code = r#\"\ndef hello(name: str) -> str:\n    \"\"\"Say hello.\"\"\"\n    return f\"Hello, {name}!\"\n\"#;\n        let tree = parse_python(code);\n        let python = Python;\n\n        // Find function_definition\n        let root = tree.root_node();\n        let func_node = Python::child_by_kind(root, \"function_definition\").unwrap();\n\n        let func = python.extract_function(func_node, code.as_bytes()).unwrap();\n        assert_eq!(func.name, \"hello\");\n        assert!(func.params.iter().any(|p| p.contains(\"name\")));\n        assert_eq!(func.return_type, Some(\"str\".to_string()));\n        assert_eq!(func.docstring, Some(\"Say hello.\".to_string()));\n        assert!(!func.is_async);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 170
    },
    {
      "name": "test_extract_async_function",
      "qualified_name": "src/lang/python.rs::test_extract_async_function",
      "file": "src/lang/python.rs",
      "line": 1893,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_async_function() -> bytes:\n    pass\n\"#;\n        let tree = parse_python(code);\n        let python = Python;\n\n        let root = tree.root_node();\n        let func_node = Python::child_by_kind(root, \"function_definition\").unwrap();\n\n        let func = python.extract_function(func_node, code.as_bytes()).unwrap();\n        assert_eq!(func.name, \"fetch\");\n        assert!(func.is_async);\n    }",
      "docstring": "",
      "calls": [
        "parse_python",
        "child_by_kind",
        "extract_function",
        "extract_function",
        "parse_rust"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:14, def-use chains:6",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_async_function() {\n        let code = r#\"\nasync def fetch(url: str) -> bytes:\n    pass\n\"#;\n        let tree = parse_python(code);\n        let python = Python;\n\n        let root = tree.root_node();\n        let func_node = Python::child_by_kind(root, \"function_definition\").unwrap();\n\n        let func = python.extract_function(func_node, code.as_bytes()).unwrap();\n        assert_eq!(func.name, \"fetch\");\n        assert!(func.is_async);\n    }\n",
      "semantic_tags": [
        "crud",
        "async_ops",
        "validation",
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 105
    },
    {
      "name": "test_extract_decorated_function",
      "qualified_name": "src/lang/python.rs::test_extract_decorated_function",
      "file": "src/lang/python.rs",
      "line": 1910,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_decorated_function() -> int:\n    return x\n\"#;\n        let tree = parse_python(code);\n        let python = Python;\n\n        let root = tree.root_node();\n        let decorated = Python::child_by_kind(root, \"decorated_definition\").unwrap();\n\n        let func = python.extract_function(decorated, code.as_bytes()).unwrap();\n        assert_eq!(func.name, \"my_method\");\n        assert_eq!(func.decorators.len(), 2);\n        assert!(func.decorators.iter().any(|d| d.contains(\"staticmethod\")));\n    }",
      "docstring": "",
      "calls": [
        "extract_from_file",
        "extract_from_file",
        "parse_python",
        "create_temp_file",
        "extract_function"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:19, def-use chains:6",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_decorated_function() {\n        let code = r#\"\n@staticmethod\n@other_decorator\ndef my_method(x: int) -> int:\n    return x\n\"#;\n        let tree = parse_python(code);\n        let python = Python;\n\n        let root = tree.root_node();\n        let decorated = Python::child_by_kind(root, \"decorated_definition\").unwrap();\n\n        let func = python.extract_function(decorated, code.as_bytes()).unwrap();\n        assert_eq!(func.name, \"my_method\");\n        assert_eq!(func.decorators.len(), 2);\n        assert!(func.decorators.iter().any(|d| d.contains(\"staticmethod\")));\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 136
    },
    {
      "name": "test_extract_class",
      "qualified_name": "src/lang/python.rs::test_extract_class",
      "file": "src/lang/python.rs",
      "line": 1930,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_class() -> str:\n        return str(x)\n\"#;\n        let tree = parse_python(code);\n        let python = Python;\n\n        let root = tree.root_node();\n        let class_node = Python::child_by_kind(root, \"class_definition\").unwrap();\n\n        let class = python.extract_class(class_node, code.as_bytes()).unwrap();\n        assert_eq!(class.name, \"MyClass\");\n        assert_eq!(class.bases, vec![\"Base1\", \"Base2\"]);\n        assert_eq!(class.docstring, Some(\"A test class.\".to_string()));\n        assert_eq!(class.methods.len(), 1);\n        assert_eq!(class.methods[0].name, \"method\");\n    }",
      "docstring": "",
      "calls": [
        "extract_class",
        "extract_class",
        "parse_java",
        "extract_class",
        "parse_ts"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:19, def-use chains:11",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_class() {\n        let code = r#\"\nclass MyClass(Base1, Base2):\n    \"\"\"A test class.\"\"\"\n\n    def method(self, x: int) -> str:\n        return str(x)\n\"#;\n        let tree = parse_python(code);\n        let python = Python;\n\n        let root = tree.root_node();\n        let class_node = Python::child_by_kind(root, \"class_definition\").unwrap();\n\n        let class = python.extract_class(class_node, code.as_bytes()).unwrap();\n        assert_eq!(class.name, \"MyClass\");\n        assert_eq!(class.bases, vec![\"Base1\", \"Base2\"]);\n        assert_eq!(class.docstring, Some(\"A test class.\".to_string()));\n        assert_eq!(class.methods.len(), 1);\n        assert_eq!(class.methods[0].name, \"method\");\n    }\n",
      "semantic_tags": [
        "test"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 176
    },
    {
      "name": "test_extract_imports",
      "qualified_name": "src/lang/python.rs::test_extract_imports",
      "file": "src/lang/python.rs",
      "line": 1953,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_extract_imports()",
      "docstring": "",
      "calls": [
        "extract_imports",
        "extract_imports",
        "extract_imports",
        "parse_java",
        "parse_python"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:18, def-use chains:18",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_extract_imports() {\n        let code = r#\"\nimport os\nimport sys as system\nfrom pathlib import Path\nfrom collections import defaultdict as dd\nfrom . import local_module\nfrom ..parent import something\n\"#;\n        let tree = parse_python(code);\n        let python = Python;\n\n        let imports = python.extract_imports(&tree, code.as_bytes());\n        assert_eq!(imports.len(), 6);\n\n        // import os\n        assert_eq!(imports[0].module, \"os\");\n        assert!(!imports[0].is_from);\n\n        // import sys as system\n        assert_eq!(imports[1].module, \"sys\");\n        assert!(imports[1].aliases.contains_key(\"sys\"));\n\n        // from pathlib import Path\n        assert_eq!(imports[2].module, \"pathlib\");\n        assert!(imports[2].is_from);\n        assert!(imports[2].names.contains(&\"Path\".to_string()));\n\n        // from collections import defaultdict as dd\n        assert_eq!(imports[3].module, \"collections\");\n        assert!(imports[3].aliases.contains_key(\"defaultdict\"));\n\n        // from . import local_module\n        assert!(imports[4].is_from);\n        assert_eq!(imports[4].level, 1);\n\n        // from ..parent import something\n        assert!(imports[5].is_from);\n        assert_eq!(imports[5].level, 2);\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 297
    },
    {
      "name": "test_build_cfg",
      "qualified_name": "src/lang/python.rs::test_build_cfg",
      "file": "src/lang/python.rs",
      "line": 1995,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_cfg()",
      "docstring": "",
      "calls": [
        "build_cfg",
        "build_cfg",
        "parse_python",
        "child_by_kind",
        "parse_c"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:16, def-use chains:9",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_build_cfg() {\n        let code = r#\"\ndef example(x):\n    if x > 0:\n        return True\n    return False\n\"#;\n        let tree = parse_python(code);\n        let python = Python;\n\n        let root = tree.root_node();\n        let func_node = Python::child_by_kind(root, \"function_definition\").unwrap();\n\n        let cfg = python.build_cfg(func_node, code.as_bytes()).unwrap();\n        assert_eq!(cfg.function_name, \"example\");\n        assert!(!cfg.blocks.is_empty());\n        assert!(!cfg.edges.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 1,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 122
    },
    {
      "name": "test_build_dfg",
      "qualified_name": "src/lang/python.rs::test_build_dfg",
      "file": "src/lang/python.rs",
      "line": 2015,
      "language": "rust",
      "unit_type": "function",
      "signature": "fn test_build_dfg()",
      "docstring": "",
      "calls": [
        "parse_c",
        "build_dfg",
        "parse_java",
        "build_dfg",
        "build_dfg"
      ],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:18, def-use chains:14",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "    fn test_build_dfg() {\n        let code = r#\"\ndef example(x, y):\n    z = x + y\n    return z\n\"#;\n        let tree = parse_python(code);\n        let python = Python;\n\n        let root = tree.root_node();\n        let func_node = Python::child_by_kind(root, \"function_definition\").unwrap();\n\n        let dfg = python.build_dfg(func_node, code.as_bytes()).unwrap();\n        assert_eq!(dfg.function_name, \"example\");\n\n        // Check definitions\n        assert!(dfg.definitions.contains_key(\"x\"));\n        assert!(dfg.definitions.contains_key(\"y\"));\n        assert!(dfg.definitions.contains_key(\"z\"));\n\n        // Check uses\n        assert!(dfg.uses.contains_key(\"x\"));\n        assert!(dfg.uses.contains_key(\"y\"));\n        assert!(dfg.uses.contains_key(\"z\"));\n\n        // Check edges exist\n        assert!(!dfg.edges.is_empty());\n    }\n",
      "semantic_tags": [
        "test",
        "validation"
      ],
      "complexity": {
        "depth": 2,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 204
    },
    {
      "name": "Python",
      "qualified_name": "src/lang/python.rs::Python",
      "file": "src/lang/python.rs",
      "line": 17,
      "language": "rust",
      "unit_type": "class",
      "signature": "class Python",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "pub struct Python;\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 0,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 4
    },
    {
      "name": "PythonCFGBuilder",
      "qualified_name": "src/lang/python.rs::PythonCFGBuilder",
      "file": "src/lang/python.rs",
      "line": 579,
      "language": "rust",
      "unit_type": "class",
      "signature": "class PythonCFGBuilder",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "struct PythonCFGBuilder<'a> {\n    source: &'a [u8],\n    blocks: HashMap<BlockId, CFGBlock>,\n    edges: Vec<CFGEdge>,\n    next_block_id: usize,\n    exits: Vec<BlockId>,\n    /// Stack of loop headers for continue statements\n    loop_headers: Vec<BlockId>,\n    /// Stack of after-loop blocks for break statements\n    loop_exits: Vec<BlockId>,\n}\n",
      "semantic_tags": [
        "iteration"
      ],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 4
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 88
    },
    {
      "name": "VarRef",
      "qualified_name": "src/lang/python.rs::VarRef",
      "file": "src/lang/python.rs",
      "line": 1162,
      "language": "rust",
      "unit_type": "class",
      "signature": "class VarRef",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "struct VarRef {\n    name: String,\n    line: usize,\n    kind: DataflowKind,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 22
    },
    {
      "name": "PythonDFGBuilder",
      "qualified_name": "src/lang/python.rs::PythonDFGBuilder",
      "file": "src/lang/python.rs",
      "line": 1169,
      "language": "rust",
      "unit_type": "class",
      "signature": "class PythonDFGBuilder",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "std::collections, tree_sitter, crate::ast::types, crate::cfg::types, crate::dfg::types",
      "code_preview": "struct PythonDFGBuilder<'a> {\n    source: &'a [u8],\n    refs: Vec<VarRef>,\n}\n",
      "semantic_tags": [],
      "complexity": {
        "depth": 1,
        "branches": 0,
        "loops": 0
      },
      "chunk_index": 0,
      "chunk_total": 1,
      "parent_name": "",
      "token_count": 27
    }
  ],
  "model": "Qwen/Qwen3-Embedding-0.6B",
  "dimension": 1024,
  "native_dimension": 1024,
  "is_mrl_truncated": false,
  "count": 1032,
  "index_type": "usearch",
  "languages": [
    "rust"
  ],
  "created_at": "2026-01-14T05:22:14.602946"
}