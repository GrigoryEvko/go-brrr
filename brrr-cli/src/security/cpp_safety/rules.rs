//! Static rule definitions for the C++ safety analyzer.

use crate::security::common::{Confidence, Severity};

use super::types::SafetyAxiom;

/// A static rule definition used for metadata lookup.
pub(crate) struct RuleDef {
    pub id: &'static str,
    pub axiom: SafetyAxiom,
    pub severity: Severity,
    pub confidence: Confidence,
    pub title: &'static str,
    pub description: &'static str,
    pub remediation: &'static str,
    pub cwe: Option<u32>,
}

/// Complete rule catalog.
pub(crate) const RULES: &[RuleDef] = &[
    // ── InitSafe ────────────────────────────────────────────────────────────
    RuleDef {
        id: "INIT-001",
        axiom: SafetyAxiom::InitSafe,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "Struct field without NSDMI (non-static data member initializer)",
        description: "Field has no default value (= expr or {}). Uninitialized fields cause UB on read.",
        remediation: "Add a default value: `int x = 0;` or `int x{};`",
        cwe: Some(457),
    },
    RuleDef {
        id: "INIT-002",
        axiom: SafetyAxiom::InitSafe,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "Padding/reserved array without zero-init",
        description: "Array field like `uint8_t pad[N]` without `= {}` leaks stack/heap contents.",
        remediation: "Zero-init the array: `uint8_t pad[N]{};` or `= {0}`",
        cwe: Some(457),
    },
    RuleDef {
        id: "INIT-003",
        axiom: SafetyAxiom::InitSafe,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "Field not in constructor member initializer list",
        description: "Field without NSDMI is also missing from the constructor's member initializer list.",
        remediation: "Add the field to the constructor initializer list or add NSDMI",
        cwe: Some(457),
    },
    RuleDef {
        id: "INIT-004",
        axiom: SafetyAxiom::InitSafe,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "Uninitialized local variable",
        description: "Local variable declared without initialization may contain garbage values.",
        remediation: "Initialize at declaration: `int x = 0;` or `auto x = Type{};`",
        cwe: Some(457),
    },

    // ── TypeSafe ────────────────────────────────────────────────────────────
    RuleDef {
        id: "TYPE-001",
        axiom: SafetyAxiom::TypeSafe,
        severity: Severity::Medium,
        confidence: Confidence::High,
        title: "Plain enum instead of enum class",
        description: "Unscoped enum leaks names into enclosing scope and allows implicit int conversion.",
        remediation: "Use `enum class` for type-safe scoped enumerations",
        cwe: Some(704),
    },
    RuleDef {
        id: "TYPE-002",
        axiom: SafetyAxiom::TypeSafe,
        severity: Severity::Low,
        confidence: Confidence::Low,
        title: "3+ parameters of same integer type (missing strong types)",
        description: "Multiple parameters of the same integer type are easily transposed at call sites.",
        remediation: "Use strong typedefs (enum class, tagged struct) to distinguish parameters",
        cwe: Some(628),
    },
    RuleDef {
        id: "TYPE-003",
        axiom: SafetyAxiom::TypeSafe,
        severity: Severity::Medium,
        confidence: Confidence::High,
        title: "Single-argument constructor without explicit",
        description: "Allows implicit conversions that can hide bugs at call sites.",
        remediation: "Mark the constructor `explicit`",
        cwe: Some(704),
    },
    RuleDef {
        id: "TYPE-004",
        axiom: SafetyAxiom::TypeSafe,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "reinterpret_cast usage",
        description: "reinterpret_cast bypasses the type system entirely and can cause UB.",
        remediation: "Use `std::bit_cast` (C++20) for type punning or redesign to avoid cast",
        cwe: Some(704),
    },
    RuleDef {
        id: "TYPE-005",
        axiom: SafetyAxiom::TypeSafe,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "static_cast from enum to integer",
        description: "Manual enum-to-integer conversion loses type information.",
        remediation: "Use `std::to_underlying()` (C++23) for explicit intent",
        cwe: Some(704),
    },
    RuleDef {
        id: "TYPE-006",
        axiom: SafetyAxiom::TypeSafe,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "C-style cast in C++ code",
        description: "C-style casts are unchecked and can perform dangerous conversions silently.",
        remediation: "Use static_cast, const_cast, or reinterpret_cast (with justification)",
        cwe: Some(704),
    },

    // ── NullSafe ────────────────────────────────────────────────────────────
    RuleDef {
        id: "NULL-001",
        axiom: SafetyAxiom::NullSafe,
        severity: Severity::Medium,
        confidence: Confidence::Low,
        title: "Missing [[nodiscard]] on pointer/ref-returning const method",
        description: "Ignoring a returned pointer/reference likely means a missed null check.",
        remediation: "Add `[[nodiscard]]` to const methods returning pointers or references",
        cwe: Some(252),
    },
    RuleDef {
        id: "NULL-002",
        axiom: SafetyAxiom::NullSafe,
        severity: Severity::High,
        confidence: Confidence::Medium,
        title: "Allocation without null check",
        description: "malloc/calloc/realloc result used without null check. Null deref = crash.",
        remediation: "Check for NULL: `if (!ptr) { /* handle error */ }`",
        cwe: Some(476),
    },
    RuleDef {
        id: "NULL-003",
        axiom: SafetyAxiom::NullSafe,
        severity: Severity::Low,
        confidence: Confidence::Low,
        title: "Adjacent pointer + count fields without span accessor",
        description: "Raw pointer + size pair is a common source of buffer overflows.",
        remediation: "Provide a `std::span` accessor method or use `gsl::span`",
        cwe: Some(119),
    },
    RuleDef {
        id: "NULL-004",
        axiom: SafetyAxiom::NullSafe,
        severity: Severity::High,
        confidence: Confidence::Medium,
        title: "Pointer dereference without prior null check",
        description: "Dereferencing a pointer without null validation causes UB on null.",
        remediation: "Add a null check or use references/gsl::not_null",
        cwe: Some(476),
    },

    // ── MemSafe ─────────────────────────────────────────────────────────────
    RuleDef {
        id: "MEM-001",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "Raw new expression",
        description: "Raw `new` bypasses RAII and creates manual memory management obligations.",
        remediation: "Use arena allocation, std::make_unique, or std::make_shared",
        cwe: Some(401),
    },
    RuleDef {
        id: "MEM-002",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "Raw delete expression",
        description: "Raw `delete` indicates manual memory management, prone to double-free and UAF.",
        remediation: "Use smart pointers (unique_ptr/shared_ptr) or arena allocators",
        cwe: Some(415),
    },
    RuleDef {
        id: "MEM-003",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Low,
        confidence: Confidence::High,
        title: "= delete without reason string (C++26)",
        description: "C++26 allows `= delete(\"reason\")` for better diagnostics.",
        remediation: "Add a reason: `void f() = delete(\"use g() instead\");`",
        cwe: None,
    },
    RuleDef {
        id: "MEM-004",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "Missing static_assert(sizeof) on aligned struct",
        description: "Struct with `alignas` but no sizeof assertion may have unexpected padding.",
        remediation: "Add `static_assert(sizeof(MyStruct) == EXPECTED_SIZE);`",
        cwe: Some(131),
    },
    RuleDef {
        id: "MEM-005",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "std::string field in data struct",
        description: "std::string allocates on the heap; in data-oriented structs prefer arena strings.",
        remediation: "Use a string_view with arena-backed storage or fixed-size char array",
        cwe: None,
    },
    RuleDef {
        id: "MEM-006",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "std::shared_ptr usage",
        description: "shared_ptr has atomic reference counting overhead and complicates ownership.",
        remediation: "Prefer unique_ptr, raw pointers with clear ownership, or arena allocation",
        cwe: None,
    },
    RuleDef {
        id: "MEM-007",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "Virtual method in performance-critical aligned struct",
        description: "Virtual dispatch adds a vtable pointer, breaking cache-line alignment.",
        remediation: "Use CRTP or function pointers for polymorphism in data-oriented structs",
        cwe: None,
    },
    RuleDef {
        id: "MEM-008",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::Medium,
        title: "Raw multiplication before allocation",
        description: "Unchecked `count * size` can overflow, causing undersized allocation.",
        remediation: "Use `std::mul_sat()` (C++26) or check: `if (count > SIZE_MAX / size) { ... }`",
        cwe: Some(190),
    },

    // ── RaceFree ────────────────────────────────────────────────────────────
    RuleDef {
        id: "RACE-001",
        axiom: SafetyAxiom::RaceFree,
        severity: Severity::High,
        confidence: Confidence::Low,
        title: "Mutable field without synchronization",
        description: "A `mutable` field can be modified in const methods, creating hidden shared mutation.",
        remediation: "Protect with std::mutex or use std::atomic for the mutable field",
        cwe: Some(362),
    },
    RuleDef {
        id: "RACE-002",
        axiom: SafetyAxiom::RaceFree,
        severity: Severity::High,
        confidence: Confidence::Medium,
        title: "std::thread::detach() usage",
        description: "Detached threads are unjoined; accessing shared state after detach is a data race.",
        remediation: "Use std::jthread (C++20) or ensure proper synchronization before detach",
        cwe: Some(362),
    },
    RuleDef {
        id: "RACE-003",
        axiom: SafetyAxiom::RaceFree,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "Shared data without lock_guard/unique_lock",
        description: "std::mutex member present but methods access data without holding the lock.",
        remediation: "Use std::lock_guard or std::unique_lock in every method accessing shared data",
        cwe: Some(362),
    },

    // ── LeakFree ────────────────────────────────────────────────────────────
    RuleDef {
        id: "LEAK-001",
        axiom: SafetyAxiom::LeakFree,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "fopen/open without RAII wrapper",
        description: "C-style file handles must be manually closed; exception paths can leak.",
        remediation: "Use std::fstream, std::ifstream, or a custom RAII wrapper",
        cwe: Some(775),
    },
    RuleDef {
        id: "LEAK-002",
        axiom: SafetyAxiom::LeakFree,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "Missing virtual destructor in polymorphic base class",
        description: "Deleting via base pointer without virtual destructor causes resource leak and UB.",
        remediation: "Add `virtual ~ClassName() = default;` to the base class",
        cwe: Some(prevent_leak_cwe()),
    },
    RuleDef {
        id: "LEAK-003",
        axiom: SafetyAxiom::LeakFree,
        severity: Severity::Low,
        confidence: Confidence::Low,
        title: "Socket/handle without RAII wrapper",
        description: "Raw file descriptors or socket handles can leak on exception or early return.",
        remediation: "Wrap handles in RAII types that close on destruction",
        cwe: Some(775),
    },

    // ── DetDrop ─────────────────────────────────────────────────────────────
    RuleDef {
        id: "DETD-001",
        axiom: SafetyAxiom::DetDrop,
        severity: Severity::Low,
        confidence: Confidence::Low,
        title: "Global/static variable with non-trivial destructor",
        description: "Static initialization/destruction order is unspecified across translation units.",
        remediation: "Use a function-local static (Meyers singleton) or avoid global state",
        cwe: Some(696),
    },
    RuleDef {
        id: "DETD-002",
        axiom: SafetyAxiom::DetDrop,
        severity: Severity::Low,
        confidence: Confidence::Low,
        title: "std::unordered_map with non-trivial destructor values",
        description: "Destruction order of unordered_map entries is unspecified.",
        remediation: "If destruction order matters, use std::map or a vector of pairs",
        cwe: Some(696),
    },

    // ── Performance ─────────────────────────────────────────────────────────
    RuleDef {
        id: "PERF-001",
        axiom: SafetyAxiom::Performance,
        severity: Severity::Low,
        confidence: Confidence::Low,
        title: "std::unordered_map in hot-path struct",
        description: "unordered_map has poor cache locality; consider flat_hash_map or sorted vector.",
        remediation: "Use absl::flat_hash_map, robin_map, or a sorted std::vector for small sets",
        cwe: None,
    },
    RuleDef {
        id: "PERF-002",
        axiom: SafetyAxiom::Performance,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "std::atomic without alignas(64) (false sharing risk)",
        description: "Atomics on the same cache line cause false sharing, destroying scalability.",
        remediation: "Add `alignas(64)` or use `std::hardware_destructive_interference_size`",
        cwe: None,
    },
    RuleDef {
        id: "PERF-003",
        axiom: SafetyAxiom::Performance,
        severity: Severity::Low,
        confidence: Confidence::Low,
        title: "Missing [[likely]]/[[unlikely]] on error branch",
        description: "Error-handling branches are rarely taken; hint helps branch predictor.",
        remediation: "Add `[[unlikely]]` on error paths and `[[likely]]` on hot paths",
        cwe: None,
    },
    RuleDef {
        id: "PERF-004",
        axiom: SafetyAxiom::Performance,
        severity: Severity::Low,
        confidence: Confidence::Low,
        title: "Pure function without constexpr",
        description: "Functions with no side effects can potentially be evaluated at compile time.",
        remediation: "Consider marking as `constexpr` or `consteval` if possible",
        cwe: None,
    },
    RuleDef {
        id: "PERF-005",
        axiom: SafetyAxiom::Performance,
        severity: Severity::Low,
        confidence: Confidence::Low,
        title: "std::function field (type-erased callable)",
        description: "std::function has heap allocation and virtual dispatch overhead.",
        remediation: "Use templates, function_ref, or inplace_function for hot paths",
        cwe: None,
    },

    // ── AntiPattern ─────────────────────────────────────────────────────────
    RuleDef {
        id: "ANTI-001",
        axiom: SafetyAxiom::AntiPattern,
        severity: Severity::Medium,
        confidence: Confidence::High,
        title: "RTTI usage (dynamic_cast / typeid)",
        description: "RTTI has runtime overhead and often indicates a design flaw.",
        remediation: "Use the visitor pattern, std::variant, or CRTP instead",
        cwe: None,
    },
    RuleDef {
        id: "ANTI-002",
        axiom: SafetyAxiom::AntiPattern,
        severity: Severity::Low,
        confidence: Confidence::Low,
        title: "std::variant in data struct",
        description: "variant has space overhead (max of all alternatives) and complex visitation.",
        remediation: "Consider a kind enum + union, or tagged struct hierarchy",
        cwe: None,
    },
    RuleDef {
        id: "ANTI-003",
        axiom: SafetyAxiom::AntiPattern,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "Exception throw in code",
        description: "Exceptions have unpredictable performance cost and complicate reasoning.",
        remediation: "Use std::expected (C++23), error codes, or Result types",
        cwe: None,
    },

    // ── Lifetime Safety (§1.5.1 D3390) ────────────────────────────────────
    RuleDef {
        id: "LIFE-001",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::Medium,
        title: "string_view bound to temporary std::string",
        description: "string_view does not own its data; binding to a temporary string creates a dangling view after the statement ends.",
        remediation: "Store the string in a named variable first, or use std::string directly",
        cwe: Some(416),
    },
    RuleDef {
        id: "LIFE-002",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::Medium,
        title: "span bound to temporary container",
        description: "span does not own its data; binding to a temporary container creates a dangling span.",
        remediation: "Store the container in a named variable first, or pass by reference",
        cwe: Some(416),
    },
    RuleDef {
        id: "LIFE-003",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Medium,
        confidence: Confidence::Low,
        title: "Non-owning view stored as class member",
        description: "string_view/span stored as struct/class member may outlive the referenced data.",
        remediation: "Use std::string/std::vector for owned storage, or document the lifetime contract explicitly",
        cwe: Some(416),
    },
    RuleDef {
        id: "LIFE-004",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "Returning non-owning view to local data",
        description: "Returning string_view or span to function-local data creates a dangling reference.",
        remediation: "Return std::string or std::vector instead of the non-owning view",
        cwe: Some(416),
    },

    // ── Iterator Invalidation (§2.2.2 D3390) ──────────────────────────────
    RuleDef {
        id: "LIFE-005",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "Container mutation during range-for loop",
        description: "Calling push_back/erase/insert/clear on a container while iterating over it with range-for invalidates iterators, causing UB.",
        remediation: "Collect modifications and apply after the loop, or use erase-remove idiom",
        cwe: Some(416),
    },
    RuleDef {
        id: "LIFE-006",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "Container mutation while holding iterator",
        description: "Modifying a container while iterating with begin()/end() invalidates the iterator.",
        remediation: "Use the return value of erase() to advance, or collect changes for post-loop application",
        cwe: Some(416),
    },
    RuleDef {
        id: "LIFE-007",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Medium,
        confidence: Confidence::Low,
        title: "Container mutation while reference/pointer to element exists",
        description: "Mutating a container (push_back, insert, erase) while holding a reference or pointer to an element may invalidate that reference.",
        remediation: "Re-obtain references after container mutation, or use stable containers like std::list",
        cwe: Some(416),
    },

    // ── Initializer List Dangling (§2.2.3 D3390) ──────────────────────────
    RuleDef {
        id: "LIFE-008",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "Local variable of type std::initializer_list",
        description: "The backing array of initializer_list is destroyed at the end of the full expression; storing it in a local variable creates a dangling reference.",
        remediation: "Use std::vector, std::array, or a C array instead",
        cwe: Some(416),
    },
    RuleDef {
        id: "LIFE-009",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "Function parameter of type std::initializer_list stored or returned",
        description: "The backing array only lives for the duration of the function call; storing it outlives the data.",
        remediation: "Accept a span<const T> or const vector<T>& instead",
        cwe: Some(416),
    },
    RuleDef {
        id: "LIFE-010",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "std::initializer_list as class data member",
        description: "Storing initializer_list as a member is almost always wrong; the backing array doesn't persist beyond the initializing expression.",
        remediation: "Use std::vector<T> or std::array<T, N> as the member type",
        cwe: Some(416),
    },

    // ── Return Reference/Pointer to Local (§2.2 D3390) ────────────────────
    RuleDef {
        id: "LIFE-011",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Critical,
        confidence: Confidence::High,
        title: "Returning reference or pointer to local variable",
        description: "Function returns reference or pointer to a local variable; the variable is destroyed when the function returns, creating a dangling reference.",
        remediation: "Return by value, use an output parameter, or allocate on the heap",
        cwe: Some(562),
    },
    RuleDef {
        id: "LIFE-013",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::Medium,
        title: "Lambda capturing by reference escapes function scope",
        description: "A lambda with [&] capture that is returned, stored in std::function, or passed to async/thread creates dangling references when the enclosing scope exits.",
        remediation: "Capture by value [=] or explicitly capture needed variables by value",
        cwe: Some(416),
    },
    RuleDef {
        id: "LIFE-014",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::High,
        confidence: Confidence::Medium,
        title: "std::ref/std::cref wrapping local variable",
        description: "std::reference_wrapper wrapping a local variable that escapes scope creates a dangling reference.",
        remediation: "Pass by value or ensure the referenced variable outlives the wrapper",
        cwe: Some(416),
    },
    // ── §2.1 Unsafe Context (UCTX-xxx) ──────────────────────────────────────
    RuleDef {
        id: "UCTX-001",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "Pointer arithmetic (unsafe context)",
        description: "Pointer arithmetic (ptr+n, ptr++, ptr[n]) can advance past allocation bounds, causing buffer overflow UB. D3390 §2.1 prohibits this in safe context.",
        remediation: "Use std::span, std::array, or iterator-based access instead of raw pointer arithmetic",
        cwe: Some(119),
    },
    RuleDef {
        id: "UCTX-002",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Low,
        confidence: Confidence::Low,
        title: "Pointer difference (unsafe context)",
        description: "Taking the difference of pointers into different allocations is undefined behavior. D3390 §2.1 prohibits this in safe context.",
        remediation: "Use iterator::distance or container::size instead of pointer subtraction",
        cwe: Some(469),
    },
    RuleDef {
        id: "UCTX-004",
        axiom: SafetyAxiom::TypeSafe,
        severity: Severity::High,
        confidence: Confidence::High,
        title: "Union type definition (unsafe type punning)",
        description: "Union field access without discriminant check is type confusion UB. D3390 §2.1 treats union access as unsafe. Prefer std::variant with visit.",
        remediation: "Replace union with std::variant and use std::visit for safe access",
        cwe: Some(188),
    },
    RuleDef {
        id: "UCTX-005",
        axiom: SafetyAxiom::RaceFree,
        severity: Severity::Medium,
        confidence: Confidence::Medium,
        title: "Mutable static variable (data race hazard)",
        description: "Non-const static variables are data race hazards in multi-threaded programs. D3390 §2.1 prohibits naming mutable statics in safe context.",
        remediation: "Use thread_local, const, constexpr, or protect with a mutex",
        cwe: Some(362),
    },
    RuleDef {
        id: "UCTX-006",
        axiom: SafetyAxiom::MemSafe,
        severity: Severity::Low,
        confidence: Confidence::High,
        title: "Inline assembly (unsafe context)",
        description: "Inline assembly bypasses all compiler safety checks. D3390 §2.1 treats asm blocks as inherently unsafe context.",
        remediation: "Use compiler intrinsics or constexpr functions as safe alternatives where possible",
        cwe: Some(676),
    },
];

/// CWE for resource leak via missing virtual destructor (improper resource shutdown).
const fn prevent_leak_cwe() -> u32 {
    404
}

/// Look up a rule definition by ID.
pub(crate) fn lookup_rule(id: &str) -> Option<&'static RuleDef> {
    RULES.iter().find(|r| r.id == id)
}
