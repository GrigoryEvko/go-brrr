\documentclass[11pt,a4paper]{report}

%=============================================================================
% PACKAGES
%=============================================================================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{stmaryrd}           % \llbracket, \rrbracket
\usepackage{tikz-cd}            % commutative diagrams (tikzcd environment)
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{etoolbox}           % for \patchcmd
\usepackage{tcolorbox}
\usepackage{mathpartir}         % for inference rules

\geometry{margin=1in}

%=============================================================================
% DENSE FORMATTING - Remove chapter page breaks and tighten spacing
%=============================================================================

% Prevent chapters from starting on new pages
\makeatletter
\patchcmd{\chapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}
\patchcmd{\chapter}{\clearpage}{}{}{}
\makeatother

% Chapter formatting: no page break, reduced spacing
\titleformat{\chapter}[block]
  {\normalfont\Large\bfseries}{\thechapter.}{0.5em}{}
\titlespacing*{\chapter}{0pt}{1.5ex plus 0.5ex minus 0.3ex}{1ex plus 0.3ex}

% Section formatting: tighter spacing
\titlespacing*{\section}{0pt}{1.5ex plus 0.5ex minus 0.3ex}{0.8ex plus 0.2ex}
\titlespacing*{\subsection}{0pt}{1.2ex plus 0.4ex minus 0.2ex}{0.6ex plus 0.2ex}
\titlespacing*{\subsubsection}{0pt}{1ex plus 0.3ex minus 0.2ex}{0.5ex plus 0.1ex}

% Part formatting: reduced spacing
\titleformat{\part}[display]
  {\normalfont\huge\bfseries\centering}{\partname\ \thepart}{10pt}{\Huge}
\titlespacing*{\part}{0pt}{20pt}{15pt}

% Reduce paragraph spacing
\setlength{\parskip}{0.3ex plus 0.1ex minus 0.1ex}
\setlength{\parindent}{1.5em}

% Reduce spacing around math environments
\AtBeginDocument{%
  \setlength{\abovedisplayskip}{6pt plus 2pt minus 2pt}%
  \setlength{\belowdisplayskip}{6pt plus 2pt minus 2pt}%
  \setlength{\abovedisplayshortskip}{3pt plus 1pt minus 1pt}%
  \setlength{\belowdisplayshortskip}{3pt plus 1pt minus 1pt}%
}

% Tighten list spacing globally via enumitem
\setlist{nosep, leftmargin=*, labelsep=0.5em}
\setlist[enumerate]{topsep=0.3ex, itemsep=0.1ex, parsep=0.1ex}
\setlist[itemize]{topsep=0.3ex, itemsep=0.1ex, parsep=0.1ex}

%=============================================================================
% THEOREM ENVIRONMENTS
%=============================================================================
\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\newtheorem{example}[definition]{Example}
\newtheorem{remark}[definition]{Remark}

\theoremstyle{plain}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{proposition}[definition]{Proposition}

\theoremstyle{remark}
\newtheorem*{notation}{Notation}

%=============================================================================
% CUSTOM COMMANDS - SEMANTIC BRACKETS
%=============================================================================
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\semenv}[2]{\llbracket #1 \rrbracket_{#2}}

%=============================================================================
% CUSTOM COMMANDS - TYPES
%=============================================================================
\newcommand{\TInt}{\mathsf{Int}}
\newcommand{\TBool}{\mathsf{Bool}}
\newcommand{\TString}{\mathsf{String}}
\newcommand{\TFloat}{\mathsf{Float}}
\newcommand{\TUnit}{\mathsf{Unit}}
\newcommand{\TNever}{\mathsf{Never}}
\newcommand{\TAny}{\mathsf{Any}}
\newcommand{\TUnknown}{\mathsf{Unknown}}
\newcommand{\TOption}[1]{\mathsf{Option}[#1]}
\newcommand{\TResult}[2]{\mathsf{Result}[#1, #2]}
\newcommand{\TArray}[1]{\mathsf{Array}[#1]}
\newcommand{\TFunc}[3]{#1 \xrightarrow{#2} #3}
\newcommand{\Code}[1]{\langle #1 \rangle}
\newcommand{\TypeRep}[1]{\mathsf{TypeRep}[#1]}

%=============================================================================
% CUSTOM COMMANDS - MODES
%=============================================================================
\newcommand{\mzero}{\mathsf{0}}
\newcommand{\mone}{\mathsf{1}}
\newcommand{\momega}{\omega}
\newcommand{\maffine}{\mathsf{aff}}
\newcommand{\mrelevant}{\mathsf{rel}}
\newcommand{\own}{\mathsf{own}}
\newcommand{\rref}{\mathsf{ref}}
\newcommand{\rrefmut}{\mathsf{ref\,mut}}
\newcommand{\gc}{\mathsf{gc}}
\newcommand{\rc}{\mathsf{rc}}
\newcommand{\arc}{\mathsf{arc}}

%=============================================================================
% CUSTOM COMMANDS - EFFECTS
%=============================================================================
\newcommand{\Eff}{\mathsf{Eff}}
\newcommand{\Pure}{\bot}
\newcommand{\EThrow}[1]{\mathsf{Throw}[#1]}
\newcommand{\EPanic}{\mathsf{Panic}}
\newcommand{\EIO}{\mathsf{IO}}
\newcommand{\EAsync}{\mathsf{Async}}
\newcommand{\EAlloc}{\mathsf{Alloc}}
\newcommand{\ERead}{\mathsf{Read}}
\newcommand{\EWrite}{\mathsf{Write}}
\newcommand{\EDiverge}{\mathsf{Div}}
\newcommand{\rowext}[2]{\langle #1 \mid #2 \rangle}
\newcommand{\effjoin}{\sqcup}
\newcommand{\bigeffjoin}{\bigsqcup}
\newcommand{\effmeet}{\sqcap}
\newcommand{\effsub}{\sqsubseteq}

%=============================================================================
% CUSTOM COMMANDS - JUDGMENTS
%=============================================================================
\newcommand{\types}{\vdash}
\newcommand{\subtype}{<:}
\newcommand{\env}{\Gamma}
\newcommand{\pc}{\mathsf{pc}}
\newcommand{\at}{@}

%=============================================================================
% CUSTOM COMMANDS - LINEAR LOGIC
%=============================================================================
\newcommand{\lolli}{\multimap}
\newcommand{\tensor}{\otimes}
\newcommand{\with}{\mathbin{\&}}
\newcommand{\plus}{\oplus}
\newcommand{\bang}{!}
\newcommand{\whynot}{?}
\newcommand{\one}{\mathbf{1}}
\newcommand{\zero}{\mathbf{0}}

%=============================================================================
% LISTINGS FOR F*
%=============================================================================
\definecolor{fstar-keyword}{RGB}{0,0,180}
\definecolor{fstar-string}{RGB}{180,0,0}
\definecolor{fstar-comment}{RGB}{0,128,0}
\definecolor{fstar-type}{RGB}{128,0,128}

\lstdefinelanguage{fstar}{
  keywords={let, rec, in, if, then, else, match, with, type, val,
            module, open, assume, assert, requires, ensures,
            forall, exists, fun, function, and, or, not, true, false,
            Tot, Lemma, Type, effect, new_effect, sub_effect,
            inline_for_extraction, unfold, irreducible, opaque,
            private, abstract, noeq, unopteq},
  keywordstyle=\color{fstar-keyword}\bfseries,
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{(*}{*)},
  commentstyle=\color{fstar-comment}\itshape,
  stringstyle=\color{fstar-string},
  morestring=[b]",
  basicstyle=\ttfamily\small,
  breaklines=true,
  showstringspaces=false,
  tabsize=2,
  extendedchars=true,
  inputencoding=utf8,
  escapeinside={(*@}{@*)},
  literate={->}{$\rightarrow$}1
           {=>}{$\Rightarrow$}1
           {<-}{$\leftarrow$}1
           {forall}{$\forall$}1
           {exists}{$\exists$}1
           {/\\}{$\land$}1
           {\\/}{$\lor$}1
           {~}{$\lnot$}1
           {<=}{$\leq$}1
           {>=}{$\geq$}1
           {<>}{$\neq$}1
           {alpha}{$\alpha$}1
           {beta}{$\beta$}1
           {gamma}{$\gamma$}1
           {delta}{$\delta$}1
           {epsilon}{$\varepsilon$}1
           {tau}{$\tau$}1
           {sigma}{$\sigma$}1
           {rho}{$\rho$}1
           {omega}{$\omega$}1
           {τ}{$\tau$}1
           {⊆}{$\subseteq$}1
           {∪}{$\cup$}1
           {μ}{$\mu$}1
           {ν}{$\nu$}1
           {⊕}{$\oplus$}1
           {◁}{$\triangleleft$}1
           {▷}{$\triangleright$}1
           {ε}{$\varepsilon$}1
           {↦}{$\mapsto$}1
           {⊥}{$\bot$}1
           {⊤}{$\top$}1
           {₁}{1}1
           {₂}{2}1
           {≅}{$\cong$}1
           {∃}{$\exists$}1
           {Σ}{$\Sigma$}1
           {λ}{$\lambda$}1
           {α}{$\alpha$}1
           {β}{$\beta$}1
           {γ}{$\gamma$}1
           {δ}{$\delta$}1
           {σ}{$\sigma$}1
           {ρ}{$\rho$}1
           {ω}{$\omega$}1
           {π}{$\pi$}1
           {κ}{$\kappa$}1
           {Γ}{$\Gamma$}1
           {Δ}{$\Delta$}1
           {Π}{$\Pi$}1
           {Λ}{$\Lambda$}1
           {∀}{$\forall$}1
           {≈}{$\approx$}1
           {⟹}{$\Longrightarrow$}1
           {∧}{$\land$}1
           {∨}{$\lor$}1
           {¬}{$\lnot$}1
           {≤}{$\leq$}1
           {≥}{$\geq$}1
           {≠}{$\neq$}1
           {∈}{$\in$}1
           {∉}{$\notin$}1
           {⊂}{$\subset$}1
           {⊃}{$\supset$}1
           {⊇}{$\supseteq$}1
           {∩}{$\cap$}1
           {→}{$\rightarrow$}1
           {←}{$\leftarrow$}1
           {⇒}{$\Rightarrow$}1
           {⇐}{$\Leftarrow$}1
           {⇔}{$\Leftrightarrow$}1
           {⟨}{$\langle$}1
           {⟩}{$\rangle$}1
           {⊢}{$\vdash$}1
           {⊣}{$\dashv$}1
           {⊔}{$\sqcup$}1
           {⊓}{$\sqcap$}1
           {⊏}{$\sqsubset$}1
           {⊑}{$\sqsubseteq$}1
           {⊐}{$\sqsupset$}1
           {⊒}{$\sqsupseteq$}1
           {∘}{$\circ$}1
           {×}{$\times$}1
           {÷}{$\div$}1
           {·}{$\cdot$}1
           {†}{$\dagger$}1
           {‡}{$\ddagger$}1
           {∞}{$\infty$}1
           {∂}{$\partial$}1
           {∇}{$\nabla$}1
           {∅}{$\emptyset$}1
           {ℕ}{$\mathbb{N}$}1
           {ℤ}{$\mathbb{Z}$}1
           {ℚ}{$\mathbb{Q}$}1
           {ℝ}{$\mathbb{R}$}1
           {ℂ}{$\mathbb{C}$}1
           {≡}{$\equiv$}1
           {⊸}{$\multimap$}1
           {⊗}{$\otimes$}1
           {∎}{$\blacksquare$}1
           {′}{'}1
           {″}{''}2
           {‴}{'''}3
           {⁰}{0}1
           {¹}{1}1
           {²}{2}1
           {³}{3}1
           {⁴}{4}1
           {⁵}{5}1
           {⁶}{6}1
           {⁷}{7}1
           {⁸}{8}1
           {⁹}{9}1
           {₀}{0}1
           {₃}{3}1
           {₄}{4}1
           {₅}{5}1
           {₆}{6}1
           {₇}{7}1
           {₈}{8}1
           {₉}{9}1
           {θ}{$\theta$}1
           {φ}{$\varphi$}1
           {ψ}{$\psi$}1
           {χ}{$\chi$}1
           {η}{$\eta$}1
           {ζ}{$\zeta$}1
           {ξ}{$\xi$}1
           {ϕ}{$\phi$}1
           {ι}{$\iota$}1
           {Θ}{$\Theta$}1
           {Φ}{$\Phi$}1
           {Ψ}{$\Psi$}1
           {Ω}{$\Omega$}1
           {⌊}{$\lfloor$}1
           {⌋}{$\rfloor$}1
           {⌈}{$\lceil$}1
           {⌉}{$\rceil$}1
           {⟦}{$\llbracket$}1
           {⟧}{$\rrbracket$}1
           {★}{$\star$}1
           {●}{$\bullet$}1
           {○}{$\circ$}1
           {◆}{$\diamondsuit$}1
           {▶}{$\triangleright$}1
           {◀}{$\triangleleft$}1
}

\lstset{language=fstar}

\tcbuselibrary{listings,skins,breakable}

\newtcblisting{fstarcode}[1][]{
  listing only,
  listing options={language=fstar,aboveskip=0pt,belowskip=0pt},
  colback=gray!5,
  colframe=gray!50,
  boxrule=0.3pt,
  left=3pt,
  right=3pt,
  top=1pt,
  bottom=1pt,
  boxsep=1pt,
  before skip=4pt plus 1pt minus 1pt,
  after skip=4pt plus 1pt minus 1pt,
  breakable,
  lines before break=2,
  enforce breakable,
  #1
}

%=============================================================================
% TITLE
%=============================================================================
\title{%
  \textbf{Brrr-Lang Specification v0.4}\\[0.5em]
  \large From Semantics to Silicon:\\
  A Mathematically Rigorous Intermediate Representation\\
  for Multi-Language Static Analysis
}

\author{%
  Brrr-Machine Project
}

\date{January 2026}

%=============================================================================
% DOCUMENT
%=============================================================================
\begin{document}

\maketitle

\begin{abstract}
Brrr-Lang is a unified intermediate representation designed for multi-language static analysis with mathematically rigorous foundations. This specification grounds all constructs in established type theory, linear logic, effect algebras, and denotational semantics. We provide formal definitions, typing rules, and F* mechanizations for verification.

This document covers Parts I--III: Type Primitives, Type System, and Ownership \& Memory, establishing the algebraic foundations upon which the rest of the language is built.
\end{abstract}

\tableofcontents

%=============================================================================
% PART I: FOUNDATIONS
%=============================================================================
\part{Foundations}

\chapter{Semantic Domains}

This chapter establishes the denotational foundation for Brrr-Lang. All subsequent definitions are grounded in these semantic domains.

\section{Domain Theory Preliminaries}

\begin{definition}[Complete Partial Order]
A \emph{complete partial order} (CPO) is a partially ordered set $(D, \sqsubseteq)$ such that:
\begin{enumerate}
  \item There exists a least element $\bot \in D$
  \item Every $\omega$-chain $d_0 \sqsubseteq d_1 \sqsubseteq d_2 \sqsubseteq \cdots$ has a least upper bound $\bigsqcup_{i \in \omega} d_i$
\end{enumerate}
\end{definition}

\begin{definition}[Scott-Continuous Function]
A function $f : D \to E$ between CPOs is \emph{Scott-continuous} if:
\begin{enumerate}
  \item $f$ is monotonic: $d \sqsubseteq d' \implies f(d) \sqsubseteq f(d')$
  \item $f$ preserves least upper bounds of chains: $f(\bigsqcup_i d_i) = \bigsqcup_i f(d_i)$
\end{enumerate}
\end{definition}

\begin{definition}[Lifted Domain]
For any set $A$, the \emph{lifted domain} $A_\bot$ is:
\[
  A_\bot = A \cup \{\bot\}
\]
with ordering $\bot \sqsubseteq a$ for all $a \in A$, and $a \sqsubseteq a$ (flat domain).
\end{definition}

\section{Value Domain}

\begin{definition}[Base Value Domain]
The domain of base values is:
\[
  \mathsf{Val}_{\mathsf{base}} = \TUnit + \TBool + \TInt + \TFloat + \TString
\]
where each component is a flat lifted domain.
\end{definition}

\begin{definition}[Location Domain]
The domain of heap locations is a countably infinite set:
\[
  \mathsf{Loc} = \mathbb{N}
\]
\end{definition}

\begin{definition}[Value Domain]
The full value domain is the solution to the recursive domain equation:
\[
  \mathsf{Val} = \mathsf{Val}_{\mathsf{base}} + \mathsf{Loc} + (\mathsf{Val} \times \mathsf{Val}) + [\mathsf{Val}] + (\mathsf{Env} \to \mathsf{Comp}[\mathsf{Val}])
\]
representing: primitives, references, pairs, lists, and closures.
\end{definition}

\section{Environment and Heap}

\begin{definition}[Environment]
An environment maps variables to locations:
\[
  \mathsf{Env} = \mathsf{Var} \rightharpoonup \mathsf{Loc}
\]
where $\rightharpoonup$ denotes partial functions with finite domain.
\end{definition}

\begin{definition}[Heap]
A heap maps locations to tagged values:
\[
  \mathsf{Heap} = \mathsf{Loc} \rightharpoonup (\mathsf{Tag} \times \mathsf{Val})
\]
where $\mathsf{Tag}$ carries runtime type information.
\end{definition}

\begin{definition}[Ownership State]
The ownership state tracks resource ownership:
\[
  \mathsf{OwnState} = \{
    \mathsf{owns} : \mathcal{P}(\mathsf{Loc}),\;
    \mathsf{borrows} : \mathsf{Loc} \rightharpoonup \mathsf{BorrowKind}
  \}
\]
where $\mathsf{BorrowKind} = \{\mathsf{Shared}, \mathsf{Exclusive}\}$.
\end{definition}

\section{Computation Domain}

\begin{definition}[Effect Signature]
The effect signature is a set of operation symbols:
\[
  \Sigma_{\Eff} = \{\EThrow{}, \EPanic, \EIO, \EAlloc, \ERead, \EWrite, \EAsync, \EDiverge\}
\]
\end{definition}

\begin{definition}[Computation Domain]
The computation domain is a graded monad indexed by effects:
\[
  \mathsf{Comp}_\varepsilon[A] = \mathsf{OwnState} \times \mathsf{Heap} \to
    (A + \mathsf{Exn}) \times \mathsf{OwnState} \times \mathsf{Heap} \times \mathsf{Trace}_\varepsilon
\]
where $\mathsf{Trace}_\varepsilon$ records the effects performed.
\end{definition}

\begin{definition}[Graded Monad Operations]
The computation domain forms a graded monad with:
\begin{align*}
  \mathsf{return}_\Pure &: A \to \mathsf{Comp}_\Pure[A] \\
  \mathsf{return}_\Pure(a) &= \lambda(s, h).\ (\mathsf{inl}(a), s, h, \epsilon) \\[1em]
  (\gg\!=)_{\varepsilon_1, \varepsilon_2} &: \mathsf{Comp}_{\varepsilon_1}[A] \to (A \to \mathsf{Comp}_{\varepsilon_2}[B]) \to \mathsf{Comp}_{\varepsilon_1 \effjoin \varepsilon_2}[B] \\
  (m \gg\!= f)(s, h) &= \begin{cases}
    (f(a))(s', h') & \text{if } m(s,h) = (\mathsf{inl}(a), s', h', t) \\
    (\mathsf{inr}(e), s', h', t) & \text{if } m(s,h) = (\mathsf{inr}(e), s', h', t)
  \end{cases}
\end{align*}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Semantic Domains in F*}]
module BrrrSemantics.Domains

open FStar.FunctionalExtensionality

(* Base types *)
type base_val =
  | VUnit  : base_val
  | VBool  : bool -> base_val
  | VInt   : int -> base_val
  | VFloat : float -> base_val
  | VString: string -> base_val

(* Locations *)
type loc = nat

(* Borrow kinds *)
type borrow_kind = | Shared | Exclusive

(* Ownership state *)
noeq type own_state = {
  owns    : loc -> bool;
  borrows : loc -> option borrow_kind
}

(* Tags for runtime type info *)
type tag =
  | TagBase   : base_val -> tag
  | TagRef    : loc -> tag
  | TagPair   : tag
  | TagArray  : tag
  | TagClosure: tag

(* Forward declaration for recursive domain *)
val value : Type0
val heap  : Type0
val env   : Type0

(* Heap as partial map *)
let heap = loc -> option (tag & value)

(* Environment as partial map *)
let env = string -> option loc

(* Effect trace *)
type effect_label =
  | EThrow | EPanic | EIO | EAlloc | ERead | EWrite | EAsync | EDiv

type trace = list effect_label

(* Computation result *)
type comp_result (a:Type) =
  | Ok  : v:a -> own_state -> heap -> trace -> comp_result a
  | Err : exn:value -> own_state -> heap -> trace -> comp_result a

(* Computation monad *)
let comp (a:Type) = own_state -> heap -> comp_result a

(* Monad operations *)
let return (#a:Type) (x:a) : comp a =
  fun s h -> Ok x s h []

let bind (#a #b:Type) (m:comp a) (f:a -> comp b) : comp b =
  fun s h ->
    match m s h with
    | Ok v s' h' t ->
        (match f v s' h' with
         | Ok v' s'' h'' t' -> Ok v' s'' h'' (t @ t')
         | Err e s'' h'' t' -> Err e s'' h'' (t @ t'))
    | Err e s' h' t -> Err e s' h' t
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Type Primitives}

This chapter defines the primitive types of Brrr-Lang with full algebraic structure.

\section{Boolean Type}

\begin{definition}[Boolean Type]
The boolean type $\TBool$ is the two-element set with standard operations:
\[
  \TBool = \{\mathsf{true}, \mathsf{false}\}
\]
\end{definition}

\begin{definition}[Boolean Semantics]
\begin{align*}
  \sem{\mathsf{true}} &= 1 \\
  \sem{\mathsf{false}} &= 0 \\
  \sem{\lnot b} &= 1 - \sem{b} \\
  \sem{a \land b} &= \min(\sem{a}, \sem{b}) \\
  \sem{a \lor b} &= \max(\sem{a}, \sem{b})
\end{align*}
\end{definition}

\section{Numeric Types}

\begin{definition}[Integer Type Family]
The integer type is parameterized by width and signedness:
\[
  \TInt[w, s] \quad \text{where } w \in \{8, 16, 32, 64, 128, \mathsf{Big}\}, \; s \in \{\mathsf{Signed}, \mathsf{Unsigned}\}
\]

The semantic domain is:
\[
  \sem{\TInt[w, \mathsf{Signed}]} = \{n \in \mathbb{Z} \mid -2^{w-1} \leq n < 2^{w-1}\}
\]
\[
  \sem{\TInt[w, \mathsf{Unsigned}]} = \{n \in \mathbb{Z} \mid 0 \leq n < 2^w\}
\]
\[
  \sem{\TInt[\mathsf{Big}, \_]} = \mathbb{Z}
\]
\end{definition}

\begin{definition}[Float Type Family]
\[
  \TFloat[p] \quad \text{where } p \in \{16, 32, 64\}
\]
with IEEE 754 semantics for the respective precision.
\end{definition}

\section{Unit and Never Types}

\begin{definition}[Unit Type]
The unit type has exactly one value:
\[
  \TUnit = \{()\} \qquad \sem{\TUnit} = \{\star\}
\]
\end{definition}

\begin{definition}[Never Type]
The never type (bottom type) is uninhabited:
\[
  \TNever = \emptyset \qquad \sem{\TNever} = \emptyset
\]

$\TNever$ is the initial object in the category of types:
\[
  \forall \tau.\ \exists! f : \TNever \to \tau
\]
\end{definition}

\section{String Type}

\begin{definition}[String Type]
The string type represents UTF-8 encoded text:
\[
  \TString = \mathsf{List}[\mathsf{Char}] \quad \text{where } \mathsf{Char} = \text{Unicode scalar value}
\]
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Primitive Types in F*}]
module BrrrSemantics.Primitives

(* Integer width *)
type int_width = | I8 | I16 | I32 | I64 | I128 | IBig

(* Signedness *)
type signedness = | Signed | Unsigned

(* Integer type family *)
type int_type = {
  width : int_width;
  sign  : signedness
}

(* Value bounds *)
let int_min (t:int_type) : option int =
  match t.width, t.sign with
  | IBig, _ -> None
  | I8,  Signed   -> Some (-128)
  | I8,  Unsigned -> Some 0
  | I16, Signed   -> Some (-32768)
  | I16, Unsigned -> Some 0
  | I32, Signed   -> Some (-2147483648)
  | I32, Unsigned -> Some 0
  | I64, Signed   -> Some (-9223372036854775808)
  | I64, Unsigned -> Some 0
  | I128, Signed  -> Some (-170141183460469231731687303715884105728)
  | I128, Unsigned-> Some 0

let int_max (t:int_type) : option int =
  match t.width, t.sign with
  | IBig, _ -> None
  | I8,  Signed   -> Some 127
  | I8,  Unsigned -> Some 255
  | I16, Signed   -> Some 32767
  | I16, Unsigned -> Some 65535
  | I32, Signed   -> Some 2147483647
  | I32, Unsigned -> Some 4294967295
  | I64, Signed   -> Some 9223372036854775807
  | I64, Unsigned -> Some 18446744073709551615
  | I128, _ -> (* elided for brevity *) None

(* Well-formed integer value *)
let valid_int (t:int_type) (n:int) : bool =
  match int_min t, int_max t with
  | Some lo, Some hi -> lo <= n && n <= hi
  | None, None -> true  (* BigInt *)
  | _ -> false

(* Float precision *)
type float_prec = | F16 | F32 | F64

(* Unit type - single inhabitant *)
type unit_t = | Unit

(* Never type - no inhabitants *)
type never = | (* empty *)

(* Absurd elimination for Never *)
let absurd (#a:Type) (n:never) : a = match n with

(* Boolean operations with semantics *)
let bool_sem (b:bool) : nat = if b then 1 else 0

let not_sem (b:bool) : bool = not b

let and_sem (a b:bool) : bool = a && b

let or_sem (a b:bool) : bool = a || b

(* Semantic equivalence lemmas *)
val not_sem_correct: b:bool -> Lemma (bool_sem (not_sem b) = 1 - bool_sem b)
let not_sem_correct b = ()

val and_sem_correct: a:bool -> b:bool ->
  Lemma (bool_sem (and_sem a b) = min (bool_sem a) (bool_sem b))
let and_sem_correct a b = ()

val or_sem_correct: a:bool -> b:bool ->
  Lemma (bool_sem (or_sem a b) = max (bool_sem a) (bool_sem b))
let or_sem_correct a b = ()
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Top and Bottom Types}

\section{The Any Type (Top)}

\begin{definition}[Any Type]
$\TAny$ is the top type---the supertype of all types:
\[
  \forall \tau.\ \tau \subtype \TAny
\]

Semantically, $\TAny$ is the terminal object (up to iso):
\[
  \sem{\TAny} = \coprod_{\tau \in \mathsf{Type}} \sem{\tau}
\]
a tagged union of all types.
\end{definition}

\begin{definition}[Unknown Type]
$\TUnknown$ is the safe top type requiring runtime checks:
\[
  \TUnknown \cong \TAny
\]
but with different typing rules---values of type $\TUnknown$ cannot be used without explicit type narrowing.
\end{definition}

\section{Subtyping Lattice}

\begin{theorem}[Type Lattice]
The types form a bounded lattice under subtyping:
\[
  (\mathsf{Type}, \subtype, \sqcup, \sqcap, \TNever, \TAny)
\]
where:
\begin{itemize}
  \item $\TNever$ is the bottom (least element)
  \item $\TAny$ is the top (greatest element)
  \item $\tau_1 \sqcup \tau_2$ is the least upper bound (join)
  \item $\tau_1 \sqcap \tau_2$ is the greatest lower bound (meet)
\end{itemize}
\end{theorem}

\begin{definition}[Subtyping Rules]
\begin{mathpar}
  \inferrule*[right=S-Refl]
    { }
    {\tau \subtype \tau}
  \and
  \inferrule*[right=S-Trans]
    {\tau_1 \subtype \tau_2 \\ \tau_2 \subtype \tau_3}
    {\tau_1 \subtype \tau_3}
  \and
  \inferrule*[right=S-Bot]
    { }
    {\TNever \subtype \tau}
  \and
  \inferrule*[right=S-Top]
    { }
    {\tau \subtype \TAny}
\end{mathpar}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Top and Bottom Types in F*}]
module BrrrSemantics.TopBottom

open BrrrSemantics.Primitives

(* Type representation *)
noeq type brrr_type =
  | TNever   : brrr_type
  | TUnit    : brrr_type
  | TBool    : brrr_type
  | TInt     : int_type -> brrr_type
  | TFloat   : float_prec -> brrr_type
  | TString  : brrr_type
  | TOption  : brrr_type -> brrr_type
  | TArray   : brrr_type -> brrr_type
  | TFunc    : brrr_type -> brrr_type -> effect_row -> brrr_type
  | TPair    : brrr_type -> brrr_type -> brrr_type
  | TAny     : brrr_type
  | TUnknown : brrr_type

and effect_row =
  | EffPure : effect_row
  | EffCons : effect_label -> effect_row -> effect_row
  | EffVar  : string -> effect_row

(* Subtyping relation *)
let rec subtype (t1 t2:brrr_type) : bool =
  if t1 = t2 then true
  else match t1, t2 with
  | TNever, _ -> true              (* Bottom subtypes everything *)
  | _, TAny -> true                (* Everything subtypes top *)
  | TOption t1', TOption t2' -> subtype t1' t2'
  | TArray t1', TArray t2' -> t1' = t2'  (* Arrays are invariant *)
  | TFunc a1 r1 e1, TFunc a2 r2 e2 ->
      subtype a2 a1 &&             (* Contravariant in argument *)
      subtype r1 r2 &&             (* Covariant in result *)
      effect_subtype e1 e2         (* Covariant in effect *)
  | TPair a1 b1, TPair a2 b2 ->
      subtype a1 a2 && subtype b1 b2
  | _, _ -> false

and effect_subtype (e1 e2:effect_row) : bool =
  match e1, e2 with
  | EffPure, _ -> true             (* Pure subtypes any effect *)
  | _, EffVar _ -> true            (* Variables are upper bounds *)
  | EffCons l1 r1, EffCons l2 r2 -> l1 = l2 && effect_subtype r1 r2
  | _, _ -> false

(* Subtyping is reflexive *)
val subtype_refl: t:brrr_type -> Lemma (subtype t t)
let subtype_refl t = ()

(* Subtyping is transitive - PROVEN in reference implementation *)
val subtype_trans: t1:brrr_type -> t2:brrr_type -> t3:brrr_type ->
  Lemma (requires subtype t1 t2 /\ subtype t2 t3)
        (ensures subtype t1 t3)
let rec subtype_trans t1 t2 t3 =
  (* Proof by structural induction on t1, handling:
     - TNever (bottom): trivial since TNever <: anything
     - TAny (top): if t2 <: TAny and TAny <: t3, t3 must be TAny
     - TOption/TArray: recurse on inner types
     - TFunc: contravariant args, covariant returns
     - TPair: covariant in both components
     See BrrrTypes.fst for full 200-line proof with Z3 hints *)
  ()

(* Never is bottom *)
val never_is_bottom: t:brrr_type -> Lemma (subtype TNever t)
let never_is_bottom t = ()

(* Any is top *)
val any_is_top: t:brrr_type -> Lemma (subtype t TAny)
let any_is_top t = ()
\end{fstarcode}

\begin{remark}[Implementation Note: SMT Tractability for Type Transitivity]
The simplified \texttt{brrr\_type} shown above has 12 constructors. In a full implementation
supporting all features (references, modalities, wrappers), the constructor count can grow to 25+.
This causes Z3 quantifier explosion in transitivity proofs: with $n$ constructors, the SMT solver
must consider $n^3$ combinations for the lemma
$\forall t_1, t_2, t_3.\; t_1 \subtype t_2 \land t_2 \subtype t_3 \Rightarrow t_1 \subtype t_3$.

\textbf{Workaround:} The reference implementation restructures \texttt{brrr\_type} using
\emph{discriminator types} to keep the top-level constructor count at 12:

\begin{verbatim}
type prim_kind = PUnit | PNever | PBool | PString | PChar | PDynamic
type numeric_type = NumInt of int_type | NumFloat of float_prec
type wrapper_kind = WArray | WSlice | WOption | WBox | WRef | WRefMut | WRc | WArc | WRaw
type modal_kind = MBoxMod of ref_kind | MDiamondMod

noeq type brrr_type =
  | TPrim    : prim_kind -> brrr_type      (* 6 primitives in 1 constructor *)
  | TNumeric : numeric_type -> brrr_type   (* int/float with widths *)
  | TWrap    : wrapper_kind -> brrr_type -> brrr_type  (* 9 wrappers in 1 *)
  | TModal   : modal_kind -> brrr_type -> brrr_type    (* Box/Diamond modalities *)
  | TResult  : brrr_type -> brrr_type -> brrr_type
  | TTuple   : list brrr_type -> brrr_type
  | TFunc    : func_type -> brrr_type
  | TVar     : type_var -> brrr_type
  | TApp     : brrr_type -> list brrr_type -> brrr_type
  | TNamed   : type_name -> brrr_type
  | TStruct  : struct_type -> brrr_type
  | TEnum    : enum_type -> brrr_type
\end{verbatim}

This reduces Z3 complexity from $27^3 = 19{,}683$ to $12^3 = 1{,}728$ case combinations,
making all transitivity lemmas (\texttt{type\_eq\_trans}, \texttt{subtype\_trans}) provable
without admits. Convenience aliases (\texttt{t\_unit}, \texttt{t\_bool}, \texttt{t\_i32}, etc.)
preserve ergonomic type construction.
\end{remark}


%=============================================================================
% PART II: TYPE SYSTEM
%=============================================================================
\part{Type System}

\chapter{Effect Algebra}

The effect system is grounded in algebraic structure: a bounded join-semilattice with row polymorphism.

\section{Effect Semilattice}

\begin{definition}[Effect Semilattice]
The effect algebra is a tuple $(\Eff, \effjoin, \Pure)$ where:
\begin{itemize}
  \item $\Eff$ is the set of effect rows
  \item $\effjoin : \Eff \times \Eff \to \Eff$ is the join operation
  \item $\Pure \in \Eff$ is the unit (pure/empty effect)
\end{itemize}
satisfying the semilattice laws.
\end{definition}

\begin{theorem}[Semilattice Laws]
For all $\varepsilon, \varepsilon_1, \varepsilon_2, \varepsilon_3 \in \Eff$:
\begin{align}
  \varepsilon \effjoin \varepsilon &= \varepsilon & \text{(Idempotent)} \\
  \varepsilon_1 \effjoin \varepsilon_2 &= \varepsilon_2 \effjoin \varepsilon_1 & \text{(Commutative)} \\
  (\varepsilon_1 \effjoin \varepsilon_2) \effjoin \varepsilon_3 &= \varepsilon_1 \effjoin (\varepsilon_2 \effjoin \varepsilon_3) & \text{(Associative)} \\
  \Pure \effjoin \varepsilon &= \varepsilon & \text{(Identity)}
\end{align}
\end{theorem}

\begin{definition}[Effect Subtyping]
The effect ordering is derived from the semilattice:
\[
  \varepsilon_1 \effsub \varepsilon_2 \iff \varepsilon_1 \effjoin \varepsilon_2 = \varepsilon_2
\]
Equivalently: $\varepsilon_1 \effsub \varepsilon_2$ iff $\varepsilon_2$ has at least the effects of $\varepsilon_1$.
\end{definition}

\begin{lemma}[Derived Order Properties]
\begin{align}
  \varepsilon &\effsub \varepsilon & \text{(Reflexive)} \\
  \varepsilon_1 \effsub \varepsilon_2 \land \varepsilon_2 \effsub \varepsilon_3 &\implies \varepsilon_1 \effsub \varepsilon_3 & \text{(Transitive)} \\
  \Pure &\effsub \varepsilon & \text{(Pure is bottom)} \\
  \varepsilon_1 &\effsub \varepsilon_1 \effjoin \varepsilon_2 & \text{(Join upper bound)}
\end{align}
\end{lemma}

\section{Effect Row Syntax}

\begin{definition}[Effect Row Grammar]
\begin{align*}
  \varepsilon &::= \Pure & \text{(pure effect)} \\
    &\mid \rowext{E}{\varepsilon} & \text{(effect extension)} \\
    &\mid \rho & \text{(effect variable)} \\[1em]
  E &::= \EThrow{\tau} & \text{(exception)} \\
    &\mid \EPanic & \text{(panic/abort)} \\
    &\mid \EIO & \text{(I/O)} \\
    &\mid \EAsync & \text{(async)} \\
    &\mid \EAlloc & \text{(allocation)} \\
    &\mid \ERead & \text{(memory read)} \\
    &\mid \EWrite & \text{(memory write)} \\
    &\mid \EDiverge & \text{(divergence)}
\end{align*}
\end{definition}

\begin{definition}[Row Equivalence]
Effect rows are equivalent modulo:
\begin{align}
  \rowext{E_1}{\rowext{E_2}{\varepsilon}} &\equiv \rowext{E_2}{\rowext{E_1}{\varepsilon}} & \text{(Row-Comm)} \\
  \rowext{E}{\rowext{E}{\varepsilon}} &\equiv \rowext{E}{\varepsilon} & \text{(Row-Idem)}
\end{align}
\end{definition}

\section{Graded Monad Structure}

\begin{definition}[Graded Monad]
The computation type $\tau \at \varepsilon$ (type $\tau$ with effect $\varepsilon$) forms a graded monad $T_\varepsilon$ with:
\begin{align*}
  \eta_\Pure &: \tau \to T_\Pure[\tau] \\
  \mu_{\varepsilon_1, \varepsilon_2} &: T_{\varepsilon_1}[T_{\varepsilon_2}[\tau]] \to T_{\varepsilon_1 \effjoin \varepsilon_2}[\tau]
\end{align*}
\end{definition}

\begin{theorem}[Graded Monad Laws]
\begin{align}
  \mu \circ T_{\varepsilon_1}[\eta] &= \mathsf{id} & \text{(GM-Right)} \\
  \mu \circ \eta &= \mathsf{id} & \text{(GM-Left)} \\
  \mu \circ \mu &= \mu \circ T[\mu] & \text{(GM-Assoc)}
\end{align}
with effect indices properly tracked.
\end{theorem}

\section{Effect Typing Rules}

\begin{definition}[Effectful Function Type]
\[
  \tau_1 \xrightarrow{\varepsilon} \tau_2 \triangleq \tau_1 \to T_\varepsilon[\tau_2]
\]
\end{definition}

\begin{definition}[Effect Typing Judgment]
The judgment $\env \types e : \tau \; [\varepsilon]$ means:
\begin{quote}
  Under context $\env$, expression $e$ has type $\tau$ and may perform effects in $\varepsilon$.
\end{quote}
\end{definition}

\begin{definition}[Core Effect Typing Rules]
\begin{mathpar}
  \inferrule*[right=E-Pure]
    {\env \types e : \tau \; [\Pure]}
    {\env \types e : \tau \; [\varepsilon]}
  \and
  \inferrule*[right=E-Sub]
    {\env \types e : \tau \; [\varepsilon_1] \\ \varepsilon_1 \effsub \varepsilon_2}
    {\env \types e : \tau \; [\varepsilon_2]}
  \and
  \inferrule*[right=E-Seq]
    {\env \types e_1 : \tau_1 \; [\varepsilon_1] \\ \env \types e_2 : \tau_2 \; [\varepsilon_2]}
    {\env \types e_1; e_2 : \tau_2 \; [\varepsilon_1 \effjoin \varepsilon_2]}
  \and
  \inferrule*[right=E-App]
    {\env \types e_1 : \tau_1 \xrightarrow{\varepsilon_f} \tau_2 \; [\varepsilon_1] \\
     \env \types e_2 : \tau_1 \; [\varepsilon_2]}
    {\env \types e_1 \; e_2 : \tau_2 \; [\varepsilon_1 \effjoin \varepsilon_2 \effjoin \varepsilon_f]}
\end{mathpar}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Effect Algebra in F*}]
module BrrrSemantics.Effects

(* Effect labels *)
type effect_label =
  | EThrow  : brrr_type -> effect_label  (* Exception with type *)
  | EPanic  : effect_label
  | EIO     : effect_label
  | EAsync  : effect_label
  | EAlloc  : effect_label
  | ERead   : effect_label
  | EWrite  : effect_label
  | EDiv    : effect_label

(* Effect row - set-like with variable *)
noeq type effect_row =
  | Pure    : effect_row                          (* Bottom: no effects *)
  | Extend  : effect_label -> effect_row -> effect_row  (* Extension *)
  | Var     : string -> effect_row                (* Polymorphic variable *)

(* Membership check *)
let rec has_effect (e:effect_label) (row:effect_row) : bool =
  match row with
  | Pure -> false
  | Extend e' rest -> e = e' || has_effect e rest
  | Var _ -> true  (* Variables may contain any effect *)

(* Effect join (union) *)
let rec effect_join (r1 r2:effect_row) : effect_row =
  match r1 with
  | Pure -> r2
  | Var v -> Var v  (* Variable absorbs *)
  | Extend e rest ->
      if has_effect e r2
      then effect_join rest r2  (* Idempotent: skip duplicate *)
      else Extend e (effect_join rest r2)

(* Effect subtyping: e1 <= e2 iff join e1 e2 = e2 *)
let effect_sub (e1 e2:effect_row) : bool =
  effect_join e1 e2 = e2

(* Semilattice laws *)

(* Idempotent: e ⊔ e = e *)
val join_idempotent: e:effect_row ->
  Lemma (effect_join e e = e) [SMTPat (effect_join e e)]
let rec join_idempotent e = match e with
  | Pure -> ()
  | Var _ -> ()
  | Extend l rest -> join_idempotent rest

(* Commutative: e1 ⊔ e2 = e2 ⊔ e1 *)
val join_comm: e1:effect_row -> e2:effect_row ->
  Lemma (effect_join e1 e2 = effect_join e2 e1)
let join_comm e1 e2 = admit() (* Requires careful proof *)

(* Identity: Pure ⊔ e = e *)
val join_identity: e:effect_row ->
  Lemma (effect_join Pure e = e) [SMTPat (effect_join Pure e)]
let join_identity e = ()

(* Pure is bottom *)
val pure_is_bottom: e:effect_row ->
  Lemma (effect_sub Pure e) [SMTPat (effect_sub Pure e)]
let pure_is_bottom e = join_identity e

(* Graded monad type *)
noeq type comp (a:Type) (eff:effect_row) =
  | MkComp : (unit -> a) -> comp a eff

(* Return (pure) *)
let return (#a:Type) (x:a) : comp a Pure =
  MkComp (fun () -> x)

(* Bind with effect join *)
let bind (#a #b:Type) (#e1 #e2:effect_row)
         (m:comp a e1) (f:a -> comp b e2)
         : comp b (effect_join e1 e2) =
  match m with
  | MkComp run_m ->
      MkComp (fun () ->
        let x = run_m () in
        match f x with
        | MkComp run_f -> run_f ())
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Algebraic Effect Handlers}

\section{Effect Signatures}

\begin{definition}[Effect Signature]
An effect signature declares operations with their types:
\[
  \mathsf{effect} \; E \; \{ \; \mathsf{op}_1 : \tau_1 \rightsquigarrow \sigma_1, \; \ldots, \; \mathsf{op}_n : \tau_n \rightsquigarrow \sigma_n \; \}
\]
where $\mathsf{op}_i : \tau_i \rightsquigarrow \sigma_i$ means operation $\mathsf{op}_i$ takes argument of type $\tau_i$ and returns $\sigma_i$.
\end{definition}

\begin{example}[Standard Effect Signatures]
\begin{align*}
  &\mathsf{effect} \; \mathsf{Exception}[E] \; \{ \\
  &\quad \mathsf{throw} : E \rightsquigarrow \TNever \\
  &\} \\[1em]
  &\mathsf{effect} \; \mathsf{State}[S] \; \{ \\
  &\quad \mathsf{get} : \TUnit \rightsquigarrow S \\
  &\quad \mathsf{put} : S \rightsquigarrow \TUnit \\
  &\} \\[1em]
  &\mathsf{effect} \; \mathsf{Async} \; \{ \\
  &\quad \mathsf{await} : \mathsf{Future}[\tau] \rightsquigarrow \tau \\
  &\quad \mathsf{spawn} : (\TUnit \xrightarrow{[\EAsync]} \tau) \rightsquigarrow \mathsf{Future}[\tau] \\
  &\}
\end{align*}
\end{example}

\section{Handler Definition}

\begin{definition}[Effect Handler]
A handler for effect $E$ with operations $\{\mathsf{op}_i\}$ is:
\[
  \mathsf{handle} \; e \; \mathsf{with} \; \{
    \mathsf{return} \; x \Rightarrow e_r, \;
    \mathsf{op}_1(x, k) \Rightarrow e_1, \;
    \ldots
  \}
\]
where $k$ is the continuation.
\end{definition}

\begin{definition}[Handler Typing]
\begin{mathpar}
  \inferrule*[right=T-Handle]
    {\env \types e : \tau \; [\rowext{E}{\varepsilon}] \\
     \env, x : \tau \types e_r : \sigma \; [\varepsilon'] \\
     \forall i.\; \env, x_i : \tau_i, k_i : \sigma_i \to \sigma \; [\varepsilon'] \types e_i : \sigma \; [\varepsilon']}
    {\env \types \mathsf{handle} \; e \; \mathsf{with} \; H : \sigma \; [\varepsilon \effjoin \varepsilon']}
\end{mathpar}
\end{definition}

\section{Continuation Linearity}

\begin{definition}[Continuation Modes]
\begin{itemize}
  \item \textbf{One-shot} (default): Continuation $k$ can be called at most once. Linear resource.
  \item \textbf{Multi-shot}: Continuation $k$ can be called multiple times. Requires copying.
\end{itemize}
\end{definition}

\begin{definition}[Linearity Constraint]
For one-shot handlers, the continuation $k$ has linear type:
\[
  k : \sigma_i \lolli \sigma \; [\varepsilon']
\]
For multi-shot handlers:
\[
  k : \sigma_i \to \sigma \; [\varepsilon']
\]
\end{definition}

\section{Handler Semantics}

\begin{definition}[Operational Semantics]
\begin{align*}
  &\mathsf{handle} \; v \; \mathsf{with} \; H \longrightarrow e_r[x := v] \\
  &\mathsf{handle} \; E[\mathsf{op}(v)] \; \mathsf{with} \; H \longrightarrow
    e_{\mathsf{op}}[x := v, k := \lambda y.\, \mathsf{handle} \; E[y] \; \mathsf{with} \; H]
\end{align*}
where $E$ is an evaluation context not containing handlers for $\mathsf{op}$.
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Effect Handlers in F*}]
module BrrrSemantics.Handlers

open BrrrSemantics.Effects

(* Continuation type - parameterized by linearity *)
type linearity = | OneShot | MultiShot

(* Operation signature *)
noeq type op_sig = {
  op_name : string;
  arg_type : brrr_type;
  ret_type : brrr_type
}

(* Effect signature *)
noeq type effect_sig = {
  eff_name : string;
  operations : list op_sig
}

(* Handler clause *)
noeq type handler_clause (a:Type) (b:Type) =
  | ReturnClause : (a -> b) -> handler_clause a b
  | OpClause : op_sig ->
               (arg:Type) -> (ret:Type) ->
               (arg -> (ret -> b) -> b) ->  (* op handler with continuation *)
               handler_clause a b

(* Full handler *)
noeq type handler (a:Type) (b:Type) = {
  return_clause : a -> b;
  op_clauses : list (handler_clause a b);
  cont_linearity : linearity
}

(* Free monad for effects *)
noeq type free (eff:effect_sig) (a:Type) =
  | Pure : a -> free eff a
  | Impure : op:op_sig{List.mem op eff.operations} ->
             arg:Type ->
             (ret:Type -> free eff a) ->
             free eff a

(* Handle operation *)
let rec handle_free (#eff:effect_sig) (#a #b:Type)
                    (h:handler a b) (m:free eff a) : b =
  match m with
  | Pure x -> h.return_clause x
  | Impure op arg cont ->
      (* Find matching operation clause *)
      let clause = find_op_clause op h.op_clauses in
      match clause with
      | Some (OpClause _ _ _ handler_fn) ->
          handler_fn arg (fun ret -> handle_free h (cont ret))
      | None ->
          (* Forward unhandled operation - would need outer handler *)
          admit()

and find_op_clause (op:op_sig) (clauses:list (handler_clause 'a 'b))
    : option (handler_clause 'a 'b) =
  match clauses with
  | [] -> None
  | OpClause op' _ _ _ :: rest ->
      if op.op_name = op'.op_name then Some (OpClause op' _ _ _)
      else find_op_clause op rest
  | _ :: rest -> find_op_clause op rest

(* Example: Exception effect *)
let exception_sig : effect_sig = {
  eff_name = "Exception";
  operations = [{op_name = "throw"; arg_type = TAny; ret_type = TNever}]
}

(* Example: State effect *)
let state_sig (s:brrr_type) : effect_sig = {
  eff_name = "State";
  operations = [
    {op_name = "get"; arg_type = TUnit; ret_type = s};
    {op_name = "put"; arg_type = s; ret_type = TUnit}
  ]
}

(* Run state handler *)
let run_state (#a:Type) (#s:Type) (init:s)
              (m:free (state_sig (TInt I32 Signed)) a) : a & s =
  let h : handler a (s -> a & s) = {
    return_clause = (fun x -> fun st -> (x, st));
    op_clauses = [
      OpClause {op_name="get"; arg_type=TUnit; ret_type=TInt I32 Signed}
               unit s
               (fun () k -> fun st -> k st st);
      OpClause {op_name="put"; arg_type=TInt I32 Signed; ret_type=TUnit}
               s unit
               (fun new_st k -> fun _ -> k () new_st)
    ];
    cont_linearity = OneShot
  } in
  handle_free h m init
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Type Polymorphism}

\section{Parametric Polymorphism}

\begin{definition}[Universal Type]
\[
  \forall \alpha : \kappa.\, \tau
\]
where $\alpha$ is a type variable of kind $\kappa$.
\end{definition}

\begin{definition}[Polymorphic Typing Rules]
\begin{mathpar}
  \inferrule*[right=T-TAbs]
    {\env, \alpha : \kappa \types e : \tau \; [\varepsilon]}
    {\env \types \Lambda \alpha : \kappa.\, e : \forall \alpha : \kappa.\, \tau \; [\varepsilon]}
  \and
  \inferrule*[right=T-TApp]
    {\env \types e : \forall \alpha : \kappa.\, \tau \; [\varepsilon] \\ \env \types \sigma : \kappa}
    {\env \types e\,[\sigma] : \tau[\alpha := \sigma] \; [\varepsilon]}
\end{mathpar}
\end{definition}

\section{Row Polymorphism}

\begin{definition}[Row-Polymorphic Function]
A function polymorphic in its effect row:
\[
  \forall \rho.\, \tau_1 \xrightarrow{\rowext{E}{\rho}} \tau_2
\]
\end{definition}

\begin{example}[Row-Polymorphic Map]
\[
  \mathsf{map} : \forall \alpha \beta \rho.\, (\alpha \xrightarrow{\rho} \beta) \to \TArray[\alpha] \xrightarrow{\rho} \TArray[\beta]
\]
The function $\mathsf{map}$ preserves whatever effects $f$ has.
\end{example}

\section{Higher-Kinded Types}

\begin{definition}[Kind System]
\begin{align*}
  \kappa &::= \star & \text{(type)} \\
    &\mid \kappa_1 \to \kappa_2 & \text{(type constructor)} \\
    &\mid \mathsf{Row} & \text{(effect row)} \\
    &\mid \mathsf{Region} & \text{(lifetime/region)}
\end{align*}
\end{definition}

\begin{example}[Higher-Kinded Functor]
\[
  \mathsf{Functor} : (\star \to \star) \to \star
\]
\[
  \mathsf{fmap} : \forall F : \star \to \star.\, \mathsf{Functor}[F] \Rightarrow
    \forall \alpha \beta.\, (\alpha \to \beta) \to F[\alpha] \to F[\beta]
\]
\end{example}

\section{Variance}

\begin{definition}[Variance Annotations]
\begin{itemize}
  \item \textbf{Covariant} ($+$): $\tau_1 \subtype \tau_2 \implies F[\tau_1] \subtype F[\tau_2]$
  \item \textbf{Contravariant} ($-$): $\tau_1 \subtype \tau_2 \implies F[\tau_2] \subtype F[\tau_1]$
  \item \textbf{Invariant} ($\circ$): No subtyping relationship derived
  \item \textbf{Bivariant} ($\pm$): Both directions hold
\end{itemize}
\end{definition}

\begin{theorem}[Function Variance]
For function types $\tau_1 \xrightarrow{\varepsilon} \tau_2$:
\begin{itemize}
  \item Contravariant in $\tau_1$ (argument)
  \item Covariant in $\tau_2$ (result)
  \item Covariant in $\varepsilon$ (effect)
\end{itemize}
\end{theorem}

\section{F* Mechanization}

\begin{fstarcode}[title={Polymorphism in F*}]
module BrrrSemantics.Polymorphism

(* Kind *)
type kind =
  | KStar   : kind                    (* Types *)
  | KArrow  : kind -> kind -> kind    (* Type constructors *)
  | KRow    : kind                    (* Effect rows *)
  | KRegion : kind                    (* Lifetimes *)

(* Type with kind annotation *)
noeq type kinded_type =
  | KTVar   : string -> kind -> kinded_type
  | KTApp   : kinded_type -> kinded_type -> kinded_type
  | KTArrow : kinded_type -> kinded_type -> effect_row -> kinded_type
  | KTForall: string -> kind -> kinded_type -> kinded_type

(* Kind checking *)
let rec kind_of (ctx:list (string & kind)) (t:kinded_type) : option kind =
  match t with
  | KTVar v k ->
      if List.mem (v, k) ctx then Some k else None
  | KTApp f arg ->
      (match kind_of ctx f, kind_of ctx arg with
       | Some (KArrow k1 k2), Some k1' ->
           if k1 = k1' then Some k2 else None
       | _ -> None)
  | KTArrow t1 t2 _ ->
      (match kind_of ctx t1, kind_of ctx t2 with
       | Some KStar, Some KStar -> Some KStar
       | _ -> None)
  | KTForall v k body ->
      kind_of ((v, k) :: ctx) body

(* Variance *)
type variance = | Covariant | Contravariant | Invariant | Bivariant

(* Combine variances *)
let combine_variance (v1 v2:variance) : variance =
  match v1, v2 with
  | Bivariant, _ -> Bivariant
  | _, Bivariant -> Bivariant
  | Invariant, _ -> Invariant
  | _, Invariant -> Invariant
  | Covariant, Covariant -> Covariant
  | Contravariant, Contravariant -> Covariant
  | Covariant, Contravariant -> Contravariant
  | Contravariant, Covariant -> Contravariant

(* Flip variance (for contravariant positions) *)
let flip_variance (v:variance) : variance =
  match v with
  | Covariant -> Contravariant
  | Contravariant -> Covariant
  | _ -> v

(* Variance of type variable in type *)
let rec variance_of (v:string) (t:kinded_type) : variance =
  match t with
  | KTVar v' _ -> if v = v' then Covariant else Bivariant
  | KTApp f arg ->
      combine_variance (variance_of v f) (variance_of v arg)
  | KTArrow t1 t2 _ ->
      combine_variance
        (flip_variance (variance_of v t1))  (* Contravariant in arg *)
        (variance_of v t2)                   (* Covariant in result *)
  | KTForall _ _ body -> variance_of v body

(* Example: Option is covariant *)
let option_variance : variance = Covariant

(* Example: Function argument is contravariant *)
let func_arg_variance : variance = Contravariant
\end{fstarcode}


%=============================================================================
% PART III: OWNERSHIP & MEMORY
%=============================================================================
\part{Ownership \& Memory}

\chapter{Mode Semiring}

This chapter grounds ownership in linear logic's resource algebra, replacing ad-hoc Rust-inspired modes with a principled mode semiring.

\section{Mode Definition}

\begin{definition}[Mode Semiring]
The mode semiring $(M, +, \cdot, \mzero, \mone)$ consists of:
\begin{itemize}
  \item $M = \{\mzero, \mone, \momega\}$ (absent, linear, unrestricted)
  \item $+$ : mode addition (parallel use)
  \item $\cdot$ : mode multiplication (sequential use)
  \item $\mzero$ : additive identity (absent)
  \item $\mone$ : multiplicative identity (linear)
\end{itemize}
\end{definition}

\begin{definition}[Mode Operations]
\[
\begin{array}{c|ccc}
  + & \mzero & \mone & \momega \\
  \hline
  \mzero & \mzero & \mone & \momega \\
  \mone & \mone & \momega & \momega \\
  \momega & \momega & \momega & \momega
\end{array}
\qquad
\begin{array}{c|ccc}
  \cdot & \mzero & \mone & \momega \\
  \hline
  \mzero & \mzero & \mzero & \mzero \\
  \mone & \mzero & \mone & \momega \\
  \momega & \mzero & \momega & \momega
\end{array}
\]
\end{definition}

\begin{theorem}[Semiring Laws]
For all $m, m_1, m_2, m_3 \in M$:
\begin{align}
  \mzero + m &= m & \text{(additive identity)} \\
  m_1 + m_2 &= m_2 + m_1 & \text{(additive commutativity)} \\
  (m_1 + m_2) + m_3 &= m_1 + (m_2 + m_3) & \text{(additive associativity)} \\
  \mone \cdot m &= m & \text{(multiplicative identity)} \\
  \mzero \cdot m &= \mzero & \text{(multiplicative absorption)} \\
  m_1 \cdot (m_2 + m_3) &= m_1 \cdot m_2 + m_1 \cdot m_3 & \text{(distributivity)}
\end{align}
\end{theorem}

\begin{definition}[Mode Ordering]
The subusage ordering:
\[
  \mzero \leq \mone \leq \momega
\]
Interpretation: $m_1 \leq m_2$ means mode $m_1$ can be weakened to $m_2$.
\end{definition}

\section{Extended Mode Lattice}

\begin{definition}[Extended Modes]
For practical use, we extend with affine and relevant modes:
\[
  M_{\mathsf{ext}} = \{\mzero, \mone, \maffine, \mrelevant, \momega\}
\]
with lattice structure:
\[
\begin{tikzcd}[row sep=small, column sep=small]
  & \momega & \\
  \maffine \arrow[ur] & & \mrelevant \arrow[ul] \\
  & \mone \arrow[ul] \arrow[ur] & \\
  & \mzero \arrow[u] &
\end{tikzcd}
\]
\end{definition}

\begin{definition}[Mode Semantics]
\begin{itemize}
  \item $\mzero$ (absent): Cannot be used
  \item $\mone$ (linear): Must be used exactly once
  \item $\maffine$: May be used at most once (drop allowed)
  \item $\mrelevant$: Must be used at least once (copy allowed)
  \item $\momega$ (unrestricted): Any number of uses
\end{itemize}
\end{definition}

\section{Type-with-Mode Syntax}

\begin{definition}[Mode-Annotated Type]
\[
  \tau \at m
\]
denotes type $\tau$ with usage mode $m$.
\end{definition}

\begin{example}[Mode Annotations]
\begin{align*}
  \TString \at \mone &\quad \text{(linear string, must use once)} \\
  \TInt \at \momega &\quad \text{(unrestricted int, can copy)} \\
  \mathsf{Handle} \at \maffine &\quad \text{(affine handle, must close or drop)}
\end{align*}
\end{example}

\section{F* Mechanization}

\begin{fstarcode}[title={Mode Semiring in F*}]
module BrrrSemantics.Modes

(* Core modes *)
type mode =
  | MZero   : mode    (* 0: absent, cannot use *)
  | MOne    : mode    (* 1: linear, use exactly once *)
  | MOmega  : mode    (* ω: unrestricted, use any number *)

(* Extended modes *)
type mode_ext =
  | MZeroE    : mode_ext
  | MOneE     : mode_ext
  | MAffine   : mode_ext    (* use at most once *)
  | MRelevant : mode_ext    (* use at least once *)
  | MOmegaE   : mode_ext

(* Mode addition (parallel composition) *)
let mode_add (m1 m2:mode) : mode =
  match m1, m2 with
  | MZero, m -> m
  | m, MZero -> m
  | MOne, MOne -> MOmega
  | MOmega, _ -> MOmega
  | _, MOmega -> MOmega

(* Mode multiplication (sequential composition) *)
let mode_mul (m1 m2:mode) : mode =
  match m1, m2 with
  | MZero, _ -> MZero
  | _, MZero -> MZero
  | MOne, m -> m
  | m, MOne -> m
  | MOmega, MOmega -> MOmega

(* Mode ordering (can weaken m1 to m2) *)
let mode_leq (m1 m2:mode) : bool =
  match m1, m2 with
  | MZero, _ -> true
  | MOne, MOne -> true
  | MOne, MOmega -> true
  | MOmega, MOmega -> true
  | _, _ -> false

(* Semiring law proofs *)

(* Additive identity: 0 + m = m *)
val add_identity: m:mode -> Lemma (mode_add MZero m = m)
let add_identity m = ()

(* Additive commutativity: m1 + m2 = m2 + m1 *)
val add_comm: m1:mode -> m2:mode -> Lemma (mode_add m1 m2 = mode_add m2 m1)
let add_comm m1 m2 = ()

(* Multiplicative identity: 1 * m = m *)
val mul_identity: m:mode -> Lemma (mode_mul MOne m = m)
let mul_identity m = ()

(* Multiplicative absorption: 0 * m = 0 *)
val mul_absorb: m:mode -> Lemma (mode_mul MZero m = MZero)
let mul_absorb m = ()

(* Distributivity: m1 * (m2 + m3) = m1*m2 + m1*m3 *)
val distributive: m1:mode -> m2:mode -> m3:mode ->
  Lemma (mode_mul m1 (mode_add m2 m3) = mode_add (mode_mul m1 m2) (mode_mul m1 m3))
let distributive m1 m2 m3 =
  match m1, m2, m3 with
  | MZero, _, _ -> ()
  | _, MZero, _ -> ()
  | _, _, MZero -> ()
  | MOne, MOne, MOne -> ()
  | MOne, MOne, MOmega -> ()
  | MOne, MOmega, MOne -> ()
  | MOne, MOmega, MOmega -> ()
  | MOmega, _, _ -> ()

(* Type with mode *)
noeq type moded_type = {
  ty   : brrr_type;
  mode : mode
}

(* Context is list of moded bindings *)
type moded_ctx = list (string & moded_type)

(* Split context for linear typing *)
let rec ctx_split (ctx:moded_ctx) : option (moded_ctx & moded_ctx) =
  match ctx with
  | [] -> Some ([], [])
  | (x, {ty; mode=MZero}) :: rest ->
      (match ctx_split rest with
       | Some (l, r) -> Some ((x, {ty; mode=MZero}) :: l,
                              (x, {ty; mode=MZero}) :: r)
       | None -> None)
  | (x, {ty; mode=MOne}) :: rest ->
      (match ctx_split rest with
       | Some (l, r) ->
           (* Linear: goes to exactly one side *)
           Some ((x, {ty; mode=MOne}) :: l, r)  (* or (l, (x,{ty;mode=MOne})::r) *)
       | None -> None)
  | (x, {ty; mode=MOmega}) :: rest ->
      (match ctx_split rest with
       | Some (l, r) -> Some ((x, {ty; mode=MOmega}) :: l,
                              (x, {ty; mode=MOmega}) :: r)
       | None -> None)
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Linear Type System}

\section{Linear Typing Judgment}

\begin{definition}[Linear Context]
A linear context $\env$ maps variables to mode-annotated types:
\[
  \env = x_1 : \tau_1 \at m_1, \ldots, x_n : \tau_n \at m_n
\]
\end{definition}

\begin{definition}[Context Operations]
\begin{itemize}
  \item \textbf{Addition}: $\env_1 + \env_2$ adds modes pointwise
  \item \textbf{Scaling}: $m \cdot \env$ multiplies all modes by $m$
  \item \textbf{Split}: $\env = \env_1 + \env_2$ for parallel use
\end{itemize}
\end{definition}

\begin{definition}[Linear Typing Rules]
\begin{mathpar}
  \inferrule*[right=L-Var]
    { }
    {x : \tau \at \mone \types x : \tau \; [\Pure]}
  \and
  \inferrule*[right=L-Weaken]
    {\env \types e : \sigma \; [\varepsilon] \\ m \geq \momega}
    {\env, x : \tau \at m \types e : \sigma \; [\varepsilon]}
  \and
  \inferrule*[right=L-Contract]
    {\env, x : \tau \at \momega, y : \tau \at \momega \types e : \sigma \; [\varepsilon]}
    {\env, z : \tau \at \momega \types e[z/x, z/y] : \sigma \; [\varepsilon]}
  \and
  \inferrule*[right=L-Abs]
    {\env, x : \tau_1 \at m \types e : \tau_2 \; [\varepsilon]}
    {\env \types \lambda x.\, e : (\tau_1 \at m) \xrightarrow{\varepsilon} \tau_2 \; [\Pure]}
  \and
  \inferrule*[right=L-App]
    {\env_1 \types e_1 : (\tau_1 \at m) \xrightarrow{\varepsilon_f} \tau_2 \; [\varepsilon_1] \\
     \env_2 \types e_2 : \tau_1 \; [\varepsilon_2]}
    {\env_1 + \env_2 \types e_1 \; e_2 : \tau_2 \; [\varepsilon_1 \effjoin \varepsilon_2 \effjoin \varepsilon_f]}
  \and
  \inferrule*[right=L-Pair]
    {\env_1 \types e_1 : \tau_1 \; [\varepsilon_1] \\ \env_2 \types e_2 : \tau_2 \; [\varepsilon_2]}
    {\env_1 + \env_2 \types (e_1, e_2) : \tau_1 \tensor \tau_2 \; [\varepsilon_1 \effjoin \varepsilon_2]}
  \and
  \inferrule*[right=L-LetPair]
    {\env_1 \types e_1 : \tau_1 \tensor \tau_2 \; [\varepsilon_1] \\
     \env_2, x : \tau_1 \at \mone, y : \tau_2 \at \mone \types e_2 : \sigma \; [\varepsilon_2]}
    {\env_1 + \env_2 \types \mathsf{let}\, (x, y) = e_1 \;\mathsf{in}\; e_2 : \sigma \; [\varepsilon_1 \effjoin \varepsilon_2]}
\end{mathpar}
\end{definition}

\section{Exponential Modality}

\begin{definition}[Exponential Type]
The exponential $\bang \tau$ internalizes unrestricted use:
\[
  \bang \tau \cong \tau \at \momega
\]
\end{definition}

\begin{definition}[Exponential Typing Rules]
\begin{mathpar}
  \inferrule*[right=L-Promote]
    {\bang\env \types e : \tau \; [\varepsilon]}
    {\bang\env \types \bang e : \bang\tau \; [\varepsilon]}
  \and
  \inferrule*[right=L-Derelict]
    {\env \types e : \bang\tau \; [\varepsilon]}
    {\env \types \mathsf{derelict}(e) : \tau \; [\varepsilon]}
\end{mathpar}
where $\bang\env$ means all variables in $\env$ have mode $\momega$.
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Linear Type System in F*}]
module BrrrSemantics.Linear

open BrrrSemantics.Modes
open BrrrSemantics.Effects

(* Expression AST *)
noeq type expr =
  | EVar    : string -> expr
  | ELam    : string -> moded_type -> expr -> expr
  | EApp    : expr -> expr -> expr
  | EPair   : expr -> expr -> expr
  | ELetPair: string -> string -> expr -> expr -> expr
  | EBang   : expr -> expr           (* Promote to exponential *)
  | EDerelict: expr -> expr          (* Use exponential once *)
  | EUnit   : expr
  | ELit    : base_val -> expr

(* Typing result *)
type typing_result =
  | TyOk    : brrr_type -> effect_row -> moded_ctx -> typing_result
  | TyError : string -> typing_result

(* Context addition - pointwise mode addition *)
let rec ctx_add (c1 c2:moded_ctx) : option moded_ctx =
  match c1, c2 with
  | [], [] -> Some []
  | (x1, t1) :: r1, (x2, t2) :: r2 ->
      if x1 = x2 && t1.ty = t2.ty then
        match ctx_add r1 r2 with
        | Some rest -> Some ((x1, {ty=t1.ty; mode=mode_add t1.mode t2.mode}) :: rest)
        | None -> None
      else None
  | _, _ -> None

(* Check if context is all omega (for promotion) *)
let rec ctx_all_omega (ctx:moded_ctx) : bool =
  match ctx with
  | [] -> true
  | (_, {mode=MOmega}) :: rest -> ctx_all_omega rest
  | _ -> false

(* Check if variable is used (mode > 0) *)
let is_used (m:mode) : bool = m <> MZero

(* Linear type checking *)
let rec typecheck (ctx:moded_ctx) (e:expr) : typing_result =
  match e with
  | EVar x ->
      (match List.assoc x ctx with
       | Some {ty; mode} ->
           if is_used mode then
             (* Use variable: subtract one use *)
             let ctx' = List.map (fun (y, t) ->
               if y = x then (y, {t with mode =
                 match t.mode with
                 | MOne -> MZero
                 | MOmega -> MOmega
                 | _ -> MZero})
               else (y, t)) ctx in
             TyOk ty Pure ctx'
           else TyError ("Variable " ^ x ^ " not available")
       | None -> TyError ("Unbound variable " ^ x))

  | ELam x param_ty body ->
      let extended_ctx = (x, param_ty) :: ctx in
      (match typecheck extended_ctx body with
       | TyOk ret_ty eff ctx' ->
           (* Check x was used according to its mode *)
           let func_ty = TFunc param_ty.ty ret_ty eff in
           TyOk func_ty Pure ctx
       | err -> err)

  | EApp f arg ->
      (match typecheck ctx f with
       | TyOk (TFunc arg_ty ret_ty eff_f) eff1 ctx1 ->
           (match typecheck ctx1 arg with
            | TyOk arg_ty' eff2 ctx2 ->
                if subtype arg_ty' arg_ty then
                  TyOk ret_ty (effect_join eff1 (effect_join eff2 eff_f)) ctx2
                else TyError "Argument type mismatch"
            | err -> err)
       | TyOk _ _ _ -> TyError "Not a function"
       | err -> err)

  | EPair e1 e2 ->
      (match typecheck ctx e1 with
       | TyOk t1 eff1 ctx1 ->
           (match typecheck ctx1 e2 with
            | TyOk t2 eff2 ctx2 ->
                TyOk (TPair t1 t2) (effect_join eff1 eff2) ctx2
            | err -> err)
       | err -> err)

  | EBang inner ->
      if ctx_all_omega ctx then
        match typecheck ctx inner with
        | TyOk t eff ctx' ->
            (* Exponential: type becomes copyable *)
            TyOk t eff ctx'  (* In real impl, wrap type *)
        | err -> err
      else TyError "Cannot promote: context not all omega"

  | EUnit -> TyOk TUnit Pure ctx

  | ELit v ->
      let ty = match v with
        | VBool _ -> TBool
        | VInt _  -> TInt {width=I64; sign=Signed}
        | VFloat _ -> TFloat F64
        | VString _ -> TString
        | VUnit -> TUnit
      in TyOk ty Pure ctx

  | _ -> TyError "Not implemented"

(* Verify all linear resources consumed *)
let check_consumed (ctx:moded_ctx) : bool =
  List.for_all (fun (_, {mode}) ->
    mode = MZero || mode = MOmega) ctx
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Borrowing as Fractional Permissions}

\section{Fractional Permissions}

\begin{definition}[Permission Fraction]
A permission $p \in (0, 1]$ represents partial ownership:
\begin{itemize}
  \item $p = 1$: Full ownership (read, write, move, drop)
  \item $0 < p < 1$: Partial ownership (read only)
\end{itemize}
\end{definition}

\begin{definition}[Permission Operations]
\begin{align*}
  \mathsf{split} &: \tau \at p \to (\tau \at p/2) \tensor (\tau \at p/2) \\
  \mathsf{join} &: (\tau \at p_1) \tensor (\tau \at p_2) \to \tau \at (p_1 + p_2) \quad \text{if } p_1 + p_2 \leq 1
\end{align*}
\end{definition}

\begin{theorem}[Permission Invariant]
For any resource, the sum of all permissions equals 1:
\[
  \sum_{i} p_i = 1
\]
\end{theorem}

\section{Borrowing as Modal Operators}

\begin{definition}[Box Modality (Shared Borrow)]
$\Box\tau$ represents a frozen/borrowed reference:
\[
  \&x : \Box\tau \quad \text{(immutable borrow)}
\]
Properties:
\begin{itemize}
  \item $\Box\tau$ can be duplicated (shared borrows coexist)
  \item $\Box\tau$ provides read-only access
\end{itemize}
\end{definition}

\begin{definition}[Diamond Modality (Exclusive Borrow)]
$\Diamond\tau$ represents exclusive access:
\[
  \&\mathsf{mut}\, x : \Diamond\tau \quad \text{(mutable borrow)}
\]
Properties:
\begin{itemize}
  \item $\Diamond\tau$ is linear (exactly one holder)
  \item $\Diamond\tau$ provides read-write access
\end{itemize}
\end{definition}

\begin{definition}[Borrow Typing Rules]
\begin{mathpar}
  \inferrule*[right=T-Freeze]
    {\env \types e : \tau \at \mone \; [\varepsilon]}
    {\env \types \mathsf{freeze}(e) : \Box\tau \at \momega \; [\varepsilon]}
  \and
  \inferrule*[right=T-Read]
    {\env \types e : \Box\tau \; [\varepsilon]}
    {\env \types \mathsf{read}(e) : \tau \; [\varepsilon \effjoin \ERead]}
  \and
  \inferrule*[right=T-MutBorrow]
    {\env \types e : \tau \at \mone \; [\varepsilon] \\ \text{no other borrows of } e}
    {\env \types \&\mathsf{mut}\, e : \Diamond\tau \at \mone \; [\varepsilon]}
  \and
  \inferrule*[right=T-Write]
    {\env \types e_1 : \Diamond\tau \at \mone \; [\varepsilon_1] \\ \env \types e_2 : \tau \; [\varepsilon_2]}
    {\env \types *e_1 := e_2 : \TUnit \; [\varepsilon_1 \effjoin \varepsilon_2 \effjoin \EWrite]}
\end{mathpar}
\end{definition}

\section{Mapping to Rust-Style Syntax}

\begin{definition}[Ownership Mode Mapping]
\begin{center}
\begin{tabular}{lll}
\toprule
Brrr-Lang Mode & Linear Logic & Rust Equivalent \\
\midrule
$\own\, \tau$ & $\tau \at \mone$ & \texttt{T} (owned) \\
$\rref\, \tau$ & $\Box\tau \at \momega$ & \texttt{\&T} \\
$\rrefmut\, \tau$ & $\Diamond\tau \at \mone$ & \texttt{\&mut T} \\
$\rc\, \tau$ & $\bang(\mathsf{counted}\, \tau) \at \momega$ & \texttt{Rc<T>} \\
$\arc\, \tau$ & $\bang(\mathsf{atomic\_counted}\, \tau) \at \momega$ & \texttt{Arc<T>} \\
$\gc\, \tau$ & $\bang(\mathsf{gc\_managed}\, \tau) \at \momega$ & GC types \\
\bottomrule
\end{tabular}
\end{center}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Borrowing in F*}]
module BrrrSemantics.Borrow

open BrrrSemantics.Modes

(* Permission fraction (represented as rational) *)
type permission = { num : nat; denom : pos }

let full_perm : permission = { num = 1; denom = 1 }
let half_perm : permission = { num = 1; denom = 2 }

let perm_leq (p1 p2:permission) : bool =
  p1.num * p2.denom <= p2.num * p1.denom

let perm_add (p1 p2:permission) : permission =
  { num = p1.num * p2.denom + p2.num * p1.denom;
    denom = p1.denom * p2.denom }

let perm_half (p:permission) : permission =
  { num = p.num; denom = p.denom * 2 }

(* Borrow kind *)
type borrow_mode =
  | BShared    : permission -> borrow_mode   (* &T with fraction *)
  | BExclusive : borrow_mode                 (* &mut T *)
  | BOwned     : borrow_mode                 (* T owned *)

(* Reference type with borrow info *)
noeq type ref_type = {
  inner_ty : brrr_type;
  borrow   : borrow_mode;
  region   : string           (* Lifetime/region variable *)
}

(* Can read? *)
let can_read (b:borrow_mode) : bool = true  (* All borrows allow read *)

(* Can write? *)
let can_write (b:borrow_mode) : bool =
  match b with
  | BExclusive -> true
  | BOwned -> true
  | BShared _ -> false

(* Can share (duplicate)? *)
let can_share (b:borrow_mode) : bool =
  match b with
  | BShared _ -> true
  | _ -> false

(* Split shared borrow *)
let split_shared (p:permission) : option (permission & permission) =
  let half = perm_half p in
  Some (half, half)

(* Join shared borrows *)
let join_shared (p1 p2:permission) : option permission =
  let sum = perm_add p1 p2 in
  if perm_leq sum full_perm then Some sum
  else None  (* Would exceed full permission *)

(* Borrow checking state *)
noeq type borrow_state = {
  loans : list (string & borrow_mode);  (* Active borrows *)
}

(* Check if mutable borrow is allowed *)
let can_mut_borrow (var:string) (state:borrow_state) : bool =
  (* No existing borrows of this variable *)
  not (List.exists (fun (v, _) -> v = var) state.loans)

(* Check if shared borrow is allowed *)
let can_shared_borrow (var:string) (state:borrow_state) : bool =
  (* No exclusive borrows of this variable *)
  not (List.exists (fun (v, b) ->
    v = var && (match b with BExclusive -> true | _ -> false))
    state.loans)

(* Create shared borrow *)
let create_shared_borrow (var:string) (state:borrow_state)
    : option borrow_state =
  if can_shared_borrow var state then
    Some { loans = (var, BShared half_perm) :: state.loans }
  else None

(* Create mutable borrow *)
let create_mut_borrow (var:string) (state:borrow_state)
    : option borrow_state =
  if can_mut_borrow var state then
    Some { loans = (var, BExclusive) :: state.loans }
  else None

(* Release borrow *)
let release_borrow (var:string) (state:borrow_state) : borrow_state =
  { loans = List.filter (fun (v, _) -> v <> var) state.loans }
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Region Types and Lifetimes}

\section{Region Variables}

\begin{definition}[Region]
A region $\rho$ represents a scope during which memory is valid:
\[
  \tau \at \rho \quad \text{(type $\tau$ allocated in region $\rho$)}
\]
\end{definition}

\begin{definition}[Region Capability]
$\mathsf{cap}[\rho]$ is the capability to access region $\rho$.
\end{definition}

\begin{definition}[Region Ordering (Outlives)]
$\rho_1 \leq \rho_2$ means region $\rho_1$ outlives (includes) $\rho_2$:
\[
  \rho_1 \leq \rho_2 \implies \tau \at \rho_1 \subtype \tau \at \rho_2
\]
\end{definition}

\section{Region Typing Rules}

\begin{definition}[Region Scoping]
\begin{mathpar}
  \inferrule*[right=R-Alloc]
    {\env; \mathsf{cap}[\rho] \types e : \tau \; [\varepsilon]}
    {\env; \mathsf{cap}[\rho] \types \mathsf{new\_at}[\rho](e) : \tau \at \rho \; [\varepsilon \effjoin \EAlloc]}
  \and
  \inferrule*[right=R-LetRegion]
    {\env; \mathsf{cap}[\rho] \types e : \tau \; [\varepsilon] \\ \rho \notin \mathsf{frv}(\tau)}
    {\env \types \mathsf{letregion}\, \rho \;\mathsf{in}\; e : \tau \; [\varepsilon]}
  \and
  \inferrule*[right=R-Sub]
    {\env \types e : \tau \at \rho_1 \; [\varepsilon] \\ \rho_1 \leq \rho_2}
    {\env \types e : \tau \at \rho_2 \; [\varepsilon]}
\end{mathpar}
\end{definition}

\begin{definition}[Static Region]
$\mathsf{static}$ is the region that outlives all others:
\[
  \forall \rho.\; \mathsf{static} \leq \rho
\]
\end{definition}

\section{Lifetime-Bounded References}

\begin{definition}[Reference with Lifetime]
\[
  \rref[\rho]\, \tau \quad \text{(reference to $\tau$ valid for lifetime $\rho$)}
\]
\end{definition}

\begin{definition}[Reference Typing]
\begin{mathpar}
  \inferrule*[right=T-Ref]
    {\env \types e : \tau \at \rho \; [\varepsilon]}
    {\env \types \&e : \rref[\rho]\, \tau \; [\varepsilon]}
  \and
  \inferrule*[right=T-Deref]
    {\env; \mathsf{cap}[\rho] \types e : \rref[\rho]\, \tau \; [\varepsilon]}
    {\env; \mathsf{cap}[\rho] \types *e : \tau \; [\varepsilon \effjoin \ERead]}
\end{mathpar}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Regions and Lifetimes in F*}]
module BrrrSemantics.Regions

(* Region identifier *)
type region =
  | RStatic : region                    (* 'static - lives forever *)
  | RNamed  : string -> region          (* Named region variable *)
  | RFresh  : nat -> region             (* Fresh region from letregion *)

(* Region ordering (outlives) *)
let region_outlives (r1 r2:region) : bool =
  match r1, r2 with
  | RStatic, _ -> true                  (* Static outlives everything *)
  | RNamed a, RNamed b -> a = b         (* Same region *)
  | RFresh n1, RFresh n2 -> n1 <= n2    (* Earlier = longer lived *)
  | _, _ -> false

(* Type with region annotation *)
noeq type regioned_type = {
  base : brrr_type;
  region : region
}

(* Region capability *)
type region_cap = region

(* Region context *)
type region_ctx = list region_cap

(* Check if region is accessible *)
let has_cap (r:region) (ctx:region_ctx) : bool =
  List.mem r ctx

(* Reference type with lifetime *)
noeq type ref_with_lifetime = {
  pointee : brrr_type;
  lifetime : region;
  mutability : bool    (* true = &mut, false = & *)
}

(* Free region variables in type *)
let rec free_regions (t:brrr_type) : list region =
  match t with
  | TFunc a r _ -> free_regions a @ free_regions r
  | TOption t' -> free_regions t'
  | TArray t' -> free_regions t'
  | TPair a b -> free_regions a @ free_regions b
  | _ -> []

(* Check region escapes scope *)
let region_escapes (r:region) (t:brrr_type) : bool =
  List.mem r (free_regions t)

(* Letregion scope *)
let letregion_ok (r:region) (body_ty:brrr_type) : bool =
  not (region_escapes r body_ty)

(* Region substitution *)
let rec subst_region (old_r new_r:region) (t:brrr_type) : brrr_type =
  (* Would need regioned_type throughout - simplified here *)
  t

(* Well-formed reference: lifetime must be in scope *)
let ref_wf (ref:ref_with_lifetime) (ctx:region_ctx) : bool =
  has_cap ref.lifetime ctx

(* Subtyping with regions *)
let ref_subtype (r1 r2:ref_with_lifetime) : bool =
  r1.pointee = r2.pointee &&
  r1.mutability = r2.mutability &&
  region_outlives r1.lifetime r2.lifetime
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Separation Logic Compatibility}

\section{Separating Conjunction}

\begin{definition}[Tensor Product]
The tensor product $\tau_1 \tensor \tau_2$ represents values in disjoint memory:
\[
  \tau_1 \tensor \tau_2 \quad \text{($\tau_1$ and $\tau_2$ occupy separate resources)}
\]
\end{definition}

\begin{theorem}[Separation Property]
If $\env_1 \types e_1 : \tau_1$ and $\env_2 \types e_2 : \tau_2$ with $\env_1$ and $\env_2$ disjoint, then:
\[
  \env_1 + \env_2 \types (e_1, e_2) : \tau_1 \tensor \tau_2
\]
The values do not alias.
\end{theorem}

\section{Magic Wand}

\begin{definition}[Linear Implication]
The magic wand (linear implication) $\tau_1 \lolli \tau_2$ means:
\begin{quote}
  Given $\tau_1$, produce $\tau_2$ (consuming $\tau_1$)
\end{quote}
\end{definition}

\begin{definition}[Linear Function Typing]
\begin{mathpar}
  \inferrule*[right=T-Lolli-I]
    {\env, x : \tau_1 \at \mone \types e : \tau_2 \; [\varepsilon]}
    {\env \types \lambda x.\, e : \tau_1 \lolli \tau_2 \; [\varepsilon]}
  \and
  \inferrule*[right=T-Lolli-E]
    {\env_1 \types e_1 : \tau_1 \lolli \tau_2 \; [\varepsilon_1] \\ \env_2 \types e_2 : \tau_1 \; [\varepsilon_2]}
    {\env_1 + \env_2 \types e_1 \; e_2 : \tau_2 \; [\varepsilon_1 \effjoin \varepsilon_2]}
\end{mathpar}
\end{definition}

\section{Frame Rule}

\begin{theorem}[Frame Rule]
If $\env \types e : \tau \; [\varepsilon]$, then for any $\Delta$ disjoint from $e$'s resources:
\[
  \env, \Delta \types e : \tau \; [\varepsilon]
\]
with $\Delta$ unchanged.
\end{theorem}

This enables local reasoning about heap-manipulating programs.

\section{Ownership Predicates}

\begin{definition}[Points-To Predicate]
In separation logic style:
\begin{align*}
  x \mapsto v &\quad \text{($x$ points to value $v$, full ownership)} \\
  x \mapsto^p v &\quad \text{($x$ points to $v$ with permission $p$)}
\end{align*}
\end{definition}

\begin{definition}[Ownership Mapping]
\begin{center}
\begin{tabular}{ll}
\toprule
Brrr-Lang Type & Separation Logic \\
\midrule
$\own\, x : \tau$ & $x \mapsto v$ \\
$\rref\, x : \tau$ & $x \mapsto^{1/n} v$ (shared, read-only) \\
$\rrefmut\, x : \tau$ & $x \mapsto v$ (exclusive) \\
\bottomrule
\end{tabular}
\end{center}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Separation Logic in F*}]
module BrrrSemantics.Separation

open BrrrSemantics.Modes
open BrrrSemantics.Borrow

(* Heap as separation algebra *)
type heap = loc -> option (brrr_type & value)

(* Disjoint heaps *)
let disjoint (h1 h2:heap) : bool =
  forall (l:loc). not (Some? (h1 l) && Some? (h2 l))

(* Heap composition (requires disjoint) *)
let heap_compose (h1 h2:heap) : heap =
  fun l -> match h1 l with
    | Some v -> Some v
    | None -> h2 l

(* Separation logic assertion *)
noeq type sl_assert =
  | SLEmp    : sl_assert                           (* Empty heap *)
  | SLPointsTo : loc -> value -> sl_assert         (* l |-> v *)
  | SLPointsToFrac : loc -> permission -> value -> sl_assert  (* l |->^p v *)
  | SLStar   : sl_assert -> sl_assert -> sl_assert (* P * Q *)
  | SLWand   : sl_assert -> sl_assert -> sl_assert (* P -* Q *)
  | SLPure   : bool -> sl_assert                   (* Pure assertion *)

(* Satisfaction relation *)
let rec satisfies (h:heap) (p:sl_assert) : bool =
  match p with
  | SLEmp ->
      forall (l:loc). None? (h l)
  | SLPointsTo l v ->
      h l = Some (TAny, v) (* Simplified *)
  | SLStar p1 p2 ->
      exists (h1 h2:heap).
        disjoint h1 h2 &&
        heap_compose h1 h2 = h &&
        satisfies h1 p1 &&
        satisfies h2 p2
  | SLWand p1 p2 ->
      forall (h':heap).
        disjoint h h' && satisfies h' p1 ==>
        satisfies (heap_compose h h') p2
  | SLPure b -> b
  | _ -> false

(* Frame rule: {P} c {Q} implies {P * R} c {Q * R} *)
type hoare_triple = {
  pre  : sl_assert;
  cmd  : expr;
  post : sl_assert
}

(* Frame rule is derivable *)
val frame_rule: ht:hoare_triple -> frame:sl_assert ->
  Lemma (requires satisfies_triple ht)
        (ensures satisfies_triple {
          pre = SLStar ht.pre frame;
          cmd = ht.cmd;
          post = SLStar ht.post frame
        })

(* Separation logic for ownership transfer *)
let move_ownership (src dst:string) (h:heap) (v:value) : heap =
  fun l ->
    if l = lookup_loc src then None
    else if l = lookup_loc dst then Some (TAny, v)
    else h l

(* Borrow creates fractional permission *)
let create_borrow (var:string) (h:heap) : sl_assert =
  match lookup_loc_val var h with
  | Some (l, v) -> SLPointsToFrac l half_perm v
  | None -> SLPure false
\end{fstarcode}


%=============================================================================
% PART IV: ADVANCED EFFECTS
%=============================================================================
\part{Advanced Effects}

\chapter{Delimited Control}

This chapter grounds all control flow in delimited continuations, providing a unified semantic foundation for exceptions, early return, loops, and coroutines.

\section{Continuation Fundamentals}

\begin{definition}[Continuation]
A continuation $\kappa : \tau \to \sigma$ represents "the rest of the computation" expecting a value of type $\tau$ and producing $\sigma$.
\end{definition}

\begin{definition}[CPS Types]
The CPS transformation maps types:
\begin{align*}
  \sem{\tau}^{\mathsf{cps}} &= \forall \alpha.\, (\tau \to \alpha) \to \alpha
\end{align*}
\end{definition}

\begin{definition}[Evaluation Contexts]
An evaluation context $E$ is a term with a hole $[\cdot]$:
\begin{align*}
  E &::= [\cdot] \\
    &\mid E\; e \mid v\; E \\
    &\mid \mathsf{let}\, x = E \;\mathsf{in}\; e \\
    &\mid (E, e) \mid (v, E) \\
    &\mid \mathsf{if}\, E \,\mathsf{then}\, e_1 \,\mathsf{else}\, e_2
\end{align*}
\end{definition}

\section{Prompts and Delimiters}

\begin{definition}[Prompt]
A prompt $p$ is a delimiter marking the boundary of continuation capture:
\[
  \mathsf{reset}\langle p \rangle\, e
\]
The prompt $p$ is a label identifying which delimiter to capture up to.
\end{definition}

\begin{definition}[Shift (Continuation Capture)]
$\mathsf{shift}\langle p \rangle\, (\lambda k.\, e)$ captures the continuation up to the nearest enclosing $\mathsf{reset}\langle p \rangle$:
\[
  \mathsf{reset}\langle p \rangle\, E[\mathsf{shift}\langle p \rangle\, (\lambda k.\, e)] \longrightarrow
    \mathsf{reset}\langle p \rangle\, e[k := \lambda x.\, \mathsf{reset}\langle p \rangle\, E[x]]
\]
\end{definition}

\begin{definition}[Delimited Control Typing]
\begin{mathpar}
  \inferrule*[right=T-Reset]
    {\env \types e : \tau \; [\rowext{\mathsf{Prompt}\langle p, \sigma \rangle}{\varepsilon}]}
    {\env \types \mathsf{reset}\langle p \rangle\, e : \sigma \; [\varepsilon]}
  \and
  \inferrule*[right=T-Shift]
    {\env, k : \tau \to \sigma \; [\varepsilon] \types e : \sigma \; [\varepsilon']}
    {\env \types \mathsf{shift}\langle p \rangle\, (\lambda k.\, e) : \tau \; [\rowext{\mathsf{Prompt}\langle p, \sigma \rangle}{\varepsilon'}]}
\end{mathpar}
\end{definition}

\section{Control Operators}

\begin{definition}[Abort]
Abort discards the continuation entirely:
\[
  \mathsf{abort}\langle p \rangle\, v \triangleq \mathsf{shift}\langle p \rangle\, (\lambda \_.\, v)
\]
\end{definition}

\begin{definition}[Call/CC (Undelimited)]
Classical call/cc can be encoded:
\[
  \mathsf{call/cc}\, f \triangleq \mathsf{shift}\langle \mathsf{top} \rangle\, (\lambda k.\, k\, (f\, k))
\]
Warning: Undelimited continuations are more powerful but harder to reason about.
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Delimited Control in F*}]
module BrrrSemantics.DelimitedControl

(* Prompt label *)
type prompt = string

(* Answer type for a prompt *)
type answer_type = brrr_type

(* Continuation type *)
noeq type cont (a:Type) (r:Type) =
  | Cont : (a -> r) -> cont a r

(* Apply continuation *)
let apply_cont (#a #r:Type) (k:cont a r) (x:a) : r =
  match k with Cont f -> f x

(* Delimited control monad *)
noeq type dc (a:Type) (r:Type) =
  | Pure   : a -> dc a r
  | Shift  : prompt -> (cont a r -> dc r r) -> dc a r

(* Reset: run computation with delimiter *)
let rec reset (#a:Type) (p:prompt) (m:dc a a) : a =
  match m with
  | Pure x -> x
  | Shift p' body ->
      if p = p' then
        (* Capture continuation *)
        let k : cont a a = Cont (fun x -> reset p (Pure x)) in
        reset p (body k)
      else
        (* Propagate to outer reset *)
        admit() (* Would need effect row *)

(* Shift: capture continuation *)
let shift (#a #r:Type) (p:prompt) (f:cont a r -> dc r r) : dc a r =
  Shift p f

(* Abort: discard continuation *)
let abort (#a #r:Type) (p:prompt) (v:r) : dc a r =
  Shift p (fun _ -> Pure v)

(* Example: early exit *)
let example_early_exit () : int =
  reset "exit" (
    let x = 1 in
    let y = shift "exit" (fun k ->
      (* k is: fun v -> let y = v in x + y *)
      (* We can use it: *) apply_cont k 10
      (* Or abort: Pure 42 *)
    ) in
    Pure (x + y)
  )
  (* Result: 11 if we use k, or 42 if we abort *)

(* CPS transformation *)
type cps (a:Type) = forall r. (a -> r) -> r

let cps_return (#a:Type) (x:a) : cps a =
  fun k -> k x

let cps_bind (#a #b:Type) (m:cps a) (f:a -> cps b) : cps b =
  fun k -> m (fun x -> f x k)

(* Reset in CPS *)
let cps_reset (#a:Type) (m:cps a) : a =
  m (fun x -> x)

(* Shift in CPS *)
let cps_shift (#a #r:Type) (f:(a -> r) -> r) : cps a =
  fun k -> f k
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Control Flow as Delimited Continuations}

This chapter derives all standard control flow from delimited continuations.

\section{Return as Abort}

\begin{definition}[Return Derivation]
Every function implicitly has a reset at its boundary:
\begin{align*}
  \mathsf{fn}\, f(x : \tau) \to \sigma \triangleq \mathsf{body}
  &\equiv \lambda x.\, \mathsf{reset}\langle \mathsf{ret}_f \rangle\, \mathsf{body}
\end{align*}

Early return aborts to this delimiter:
\[
  \mathsf{return}\, e \triangleq \mathsf{abort}\langle \mathsf{ret}_f \rangle\, e
\]
\end{definition}

\begin{definition}[Return Typing]
\begin{mathpar}
  \inferrule*[right=T-Return]
    {\env \types e : \sigma \; [\varepsilon] \\ \text{enclosing function returns } \sigma}
    {\env \types \mathsf{return}\, e : \TNever \; [\rowext{\mathsf{Return}\langle\sigma\rangle}{\varepsilon}]}
\end{mathpar}
\end{definition}

\section{Exceptions as Effects}

\begin{definition}[Exception Derivation]
Exceptions are abort with a handler:
\begin{align*}
  \mathsf{throw}\, e &\triangleq \mathsf{abort}\langle \mathsf{exn} \rangle\, (\mathsf{Err}\, e) \\[1em]
  \mathsf{try}\, e_1 \,\mathsf{catch}\, \{E(x) \Rightarrow e_2\}
  &\triangleq \mathsf{reset}\langle \mathsf{exn} \rangle\, e_1 \mid_{\mathsf{match}} \{\\
  &\qquad \mathsf{Ok}(v) \Rightarrow v \\
  &\qquad \mathsf{Err}(x : E) \Rightarrow e_2 \\
  &\}
\end{align*}
\end{definition}

\begin{definition}[Exception Typing]
\begin{mathpar}
  \inferrule*[right=T-Throw]
    {\env \types e : E \; [\varepsilon]}
    {\env \types \mathsf{throw}\, e : \TNever \; [\rowext{\EThrow{E}}{\varepsilon}]}
  \and
  \inferrule*[right=T-TryCatch]
    {\env \types e_1 : \tau \; [\rowext{\EThrow{E}}{\varepsilon}] \\
     \env, x : E \types e_2 : \tau \; [\varepsilon']}
    {\env \types \mathsf{try}\, e_1 \,\mathsf{catch}\, \{E(x) \Rightarrow e_2\} : \tau \; [\varepsilon \effjoin \varepsilon']}
\end{mathpar}
\end{definition}

\section{Loops as Fixpoints}

\begin{definition}[While Loop Derivation]
Loops are recursive functions (fixpoints):
\[
  \mathsf{while}\, c \; \{\mathsf{body}\} \triangleq
    \mathsf{fix}\, (\lambda \mathsf{loop}.\, \lambda ().\,
      \mathsf{if}\, c \,\mathsf{then}\, \{\mathsf{body}; \mathsf{loop}()\} \,\mathsf{else}\, ())(\ )
\]
\end{definition}

\begin{definition}[For Loop Derivation]
\[
  \mathsf{for}\, x \,\mathsf{in}\, \mathsf{iter} \; \{\mathsf{body}\} \triangleq
    \mathsf{iter}.\mathsf{fold}((), \lambda (\_, x).\, \mathsf{body})
\]
\end{definition}

\begin{definition}[Infinite Loop]
\[
  \mathsf{loop} \; \{\mathsf{body}\} \triangleq
    \mathsf{fix}\, (\lambda \mathsf{loop}.\, \lambda ().\, \{\mathsf{body}; \mathsf{loop}()\})(\ )
\]
\end{definition}

\begin{definition}[Loop Typing with Divergence]
\begin{mathpar}
  \inferrule*[right=T-While]
    {\env \types c : \TBool \; [\varepsilon_1] \\ \env \types \mathsf{body} : \TUnit \; [\varepsilon_2]}
    {\env \types \mathsf{while}\, c \; \{\mathsf{body}\} : \TUnit \; [\varepsilon_1 \effjoin \varepsilon_2 \effjoin \EDiverge]}
\end{mathpar}
\end{definition}

\section{Labeled Break/Continue}

\begin{definition}[Labeled Loop Structure]
A labeled loop introduces two prompts---one for break, one for continue:
\begin{align*}
  &\mathsf{label}\, \ell : \mathsf{loop} \; \{\mathsf{body}\} \\
  &\quad \triangleq \mathsf{reset}\langle \ell_{\mathsf{break}} \rangle\, \{\\
  &\qquad\quad \mathsf{fix}\, (\lambda \mathsf{iter}.\, \lambda ().\,\\
  &\qquad\qquad \mathsf{reset}\langle \ell_{\mathsf{continue}} \rangle\, \mathsf{body};\\
  &\qquad\qquad \mathsf{iter}()\\
  &\qquad\quad )(\ )\\
  &\quad \}
\end{align*}
\end{definition}

\begin{definition}[Break Derivation]
\begin{align*}
  \mathsf{break}\, \ell &\triangleq \mathsf{abort}\langle \ell_{\mathsf{break}} \rangle\, () \\
  \mathsf{break}\, \ell(v) &\triangleq \mathsf{abort}\langle \ell_{\mathsf{break}} \rangle\, v
\end{align*}
\end{definition}

\begin{definition}[Continue Derivation]
\[
  \mathsf{continue}\, \ell \triangleq \mathsf{abort}\langle \ell_{\mathsf{continue}} \rangle\, ()
\]
\end{definition}

\begin{definition}[Break/Continue Typing]
\begin{mathpar}
  \inferrule*[right=T-Break]
    {\env \types e : \tau \; [\varepsilon] \\ \text{enclosing loop } \ell \text{ expects } \tau}
    {\env \types \mathsf{break}\, \ell(e) : \TNever \; [\rowext{\mathsf{Break}\langle\ell, \tau\rangle}{\varepsilon}]}
  \and
  \inferrule*[right=T-Continue]
    {\text{enclosing loop } \ell}
    {\env \types \mathsf{continue}\, \ell : \TNever \; [\mathsf{Continue}\langle\ell\rangle]}
\end{mathpar}
\end{definition}

\section{Defer as Finalizer}

\begin{definition}[Defer Derivation]
Defer installs a finalizer that runs on scope exit:
\[
  \mathsf{defer}\, e; \mathsf{rest} \triangleq
    \mathsf{bracket}\, (\lambda k.\, \{e; k()\})\, \mathsf{rest}
\]
where $\mathsf{bracket}$ ensures the finalizer runs regardless of how scope exits.
\end{definition}

\begin{definition}[Bracket Combinator]
\[
  \mathsf{bracket} : ((\tau \to \tau) \to \tau \to \tau) \to \tau \to \tau
\]
\[
  \mathsf{bracket}\, \mathsf{finalizer}\, \mathsf{body} =
    \mathsf{let}\, r = \mathsf{body} \;\mathsf{in}\;
    \mathsf{finalizer}(\lambda ().\, r)
\]
\end{definition}

\begin{definition}[Defer Typing]
\begin{mathpar}
  \inferrule*[right=T-Defer]
    {\env \types e_d : \TUnit \; [\varepsilon_d] \\ \env \types e : \tau \; [\varepsilon]}
    {\env \types \mathsf{defer}\, e_d; e : \tau \; [\varepsilon_d \effjoin \varepsilon]}
\end{mathpar}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Control Flow Derivations in F*}]
module BrrrSemantics.ControlFlow

open BrrrSemantics.DelimitedControl

(* Control effect *)
type control_effect =
  | CReturn   : brrr_type -> control_effect
  | CThrow    : brrr_type -> control_effect
  | CBreak    : string -> brrr_type -> control_effect
  | CContinue : string -> control_effect

(* Return as abort *)
let return_impl (#a:Type) (ret_prompt:prompt) (v:a) : dc a a =
  abort ret_prompt v

(* Function wrapper with return handling *)
let fn_wrapper (#a #r:Type) (body:dc r r) : r =
  reset "return" body

(* Exception handling *)
type result (a:Type) (e:Type) =
  | Ok  : a -> result a e
  | Err : e -> result a e

let throw (#a #e:Type) (exn:e) : dc a (result a e) =
  abort "exn" (Err exn)

let try_catch (#a #e:Type) (body:dc a (result a e)) (handler:e -> dc a (result a e))
    : dc a (result a e) =
  let r = reset "exn" (
    match body with
    | Pure x -> Pure (Ok x)
    | _ -> body
  ) in
  match r with
  | Ok v -> Pure (Ok v)
  | Err e -> handler e

(* Fixpoint combinator *)
let rec fix (#a:Type) (f:(a -> a) -> a -> a) (x:a) : a =
  f (fix f) x

(* While loop as fixpoint *)
let while_loop (cond:unit -> bool) (body:unit -> unit) : unit =
  fix (fun loop () ->
    if cond () then (body (); loop ())
    else ()
  ) ()

(* Labeled loop with break/continue *)
type loop_control =
  | LBreak    : option 'a -> loop_control
  | LContinue : loop_control
  | LNormal   : loop_control

let labeled_loop (#a:Type) (label:string) (body:unit -> dc loop_control loop_control)
    : option a =
  reset (label ^ "_break") (
    fix (fun iter () ->
      let ctrl = reset (label ^ "_continue") (body ()) in
      match ctrl with
      | Pure LNormal -> iter ()
      | Pure LContinue -> iter ()
      | Pure (LBreak v) -> Pure (LBreak v)
      | _ -> iter ()
    ) ()
  ) |> (function
    | Pure (LBreak (Some v)) -> Some v
    | _ -> None
  )

(* Break implementation *)
let break (#a:Type) (label:string) (v:option a) : dc loop_control loop_control =
  abort (label ^ "_break") (LBreak v)

(* Continue implementation *)
let continue (label:string) : dc loop_control loop_control =
  abort (label ^ "_continue") LContinue

(* Defer/bracket pattern *)
let bracket (#a:Type) (finalizer:unit -> unit) (body:unit -> a) : a =
  let result = body () in
  finalizer ();
  result

let with_defer (#a:Type) (cleanup:unit -> unit) (body:unit -> a) : a =
  bracket cleanup body

(* Example: file handling with defer *)
let example_file_handling () : string =
  with_defer
    (fun () -> (* close file *) ())
    (fun () ->
      (* open file *)
      (* read contents *)
      "file contents"
    )
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Generators and Coroutines}

\section{Generator as Effect}

\begin{definition}[Yield Effect]
\[
  \mathsf{effect}\; \mathsf{Yield}[Y, R] \; \{
    \mathsf{yield} : Y \rightsquigarrow R
  \}
\]
A generator yields values of type $Y$ and receives resumption values of type $R$.
\end{definition}

\begin{definition}[Generator Type]
\[
  \mathsf{Generator}[Y, R, T] \cong \TUnit \xrightarrow{[\mathsf{Yield}[Y, R]]} T
\]
\end{definition}

\begin{definition}[Generator Typing]
\begin{mathpar}
  \inferrule*[right=T-Yield]
    {\env \types e : Y \; [\varepsilon]}
    {\env \types \mathsf{yield}\, e : R \; [\rowext{\mathsf{Yield}[Y, R]}{\varepsilon}]}
  \and
  \inferrule*[right=T-Generator]
    {\env \types e : T \; [\rowext{\mathsf{Yield}[Y, R]}{\varepsilon}]}
    {\env \types \mathsf{generator}\; e : \mathsf{Generator}[Y, R, T] \; [\varepsilon]}
\end{mathpar}
\end{definition}

\section{Generator Semantics via Handlers}

\begin{definition}[Generator Runner]
\begin{align*}
  &\mathsf{run\_generator} : \mathsf{Generator}[Y, R, T] \to \mathsf{Iterator}[Y] \\
  &\mathsf{run\_generator}\, g = \mathsf{handle}\, g() \,\mathsf{with}\, \{ \\
  &\quad \mathsf{return}\, x \Rightarrow \mathsf{Done}(x) \\
  &\quad \mathsf{yield}(y, k) \Rightarrow \mathsf{Yielded}(y, \lambda r.\, \mathsf{run\_generator}\, (\lambda ().\, k(r))) \\
  &\}
\end{align*}
\end{definition}

\section{Async/Await}

\begin{definition}[Async Effect]
\[
  \mathsf{effect}\; \mathsf{Async} \; \{
    \mathsf{await} : \mathsf{Future}[\tau] \rightsquigarrow \tau,\;
    \mathsf{spawn} : (\TUnit \xrightarrow{[\EAsync]} \tau) \rightsquigarrow \mathsf{Future}[\tau]
  \}
\]
\end{definition}

\begin{definition}[Future Types]
\begin{align*}
  \mathsf{Future}[\tau, \mathsf{Hot}] &\quad \text{(computation already started)} \\
  \mathsf{Future}[\tau, \mathsf{Cold}] &\quad \text{(computation deferred until awaited)}
\end{align*}
\end{definition}

\begin{definition}[Async Typing]
\begin{mathpar}
  \inferrule*[right=T-Async]
    {\env \types e : \tau \; [\rowext{\EAsync}{\varepsilon}]}
    {\env \types \mathsf{async}\, e : \mathsf{Future}[\tau, \mathsf{Cold}] \; [\varepsilon]}
  \and
  \inferrule*[right=T-Await]
    {\env \types e : \mathsf{Future}[\tau, \_] \; [\varepsilon]}
    {\env \types \mathsf{await}\, e : \tau \; [\rowext{\EAsync}{\varepsilon}]}
  \and
  \inferrule*[right=T-Spawn]
    {\env \types e : \tau \; [\rowext{\EAsync}{\varepsilon}]}
    {\env \types \mathsf{spawn}\, e : \mathsf{Future}[\tau, \mathsf{Hot}] \; [\varepsilon]}
\end{mathpar}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Generators and Async in F*}]
module BrrrSemantics.Generators

(* Generator state *)
noeq type gen_state (y:Type) (r:Type) (t:Type) =
  | GenDone    : t -> gen_state y r t
  | GenYielded : y -> (r -> gen_state y r t) -> gen_state y r t

(* Generator as resumable computation *)
noeq type generator (y:Type) (r:Type) (t:Type) =
  | Gen : (unit -> gen_state y r t) -> generator y r t

(* Create generator *)
let make_generator (#y #r #t:Type) (body:unit -> gen_state y r t)
    : generator y r t =
  Gen body

(* Step generator *)
let step_generator (#y #r #t:Type) (g:generator y r t)
    : gen_state y r t =
  match g with Gen f -> f ()

(* Yield operation (used inside generator) *)
let yield (#y #r:Type) (value:y) (cont:r -> gen_state y r 'a)
    : gen_state y r 'a =
  GenYielded value cont

(* Iterator from generator *)
noeq type iterator (a:Type) =
  | IterDone : iterator a
  | IterNext : a -> (unit -> iterator a) -> iterator a

let rec gen_to_iter (#y #t:Type) (g:generator y unit t) : iterator y =
  match step_generator g with
  | GenDone _ -> IterDone
  | GenYielded v cont ->
      IterNext v (fun () -> gen_to_iter (Gen (fun () -> cont ())))

(* Async/Await *)

(* Future temperature *)
type temperature = | Hot | Cold

(* Future state *)
noeq type future_state (a:Type) =
  | Pending  : (unit -> future_state a) -> future_state a
  | Resolved : a -> future_state a
  | Failed   : exn -> future_state a

(* Future with temperature *)
noeq type future (a:Type) (temp:temperature) = {
  state : ref (future_state a);
  temp  : temperature
}

(* Async block - creates cold future *)
let async_cold (#a:Type) (body:unit -> a) : future a Cold = {
  state = ref (Pending (fun () -> Resolved (body ())));
  temp = Cold
}

(* Spawn - creates hot future (starts immediately) *)
let spawn (#a:Type) (body:unit -> a) : future a Hot =
  (* In real impl, would schedule on executor *)
  let result = body () in
  { state = ref (Resolved result); temp = Hot }

(* Await - blocks until resolved *)
let await (#a:Type) (#t:temperature) (fut:future a t) : a =
  let rec poll () : a =
    match !fut.state with
    | Resolved v -> v
    | Failed e -> raise e
    | Pending next ->
        fut.state := next ();
        poll ()
  in poll ()

(* Async effect signature *)
noeq type async_op =
  | OpAwait : #a:Type -> future a Hot -> async_op
  | OpSpawn : #a:Type -> (unit -> a) -> async_op

(* Async computation as free monad *)
noeq type async_comp (a:Type) =
  | AsyncPure  : a -> async_comp a
  | AsyncBind  : async_op -> (unit -> async_comp a) -> async_comp a

(* Run async computation *)
let rec run_async (#a:Type) (comp:async_comp a) : a =
  match comp with
  | AsyncPure x -> x
  | AsyncBind (OpAwait fut) cont ->
      let v = await fut in
      run_async (cont ())
  | AsyncBind (OpSpawn body) cont ->
      let _ = spawn body in
      run_async (cont ())
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Structured Concurrency}

\section{Task Groups}

\begin{definition}[Task Group]
A task group ensures all spawned tasks complete before the group exits:
\[
  \mathsf{TaskGroup} : \mathsf{Set}[\mathsf{Future}[\tau]]
\]
\end{definition}

\begin{definition}[Task Group Operations]
\begin{align*}
  \mathsf{spawn\_in} &: \mathsf{TaskGroup} \to (\TUnit \to \tau \; [\EAsync]) \to \mathsf{Future}[\tau] \\
  \mathsf{wait\_all} &: \mathsf{TaskGroup} \to [\tau] \; [\EAsync]
\end{align*}
\end{definition}

\begin{definition}[Structured Concurrency Typing]
\begin{mathpar}
  \inferrule*[right=T-TaskGroup]
    {\env, g : \mathsf{TaskGroup} \types e : \tau \; [\varepsilon]}
    {\env \types \mathsf{task\_group}\, (\lambda g.\, e) : \tau \; [\varepsilon]}
\end{mathpar}
The task group $g$ cannot escape; all tasks must complete within the scope.
\end{definition}

\section{Cancellation}

\begin{definition}[Cancellation Token]
\[
  \mathsf{CancelToken} : \{\mathsf{cancelled} : \mathsf{ref}\, \TBool\}
\]
\end{definition}

\begin{definition}[Cancellation Typing]
\begin{mathpar}
  \inferrule*[right=T-CheckCancel]
    {\env \types \mathsf{token} : \mathsf{CancelToken} \; [\varepsilon]}
    {\env \types \mathsf{check\_cancelled}\, \mathsf{token} : \TUnit \; [\rowext{\mathsf{Cancelled}}{\varepsilon}]}
\end{mathpar}
\end{definition}

\section{Channels}

\begin{definition}[Channel Types]
\begin{align*}
  \mathsf{Sender}[\tau] &\quad \text{(send end)} \\
  \mathsf{Receiver}[\tau] &\quad \text{(receive end)} \\
  \mathsf{Channel}[\tau] &= \mathsf{Sender}[\tau] \times \mathsf{Receiver}[\tau]
\end{align*}
\end{definition}

\begin{definition}[Channel Operations]
\begin{mathpar}
  \inferrule*[right=T-Send]
    {\env \types s : \mathsf{Sender}[\tau] \; [\varepsilon_1] \\ \env \types v : \tau \; [\varepsilon_2]}
    {\env \types s.\mathsf{send}(v) : \TUnit \; [\rowext{\EAsync}{\varepsilon_1 \effjoin \varepsilon_2}]}
  \and
  \inferrule*[right=T-Recv]
    {\env \types r : \mathsf{Receiver}[\tau] \; [\varepsilon]}
    {\env \types r.\mathsf{recv}() : \TOption{\tau} \; [\rowext{\EAsync}{\varepsilon}]}
\end{mathpar}
\end{definition}

\section{Select}

\begin{definition}[Select Expression]
Select waits on multiple channels:
\begin{align*}
  &\mathsf{select}\, \{ \\
  &\quad r_1.\mathsf{recv}() \Rightarrow e_1 \\
  &\quad r_2.\mathsf{recv}() \Rightarrow e_2 \\
  &\quad \mathsf{default} \Rightarrow e_d \\
  &\}
\end{align*}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Structured Concurrency in F*}]
module BrrrSemantics.Concurrency

(* Task handle *)
noeq type task (a:Type) = {
  future : future a Hot;
  cancel : cancel_token
}

(* Cancellation token *)
and cancel_token = {
  cancelled : ref bool;
  children  : ref (list cancel_token)
}

(* Create cancellation token *)
let new_cancel_token () : cancel_token = {
  cancelled = ref false;
  children = ref []
}

(* Cancel token and children *)
let rec cancel (tok:cancel_token) : unit =
  tok.cancelled := true;
  List.iter cancel (!tok.children)

(* Check if cancelled *)
let is_cancelled (tok:cancel_token) : bool =
  !tok.cancelled

(* Task group *)
noeq type task_group = {
  tasks  : ref (list (task unit));
  parent_cancel : cancel_token
}

(* Create task group *)
let new_task_group (parent:cancel_token) : task_group = {
  tasks = ref [];
  parent_cancel = parent
}

(* Spawn in task group *)
let spawn_in (#a:Type) (g:task_group) (body:unit -> a) : task a =
  let child_cancel = new_cancel_token () in
  g.parent_cancel.children := child_cancel :: !(g.parent_cancel.children);
  let fut = spawn (fun () ->
    if is_cancelled child_cancel then raise Cancelled
    else body ()
  ) in
  let t = { future = fut; cancel = child_cancel } in
  g.tasks := ({ future = spawn (fun () -> ignore (await fut));
                cancel = child_cancel }) :: !(g.tasks);
  t

(* Wait for all tasks in group *)
let wait_all (g:task_group) : unit =
  List.iter (fun t -> ignore (await t.future)) !(g.tasks)

(* Run with task group (structured concurrency) *)
let with_task_group (#a:Type) (body:task_group -> a) : a =
  let cancel = new_cancel_token () in
  let g = new_task_group cancel in
  let result = body g in
  wait_all g;  (* Ensure all tasks complete *)
  result

(* Channel *)
noeq type channel (a:Type) = {
  buffer : ref (list a);
  closed : ref bool
}

type sender (a:Type) = channel a
type receiver (a:Type) = channel a

(* Create channel *)
let new_channel (#a:Type) () : sender a & receiver a =
  let ch = { buffer = ref []; closed = ref false } in
  (ch, ch)

(* Send on channel *)
let send (#a:Type) (s:sender a) (v:a) : unit =
  if !(s.closed) then raise ChannelClosed
  else s.buffer := !(s.buffer) @ [v]

(* Receive from channel *)
let recv (#a:Type) (r:receiver a) : option a =
  match !(r.buffer) with
  | [] -> if !(r.closed) then None else None (* would block *)
  | x :: xs -> r.buffer := xs; Some x

(* Close channel *)
let close (#a:Type) (s:sender a) : unit =
  s.closed := true

(* Select result *)
type select_result (a:Type) (b:Type) =
  | SelectFirst  : a -> select_result a b
  | SelectSecond : b -> select_result a b
  | SelectNeither : select_result a b

(* Select on two receivers *)
let select2 (#a #b:Type) (r1:receiver a) (r2:receiver b)
    : select_result a b =
  match recv r1 with
  | Some v -> SelectFirst v
  | None -> match recv r2 with
    | Some v -> SelectSecond v
    | None -> SelectNeither
\end{fstarcode}


%=============================================================================
% PART V: EXPRESSIONS & PATTERNS
%=============================================================================
\part{Expressions \& Patterns}

\chapter{Expression Semantics}

\section{Denotational Semantics}

\begin{definition}[Semantic Function]
The semantic function maps expressions to computations:
\[
  \sem{\cdot} : \mathsf{Expr} \to \mathsf{Env} \to \mathsf{Comp}[\mathsf{Val}]
\]
\end{definition}

\begin{definition}[Core Expression Semantics]
\begin{align*}
  \sem{x}\rho &= \mathsf{return}\, (\rho(x)) \\[0.5em]
  \sem{\lambda x.\, e}\rho &= \mathsf{return}\, (\mathsf{Closure}(\rho, x, e)) \\[0.5em]
  \sem{e_1\, e_2}\rho &= \sem{e_1}\rho \gg\!= \lambda f.\,
    \sem{e_2}\rho \gg\!= \lambda v.\,
    \mathsf{apply}(f, v) \\[0.5em]
  \sem{\mathsf{let}\, x = e_1 \;\mathsf{in}\; e_2}\rho &=
    \sem{e_1}\rho \gg\!= \lambda v.\,
    \sem{e_2}(\rho[x \mapsto v]) \\[0.5em]
  \sem{\mathsf{if}\, c \,\mathsf{then}\, e_1 \,\mathsf{else}\, e_2}\rho &=
    \sem{c}\rho \gg\!= \lambda b.\,
    \mathsf{if}\, b \,\mathsf{then}\, \sem{e_1}\rho \,\mathsf{else}\, \sem{e_2}\rho \\[0.5em]
  \sem{(e_1, e_2)}\rho &= \sem{e_1}\rho \gg\!= \lambda v_1.\,
    \sem{e_2}\rho \gg\!= \lambda v_2.\,
    \mathsf{return}\, (v_1, v_2)
\end{align*}
\end{definition}

\section{Compositional Effect Semantics}

\begin{definition}[Effect Composition]
Effects compose via the graded monad structure:
\[
  \sem{e_1; e_2}_{\varepsilon_1 \effjoin \varepsilon_2} =
    \sem{e_1}_{\varepsilon_1} \gg\!= \lambda \_.\, \sem{e_2}_{\varepsilon_2}
\]
\end{definition}

\begin{theorem}[Compositionality]
For all $n$-ary operators $\mathsf{op}$ and expressions $e_1, \ldots, e_n$:
\[
  \sem{\mathsf{op}(e_1, \ldots, e_n)}\rho = F_{\mathsf{op}}(\sem{e_1}\rho, \ldots, \sem{e_n}\rho)
\]
where $F_{\mathsf{op}}$ is the semantic function for $\mathsf{op}$.
\end{theorem}

\section{F* Mechanization}

\begin{fstarcode}[title={Expression Semantics in F*}]
module BrrrSemantics.Expressions

open BrrrSemantics.Domains
open BrrrSemantics.Effects

(* Expression AST *)
noeq type expr =
  | EVar     : string -> expr
  | ELit     : base_val -> expr
  | ELam     : string -> brrr_type -> expr -> expr
  | EApp     : expr -> expr -> expr
  | ELet     : string -> expr -> expr -> expr
  | EIf      : expr -> expr -> expr -> expr
  | EPair    : expr -> expr -> expr
  | EFst     : expr -> expr
  | ESnd     : expr -> expr
  | ESeq     : expr -> expr -> expr
  | EReturn  : expr -> expr
  | EThrow   : expr -> expr
  | ETry     : expr -> string -> expr -> expr

(* Value domain *)
noeq type value =
  | VBase    : base_val -> value
  | VClosure : env -> string -> expr -> value
  | VPair    : value -> value -> value
  | VInl     : value -> value
  | VInr     : value -> value

and env = string -> option value

(* Empty environment *)
let empty_env : env = fun _ -> None

(* Extend environment *)
let extend (e:env) (x:string) (v:value) : env =
  fun y -> if y = x then Some v else e y

(* Computation result *)
type result (a:Type) =
  | ROk    : a -> result a
  | RErr   : value -> result a
  | RDiv   : result a  (* Divergence *)

(* Computation monad *)
let comp (a:Type) = env -> result a

(* Monad operations *)
let return (#a:Type) (x:a) : comp a = fun _ -> ROk x

let bind (#a #b:Type) (m:comp a) (f:a -> comp b) : comp b =
  fun env -> match m env with
    | ROk v -> f v env
    | RErr e -> RErr e
    | RDiv -> RDiv

let (let*) = bind

(* Semantic function *)
let rec eval (e:expr) : comp value =
  match e with
  | EVar x ->
      fun env -> match env x with
        | Some v -> ROk v
        | None -> RErr (VBase (VString ("Unbound: " ^ x)))

  | ELit v -> return (VBase v)

  | ELam x _ body ->
      fun env -> ROk (VClosure env x body)

  | EApp f arg ->
      let* fv = eval f in
      let* av = eval arg in
      (match fv with
       | VClosure cenv x body ->
           eval body (extend cenv x av)
       | _ -> fun _ -> RErr (VBase (VString "Not a function")))

  | ELet x e1 e2 ->
      let* v = eval e1 in
      fun env -> eval e2 (extend env x v)

  | EIf cond e1 e2 ->
      let* cv = eval cond in
      (match cv with
       | VBase (VBool true) -> eval e1
       | VBase (VBool false) -> eval e2
       | _ -> fun _ -> RErr (VBase (VString "Not a boolean")))

  | EPair e1 e2 ->
      let* v1 = eval e1 in
      let* v2 = eval e2 in
      return (VPair v1 v2)

  | EFst e ->
      let* v = eval e in
      (match v with
       | VPair v1 _ -> return v1
       | _ -> fun _ -> RErr (VBase (VString "Not a pair")))

  | ESnd e ->
      let* v = eval e in
      (match v with
       | VPair _ v2 -> return v2
       | _ -> fun _ -> RErr (VBase (VString "Not a pair")))

  | ESeq e1 e2 ->
      let* _ = eval e1 in
      eval e2

  | EThrow e ->
      let* v = eval e in
      fun _ -> RErr v

  | ETry body x handler ->
      fun env -> match eval body env with
        | ROk v -> ROk v
        | RErr exn -> eval handler (extend env x exn)
        | RDiv -> RDiv

  | EReturn e ->
      (* Would need continuation to implement properly *)
      eval e

(* Run expression *)
let run (e:expr) : result value = eval e empty_env
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Pattern Matching}

Pattern matching is the eliminator for algebraic data types.

\section{Pattern Syntax}

\begin{definition}[Pattern Grammar]
\begin{align*}
  p &::= x & \text{(variable)} \\
    &\mid \_ & \text{(wildcard)} \\
    &\mid C(p_1, \ldots, p_n) & \text{(constructor)} \\
    &\mid (p_1, p_2) & \text{(pair)} \\
    &\mid [p_1, \ldots, p_n] & \text{(array)} \\
    &\mid [p_1, \ldots, p_k, \ldots p_r] & \text{(array with rest)} \\
    &\mid p \,\mathsf{if}\, e & \text{(guard)} \\
    &\mid p_1 \mid p_2 & \text{(or-pattern)} \\
    &\mid p \,@\, x & \text{(as-pattern)}
\end{align*}
\end{definition}

\section{Pattern Matching as Elimination}

\begin{definition}[Eliminator Form]
Pattern matching on type $T$ with constructors $C_1, \ldots, C_n$ is:
\[
  \mathsf{elim}_T : (T_1 \to R) \times \cdots \times (T_n \to R) \to T \to R
\]
where $C_i : T_i \to T$.
\end{definition}

\begin{theorem}[Eliminator Equation]
\[
  \mathsf{elim}_T(f_1, \ldots, f_n)(C_i(x)) = f_i(x)
\]
\end{theorem}

\begin{definition}[Match as Eliminator]
\begin{align*}
  &\mathsf{match}\, e \; \{C_1(x_1) \Rightarrow e_1 \mid \cdots \mid C_n(x_n) \Rightarrow e_n\} \\
  &\quad \triangleq \mathsf{elim}_T(\lambda x_1.\, e_1, \ldots, \lambda x_n.\, e_n)(e)
\end{align*}
\end{definition}

\section{Pattern Typing}

\begin{definition}[Pattern Typing Judgment]
$\env \types_{\mathsf{pat}} p : \tau \Rightarrow \Delta$ means pattern $p$ matches values of type $\tau$ and binds variables in $\Delta$.
\end{definition}

\begin{definition}[Pattern Typing Rules]
\begin{mathpar}
  \inferrule*[right=P-Var]
    { }
    {\env \types_{\mathsf{pat}} x : \tau \Rightarrow x : \tau}
  \and
  \inferrule*[right=P-Wild]
    { }
    {\env \types_{\mathsf{pat}} \_ : \tau \Rightarrow \cdot}
  \and
  \inferrule*[right=P-Ctor]
    {C : \tau_1 \times \cdots \times \tau_n \to T \\
     \forall i.\; \env \types_{\mathsf{pat}} p_i : \tau_i \Rightarrow \Delta_i}
    {\env \types_{\mathsf{pat}} C(p_1, \ldots, p_n) : T \Rightarrow \Delta_1, \ldots, \Delta_n}
  \and
  \inferrule*[right=P-Pair]
    {\env \types_{\mathsf{pat}} p_1 : \tau_1 \Rightarrow \Delta_1 \\
     \env \types_{\mathsf{pat}} p_2 : \tau_2 \Rightarrow \Delta_2}
    {\env \types_{\mathsf{pat}} (p_1, p_2) : \tau_1 \times \tau_2 \Rightarrow \Delta_1, \Delta_2}
  \and
  \inferrule*[right=P-Guard]
    {\env \types_{\mathsf{pat}} p : \tau \Rightarrow \Delta \\
     \env, \Delta \types e : \TBool \; [\Pure]}
    {\env \types_{\mathsf{pat}} (p \,\mathsf{if}\, e) : \tau \Rightarrow \Delta}
\end{mathpar}
\end{definition}

\begin{definition}[Match Expression Typing]
\begin{mathpar}
  \inferrule*[right=T-Match]
    {\env \types e : T \; [\varepsilon_0] \\
     \forall i.\; \env \types_{\mathsf{pat}} p_i : T \Rightarrow \Delta_i \\
     \forall i.\; \env, \Delta_i \types e_i : \sigma \; [\varepsilon_i] \\
     \text{patterns exhaustive}}
    {\env \types \mathsf{match}\, e \; \{p_1 \Rightarrow e_1 \mid \cdots\} : \sigma \; [\varepsilon_0 \effjoin \bigeffjoin_i \varepsilon_i]}
\end{mathpar}
\end{definition}

\section{Exhaustiveness and Redundancy}

\begin{definition}[Exhaustiveness]
Patterns $p_1, \ldots, p_n$ are exhaustive for type $T$ iff:
\[
  \forall v : T.\; \exists i.\; v \in \sem{p_i}
\]
\end{definition}

\begin{definition}[Redundancy]
Pattern $p_i$ is redundant iff:
\[
  \sem{p_i} \subseteq \bigcup_{j < i} \sem{p_j}
\]
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Pattern Matching in F*}]
module BrrrSemantics.Patterns

open BrrrSemantics.Expressions

(* Pattern AST *)
noeq type pattern =
  | PVar   : string -> pattern
  | PWild  : pattern
  | PCtor  : string -> list pattern -> pattern
  | PPair  : pattern -> pattern -> pattern
  | PArray : list pattern -> option string -> pattern  (* rest pattern *)
  | PGuard : pattern -> expr -> pattern
  | POr    : pattern -> pattern -> pattern
  | PAs    : pattern -> string -> pattern
  | PLit   : base_val -> pattern

(* Bindings from pattern match *)
type bindings = list (string & value)

(* Match result *)
type match_result =
  | MatchSuccess : bindings -> match_result
  | MatchFail    : match_result

(* Combine bindings *)
let combine_bindings (b1 b2:bindings) : bindings = b1 @ b2

(* Pattern matching *)
let rec match_pattern (p:pattern) (v:value) : match_result =
  match p, v with
  | PVar x, _ -> MatchSuccess [(x, v)]

  | PWild, _ -> MatchSuccess []

  | PLit lit, VBase lit' ->
      if lit = lit' then MatchSuccess [] else MatchFail

  | PCtor name pats, v ->
      (* Would need type info to destructure *)
      admit()

  | PPair p1 p2, VPair v1 v2 ->
      (match match_pattern p1 v1, match_pattern p2 v2 with
       | MatchSuccess b1, MatchSuccess b2 ->
           MatchSuccess (combine_bindings b1 b2)
       | _, _ -> MatchFail)

  | PAs p x, v ->
      (match match_pattern p v with
       | MatchSuccess binds -> MatchSuccess ((x, v) :: binds)
       | MatchFail -> MatchFail)

  | POr p1 p2, v ->
      (match match_pattern p1 v with
       | MatchSuccess b -> MatchSuccess b
       | MatchFail -> match_pattern p2 v)

  | _, _ -> MatchFail

(* Match expression *)
type arm = pattern & expr

let match_expr (scrutinee:value) (arms:list arm) (env:env)
    : result value =
  let rec try_arms (arms:list arm) : result value =
    match arms with
    | [] -> RErr (VBase (VString "Non-exhaustive match"))
    | (pat, body) :: rest ->
        match match_pattern pat scrutinee with
        | MatchSuccess binds ->
            let env' = List.fold_left
              (fun e (x, v) -> extend e x v) env binds in
            eval body env'
        | MatchFail -> try_arms rest
  in try_arms arms

(* Exhaustiveness checking *)

(* Value space representation *)
noeq type value_space =
  | VSAll   : brrr_type -> value_space           (* All values of type *)
  | VSCtor  : string -> list value_space -> value_space  (* Constructor *)
  | VSUnion : list value_space -> value_space    (* Union *)
  | VSEmpty : value_space                        (* No values *)

(* Subtract pattern from value space *)
let rec subtract_pattern (vs:value_space) (p:pattern) : value_space =
  match p with
  | PWild -> VSEmpty
  | PVar _ -> VSEmpty
  | PCtor name pats ->
      (* Remove this constructor case *)
      admit()
  | POr p1 p2 ->
      subtract_pattern (subtract_pattern vs p1) p2
  | _ -> vs

(* Check exhaustiveness *)
let is_exhaustive (ty:brrr_type) (patterns:list pattern) : bool =
  let remaining = List.fold_left subtract_pattern (VSAll ty) patterns in
  remaining = VSEmpty

(* Check redundancy *)
let rec is_useful (covered:value_space) (p:pattern) : bool =
  (* Pattern is useful if it matches something not yet covered *)
  match covered with
  | VSEmpty -> true
  | VSAll _ -> not (p = PWild || (match p with PVar _ -> true | _ -> false))
  | _ -> admit()
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Algebraic Data Types}

\section{ADT as Initial Algebra}

\begin{definition}[Polynomial Functor]
A polynomial functor $F : \mathsf{Type} \to \mathsf{Type}$ is built from:
\begin{align*}
  F &::= \mathsf{Id} & \text{(identity)} \\
    &\mid K_\tau & \text{(constant $\tau$)} \\
    &\mid F_1 + F_2 & \text{(coproduct)} \\
    &\mid F_1 \times F_2 & \text{(product)} \\
    &\mid F_1 \circ F_2 & \text{(composition)}
\end{align*}
\end{definition}

\begin{definition}[Initial Algebra]
For functor $F$, the initial $F$-algebra is $(\mu F, \mathsf{in}_F)$ where:
\begin{itemize}
  \item $\mu F$ is the least fixed point of $F$
  \item $\mathsf{in}_F : F(\mu F) \to \mu F$ is the constructor
\end{itemize}
\end{definition}

\begin{definition}[Catamorphism (Fold)]
For any $F$-algebra $(C, \alpha : F(C) \to C)$, there exists a unique:
\[
  \mathsf{fold}_F(\alpha) : \mu F \to C
\]
such that $\mathsf{fold}_F(\alpha) \circ \mathsf{in}_F = \alpha \circ F(\mathsf{fold}_F(\alpha))$
\end{definition}

\begin{example}[List as Initial Algebra]
\begin{align*}
  F_{\mathsf{List}[A]}(X) &= 1 + A \times X \\
  \mathsf{List}[A] &= \mu X.\, 1 + A \times X \\
  \mathsf{Nil} &: 1 \to \mathsf{List}[A] \\
  \mathsf{Cons} &: A \times \mathsf{List}[A] \to \mathsf{List}[A]
\end{align*}

The fold is:
\[
  \mathsf{fold}(\mathsf{nil}, \mathsf{cons}) : \mathsf{List}[A] \to C
\]
with equations:
\begin{align*}
  \mathsf{fold}(\mathsf{nil}, \mathsf{cons})(\mathsf{Nil}) &= \mathsf{nil} \\
  \mathsf{fold}(\mathsf{nil}, \mathsf{cons})(\mathsf{Cons}(a, xs)) &= \mathsf{cons}(a, \mathsf{fold}(\mathsf{nil}, \mathsf{cons})(xs))
\end{align*}
\end{example}

\section{Fold Typing}

\begin{definition}[Fold Typing Rule]
\begin{mathpar}
  \inferrule*[right=T-Fold]
    {F : \mathsf{Type} \to \mathsf{Type} \text{ polynomial} \\
     \env \types \mathsf{alg} : F(C) \to C \; [\varepsilon]}
    {\env \types \mathsf{fold}_F(\mathsf{alg}) : \mu F \to C \; [\varepsilon]}
\end{mathpar}
\end{definition}

\section{Codata and Final Coalgebras}

\begin{definition}[Final Coalgebra]
For functor $F$, the final $F$-coalgebra is $(\nu F, \mathsf{out}_F)$ where:
\begin{itemize}
  \item $\nu F$ is the greatest fixed point of $F$
  \item $\mathsf{out}_F : \nu F \to F(\nu F)$ is the destructor
\end{itemize}
\end{definition}

\begin{definition}[Anamorphism (Unfold)]
For any $F$-coalgebra $(S, \gamma : S \to F(S))$, there exists a unique:
\[
  \mathsf{unfold}_F(\gamma) : S \to \nu F
\]
such that $\mathsf{out}_F \circ \mathsf{unfold}_F(\gamma) = F(\mathsf{unfold}_F(\gamma)) \circ \gamma$
\end{definition}

\begin{example}[Stream as Final Coalgebra]
\begin{align*}
  F_{\mathsf{Stream}[A]}(X) &= A \times X \\
  \mathsf{Stream}[A] &= \nu X.\, A \times X \\
  \mathsf{head} &: \mathsf{Stream}[A] \to A \\
  \mathsf{tail} &: \mathsf{Stream}[A] \to \mathsf{Stream}[A]
\end{align*}

The unfold is:
\[
  \mathsf{unfold}(\gamma) : S \to \mathsf{Stream}[A]
\]
where $\gamma : S \to A \times S$.
\end{example}

\section{F* Mechanization}

\begin{fstarcode}[title={Algebraic Data Types in F*}]
module BrrrSemantics.ADT

(* Polynomial functor representation *)
noeq type poly_functor =
  | FId    : poly_functor                           (* Identity *)
  | FConst : brrr_type -> poly_functor              (* Constant *)
  | FSum   : poly_functor -> poly_functor -> poly_functor  (* Coproduct *)
  | FProd  : poly_functor -> poly_functor -> poly_functor  (* Product *)
  | FComp  : poly_functor -> poly_functor -> poly_functor  (* Composition *)

(* Apply functor to type *)
let rec apply_functor (f:poly_functor) (x:Type) : Type =
  match f with
  | FId -> x
  | FConst t -> (* type from brrr_type *) unit  (* simplified *)
  | FSum f1 f2 -> either (apply_functor f1 x) (apply_functor f2 x)
  | FProd f1 f2 -> apply_functor f1 x & apply_functor f2 x
  | FComp f1 f2 -> apply_functor f1 (apply_functor f2 x)

and either (a:Type) (b:Type) = | Left : a -> either a b | Right : b -> either a b

(* Fixed point (would need proper recursive types) *)
noeq type mu (f:poly_functor) =
  | In : apply_functor f (mu f) -> mu f

(* Fold (catamorphism) *)
let rec fold (#f:poly_functor) (#c:Type)
             (alg:apply_functor f c -> c) (x:mu f) : c =
  match x with
  | In fx -> alg (fmap_fold alg fx)

(* Functor map for fold - would need to be derived from functor structure *)
and fmap_fold (#f:poly_functor) (#c:Type)
              (alg:apply_functor f c -> c)
              (fx:apply_functor f (mu f))
              : apply_functor f c =
  admit() (* Depends on functor structure *)

(* List as mu (1 + A × X) *)
type list_functor (a:Type) = FSum (FConst TUnit) (FProd (FConst (* a *) TUnit) FId)

(* Codata: greatest fixed point *)
noeq type nu (f:poly_functor) =
  | CoIn : (unit -> apply_functor f (nu f)) -> nu f

(* Destructor *)
let out (#f:poly_functor) (x:nu f) : apply_functor f (nu f) =
  match x with CoIn thunk -> thunk ()

(* Unfold (anamorphism) *)
let rec unfold (#f:poly_functor) (#s:Type)
               (coalg:s -> apply_functor f s) (seed:s) : nu f =
  CoIn (fun () -> fmap_unfold coalg (coalg seed))

and fmap_unfold (#f:poly_functor) (#s:Type)
                (coalg:s -> apply_functor f s)
                (fx:apply_functor f s)
                : apply_functor f (nu f) =
  admit() (* Depends on functor structure *)

(* Stream example *)
type stream (a:Type) = nu (FProd (FConst (* a *) TUnit) FId)

let stream_head (#a:Type) (s:stream a) : unit (* would be a *) =
  match out s with (hd, _) -> hd

let stream_tail (#a:Type) (s:stream a) : stream a =
  match out s with (_, tl) -> tl

(* Iterate: unfold for streams *)
let iterate (#a:Type) (f:a -> a) (x:a) : stream a =
  unfold (fun s -> ((), (* f s *) s)) x

(* Hylomorphism: unfold then fold *)
let hylo (#f:poly_functor) (#a #b:Type)
         (alg:apply_functor f b -> b)
         (coalg:a -> apply_functor f a)
         (x:a) : b =
  fold alg (unfold coalg x)
\end{fstarcode}


%=============================================================================
% PART VI: METAPROGRAMMING
%=============================================================================
\part{Metaprogramming}

\chapter{Multi-Stage Programming}

This chapter grounds metaprogramming in typed multi-stage programming (MSP), replacing stringly-typed \texttt{eval} with a proper code type.

\section{Code Type}

\begin{definition}[Code Type]
$\Code{\tau}$ is the type of code that, when executed, produces a value of type $\tau$:
\[
  \Code{\tau} : \star \quad \text{where } \tau : \star
\]
\end{definition}

\begin{definition}[Stage Annotation]
Expressions have a stage level $n \in \mathbb{N}$:
\[
  \env \types^n e : \tau \; [\varepsilon]
\]
Stage 0 is runtime; higher stages are compile-time/generation-time.
\end{definition}

\section{Quote and Splice}

\begin{definition}[Quote]
Quote lifts an expression one stage higher:
\[
  \langle e \rangle : \Code{\tau} \quad \text{when } e : \tau
\]
\end{definition}

\begin{definition}[Splice]
Splice inserts code at the current position (lowers stage):
\[
  \mathord{\sim} e : \tau \quad \text{when } e : \Code{\tau}
\]
Splice is only valid inside a quote.
\end{definition}

\begin{definition}[Quote/Splice Typing Rules]
\begin{mathpar}
  \inferrule*[right=T-Quote]
    {\env \types^{n+1} e : \tau \; [\varepsilon]}
    {\env \types^n \langle e \rangle : \Code{\tau} \; [\varepsilon]}
  \and
  \inferrule*[right=T-Splice]
    {\env \types^n e : \Code{\tau} \; [\varepsilon]}
    {\env \types^{n+1} \mathord{\sim} e : \tau \; [\varepsilon]}
  \and
  \inferrule*[right=T-Run]
    {\env \types^0 e : \Code{\tau} \; [\varepsilon] \\ \mathsf{closed}(e)}
    {\env \types^0 \mathsf{run}(e) : \tau \; [\rowext{\mathsf{DynCode}}{\varepsilon}]}
\end{mathpar}
\end{definition}

\section{Cross-Stage Persistence}

\begin{definition}[Lift]
Lift embeds a runtime value into code:
\[
  \mathsf{lift} : \tau \to \Code{\tau} \quad \text{when } \tau \text{ is persistable}
\]
Persistable types: literals, closed values, serializable data.
\end{definition}

\begin{definition}[Lift Typing]
\begin{mathpar}
  \inferrule*[right=T-Lift]
    {\env \types^n e : \tau \; [\varepsilon] \\ \mathsf{persistable}(\tau)}
    {\env \types^n \mathsf{lift}(e) : \Code{\tau} \; [\varepsilon]}
\end{mathpar}
\end{definition}

\section{Staged Power Example}

\begin{example}[Staged Power Function]
\begin{align*}
  &\mathsf{gen\_power} : \mathbb{N} \to \Code{\TInt \to \TInt} \\
  &\mathsf{gen\_power}(0) = \langle \lambda x.\, 1 \rangle \\
  &\mathsf{gen\_power}(n) = \mathsf{let}\, r = \mathsf{gen\_power}(n-1) \;\mathsf{in}\;
    \langle \lambda x.\, x * (\mathord{\sim} r)\, x \rangle
\end{align*}

Evaluation:
\begin{align*}
  \mathsf{gen\_power}(3) &= \langle \lambda x.\, x * x * x * 1 \rangle \\
  \mathsf{run}(\mathsf{gen\_power}(3))(2) &= 8
\end{align*}
No loop overhead---multiplication is unrolled at generation time.
\end{example}

\section{F* Mechanization}

\begin{fstarcode}[title={Multi-Stage Programming in F*}]
module BrrrSemantics.Staging

(* Code representation *)
noeq type code (a:Type) =
  | CQuote  : expr -> code a
  | CLift   : a -> code a
  | CSplice : code (code a) -> code a

(* Stage level *)
type stage = nat

(* Staged expression *)
noeq type staged_expr =
  | SVar    : string -> staged_expr
  | SLit    : base_val -> staged_expr
  | SLam    : string -> staged_expr -> staged_expr
  | SApp    : staged_expr -> staged_expr -> staged_expr
  | SQuote  : staged_expr -> staged_expr           (* <e> *)
  | SSplice : staged_expr -> staged_expr           (* ~e *)
  | SLift   : staged_expr -> staged_expr           (* lift(e) *)
  | SRun    : staged_expr -> staged_expr           (* run(e) *)

(* Type checking with stages *)
noeq type staged_type =
  | STBase  : brrr_type -> staged_type
  | STCode  : staged_type -> staged_type           (* Code[T] *)
  | STArrow : staged_type -> staged_type -> staged_type

(* Staged typing context *)
type staged_ctx = list (string & staged_type & stage)

(* Stage checking *)
let rec check_stage (ctx:staged_ctx) (e:staged_expr) (expected_stage:stage)
    : option staged_type =
  match e with
  | SVar x ->
      (match List.find (fun (y, _, s) -> y = x && s <= expected_stage) ctx with
       | Some (_, t, _) -> Some t
       | None -> None)

  | SLit v -> Some (STBase TInt)  (* simplified *)

  | SLam x body ->
      (* Would need parameter type annotation *)
      admit()

  | SQuote inner ->
      (* Check inner at stage n+1, result is Code[T] at stage n *)
      (match check_stage ctx inner (expected_stage + 1) with
       | Some t -> Some (STCode t)
       | None -> None)

  | SSplice inner ->
      (* Check inner at stage n, must be Code[T], result is T at stage n+1 *)
      if expected_stage = 0 then None  (* Can't splice at stage 0 *)
      else match check_stage ctx inner (expected_stage - 1) with
        | Some (STCode t) -> Some t
        | _ -> None

  | SLift inner ->
      (* Lift value to code *)
      (match check_stage ctx inner expected_stage with
       | Some t -> Some (STCode t)
       | None -> None)

  | SRun inner ->
      (* Run only at stage 0, requires Code[T], produces T *)
      if expected_stage <> 0 then None
      else match check_stage ctx inner 0 with
        | Some (STCode t) -> Some t
        | _ -> None

  | _ -> None

(* Partial evaluation / staging *)
let rec stage_reduce (e:staged_expr) : staged_expr =
  match e with
  | SQuote (SSplice inner) -> stage_reduce inner  (* ~<e> = e *)
  | SSplice (SQuote inner) -> stage_reduce inner  (* <~e> = e *)

  | SQuote inner -> SQuote (stage_reduce inner)
  | SSplice inner -> SSplice (stage_reduce inner)

  | SApp (SLam x body) arg ->
      stage_reduce (subst x arg body)

  | SApp f arg -> SApp (stage_reduce f) (stage_reduce arg)
  | SLam x body -> SLam x (stage_reduce body)
  | _ -> e

and subst (x:string) (v:staged_expr) (e:staged_expr) : staged_expr =
  match e with
  | SVar y -> if y = x then v else e
  | SLam y body -> if y = x then e else SLam y (subst x v body)
  | SApp f arg -> SApp (subst x v f) (subst x v arg)
  | SQuote inner -> SQuote (subst x v inner)
  | SSplice inner -> SSplice (subst x v inner)
  | _ -> e

(* Generate power function *)
let rec gen_power (n:nat) : staged_expr =
  if n = 0 then
    SQuote (SLam "x" (SLit (VInt 1)))
  else
    let rest = gen_power (n - 1) in
    SQuote (SLam "x"
      (SApp (SApp (SVar "*") (SVar "x"))
            (SApp (SSplice rest) (SVar "x"))))

(* After staging: gen_power 3 reduces to code for x*x*x*1 *)
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Typed Reflection}

\section{TypeRep}

\begin{definition}[Type Representation]
$\TypeRep{\tau}$ is a runtime representation of type $\tau$:
\[
  \TypeRep{\tau} : \star
\]
\end{definition}

\begin{definition}[TypeRep Operations]
\begin{align*}
  \mathsf{typeOf} &: \forall \tau.\, \tau \to \TypeRep{\tau} \\
  \mathsf{cast} &: \forall \tau \sigma.\, \tau \to \TypeRep{\sigma} \to \TOption{\sigma} \\
  \mathsf{eqType} &: \forall \tau \sigma.\, \TypeRep{\tau} \to \TypeRep{\sigma} \to \TOption{\tau =:= \sigma}
\end{align*}
where $\tau =:= \sigma$ is a type equality witness (Leibniz equality).
\end{definition}

\begin{definition}[TypeRep Typing]
\begin{mathpar}
  \inferrule*[right=T-TypeOf]
    {\env \types e : \tau \; [\varepsilon]}
    {\env \types \mathsf{typeOf}(e) : \TypeRep{\tau} \; [\varepsilon]}
  \and
  \inferrule*[right=T-Cast]
    {\env \types e : \tau \; [\varepsilon_1] \\ \env \types r : \TypeRep{\sigma} \; [\varepsilon_2]}
    {\env \types \mathsf{cast}(e, r) : \TOption{\sigma} \; [\varepsilon_1 \effjoin \varepsilon_2]}
  \and
  \inferrule*[right=T-EqType]
    {\env \types r_1 : \TypeRep{\tau} \; [\varepsilon_1] \\ \env \types r_2 : \TypeRep{\sigma} \; [\varepsilon_2]}
    {\env \types \mathsf{eqType}(r_1, r_2) : \TOption{\tau =:= \sigma} \; [\varepsilon_1 \effjoin \varepsilon_2]}
\end{mathpar}
\end{definition}

\section{Type Equality Witness}

\begin{definition}[Leibniz Equality]
\[
  \tau =:= \sigma \triangleq \forall F : \star \to \star.\, F[\tau] \to F[\sigma]
\]
If we have $\mathsf{eq} : \tau =:= \sigma$, we can coerce any $F[\tau]$ to $F[\sigma]$.
\end{definition}

\begin{definition}[Coercion via Equality]
\[
  \mathsf{coerce} : \forall \tau \sigma.\, (\tau =:= \sigma) \to \tau \to \sigma
\]
\[
  \mathsf{coerce}(\mathsf{eq}, x) = \mathsf{eq}[\lambda T.\, T](x)
\]
\end{definition}

\section{Dynamic Type}

\begin{definition}[Dynamic Type]
For interop with dynamically-typed code:
\[
  \mathsf{Dynamic} = \exists \tau.\, (\tau \times \TypeRep{\tau})
\]
\end{definition}

\begin{definition}[Dynamic Operations]
\begin{align*}
  \mathsf{toDyn} &: \forall \tau.\, \tau \to \mathsf{Dynamic} \\
  \mathsf{fromDyn} &: \forall \tau.\, \mathsf{Dynamic} \to \TypeRep{\tau} \to \TOption{\tau}
\end{align*}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Typed Reflection in F*}]
module BrrrSemantics.Reflection

(* TypeRep as GADT *)
noeq type type_rep : Type -> Type =
  | TRInt    : type_rep int
  | TRBool   : type_rep bool
  | TRString : type_rep string
  | TRUnit   : type_rep unit
  | TROption : #a:Type -> type_rep a -> type_rep (option a)
  | TRList   : #a:Type -> type_rep a -> type_rep (list a)
  | TRPair   : #a:Type -> #b:Type -> type_rep a -> type_rep b -> type_rep (a & b)
  | TRArrow  : #a:Type -> #b:Type -> type_rep a -> type_rep b -> type_rep (a -> b)

(* Type equality witness *)
type type_eq (a:Type) (b:Type) = a -> b

(* Reflexivity *)
let type_eq_refl (#a:Type) : type_eq a a = fun x -> x

(* Symmetry *)
let type_eq_sym (#a #b:Type) (eq:type_eq a b) : type_eq b a =
  admit() (* Requires type-level tricks *)

(* Check type equality *)
let rec eq_type_rep (#a #b:Type) (ra:type_rep a) (rb:type_rep b)
    : option (type_eq a b) =
  match ra, rb with
  | TRInt, TRInt -> Some type_eq_refl
  | TRBool, TRBool -> Some type_eq_refl
  | TRString, TRString -> Some type_eq_refl
  | TRUnit, TRUnit -> Some type_eq_refl

  | TROption ra', TROption rb' ->
      (match eq_type_rep ra' rb' with
       | Some _ -> Some (admit())  (* Would need proper transport *)
       | None -> None)

  | TRList ra', TRList rb' ->
      (match eq_type_rep ra' rb' with
       | Some _ -> Some (admit())
       | None -> None)

  | TRPair ra1 ra2, TRPair rb1 rb2 ->
      (match eq_type_rep ra1 rb1, eq_type_rep ra2 rb2 with
       | Some _, Some _ -> Some (admit())
       | _, _ -> None)

  | _, _ -> None

(* Get TypeRep for a value (requires type class in real impl) *)
let typeof_int (x:int) : type_rep int = TRInt
let typeof_bool (x:bool) : type_rep bool = TRBool

(* Safe cast using TypeRep *)
let cast (#a #b:Type) (x:a) (target:type_rep b) (source:type_rep a)
    : option b =
  match eq_type_rep source target with
  | Some eq -> Some (eq x)
  | None -> None

(* Dynamic type *)
noeq type dynamic =
  | Dyn : #a:Type -> type_rep a -> a -> dynamic

(* Create dynamic *)
let to_dyn (#a:Type) (rep:type_rep a) (x:a) : dynamic =
  Dyn rep x

(* Extract from dynamic *)
let from_dyn (#a:Type) (d:dynamic) (target:type_rep a) : option a =
  match d with
  | Dyn rep x ->
      match eq_type_rep rep target with
      | Some eq -> Some (eq x)
      | None -> None

(* Example usage *)
let example_reflection () : option int =
  let d = to_dyn TRInt 42 in
  from_dyn d TRInt  (* Some 42 *)

let example_cast_fail () : option string =
  let d = to_dyn TRInt 42 in
  from_dyn d TRString  (* None *)
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Macros and Syntax Transformers}

\section{Syntax Types}

\begin{definition}[Syntax Representation]
Typed syntax fragments:
\begin{align*}
  \mathsf{Expr}[\tau] &\quad \text{(expression producing $\tau$)} \\
  \mathsf{Stmt} &\quad \text{(statement)} \\
  \mathsf{Pat}[\tau] &\quad \text{(pattern matching $\tau$)} \\
  \mathsf{Type} &\quad \text{(type expression)}
\end{align*}
\end{definition}

\begin{definition}[Macro Type]
A macro is a function on syntax:
\[
  \mathsf{macro} : \mathsf{Syntax}_{\mathsf{in}} \to \mathsf{Syntax}_{\mathsf{out}}
\]
\end{definition}

\section{Quasi-Quotation}

\begin{definition}[Quasi-Quote]
Quasi-quotation allows building syntax with holes:
\[
  \mathsf{quote}\{ e \} : \mathsf{Expr}[\tau] \quad \text{when } e : \tau
\]
With antiquotation:
\[
  \mathsf{quote}\{ \ldots \$x \ldots \} \quad \text{where } x : \mathsf{Expr}[\sigma]
\]
\end{definition}

\section{Hygiene}

\begin{definition}[Hygienic Macro]
A macro is hygienic if:
\begin{enumerate}
  \item Variables introduced by the macro don't capture user variables
  \item Variables in user code aren't captured by macro bindings
\end{enumerate}
Achieved via fresh name generation with scope tracking.
\end{definition}

\section{Macro Typing}

\begin{definition}[Macro Typing Rules]
\begin{mathpar}
  \inferrule*[right=T-MacroDef]
    {\env, x_1 : \mathsf{Syntax}_{1}, \ldots, x_n : \mathsf{Syntax}_{n} \types e : \mathsf{Syntax}_{\mathsf{out}}}
    {\env \types \mathsf{macro}\, m(x_1, \ldots, x_n) = e : \mathsf{Macro}[\mathsf{Syntax}_{1} \times \cdots \times \mathsf{Syntax}_{n} \to \mathsf{Syntax}_{\mathsf{out}}]}
  \and
  \inferrule*[right=T-MacroApp]
    {\env \types m : \mathsf{Macro}[\mathsf{Syntax}_{\mathsf{in}} \to \mathsf{Syntax}_{\mathsf{out}}] \\
     \env \types s : \mathsf{Syntax}_{\mathsf{in}}}
    {\env \types m!(s) : \mathsf{Syntax}_{\mathsf{out}}}
\end{mathpar}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Macros in F*}]
module BrrrSemantics.Macros

(* Syntax types *)
noeq type syntax =
  | SynExpr : brrr_type -> expr -> syntax
  | SynStmt : expr -> syntax
  | SynPat  : brrr_type -> pattern -> syntax
  | SynType : brrr_type -> syntax

(* Unique identifier for hygiene *)
type ident = {
  name  : string;
  scope : nat;      (* Scope level for hygiene *)
  mark  : nat       (* Unique mark for macro expansion *)
}

(* Fresh name generation *)
let fresh_counter : ref nat = ref 0

let fresh_ident (base:string) (scope:nat) : ident =
  let mark = !fresh_counter in
  fresh_counter := mark + 1;
  { name = base; scope = scope; mark = mark }

(* Quasi-quotation result *)
noeq type quasi_quote =
  | QQLit    : syntax -> quasi_quote
  | QQSplice : string -> quasi_quote       (* $var to be filled *)
  | QQSeq    : list quasi_quote -> quasi_quote

(* Fill holes in quasi-quote *)
let rec fill_quasi (qq:quasi_quote) (env:list (string & syntax)) : option syntax =
  match qq with
  | QQLit s -> Some s
  | QQSplice var ->
      List.assoc var env
  | QQSeq parts ->
      let filled = List.map (fun q -> fill_quasi q env) parts in
      if List.for_all Some? filled then
        (* Would combine syntaxes *)
        admit()
      else None

(* Macro definition *)
noeq type macro_def = {
  name   : string;
  params : list (string & (* syntax type *) string);
  body   : quasi_quote
}

(* Macro expansion *)
let expand_macro (m:macro_def) (args:list syntax) : option syntax =
  if List.length args <> List.length m.params then None
  else
    let bindings = List.map2 (fun (name, _) arg -> (name, arg)) m.params args in
    fill_quasi m.body bindings

(* Example: assert_eq macro *)
let assert_eq_macro : macro_def = {
  name = "assert_eq";
  params = [("left", "Expr"); ("right", "Expr")];
  body = QQSeq [
    QQLit (SynStmt (EIf
      (EApp (EApp (EVar "!=") (EVar "$left")) (EVar "$right"))
      (EApp (EVar "panic") (ELit (VString "assertion failed")))
      EUnit));
  ]
}

(* Hygiene: rename variables in macro output *)
let rec rename_syntax (renames:list (string & string)) (s:syntax) : syntax =
  match s with
  | SynExpr t e -> SynExpr t (rename_expr renames e)
  | SynStmt e -> SynStmt (rename_expr renames e)
  | _ -> s

and rename_expr (renames:list (string & string)) (e:expr) : expr =
  match e with
  | EVar x ->
      (match List.assoc x renames with
       | Some y -> EVar y
       | None -> e)
  | ELam x body ->
      let x' = fresh_ident x 0 in
      ELam x'.name (rename_expr ((x, x'.name) :: renames) body)
  | ELet x e1 e2 ->
      let x' = fresh_ident x 0 in
      ELet x'.name (rename_expr renames e1)
                   (rename_expr ((x, x'.name) :: renames) e2)
  | EApp f arg -> EApp (rename_expr renames f) (rename_expr renames arg)
  | EIf c t e -> EIf (rename_expr renames c)
                     (rename_expr renames t)
                     (rename_expr renames e)
  | _ -> e

(* Hygienic macro expansion *)
let expand_hygienic (m:macro_def) (args:list syntax) (scope:nat) : option syntax =
  match expand_macro m args with
  | Some result ->
      (* Generate fresh names for all binders in result *)
      Some (rename_syntax [] result)
  | None -> None
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Decorators}

\section{Decorator Type}

\begin{definition}[Decorator]
A decorator transforms a function:
\[
  \mathsf{Decorator}[\tau_1 \xrightarrow{\varepsilon_1} \sigma_1, \tau_2 \xrightarrow{\varepsilon_2} \sigma_2]
    = (\tau_1 \xrightarrow{\varepsilon_1} \sigma_1) \to (\tau_2 \xrightarrow{\varepsilon_2} \sigma_2)
\]
\end{definition}

\begin{definition}[Common Decorator Types]
\begin{align*}
  @\mathsf{cache} &: \forall \alpha \beta \varepsilon.\, (\alpha \xrightarrow{\varepsilon} \beta) \to (\alpha \xrightarrow{\varepsilon \effjoin \EAlloc} \beta) \\
  @\mathsf{log} &: \forall \alpha \beta \varepsilon.\, (\alpha \xrightarrow{\varepsilon} \beta) \to (\alpha \xrightarrow{\varepsilon \effjoin \EIO} \beta) \\
  @\mathsf{retry}(n) &: \forall \alpha \beta \varepsilon.\, (\alpha \xrightarrow{\varepsilon \effjoin \EThrow{E}} \beta) \to (\alpha \xrightarrow{\varepsilon \effjoin \EThrow{E}} \beta)
\end{align*}
\end{definition}

\section{Decorator Typing}

\begin{definition}[Decorator Application]
\begin{mathpar}
  \inferrule*[right=T-Decorator]
    {\env \types d : (\tau_1 \xrightarrow{\varepsilon_1} \sigma_1) \to (\tau_2 \xrightarrow{\varepsilon_2} \sigma_2) \; [\varepsilon_d] \\
     \env \types f : \tau_1 \xrightarrow{\varepsilon_1} \sigma_1 \; [\varepsilon_f]}
    {\env \types @d\, f : \tau_2 \xrightarrow{\varepsilon_2} \sigma_2 \; [\varepsilon_d \effjoin \varepsilon_f]}
\end{mathpar}
\end{definition}

\begin{definition}[Decorator Composition]
\[
  @d_1 \, @d_2 \, f \equiv d_1(d_2(f))
\]
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Decorators in F*}]
module BrrrSemantics.Decorators

(* Decorator type *)
type decorator (a:Type) (b:Type) (c:Type) (d:Type) =
  (a -> b) -> (c -> d)

(* Identity decorator *)
let id_decorator (#a #b:Type) : decorator a b a b =
  fun f -> f

(* Compose decorators *)
let compose_decorator (#a #b #c #d #e #f:Type)
    (d1:decorator c d e f) (d2:decorator a b c d)
    : decorator a b e f =
  fun g -> d1 (d2 g)

(* Cache decorator *)
let cache_decorator (#a #b:Type) (hash:a -> int) (eq:a -> a -> bool)
    : decorator a b a b =
  fun f ->
    let cache : ref (list (a & b)) = ref [] in
    fun x ->
      match List.find (fun (k, _) -> eq k x) !cache with
      | Some (_, v) -> v
      | None ->
          let v = f x in
          cache := (x, v) :: !cache;
          v

(* Log decorator *)
let log_decorator (#a #b:Type) (name:string) : decorator a b a b =
  fun f ->
    fun x ->
      (* print_string ("Calling " ^ name); *)
      let result = f x in
      (* print_string ("Returned from " ^ name); *)
      result

(* Retry decorator *)
let rec retry_decorator (#a #b:Type) (n:nat) : decorator a b a b =
  fun f ->
    fun x ->
      if n = 0 then f x
      else
        try f x
        with _ -> retry_decorator (n - 1) f x

(* Timing decorator *)
let time_decorator (#a #b:Type) : decorator a b a (b & int) =
  fun f ->
    fun x ->
      let start = (* get_time () *) 0 in
      let result = f x in
      let elapsed = (* get_time () - start *) 0 in
      (result, elapsed)

(* Decorator application syntax *)
let apply_decorator (#a #b #c #d:Type)
    (dec:decorator a b c d) (f:a -> b) : c -> d =
  dec f

(* Chained application *)
let example_decorated_function () =
  let base_fn (x:int) : int = x * 2 in
  let decorated =
    apply_decorator (log_decorator "double")
      (apply_decorator (cache_decorator (fun x -> x) (=)) base_fn)
  in
  decorated 21  (* Returns 42, with logging and caching *)
\end{fstarcode}


%=============================================================================
% PART VII: CONCURRENCY & SESSION TYPES
%=============================================================================
\part{Concurrency \& Session Types}

\chapter{Session Type Foundations}

Session types provide a type discipline for communication protocols, ensuring that interacting processes follow agreed-upon message sequences.

\section{Binary Session Types}

\begin{definition}[Session Type Grammar]
\begin{align*}
  S &::= !\tau.S & \text{(send $\tau$, continue as $S$)} \\
    &\mid ?\tau.S & \text{(receive $\tau$, continue as $S$)} \\
    &\mid S_1 \oplus S_2 & \text{(internal choice: select)} \\
    &\mid S_1 \mathbin{\&} S_2 & \text{(external choice: branch)} \\
    &\mid \mu X. S & \text{(recursive session)} \\
    &\mid X & \text{(session variable)} \\
    &\mid \mathsf{end} & \text{(session termination)}
\end{align*}
\end{definition}

\begin{definition}[Session Duality]
The dual of a session type $\overline{S}$ swaps sends/receives and choices:
\begin{align*}
  \overline{!\tau.S} &= ?\tau.\overline{S} \\
  \overline{?\tau.S} &= !\tau.\overline{S} \\
  \overline{S_1 \oplus S_2} &= \overline{S_1} \mathbin{\&} \overline{S_2} \\
  \overline{S_1 \mathbin{\&} S_2} &= \overline{S_1} \oplus \overline{S_2} \\
  \overline{\mu X. S} &= \mu X. \overline{S} \\
  \overline{X} &= X \\
  \overline{\mathsf{end}} &= \mathsf{end}
\end{align*}
\end{definition}

\begin{theorem}[Duality Involution]
For all session types $S$:
\[
  \overline{\overline{S}} = S
\]
\end{theorem}

\begin{proof}
By structural induction on $S$. Each case follows directly from the definition of duality.
\end{proof}

\section{Session Typing Rules}

\begin{definition}[Session Context]
A session context $\Sigma$ maps channel names to session types:
\[
  \Sigma = c_1 : S_1, \ldots, c_n : S_n
\]
\end{definition}

\begin{definition}[Session Typing Judgment]
$\Sigma; \env \types P$ means process $P$ is well-typed under session context $\Sigma$ and value context $\env$.
\end{definition}

\begin{definition}[Core Session Typing Rules]
\begin{mathpar}
  \inferrule*[right=S-Send]
    {\Sigma, c : S; \env \types P \\ \env \types e : \tau \; [\varepsilon]}
    {\Sigma, c : !\tau.S; \env \types c!\langle e \rangle.P}
  \and
  \inferrule*[right=S-Recv]
    {\Sigma, c : S; \env, x : \tau \types P}
    {\Sigma, c : ?\tau.S; \env \types c?(x).P}
  \and
  \inferrule*[right=S-Select]
    {\Sigma, c : S_i; \env \types P}
    {\Sigma, c : S_1 \oplus S_2; \env \types c \triangleleft l_i.P}
  \and
  \inferrule*[right=S-Branch]
    {\Sigma, c : S_1; \env \types P_1 \\ \Sigma, c : S_2; \env \types P_2}
    {\Sigma, c : S_1 \mathbin{\&} S_2; \env \types c \triangleright \{l_1 : P_1, l_2 : P_2\}}
  \and
  \inferrule*[right=S-Par]
    {\Sigma_1; \env \types P \\ \Sigma_2; \env \types Q \\ \Sigma_1 \cap \Sigma_2 = \emptyset}
    {\Sigma_1, \Sigma_2; \env \types P \mid Q}
  \and
  \inferrule*[right=S-New]
    {\Sigma, c : S, d : \overline{S}; \env \types P}
    {\Sigma; \env \types (\nu c\, d) P}
  \and
  \inferrule*[right=S-End]
    { }
    {c : \mathsf{end}; \env \types \mathbf{0}}
\end{mathpar}
\end{definition}

\section{Session Type Safety}

\begin{theorem}[Session Fidelity]
If $\Sigma; \env \types P$ and $P \longrightarrow P'$, then there exists $\Sigma'$ such that $\Sigma'; \env \types P'$ and the session types progress correctly.
\end{theorem}

\begin{theorem}[Communication Safety]
Well-typed processes do not have communication mismatches:
\begin{itemize}
  \item No message type errors (sending wrong type)
  \item No deadlocks from protocol violations
  \item No orphan messages
\end{itemize}
\end{theorem}

\section{F* Mechanization}

\begin{fstarcode}[title={Session Types in F*}]
module BrrrSemantics.SessionTypes

(* Session type *)
noeq type session_type =
  | SSend   : brrr_type -> session_type -> session_type  (* !τ.S *)
  | SRecv   : brrr_type -> session_type -> session_type  (* ?τ.S *)
  | SSelect : session_type -> session_type -> session_type  (* S₁ ⊕ S₂ *)
  | SBranch : session_type -> session_type -> session_type  (* S₁ & S₂ *)
  | SRec    : string -> session_type -> session_type     (* μX.S *)
  | SVar    : string -> session_type                     (* X *)
  | SEnd    : session_type                               (* end *)

(* Session duality *)
let rec dual (s:session_type) : session_type =
  match s with
  | SSend t cont -> SRecv t (dual cont)
  | SRecv t cont -> SSend t (dual cont)
  | SSelect s1 s2 -> SBranch (dual s1) (dual s2)
  | SBranch s1 s2 -> SSelect (dual s1) (dual s2)
  | SRec x body -> SRec x (dual body)
  | SVar x -> SVar x
  | SEnd -> SEnd

(* Duality is involution *)
let rec dual_involution (s:session_type)
    : Lemma (ensures dual (dual s) = s) (decreases s) =
  match s with
  | SSend t cont -> dual_involution cont
  | SRecv t cont -> dual_involution cont
  | SSelect s1 s2 -> dual_involution s1; dual_involution s2
  | SBranch s1 s2 -> dual_involution s1; dual_involution s2
  | SRec x body -> dual_involution body
  | SVar _ -> ()
  | SEnd -> ()

(* Process syntax *)
noeq type process =
  | PSend   : string -> expr -> process -> process       (* c!<e>.P *)
  | PRecv   : string -> string -> process -> process     (* c?(x).P *)
  | PSelect : string -> string -> process -> process     (* c ◁ l.P *)
  | PBranch : string -> list (string & process) -> process  (* c ▷ {l:P} *)
  | PPar    : process -> process -> process              (* P | Q *)
  | PNew    : string -> string -> session_type -> process -> process  (* (νc d)P *)
  | PEnd    : process                                    (* 0 *)
  | PRec    : string -> process -> process               (* rec X.P *)
  | PVar    : string -> process                          (* X *)

(* Session context *)
type session_ctx = list (string & session_type)

(* Lookup in session context *)
let lookup_session (c:string) (ctx:session_ctx) : option session_type =
  List.assoc c ctx

(* Remove from session context *)
let remove_session (c:string) (ctx:session_ctx) : session_ctx =
  List.filter (fun (c', _) -> c' <> c) ctx

(* Update session context *)
let update_session (c:string) (s:session_type) (ctx:session_ctx) : session_ctx =
  (c, s) :: remove_session c ctx

(* Session type checking *)
let rec check_process (sctx:session_ctx) (vctx:env) (p:process)
    : option session_ctx =
  match p with
  | PSend c e cont ->
      (match lookup_session c sctx with
       | Some (SSend t s) ->
           (* Check e has type t, then continue *)
           check_process (update_session c s sctx) vctx cont
       | _ -> None)

  | PRecv c x cont ->
      (match lookup_session c sctx with
       | Some (SRecv t s) ->
           check_process (update_session c s sctx) (extend vctx x (VBase VUnit)) cont
       | _ -> None)

  | PSelect c l cont ->
      (match lookup_session c sctx with
       | Some (SSelect s1 s2) ->
           let s = if l = "left" then s1 else s2 in
           check_process (update_session c s sctx) vctx cont
       | _ -> None)

  | PBranch c branches ->
      (match lookup_session c sctx with
       | Some (SBranch s1 s2) ->
           (* Check both branches *)
           admit()
       | _ -> None)

  | PPar p1 p2 ->
      (* Split context *)
      admit()

  | PNew c d s cont ->
      check_process ((c, s) :: (d, dual s) :: sctx) vctx cont

  | PEnd ->
      if List.for_all (fun (_, s) -> s = SEnd) sctx
      then Some []
      else None

  | _ -> None
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Multiparty Session Types}

\section{Global Types}

\begin{definition}[Global Type Grammar]
Global types describe the interaction from a global perspective:
\begin{align*}
  G &::= p \to q : \tau.G & \text{(message from $p$ to $q$)} \\
    &\mid p \to q : \{l_i : G_i\}_{i \in I} & \text{(labeled choice)} \\
    &\mid \mu X. G & \text{(recursion)} \\
    &\mid X & \text{(variable)} \\
    &\mid \mathsf{end} & \text{(termination)}
\end{align*}
\end{definition}

\begin{definition}[Projection]
Projection $G \upharpoonright p$ extracts participant $p$'s view from global type $G$:
\begin{align*}
  (q \to r : \tau.G) \upharpoonright p &= \begin{cases}
    !\langle r, \tau \rangle.(G \upharpoonright p) & \text{if } p = q \\
    ?\langle q, \tau \rangle.(G \upharpoonright p) & \text{if } p = r \\
    G \upharpoonright p & \text{otherwise}
  \end{cases} \\[1em]
  (q \to r : \{l_i : G_i\}) \upharpoonright p &= \begin{cases}
    \bigoplus_{i} l_i.(G_i \upharpoonright p) & \text{if } p = q \\
    \mathbin{\&}_{i} l_i.(G_i \upharpoonright p) & \text{if } p = r \\
    \sqcup_i (G_i \upharpoonright p) & \text{otherwise}
  \end{cases} \\[1em]
  (\mu X.G) \upharpoonright p &= \mu X.(G \upharpoonright p) \\
  X \upharpoonright p &= X \\
  \mathsf{end} \upharpoonright p &= \mathsf{end}
\end{align*}
where $\sqcup$ is the merge operator requiring compatible branches.
\end{definition}

\section{Merge Operator}

\begin{definition}[Session Type Merge]
The merge $S_1 \sqcup S_2$ combines compatible session types:
\begin{align*}
  !\langle q, \tau \rangle.S_1 \sqcup !\langle q, \tau \rangle.S_2 &= !\langle q, \tau \rangle.(S_1 \sqcup S_2) \\
  ?\langle q, \tau \rangle.S_1 \sqcup ?\langle q, \tau \rangle.S_2 &= ?\langle q, \tau \rangle.(S_1 \sqcup S_2) \\
  (S_1 \mathbin{\&} S_1') \sqcup (S_2 \mathbin{\&} S_2') &= (S_1 \sqcup S_2) \mathbin{\&} (S_1' \sqcup S_2') \\
  \mathsf{end} \sqcup \mathsf{end} &= \mathsf{end}
\end{align*}
Merge is undefined for incompatible types.
\end{definition}

\begin{theorem}[Projection Consistency]
If global type $G$ is well-formed and projectable to all participants, then for any two participants $p, q$ with dual interactions, their projections are compatible.
\end{theorem}

\section{Well-Formedness}

\begin{definition}[Well-Formed Global Type]
A global type $G$ is well-formed iff:
\begin{enumerate}
  \item Every participant appears in at least one interaction
  \item Projection is defined for all participants
  \item Recursive types are contractive (guarded)
\end{enumerate}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Multiparty Session Types in F*}]
module BrrrSemantics.MultipartySession

(* Participant identifier *)
type participant = string

(* Global type *)
noeq type global_type =
  | GMsg    : participant -> participant -> brrr_type -> global_type -> global_type
  | GChoice : participant -> participant -> list (string & global_type) -> global_type
  | GRec    : string -> global_type -> global_type
  | GVar    : string -> global_type
  | GEnd    : global_type

(* Local (endpoint) type *)
noeq type local_type =
  | LSend   : participant -> brrr_type -> local_type -> local_type
  | LRecv   : participant -> brrr_type -> local_type -> local_type
  | LSelect : participant -> list (string & local_type) -> local_type
  | LBranch : participant -> list (string & local_type) -> local_type
  | LRec    : string -> local_type -> local_type
  | LVar    : string -> local_type
  | LEnd    : local_type

(* Merge two local types *)
let rec merge_local (l1 l2:local_type) : option local_type =
  match l1, l2 with
  | LEnd, LEnd -> Some LEnd

  | LSend p t1 cont1, LSend p' t2 cont2 ->
      if p = p' && t1 = t2 then
        match merge_local cont1 cont2 with
        | Some cont -> Some (LSend p t1 cont)
        | None -> None
      else None

  | LRecv p t1 cont1, LRecv p' t2 cont2 ->
      if p = p' && t1 = t2 then
        match merge_local cont1 cont2 with
        | Some cont -> Some (LRecv p t1 cont)
        | None -> None
      else None

  | LBranch p bs1, LBranch p' bs2 ->
      if p = p' then
        (* Merge branch by branch *)
        admit()
      else None

  | _, _ -> None

(* Project global type to participant *)
let rec project (g:global_type) (p:participant) : option local_type =
  match g with
  | GMsg sender receiver ty cont ->
      (match project cont p with
       | Some cont' ->
           if p = sender then Some (LSend receiver ty cont')
           else if p = receiver then Some (LRecv sender ty cont')
           else Some cont'
       | None -> None)

  | GChoice sender receiver branches ->
      let projected = List.map (fun (l, g') ->
        match project g' p with
        | Some l' -> Some (l, l')
        | None -> None) branches in
      if List.for_all Some? projected then
        let branches' = List.map (fun (Some x) -> x) projected in
        if p = sender then Some (LSelect receiver branches')
        else if p = receiver then Some (LBranch sender branches')
        else
          (* Merge all branches for non-involved participant *)
          List.fold_left (fun acc (_, l) ->
            match acc with
            | Some acc' -> merge_local acc' l
            | None -> None
          ) (Some LEnd) branches'
      else None

  | GRec x body ->
      (match project body p with
       | Some body' -> Some (LRec x body')
       | None -> None)

  | GVar x -> Some (LVar x)

  | GEnd -> Some LEnd

(* Get all participants from global type *)
let rec participants (g:global_type) : list participant =
  match g with
  | GMsg s r _ cont -> s :: r :: participants cont
  | GChoice s r branches ->
      s :: r :: List.concat (List.map (fun (_, g') -> participants g') branches)
  | GRec _ body -> participants body
  | GVar _ -> []
  | GEnd -> []

(* Check well-formedness *)
let well_formed (g:global_type) : bool =
  let parts = List.dedup (participants g) in
  List.for_all (fun p -> Some? (project g p)) parts

(* Example: Two-buyer protocol *)
let two_buyer_protocol : global_type =
  GMsg "Buyer1" "Seller" TString (                    (* Buyer1 -> Seller: title *)
  GMsg "Seller" "Buyer1" (TInt {width=I32; sign=Signed}) (  (* Seller -> Buyer1: price *)
  GMsg "Seller" "Buyer2" (TInt {width=I32; sign=Signed}) (  (* Seller -> Buyer2: price *)
  GMsg "Buyer1" "Buyer2" (TInt {width=I32; sign=Signed}) (  (* Buyer1 -> Buyer2: share *)
  GChoice "Buyer2" "Seller" [                         (* Buyer2 -> Seller: choice *)
    ("ok", GMsg "Buyer2" "Seller" TString GEnd);      (* ok: address *)
    ("quit", GEnd)                                    (* quit: done *)
  ]))))
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Deadlock Freedom}

\section{Priority-Based Typing}

\begin{definition}[Prioritized Session Type]
A prioritized session type annotates each action with a priority level:
\[
  S ::= !^n\tau.S \mid ?^n\tau.S \mid \ldots
\]
where $n \in \mathbb{N}$ is the priority.
\end{definition}

\begin{definition}[Priority Ordering]
For deadlock freedom, priorities must be consistently ordered:
\begin{itemize}
  \item If $c$ sends at priority $n$ and $d$ receives at priority $m$, and $c$ and $d$ can interact, then $n < m$ or $m < n$
  \item No circular dependencies in priority ordering
\end{itemize}
\end{definition}

\begin{theorem}[Deadlock Freedom]
If all session types are consistently prioritized and all processes are well-typed, then the system is deadlock-free.
\end{theorem}

\section{Cycle Detection}

\begin{definition}[Dependency Graph]
The dependency graph $\mathcal{D}(P)$ has:
\begin{itemize}
  \item Nodes: channel names
  \item Edges: $c \to d$ if process waits on $c$ before acting on $d$
\end{itemize}
\end{definition}

\begin{theorem}[Acyclicity Implies Deadlock Freedom]
If $\mathcal{D}(P)$ is acyclic, then $P$ is deadlock-free.
\end{theorem}

\section{F* Mechanization}

\begin{fstarcode}[title={Deadlock Freedom in F*}]
module BrrrSemantics.DeadlockFreedom

(* Priority level *)
type priority = nat

(* Prioritized session type *)
noeq type pri_session =
  | PriSend   : priority -> brrr_type -> pri_session -> pri_session
  | PriRecv   : priority -> brrr_type -> pri_session -> pri_session
  | PriSelect : priority -> pri_session -> pri_session -> pri_session
  | PriBranch : priority -> pri_session -> pri_session -> pri_session
  | PriEnd    : pri_session

(* Get minimum priority in session type *)
let rec min_priority (s:pri_session) : option priority =
  match s with
  | PriSend p _ cont ->
      (match min_priority cont with
       | Some p' -> Some (min p p')
       | None -> Some p)
  | PriRecv p _ cont ->
      (match min_priority cont with
       | Some p' -> Some (min p p')
       | None -> Some p)
  | PriSelect p s1 s2 ->
      let m1 = min_priority s1 in
      let m2 = min_priority s2 in
      Some p  (* Simplified *)
  | PriBranch p s1 s2 ->
      Some p
  | PriEnd -> None

(* Check priority consistency for dual session types *)
let priority_consistent (s1 s2:pri_session) : bool =
  match s1, s2 with
  | PriSend p1 _ _, PriRecv p2 _ _ -> p1 < p2 || p2 < p1
  | PriRecv p1 _ _, PriSend p2 _ _ -> p1 < p2 || p2 < p1
  | _, _ -> true

(* Dependency graph as adjacency list *)
type dep_graph = list (string & list string)

(* Build dependency graph from process *)
let rec build_dep_graph (p:process) : dep_graph =
  match p with
  | PSend c _ (PRecv d _ cont) ->
      (* Wait on d after sending on c *)
      (c, [d]) :: build_dep_graph cont
  | PRecv c _ (PSend d _ cont) ->
      (* Wait on c before sending on d *)
      (c, [d]) :: build_dep_graph cont
  | PPar p1 p2 ->
      build_dep_graph p1 @ build_dep_graph p2
  | PNew _ _ _ cont -> build_dep_graph cont
  | _ -> []

(* Check if graph has cycle (simplified DFS) *)
let rec has_cycle (g:dep_graph) (visited:list string) (node:string) : bool =
  if List.mem node visited then true
  else match List.assoc node g with
    | Some neighbors ->
        List.exists (has_cycle g (node :: visited)) neighbors
    | None -> false

(* Check deadlock freedom *)
let is_deadlock_free (p:process) : bool =
  let g = build_dep_graph p in
  let nodes = List.map fst g in
  not (List.exists (has_cycle g []) nodes)

(* Lock ordering type for preventing mutex deadlocks *)
type lock_order = list string  (* Locks in acquisition order *)

(* Check lock acquisition respects order *)
let respects_lock_order (acquired:list string) (order:lock_order) : bool =
  (* All acquired locks should appear in order *)
  let positions = List.map (fun l ->
    match List.find_index ((=) l) order with
    | Some i -> i
    | None -> -1) acquired in
  (* Check positions are increasing *)
  let rec increasing = function
    | [] -> true
    | [_] -> true
    | x :: y :: rest -> x < y && increasing (y :: rest)
  in increasing positions
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Actors}

\section{Actor Model}

\begin{definition}[Actor]
An actor is a computational entity that:
\begin{enumerate}
  \item Has a unique address
  \item Has a mailbox (message queue)
  \item Processes messages sequentially
  \item Can send messages to other actors
  \item Can create new actors
  \item Can update its own behavior
\end{enumerate}
\end{definition}

\begin{definition}[Actor Type]
\[
  \mathsf{Actor}[M, S] = \{
    \mathsf{address} : \mathsf{ActorRef}[M],
    \mathsf{state} : S,
    \mathsf{behavior} : M \to S \to \mathsf{ActorComp}[S]
  \}
\]
where $M$ is the message type and $S$ is the state type.
\end{definition}

\section{Actor Typing}

\begin{definition}[Actor Reference]
$\mathsf{ActorRef}[M]$ is a capability to send messages of type $M$:
\[
  \mathsf{ActorRef}[M] : \star
\]
\end{definition}

\begin{definition}[Actor Computation]
\begin{align*}
  \mathsf{ActorComp}[S] &= \mathsf{Effect}\, [\mathsf{ActorEff}]\, S \\
  \mathsf{ActorEff} &::= \mathsf{Send}[\mathsf{ActorRef}[M], M] \\
    &\mid \mathsf{Spawn}[M', S', \mathsf{Behavior}[M', S']] \\
    &\mid \mathsf{Self}[\mathsf{ActorRef}[M]]
\end{align*}
\end{definition}

\begin{definition}[Actor Typing Rules]
\begin{mathpar}
  \inferrule*[right=T-Send]
    {\env \types r : \mathsf{ActorRef}[M] \; [\varepsilon_1] \\
     \env \types m : M \; [\varepsilon_2]}
    {\env \types r ! m : \TUnit \; [\rowext{\mathsf{ActorEff}}{\varepsilon_1 \effjoin \varepsilon_2}]}
  \and
  \inferrule*[right=T-Spawn]
    {\env \types \mathsf{init} : S \; [\varepsilon_1] \\
     \env \types \mathsf{behav} : M \to S \to \mathsf{ActorComp}[S] \; [\varepsilon_2]}
    {\env \types \mathsf{spawn}(\mathsf{init}, \mathsf{behav}) : \mathsf{ActorRef}[M] \; [\rowext{\mathsf{ActorEff}}{\varepsilon_1 \effjoin \varepsilon_2}]}
  \and
  \inferrule*[right=T-Self]
    {\text{inside actor handling } M}
    {\env \types \mathsf{self} : \mathsf{ActorRef}[M] \; [\mathsf{ActorEff}]}
\end{mathpar}
\end{definition}

\section{Actor Semantics}

\begin{definition}[Actor Configuration]
An actor configuration is:
\[
  \mathcal{C} = \{a_1 \mapsto (S_1, Q_1, B_1), \ldots, a_n \mapsto (S_n, Q_n, B_n)\}
\]
where $a_i$ is address, $S_i$ is state, $Q_i$ is message queue, $B_i$ is behavior.
\end{definition}

\begin{definition}[Actor Reduction]
\begin{align*}
  &\mathcal{C}[a \mapsto (S, m :: Q, B)] \longrightarrow \mathcal{C}'[a \mapsto (S', Q, B')] \\
  &\quad \text{where } (S', B', \mathsf{effects}) = B(m, S)
\end{align*}
Effects include spawning new actors and sending messages.
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Actors in F*}]
module BrrrSemantics.Actors

(* Actor address *)
type actor_id = nat

(* Actor reference (capability to send messages) *)
noeq type actor_ref (msg:Type) = {
  target : actor_id
}

(* Actor effect *)
noeq type actor_effect =
  | AESend  : #m:Type -> actor_ref m -> m -> actor_effect
  | AESpawn : #m:Type -> #s:Type -> s -> (m -> s -> actor_comp s) -> actor_effect
  | AESelf  : actor_effect

and actor_comp (s:Type) =
  | ACPure    : s -> actor_comp s
  | ACEffect  : actor_effect -> (unit -> actor_comp s) -> actor_comp s

(* Behavior: message handler *)
type behavior (msg:Type) (state:Type) =
  msg -> state -> actor_comp state

(* Actor state *)
noeq type actor (msg:Type) (state:Type) = {
  id       : actor_id;
  state    : state;
  mailbox  : list msg;
  behavior : behavior msg state
}

(* Actor system configuration *)
noeq type actor_system = {
  actors     : list (actor_id & (exists m s. actor m s));
  next_id    : actor_id;
  pending    : list (actor_id & (exists m. m))  (* Pending messages *)
}

(* Send message *)
let send (#m:Type) (ref:actor_ref m) (msg:m) : actor_comp unit =
  ACEffect (AESend ref msg) (fun () -> ACPure ())

(* Spawn new actor *)
let spawn (#m #s:Type) (init:s) (behav:behavior m s) : actor_comp (actor_ref m) =
  ACEffect (AESpawn init behav) (fun () ->
    (* Would return new ref - simplified *)
    ACPure ({ target = 0 }))

(* Get self reference *)
let self (#m:Type) () : actor_comp (actor_ref m) =
  ACEffect AESelf (fun () -> ACPure ({ target = 0 }))

(* Run one step of actor computation *)
let rec run_actor_comp (#s:Type) (comp:actor_comp s) (sys:actor_system)
    : s & actor_system =
  match comp with
  | ACPure s -> (s, sys)
  | ACEffect eff cont ->
      match eff with
      | AESend ref msg ->
          let sys' = { sys with
            pending = (ref.target, msg) :: sys.pending
          } in
          run_actor_comp (cont ()) sys'
      | AESpawn init behav ->
          let new_id = sys.next_id in
          let new_actor = { id = new_id; state = init; mailbox = []; behavior = behav } in
          let sys' = { sys with
            actors = (new_id, new_actor) :: sys.actors;
            next_id = new_id + 1
          } in
          run_actor_comp (cont ()) sys'
      | AESelf ->
          run_actor_comp (cont ()) sys

(* Process one message for an actor *)
let step_actor (#m #s:Type) (a:actor m s) (sys:actor_system)
    : option (actor m s & actor_system) =
  match a.mailbox with
  | [] -> None
  | msg :: rest ->
      let (new_state, sys') = run_actor_comp (a.behavior msg a.state) sys in
      Some ({ a with state = new_state; mailbox = rest }, sys')

(* Deliver pending messages *)
let deliver_messages (sys:actor_system) : actor_system =
  List.fold_left (fun sys (target, msg) ->
    (* Find actor and add to mailbox *)
    { sys with
      actors = List.map (fun (id, a) ->
        if id = target then
          (* Add message to mailbox - simplified *)
          (id, a)
        else (id, a)
      ) sys.actors
    }
  ) { sys with pending = [] } sys.pending

(* Example: Ping-pong actors *)
type ping_msg = | Ping : actor_ref pong_msg -> ping_msg
and pong_msg = | Pong : actor_ref ping_msg -> pong_msg

let ping_behavior : behavior ping_msg nat =
  fun msg count ->
    match msg with
    | Ping sender ->
        let _ = send sender (Pong ({ target = 0 })) in
        ACPure (count + 1)

let pong_behavior : behavior pong_msg nat =
  fun msg count ->
    match msg with
    | Pong sender ->
        let _ = send sender (Ping ({ target = 0 })) in
        ACPure (count + 1)
\end{fstarcode}


%=============================================================================
% PART VIII: MODULE SYSTEM
%=============================================================================
\part{Module System}

\chapter{Signatures}

The module system is grounded in ML module theory, providing abstraction, separate compilation, and code reuse.

\section{Module Language}

\begin{definition}[Module Grammar]
\begin{align*}
  M &::= \{ B_1; \ldots; B_n \} & \text{(structure)} \\
    &\mid M.x & \text{(projection)} \\
    &\mid F(M) & \text{(functor application)} \\
    &\mid M : \Sigma & \text{(transparent ascription)} \\
    &\mid M :> \Sigma & \text{(opaque ascription/sealing)}
\end{align*}
\end{definition}

\begin{definition}[Signature Grammar]
\begin{align*}
  \Sigma &::= \{ D_1; \ldots; D_n \} & \text{(signature)} \\
    &\mid \Sigma_1 \to \Sigma_2 & \text{(functor signature)} \\
    &\mid \Sigma \;\mathsf{where}\; \mathsf{type}\; p = \tau & \text{(type refinement)}
\end{align*}
\end{definition}

\begin{definition}[Declaration Grammar]
\begin{align*}
  D &::= \mathsf{type}\; t & \text{(abstract type)} \\
    &\mid \mathsf{type}\; t = \tau & \text{(manifest type)} \\
    &\mid \mathsf{val}\; x : \tau & \text{(value specification)} \\
    &\mid \mathsf{module}\; M : \Sigma & \text{(nested module)}
\end{align*}
\end{definition}

\section{Signature Typing}

\begin{definition}[Signature Typing Rules]
\begin{mathpar}
  \inferrule*[right=Sig-Empty]
    { }
    {\env \types \{\} : \mathsf{Sig}}
  \and
  \inferrule*[right=Sig-Type]
    {\env \types \Sigma : \mathsf{Sig}}
    {\env \types \{\mathsf{type}\; t; \Sigma\} : \mathsf{Sig}}
  \and
  \inferrule*[right=Sig-Val]
    {\env \types \tau : \star \\ \env \types \Sigma : \mathsf{Sig}}
    {\env \types \{\mathsf{val}\; x : \tau; \Sigma\} : \mathsf{Sig}}
  \and
  \inferrule*[right=Sig-Module]
    {\env \types \Sigma_1 : \mathsf{Sig} \\ \env \types \Sigma_2 : \mathsf{Sig}}
    {\env \types \{\mathsf{module}\; M : \Sigma_1; \Sigma_2\} : \mathsf{Sig}}
\end{mathpar}
\end{definition}

\section{Signature Matching}

\begin{definition}[Signature Subtyping]
$\Sigma_1 <: \Sigma_2$ (signature $\Sigma_1$ matches $\Sigma_2$) iff:
\begin{itemize}
  \item For each $\mathsf{type}\; t$ in $\Sigma_2$, either:
    \begin{itemize}
      \item $\Sigma_1$ has $\mathsf{type}\; t = \tau$ (more specific)
      \item $\Sigma_1$ has $\mathsf{type}\; t$ (same abstraction)
    \end{itemize}
  \item For each $\mathsf{val}\; x : \tau$ in $\Sigma_2$, $\Sigma_1$ has $\mathsf{val}\; x : \tau'$ with $\tau' <: \tau$
  \item Additional declarations in $\Sigma_1$ are allowed
\end{itemize}
\end{definition}

\begin{definition}[Signature Matching Rules]
\begin{mathpar}
  \inferrule*[right=Match-Empty]
    { }
    {\Sigma <: \{\}}
  \and
  \inferrule*[right=Match-Type-Abs]
    {\Sigma <: \Sigma' \\ \mathsf{type}\; t \in \Sigma \lor \mathsf{type}\; t = \_ \in \Sigma}
    {\Sigma <: \{\mathsf{type}\; t; \Sigma'\}}
  \and
  \inferrule*[right=Match-Type-Manifest]
    {\Sigma <: \Sigma' \\ \mathsf{type}\; t = \tau \in \Sigma}
    {\Sigma <: \{\mathsf{type}\; t = \tau; \Sigma'\}}
  \and
  \inferrule*[right=Match-Val]
    {\Sigma <: \Sigma' \\ \mathsf{val}\; x : \tau' \in \Sigma \\ \tau' <: \tau}
    {\Sigma <: \{\mathsf{val}\; x : \tau; \Sigma'\}}
\end{mathpar}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Signatures in F*}]
module BrrrSemantics.Signatures

(* Signature declaration *)
noeq type sig_decl =
  | SigTypeAbstract : string -> sig_decl              (* type t *)
  | SigTypeManifest : string -> brrr_type -> sig_decl (* type t = τ *)
  | SigVal          : string -> brrr_type -> sig_decl (* val x : τ *)
  | SigModule       : string -> signature -> sig_decl (* module M : Σ *)

(* Signature *)
and signature =
  | SigEmpty  : signature
  | SigCons   : sig_decl -> signature -> signature
  | SigFunctor: string -> signature -> signature -> signature  (* (X : Σ₁) -> Σ₂ *)
  | SigWhere  : signature -> string -> brrr_type -> signature  (* Σ where type p = τ *)

(* Module expression *)
noeq type mod_expr =
  | ModStruct    : list mod_binding -> mod_expr
  | ModProj      : mod_expr -> string -> mod_expr
  | ModApp       : mod_expr -> mod_expr -> mod_expr
  | ModAscribe   : mod_expr -> signature -> mod_expr    (* M : Σ *)
  | ModSeal      : mod_expr -> signature -> mod_expr    (* M :> Σ *)
  | ModFunctor   : string -> signature -> mod_expr -> mod_expr
  | ModIdent     : string -> mod_expr

(* Module binding *)
and mod_binding =
  | BindType   : string -> brrr_type -> mod_binding
  | BindVal    : string -> expr -> mod_binding
  | BindModule : string -> mod_expr -> mod_binding

(* Lookup declaration in signature *)
let rec lookup_sig_decl (name:string) (sig_:signature) : option sig_decl =
  match sig_ with
  | SigEmpty -> None
  | SigCons decl rest ->
      let decl_name = match decl with
        | SigTypeAbstract n -> n
        | SigTypeManifest n _ -> n
        | SigVal n _ -> n
        | SigModule n _ -> n
      in
      if decl_name = name then Some decl
      else lookup_sig_decl name rest
  | SigFunctor _ _ _ -> None
  | SigWhere base _ _ -> lookup_sig_decl name base

(* Check signature subtyping *)
let rec sig_subtype (s1 s2:signature) : bool =
  match s2 with
  | SigEmpty -> true
  | SigCons decl rest ->
      (match decl with
       | SigTypeAbstract t ->
           (* s1 must have type t (abstract or manifest) *)
           (match lookup_sig_decl t s1 with
            | Some (SigTypeAbstract _) -> sig_subtype s1 rest
            | Some (SigTypeManifest _ _) -> sig_subtype s1 rest
            | _ -> false)
       | SigTypeManifest t tau ->
           (* s1 must have type t = tau *)
           (match lookup_sig_decl t s1 with
            | Some (SigTypeManifest _ tau') -> tau = tau' && sig_subtype s1 rest
            | _ -> false)
       | SigVal x tau ->
           (* s1 must have val x with subtype *)
           (match lookup_sig_decl x s1 with
            | Some (SigVal _ tau') -> subtype tau' tau && sig_subtype s1 rest
            | _ -> false)
       | SigModule m sig_m ->
           (match lookup_sig_decl m s1 with
            | Some (SigModule _ sig_m') -> sig_subtype sig_m' sig_m && sig_subtype s1 rest
            | _ -> false))
  | SigFunctor x s_arg s_res ->
      (match s1 with
       | SigFunctor _ s_arg' s_res' ->
           sig_subtype s_arg s_arg' && sig_subtype s_res' s_res  (* Contravariant in arg *)
       | _ -> false)
  | SigWhere base path tau ->
      (* Check base and verify type equality *)
      sig_subtype s1 base

(* Ascription: check module against signature *)
let check_ascription (m:mod_expr) (sig_:signature) : bool =
  (* Would need full module type checking *)
  admit()
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Functors}

\section{Functor Definition}

\begin{definition}[Functor]
A functor is a module parameterized by another module:
\[
  \mathsf{functor}(X : \Sigma_1) \Rightarrow M : \Sigma_1 \to \Sigma_2
\]
\end{definition}

\begin{definition}[Functor Typing]
\begin{mathpar}
  \inferrule*[right=T-Functor]
    {\env, X : \Sigma_1 \types M : \Sigma_2}
    {\env \types \mathsf{functor}(X : \Sigma_1) \Rightarrow M : \Sigma_1 \to \Sigma_2}
  \and
  \inferrule*[right=T-FunctorApp]
    {\env \types F : \Sigma_1 \to \Sigma_2 \\ \env \types M : \Sigma_1}
    {\env \types F(M) : \Sigma_2[X := M]}
\end{mathpar}
\end{definition}

\section{Applicative vs Generative}

\begin{definition}[Applicative Functor]
Applicative semantics: $F(M) = F(M')$ when $M \equiv M'$.
\begin{itemize}
  \item Types are shared across applications
  \item $F(M).t = F(M).t$ (type equality preserved)
\end{itemize}
\end{definition}

\begin{definition}[Generative Functor]
Generative semantics: $F(M) \neq F(M')$ even when $M \equiv M'$.
\begin{itemize}
  \item Fresh abstract types on each application
  \item Used for stateful modules, generativity
\end{itemize}
\end{definition}

\begin{definition}[Functor Mode]
\[
  \mathsf{functor}^{\mathsf{app}}(X : \Sigma) \Rightarrow M \quad \text{(applicative, default)} \\
\]
\[
  \mathsf{functor}^{\mathsf{gen}}(X : \Sigma) \Rightarrow M \quad \text{(generative)}
\]
\end{definition}

\section{Higher-Order Functors}

\begin{definition}[Functor as First-Class Module]
Functors can take functors as arguments:
\[
  (\Sigma_1 \to \Sigma_2) \to \Sigma_3
\]
\end{definition}

\begin{example}[Functor Composition]
\begin{align*}
  &\mathsf{module}\; \mathsf{Compose} = \\
  &\quad \mathsf{functor}(F : \Sigma_1 \to \Sigma_2)(G : \Sigma_2 \to \Sigma_3)(X : \Sigma_1) \Rightarrow G(F(X))
\end{align*}
\end{example}

\section{F* Mechanization}

\begin{fstarcode}[title={Functors in F*}]
module BrrrSemantics.Functors

open BrrrSemantics.Signatures

(* Functor mode *)
type functor_mode = | Applicative | Generative

(* Functor type *)
noeq type functor_type = {
  param_name : string;
  param_sig  : signature;
  result_sig : signature;
  mode       : functor_mode
}

(* Functor value *)
noeq type functor_val = {
  ftype : functor_type;
  body  : mod_expr
}

(* Type stamp for generative functors *)
type type_stamp = nat

(* Stamped type (for generativity) *)
noeq type stamped_type =
  | Unstamped : brrr_type -> stamped_type
  | Stamped   : type_stamp -> string -> stamped_type

(* Global stamp counter *)
let stamp_counter : ref type_stamp = ref 0

let fresh_stamp () : type_stamp =
  let s = !stamp_counter in
  stamp_counter := s + 1;
  s

(* Apply functor *)
let apply_functor (f:functor_val) (arg:mod_expr) : mod_expr =
  (* Substitute parameter in body *)
  let body' = subst_mod f.ftype.param_name arg f.body in
  match f.ftype.mode with
  | Applicative -> body'
  | Generative ->
      (* Stamp all abstract types with fresh stamps *)
      stamp_abstract_types (fresh_stamp ()) body'

and subst_mod (name:string) (replacement:mod_expr) (m:mod_expr) : mod_expr =
  match m with
  | ModIdent n -> if n = name then replacement else m
  | ModStruct bindings ->
      ModStruct (List.map (subst_binding name replacement) bindings)
  | ModProj m' field -> ModProj (subst_mod name replacement m') field
  | ModApp f arg ->
      ModApp (subst_mod name replacement f) (subst_mod name replacement arg)
  | ModFunctor param sig_ body ->
      if param = name then m  (* Shadowed *)
      else ModFunctor param sig_ (subst_mod name replacement body)
  | _ -> m

and subst_binding (name:string) (replacement:mod_expr) (b:mod_binding) : mod_binding =
  match b with
  | BindModule n m -> BindModule n (subst_mod name replacement m)
  | _ -> b

and stamp_abstract_types (stamp:type_stamp) (m:mod_expr) : mod_expr =
  (* Would traverse and stamp abstract types *)
  m

(* Check applicativity: result types equal for equal arguments *)
let applicative_property (f:functor_val) (m1 m2:mod_expr) : bool =
  if f.ftype.mode = Generative then true  (* Not required *)
  else
    (* If m1 ≡ m2, then F(m1).t = F(m2).t for all types t *)
    admit()

(* Example: Set functor *)
let set_functor_sig : functor_type = {
  param_name = "Elem";
  param_sig = SigCons (SigTypeAbstract "t")
              (SigCons (SigVal "compare" (TFunc (TVar "t") (TFunc (TVar "t") TInt) Pure))
               SigEmpty);
  result_sig = SigCons (SigTypeAbstract "set")
               (SigCons (SigVal "empty" (TVar "set"))
               (SigCons (SigVal "add" (TFunc (TVar "Elem.t") (TFunc (TVar "set") (TVar "set")) Pure))
               (SigCons (SigVal "member" (TFunc (TVar "Elem.t") (TFunc (TVar "set") TBool) Pure))
                SigEmpty)));
  mode = Applicative
}

(* Higher-order functor: takes functor as argument *)
noeq type ho_functor = {
  param_functor : functor_type;
  result : signature
}
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Sealing and Abstraction}

\section{Opaque Ascription}

\begin{definition}[Sealing]
Opaque ascription $M :> \Sigma$ hides implementation details:
\begin{itemize}
  \item Abstract types in $\Sigma$ become opaque
  \item Type equalities not in $\Sigma$ are forgotten
  \item Creates an abstraction barrier
\end{itemize}
\end{definition}

\begin{definition}[Sealing Typing]
\begin{mathpar}
  \inferrule*[right=T-Seal]
    {\env \types M : \Sigma' \\ \Sigma' <: \Sigma}
    {\env \types M :> \Sigma : \Sigma}
\end{mathpar}
The result type is exactly $\Sigma$, not a subtype.
\end{definition}

\begin{theorem}[Abstraction Theorem]
If $M :> \Sigma$ and $\mathsf{type}\; t$ is abstract in $\Sigma$, then no client can distinguish the implementation type of $t$ from any other implementation satisfying $\Sigma$.
\end{theorem}

\section{Existential Types}

\begin{definition}[Module as Existential]
A sealed module $M :> \{\mathsf{type}\; t; \mathsf{val}\; x : t\}$ is equivalent to:
\[
  \exists t.\, t \times t \cong \mathsf{pack}\, (\tau, v) \;\mathsf{as}\; \exists t.\, t
\]
where $\tau$ is the hidden implementation type.
\end{definition}

\begin{definition}[Pack and Unpack]
\begin{mathpar}
  \inferrule*[right=T-Pack]
    {\env \types v : \tau[\alpha := \sigma]}
    {\env \types \mathsf{pack}\, (\sigma, v) : \exists \alpha.\, \tau}
  \and
  \inferrule*[right=T-Unpack]
    {\env \types e_1 : \exists \alpha.\, \tau \\ \env, \alpha, x : \tau \types e_2 : \sigma \\ \alpha \notin \mathsf{ftv}(\sigma)}
    {\env \types \mathsf{unpack}\, (\alpha, x) = e_1 \;\mathsf{in}\; e_2 : \sigma}
\end{mathpar}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Sealing in F*}]
module BrrrSemantics.Sealing

open BrrrSemantics.Signatures
open BrrrSemantics.Functors

(* Sealed module: hides type implementations *)
noeq type sealed_module = {
  exposed_sig : signature;
  impl        : mod_expr;
  hidden_types: list (string & brrr_type)  (* Abstract type implementations *)
}

(* Seal a module *)
let seal (m:mod_expr) (sig_:signature) : option sealed_module =
  (* Check m matches sig_ *)
  if check_ascription m sig_ then
    (* Extract abstract type implementations *)
    let hidden = collect_hidden_types m sig_ in
    Some { exposed_sig = sig_; impl = m; hidden_types = hidden }
  else None

and collect_hidden_types (m:mod_expr) (sig_:signature) : list (string & brrr_type) =
  (* Find types that are manifest in m but abstract in sig_ *)
  match sig_ with
  | SigEmpty -> []
  | SigCons (SigTypeAbstract t) rest ->
      (match get_type_impl m t with
       | Some tau -> (t, tau) :: collect_hidden_types m rest
       | None -> collect_hidden_types m rest)
  | SigCons _ rest -> collect_hidden_types m rest
  | _ -> []

and get_type_impl (m:mod_expr) (t:string) : option brrr_type =
  match m with
  | ModStruct bindings ->
      List.find_map (fun b ->
        match b with
        | BindType n tau -> if n = t then Some tau else None
        | _ -> None) bindings
  | _ -> None

(* Existential type *)
noeq type existential (f:Type -> Type) =
  | Pack : #a:Type -> a -> f a -> existential f

(* Module as existential: { type t; val x : t } ≅ ∃t. t *)
type abstract_module (sig_:Type -> Type) = existential sig_

(* Pack: hide implementation *)
let pack_module (#a:Type) (#f:Type -> Type) (impl:a) (witness:f a) : existential f =
  Pack impl witness

(* Unpack: use abstraction *)
let unpack_module (#f:Type -> Type) (#r:Type)
                  (e:existential f) (body:(#a:Type -> a -> f a -> r)) : r =
  match e with
  | Pack impl witness -> body impl witness

(* Abstraction theorem: parametricity *)
(* If client only knows abstract interface, behavior is same regardless of implementation *)

(* Two implementations of "abstract counter" *)
type counter_sig (t:Type) = {
  zero : t;
  inc  : t -> t;
  get  : t -> int
}

(* Implementation 1: using int *)
let counter_int : counter_sig int = {
  zero = 0;
  inc = fun n -> n + 1;
  get = fun n -> n
}

(* Implementation 2: using list *)
let counter_list : counter_sig (list unit) = {
  zero = [];
  inc = fun l -> () :: l;
  get = fun l -> List.length l
}

(* Sealed: client can't distinguish *)
let sealed_counter_1 : existential counter_sig = Pack 0 counter_int
let sealed_counter_2 : existential counter_sig = Pack [] counter_list

(* Client code works with either *)
let use_counter (c:existential counter_sig) : int =
  unpack_module c (fun zero ops ->
    ops.get (ops.inc (ops.inc ops.zero)))
(* Returns 2 for both implementations *)
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Mixin Composition}

\section{Include}

\begin{definition}[Module Include]
$\mathsf{include}\, M$ incorporates all bindings from $M$:
\begin{align*}
  &\mathsf{module}\; \mathsf{Extended} = \{ \\
  &\quad \mathsf{include}\; \mathsf{Base}; \\
  &\quad \mathsf{val}\; \mathsf{extra} = \ldots \\
  &\}
\end{align*}
\end{definition}

\begin{definition}[Include Typing]
\begin{mathpar}
  \inferrule*[right=T-Include]
    {\env \types M : \{D_1; \ldots; D_n\}}
    {\env \types \{\mathsf{include}\; M; B\} : \{D_1; \ldots; D_n; \mathsf{typeof}(B)\}}
\end{mathpar}
\end{definition}

\section{Linear Composition}

\begin{definition}[Module Composition]
$M_1 + M_2$ combines two modules with disjoint signatures:
\begin{mathpar}
  \inferrule*[right=T-Compose]
    {\env \types M_1 : \Sigma_1 \\ \env \types M_2 : \Sigma_2 \\ \Sigma_1 \cap \Sigma_2 = \emptyset}
    {\env \types M_1 + M_2 : \Sigma_1 + \Sigma_2}
\end{mathpar}
\end{definition}

\section{Override}

\begin{definition}[Module Override]
$M \;\mathsf{with}\; \{\mathsf{overrides}\}$ refines module components:
\begin{align*}
  &\mathsf{module}\; \mathsf{Refined} = \mathsf{Base} \;\mathsf{with}\; \{ \\
  &\quad \mathsf{type}\; t = \mathsf{SpecificType}; \\
  &\quad \mathsf{val}\; x = \mathsf{new\_impl} \\
  &\}
\end{align*}
\end{definition}

\section{Conflict Resolution}

\begin{definition}[Diamond Problem Resolution]
When composing modules with overlapping signatures:
\[
  M_1 + M_2 \;\mathsf{with}\; \{\mathsf{val}\; x = M_1.x\}
\]
explicitly selects which binding to use.
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Mixin Composition in F*}]
module BrrrSemantics.Mixins

open BrrrSemantics.Signatures

(* Get all binding names from module *)
let rec binding_names (m:mod_expr) : list string =
  match m with
  | ModStruct bindings ->
      List.map (fun b ->
        match b with
        | BindType n _ -> n
        | BindVal n _ -> n
        | BindModule n _ -> n) bindings
  | _ -> []

(* Check disjointness *)
let disjoint (m1 m2:mod_expr) : bool =
  let names1 = binding_names m1 in
  let names2 = binding_names m2 in
  not (List.exists (fun n -> List.mem n names2) names1)

(* Include: flatten module *)
let include_module (base:mod_expr) (additions:list mod_binding) : mod_expr =
  match base with
  | ModStruct base_bindings ->
      ModStruct (base_bindings @ additions)
  | _ -> ModStruct additions  (* Base not a struct, just use additions *)

(* Linear composition *)
let compose_modules (m1 m2:mod_expr) : option mod_expr =
  if disjoint m1 m2 then
    match m1, m2 with
    | ModStruct b1, ModStruct b2 -> Some (ModStruct (b1 @ b2))
    | ModStruct b1, _ -> Some (ModStruct (b1 @ [BindModule "_m2" m2]))
    | _, ModStruct b2 -> Some (ModStruct ([BindModule "_m1" m1] @ b2))
    | _, _ -> Some (ModStruct [BindModule "_m1" m1; BindModule "_m2" m2])
  else None  (* Conflict *)

(* Override binding *)
noeq type override =
  | OverrideType : string -> brrr_type -> override
  | OverrideVal  : string -> expr -> override

(* Apply overrides to module *)
let apply_overrides (m:mod_expr) (overrides:list override) : mod_expr =
  match m with
  | ModStruct bindings ->
      let bindings' = List.map (fun b ->
        let name = match b with
          | BindType n _ -> n
          | BindVal n _ -> n
          | BindModule n _ -> n
        in
        match List.find (fun o ->
          match o with
          | OverrideType n _ -> n = name
          | OverrideVal n _ -> n = name) overrides with
        | Some (OverrideType _ tau) -> BindType name tau
        | Some (OverrideVal _ e) -> BindVal name e
        | None -> b) bindings in
      ModStruct bindings'
  | _ -> m

(* Mixin: module with deferred bindings *)
noeq type mixin = {
  provided  : list mod_binding;      (* What mixin provides *)
  required  : list sig_decl          (* What mixin needs *)
}

(* Complete mixin with implementation *)
let complete_mixin (mx:mixin) (impl:mod_expr) : option mod_expr =
  (* Check impl provides required bindings *)
  let impl_names = binding_names impl in
  let required_names = List.map (fun d ->
    match d with
    | SigTypeAbstract n -> n
    | SigTypeManifest n _ -> n
    | SigVal n _ -> n
    | SigModule n _ -> n) mx.required in
  if List.for_all (fun n -> List.mem n impl_names) required_names then
    compose_modules impl (ModStruct mx.provided)
  else None

(* Example: Ordered mixin *)
let ordered_mixin : mixin = {
  provided = [
    BindVal "min" (ELam "a" TUnit (ELam "b" TUnit
      (EIf (EApp (EApp (EVar "compare") (EVar "a")) (EVar "b"))
           (EVar "a") (EVar "b"))))
  ];
  required = [
    SigTypeAbstract "t";
    SigVal "compare" (TFunc (TVar "t") (TFunc (TVar "t") TBool) Pure)
  ]
}
\end{fstarcode}


%=============================================================================
% PART IX: SECURITY & VERIFICATION
%=============================================================================
\part{Security \& Verification}

\chapter{Information Flow Types}

Information flow types prevent sensitive data from leaking to unauthorized observers.

\section{Security Lattice}

\begin{definition}[Security Lattice]
A security lattice $(L, \sqsubseteq, \sqcup, \sqcap, \bot, \top)$ where:
\begin{itemize}
  \item $L$ is a set of security levels
  \item $\sqsubseteq$ is the ``flows to'' partial order
  \item $\sqcup$ is least upper bound (join)
  \item $\sqcap$ is greatest lower bound (meet)
  \item $\bot$ is public (lowest)
  \item $\top$ is secret (highest)
\end{itemize}
\end{definition}

\begin{example}[Two-Point Lattice]
\[
  L_2 = \{\mathsf{Low}, \mathsf{High}\} \quad \text{with } \mathsf{Low} \sqsubseteq \mathsf{High}
\]
\end{example}

\begin{example}[Four-Point Lattice]
\[
\begin{tikzcd}[row sep=small, column sep=small]
  & \mathsf{TopSecret} & \\
  \mathsf{Secret} \arrow[ur] & & \mathsf{Confidential} \arrow[ul] \\
  & \mathsf{Public} \arrow[ul] \arrow[ur] &
\end{tikzcd}
\]
\end{example}

\section{Security-Typed Values}

\begin{definition}[Labeled Type]
A type with security label:
\[
  \tau^\ell \quad \text{(type $\tau$ at security level $\ell$)}
\]
\end{definition}

\begin{definition}[Subtyping with Labels]
\[
  \tau^{\ell_1} <: \tau^{\ell_2} \iff \tau <: \tau \land \ell_1 \sqsubseteq \ell_2
\]
A $\mathsf{Low}$ value can flow to $\mathsf{High}$, but not vice versa.
\end{definition}

\section{Security Typing Rules}

\begin{definition}[Security Typing Judgment]
$\env; \pc \types e : \tau^\ell$ means:
\begin{quote}
  Under context $\env$ with program counter label $\pc$, expression $e$ has type $\tau$ at level $\ell$.
\end{quote}
\end{definition}

\begin{definition}[Core Security Typing]
\begin{mathpar}
  \inferrule*[right=Sec-Var]
    {(x : \tau^\ell) \in \env}
    {\env; \pc \types x : \tau^\ell}
  \and
  \inferrule*[right=Sec-Sub]
    {\env; \pc \types e : \tau^{\ell_1} \\ \ell_1 \sqsubseteq \ell_2}
    {\env; \pc \types e : \tau^{\ell_2}}
  \and
  \inferrule*[right=Sec-App]
    {\env; \pc \types e_1 : (\tau_1^{\ell_1} \to \tau_2^{\ell_2})^{\ell_f} \\ \env; \pc \types e_2 : \tau_1^{\ell_1}}
    {\env; \pc \types e_1\, e_2 : \tau_2^{\ell_2 \sqcup \ell_f}}
  \and
  \inferrule*[right=Sec-If]
    {\env; \pc \types e_c : \mathsf{Bool}^{\ell_c} \\
     \env; \pc \sqcup \ell_c \types e_1 : \tau^\ell \\
     \env; \pc \sqcup \ell_c \types e_2 : \tau^\ell}
    {\env; \pc \types \mathsf{if}\, e_c \,\mathsf{then}\, e_1 \,\mathsf{else}\, e_2 : \tau^{\ell \sqcup \ell_c}}
  \and
  \inferrule*[right=Sec-Assign]
    {\env; \pc \types e : \tau^{\ell_e} \\ (x : \mathsf{ref}\, \tau^{\ell_x}) \in \env \\ \pc \sqcup \ell_e \sqsubseteq \ell_x}
    {\env; \pc \types x := e : \mathsf{Unit}^{\pc}}
\end{mathpar}
\end{definition}

\section{Implicit Flows}

\begin{definition}[Implicit Flow]
Information flows through control structure:
\begin{verbatim}
if secret then public := 1 else public := 0
\end{verbatim}
The value of \texttt{public} reveals \texttt{secret}.
\end{definition}

The $\pc$ (program counter) label tracks implicit flows. In Sec-If, the branches are checked under $\pc \sqcup \ell_c$, ensuring any assignment respects the guard's secrecy.

\section{F* Mechanization}

\begin{fstarcode}[title={Information Flow Types in F*}]
module BrrrSemantics.InformationFlow

(* Security level *)
type sec_level =
  | Public : sec_level      (* ⊥ - anyone can read *)
  | Secret : sec_level      (* ⊤ - restricted *)

(* Security lattice operations *)
let sec_leq (l1 l2:sec_level) : bool =
  match l1, l2 with
  | Public, _ -> true
  | Secret, Secret -> true
  | Secret, Public -> false

let sec_join (l1 l2:sec_level) : sec_level =
  match l1, l2 with
  | Secret, _ -> Secret
  | _, Secret -> Secret
  | Public, Public -> Public

let sec_meet (l1 l2:sec_level) : sec_level =
  match l1, l2 with
  | Public, _ -> Public
  | _, Public -> Public
  | Secret, Secret -> Secret

(* Labeled type *)
noeq type labeled_type = {
  base_type : brrr_type;
  label     : sec_level
}

(* Security typing context *)
type sec_ctx = list (string & labeled_type)

(* Program counter label *)
type pc_label = sec_level

(* Security type checking *)
let rec sec_typecheck (ctx:sec_ctx) (pc:pc_label) (e:expr)
    : option labeled_type =
  match e with
  | EVar x ->
      List.assoc x ctx

  | ELit v ->
      Some { base_type = type_of_val v; label = Public }

  | EApp f arg ->
      (match sec_typecheck ctx pc f, sec_typecheck ctx pc arg with
       | Some {base_type = TFunc a r _; label = lf},
         Some {base_type = ta; label = la} ->
           if subtype ta a && sec_leq la (get_arg_label a) then
             Some { base_type = r; label = sec_join lf (get_result_label r) }
           else None
       | _, _ -> None)

  | EIf cond e1 e2 ->
      (match sec_typecheck ctx pc cond with
       | Some {base_type = TBool; label = lc} ->
           let pc' = sec_join pc lc in
           (match sec_typecheck ctx pc' e1, sec_typecheck ctx pc' e2 with
            | Some t1, Some t2 ->
                if t1.base_type = t2.base_type then
                  Some { base_type = t1.base_type;
                         label = sec_join lc (sec_join t1.label t2.label) }
                else None
            | _, _ -> None)
       | _ -> None)

  | ELet x e1 e2 ->
      (match sec_typecheck ctx pc e1 with
       | Some t1 ->
           sec_typecheck ((x, t1) :: ctx) pc e2
       | None -> None)

  | _ -> None

and get_arg_label (t:brrr_type) : sec_level = Public  (* Simplified *)
and get_result_label (t:brrr_type) : sec_level = Public
and type_of_val (v:base_val) : brrr_type =
  match v with
  | VBool _ -> TBool
  | VInt _ -> TInt {width=I64; sign=Signed}
  | _ -> TUnit

(* Check assignment respects information flow *)
let check_assignment (ctx:sec_ctx) (pc:pc_label) (x:string) (e:expr) : bool =
  match List.assoc x ctx, sec_typecheck ctx pc e with
  | Some {label = lx}, Some {label = le} ->
      sec_leq (sec_join pc le) lx  (* pc ⊔ le ⊑ lx *)
  | _, _ -> false

(* Example: This should fail *)
let implicit_flow_example () : bool =
  let ctx = [("secret", {base_type = TBool; label = Secret});
             ("public", {base_type = TInt {width=I32; sign=Signed}; label = Public})] in
  let pc = Public in
  (* if secret then public := 1 else public := 0 *)
  (* The assignment happens under pc = Public ⊔ Secret = Secret *)
  (* But public has label Public, so Secret ⊑ Public fails *)
  check_assignment ctx Secret "public" (ELit (VInt 1))
  (* Returns false - correctly rejected! *)
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Noninterference}

\section{Semantic Security}

\begin{definition}[Low-Equivalence]
Two states $\sigma_1 \approx_L \sigma_2$ are low-equivalent iff they agree on all $\mathsf{Low}$-labeled values:
\[
  \sigma_1 \approx_L \sigma_2 \iff \forall x : \tau^{\mathsf{Low}}.\, \sigma_1(x) = \sigma_2(x)
\]
\end{definition}

\begin{definition}[Noninterference]
A program $P$ satisfies noninterference iff:
\[
  \sigma_1 \approx_L \sigma_2 \implies P(\sigma_1) \approx_L P(\sigma_2)
\]
Low inputs determine low outputs---high inputs cannot influence low outputs.
\end{definition}

\begin{theorem}[Type Soundness Implies Noninterference]
If $\env; \mathsf{Low} \types P : \tau^{\ell}$ (well-typed with $\pc = \mathsf{Low}$), then $P$ satisfies noninterference.
\end{theorem}

\begin{proof}[Proof Sketch]
By induction on typing derivations. The key insight is that:
\begin{enumerate}
  \item $\mathsf{High}$ data can only flow to $\mathsf{High}$ locations
  \item Branches on $\mathsf{High}$ data (raising $\pc$) can only assign to $\mathsf{High}$ locations
  \item Therefore, $\mathsf{Low}$ outputs depend only on $\mathsf{Low}$ inputs
\end{enumerate}
\end{proof}

\section{Termination-Insensitive vs Termination-Sensitive}

\begin{definition}[Termination Channel]
Programs can leak information through termination:
\begin{verbatim}
if secret then loop_forever() else ()
\end{verbatim}
Whether the program terminates reveals \texttt{secret}.
\end{definition}

\begin{definition}[TINI vs TSNI]
\begin{itemize}
  \item \textbf{TINI} (Termination-Insensitive NI): Only considers terminating executions
  \item \textbf{TSNI} (Termination-Sensitive NI): Also considers termination behavior
\end{itemize}
\end{definition}

\section{Declassification}

\begin{definition}[Declassification]
Controlled release of secret information:
\[
  \mathsf{declassify}(e, \ell_{\mathsf{from}}, \ell_{\mathsf{to}}) : \tau^{\ell_{\mathsf{to}}}
\]
where $\ell_{\mathsf{from}} \sqsubseteq\!\!\!\!/ \; \ell_{\mathsf{to}}$ (intentional downgrade).
\end{definition}

\begin{definition}[Robust Declassification]
Declassification must be:
\begin{itemize}
  \item \textbf{Intentional}: Explicitly marked in code
  \item \textbf{Bounded}: Limited by policy (who, what, when, where)
  \item \textbf{Auditable}: Logged for review
\end{itemize}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Noninterference in F*}]
module BrrrSemantics.Noninterference

open BrrrSemantics.InformationFlow

(* State: mapping from variables to values with labels *)
type sec_state = list (string & (value & sec_level))

(* Low-equivalence: states agree on Low values *)
let low_equiv (s1 s2:sec_state) : bool =
  List.for_all (fun (x, (v1, l1)) ->
    if l1 = Public then
      match List.assoc x s2 with
      | Some (v2, l2) -> l2 = Public && v1 = v2
      | None -> false
    else true) s1

(* Program execution *)
type exec_result =
  | Terminates : sec_state -> exec_result
  | Diverges   : exec_result

(* Noninterference property *)
let noninterference (p:expr) : bool =
  (* For all s1, s2: s1 ≈_L s2 ⟹ p(s1) ≈_L p(s2) *)
  (* This is a semantic property - would need to enumerate states *)
  admit()

(* Termination-insensitive noninterference *)
let tini (p:expr) (s1 s2:sec_state) : bool =
  if low_equiv s1 s2 then
    match run p s1, run p s2 with
    | Terminates s1', Terminates s2' -> low_equiv s1' s2'
    | Diverges, _ -> true  (* Don't care if one diverges *)
    | _, Diverges -> true
  else true

and run (e:expr) (s:sec_state) : exec_result =
  (* Would need full interpreter *)
  Terminates s

(* Declassification policy *)
noeq type declass_policy = {
  allowed_from : sec_level;
  allowed_to   : sec_level;
  principal    : string;      (* Who can declassify *)
  purpose      : string       (* Why *)
}

(* Declassification with policy check *)
let declassify (#a:Type) (v:a) (from_:sec_level) (to_:sec_level)
               (policy:declass_policy) : option (a & sec_level) =
  if from_ = policy.allowed_from && to_ = policy.allowed_to then
    (* Log declassification for audit *)
    Some (v, to_)
  else None

(* Robust declassification: attacker can't influence what gets declassified *)
let robust_declassify (#a:Type) (v:a) (guard:bool) (policy:declass_policy)
    : option (a & sec_level) =
  (* Guard must be Low (attacker-controlled) *)
  (* Value must be computed independently of attacker *)
  if guard then
    declassify v Secret Public policy
  else None

(* Endorsement: dual of declassification for integrity *)
let endorse (#a:Type) (v:a) (from_:sec_level) (to_:sec_level) : a & sec_level =
  (* Raise integrity level (trust untrusted input after validation) *)
  (v, to_)

(* Example: Password check with declassification *)
let check_password (input:string) (stored_hash:string) : bool =
  let input_hash = hash input in  (* input_hash is Low *)
  let result = input_hash = stored_hash in  (* result is High (depends on stored) *)
  (* Declassify the boolean result (not the password!) *)
  match declassify result Secret Public
    { allowed_from = Secret; allowed_to = Public;
      principal = "auth_system"; purpose = "login_result" } with
  | Some (r, _) -> r
  | None -> false

and hash (s:string) : string = s  (* Simplified *)
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Taint Analysis}

\section{Taint Sources and Sinks}

\begin{definition}[Taint Source]
A source introduces tainted data:
\[
  \mathsf{source}_{\mathsf{kind}} : () \to \tau^{\mathsf{Tainted}[\mathsf{kind}]}
\]
Examples: user input, network data, file contents.
\end{definition}

\begin{definition}[Taint Sink]
A sink is a security-sensitive operation:
\[
  \mathsf{sink}_{\mathsf{kind}} : \tau^{\mathsf{Untainted}} \to \sigma
\]
Examples: SQL query, shell command, HTML output.
\end{definition}

\begin{definition}[Sanitizer]
A sanitizer removes taint:
\[
  \mathsf{sanitize}_{\mathsf{kind}} : \tau^{\mathsf{Tainted}[\mathsf{kind}]} \to \tau^{\mathsf{Untainted}}
\]
Examples: escaping, validation, encoding.
\end{definition}

\section{Taint Propagation}

\begin{definition}[Taint Propagation Rules]
\begin{mathpar}
  \inferrule*[right=Taint-Op]
    {\env \types e_1 : \tau_1^{t_1} \\ \env \types e_2 : \tau_2^{t_2}}
    {\env \types e_1 \oplus e_2 : \tau^{t_1 \sqcup t_2}}
  \and
  \inferrule*[right=Taint-Call]
    {\env \types f : (\tau_1, \ldots, \tau_n) \to \sigma \\ \exists i.\, e_i : \tau_i^{\mathsf{Tainted}}}
    {\env \types f(e_1, \ldots, e_n) : \sigma^{\mathsf{Tainted}}}
  \and
  \inferrule*[right=Taint-Sink]
    {\env \types e : \tau^{\mathsf{Tainted}[\mathsf{kind}]} \\ \mathsf{sink}[\mathsf{kind}]}
    {\text{ERROR: tainted data reaches sink}}
\end{mathpar}
\end{definition}

\section{Taint Kinds}

\begin{definition}[Taint Taxonomy]
Different vulnerability classes:
\begin{align*}
  \mathsf{SQLi} &\quad \text{(SQL injection)} \\
  \mathsf{XSS} &\quad \text{(cross-site scripting)} \\
  \mathsf{CMDi} &\quad \text{(command injection)} \\
  \mathsf{PathTraversal} &\quad \text{(path traversal)} \\
  \mathsf{SSRF} &\quad \text{(server-side request forgery)}
\end{align*}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Taint Analysis in F*}]
module BrrrSemantics.TaintAnalysis

(* Taint kind *)
type taint_kind =
  | TaintSQLi         : taint_kind
  | TaintXSS          : taint_kind
  | TaintCMDi         : taint_kind
  | TaintPathTraversal: taint_kind
  | TaintSSRF         : taint_kind

(* Taint status *)
type taint_status =
  | Untainted : taint_status
  | Tainted   : list taint_kind -> taint_status

(* Join taint statuses *)
let taint_join (t1 t2:taint_status) : taint_status =
  match t1, t2 with
  | Untainted, t -> t
  | t, Untainted -> t
  | Tainted k1, Tainted k2 -> Tainted (List.dedup (k1 @ k2))

(* Tainted value *)
noeq type tainted (a:Type) = {
  value : a;
  taint : taint_status
}

(* Source: mark data as tainted *)
let source (#a:Type) (kind:taint_kind) (v:a) : tainted a =
  { value = v; taint = Tainted [kind] }

(* Sink check: ensure untainted *)
let sink (#a:Type) (kind:taint_kind) (t:tainted a) : option a =
  match t.taint with
  | Untainted -> Some t.value
  | Tainted kinds ->
      if List.mem kind kinds then None  (* Vulnerability! *)
      else Some t.value  (* Different taint kind, may be ok *)

(* Sanitizer: remove specific taint *)
let sanitize (#a:Type) (kind:taint_kind) (t:tainted a) (sanitizer:a -> a)
    : tainted a =
  let cleaned = sanitizer t.value in
  match t.taint with
  | Untainted -> { value = cleaned; taint = Untainted }
  | Tainted kinds ->
      let remaining = List.filter (fun k -> k <> kind) kinds in
      { value = cleaned;
        taint = if remaining = [] then Untainted else Tainted remaining }

(* Propagate taint through operations *)
let taint_map (#a #b:Type) (f:a -> b) (t:tainted a) : tainted b =
  { value = f t.value; taint = t.taint }

let taint_map2 (#a #b #c:Type) (f:a -> b -> c) (t1:tainted a) (t2:tainted b)
    : tainted c =
  { value = f t1.value t2.value; taint = taint_join t1.taint t2.taint }

(* Example: SQL query building *)
let user_input : tainted string =
  source TaintSQLi "Robert'; DROP TABLE students;--"

let build_query (name:tainted string) : tainted string =
  taint_map (fun n -> "SELECT * FROM users WHERE name = '" ^ n ^ "'") name

let execute_sql (query:tainted string) : option (list string) =
  match sink TaintSQLi query with
  | Some q -> Some ["result"]  (* Execute query *)
  | None -> None  (* Blocked: tainted SQL *)

(* This correctly returns None - SQL injection prevented *)
let vulnerable_query = execute_sql (build_query user_input)

(* Safe version with sanitization *)
let escape_sql (s:string) : string =
  (* Replace ' with '' *)
  String.concat "''" (String.split_on_char '\'' s)

let safe_query =
  let sanitized = sanitize TaintSQLi user_input escape_sql in
  execute_sql (build_query sanitized)
(* This returns Some [...] - sanitized input is safe *)

(* Taint tracking through data structures *)
let taint_list (#a:Type) (l:list (tainted a)) : tainted (list a) =
  let values = List.map (fun t -> t.value) l in
  let taint = List.fold_left (fun acc t -> taint_join acc t.taint) Untainted l in
  { value = values; taint = taint }
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Contracts and Verification}

\section{Function Contracts}

\begin{definition}[Contract]
A function contract specifies:
\begin{align*}
  \mathsf{fn}\; f(x : \tau) \to \sigma \\
  \quad \mathsf{requires}\; P(x) \\
  \quad \mathsf{ensures}\; Q(x, \mathsf{result})
\end{align*}
where $P$ is the precondition and $Q$ is the postcondition.
\end{definition}

\begin{definition}[Contract Typing]
\begin{mathpar}
  \inferrule*[right=T-Contract]
    {\env, x : \tau, P(x) \types e : \sigma \\ \env, x : \tau, P(x) \types Q(x, e)}
    {\env \types (\mathsf{fn}\; f(x) \;\mathsf{requires}\; P \;\mathsf{ensures}\; Q := e) : \{x : \tau \mid P\} \to \{r : \sigma \mid Q\}}
\end{mathpar}
\end{definition}

\section{Hoare Logic}

\begin{definition}[Hoare Triple]
$\{P\}\, c\, \{Q\}$ means: if $P$ holds before $c$, and $c$ terminates, then $Q$ holds after.
\end{definition}

\begin{definition}[Core Hoare Rules]
\begin{mathpar}
  \inferrule*[right=H-Skip]
    { }
    {\{P\}\, \mathsf{skip}\, \{P\}}
  \and
  \inferrule*[right=H-Assign]
    { }
    {\{P[x := e]\}\, x := e\, \{P\}}
  \and
  \inferrule*[right=H-Seq]
    {\{P\}\, c_1\, \{R\} \\ \{R\}\, c_2\, \{Q\}}
    {\{P\}\, c_1; c_2\, \{Q\}}
  \and
  \inferrule*[right=H-If]
    {\{P \land b\}\, c_1\, \{Q\} \\ \{P \land \lnot b\}\, c_2\, \{Q\}}
    {\{P\}\, \mathsf{if}\, b\, \mathsf{then}\, c_1\, \mathsf{else}\, c_2\, \{Q\}}
  \and
  \inferrule*[right=H-While]
    {\{I \land b\}\, c\, \{I\}}
    {\{I\}\, \mathsf{while}\, b\, \mathsf{do}\, c\, \{I \land \lnot b\}}
  \and
  \inferrule*[right=H-Conseq]
    {P' \Rightarrow P \\ \{P\}\, c\, \{Q\} \\ Q \Rightarrow Q'}
    {\{P'\}\, c\, \{Q'\}}
\end{mathpar}
\end{definition}

\section{Refinement Types}

\begin{definition}[Refinement Type]
\[
  \{x : \tau \mid \phi(x)\}
\]
The type of values of type $\tau$ satisfying predicate $\phi$.
\end{definition}

\begin{definition}[Refinement Subtyping]
\[
  \{x : \tau \mid \phi_1(x)\} <: \{x : \tau \mid \phi_2(x)\} \iff \forall x.\, \phi_1(x) \Rightarrow \phi_2(x)
\]
\end{definition}

\begin{example}[Refined Types]
\begin{align*}
  \mathsf{Nat} &= \{x : \TInt \mid x \geq 0\} \\
  \mathsf{Pos} &= \{x : \TInt \mid x > 0\} \\
  \mathsf{NonEmpty}[A] &= \{xs : \mathsf{List}[A] \mid \mathsf{length}(xs) > 0\}
\end{align*}
\end{example}

\section{F* Mechanization}

\begin{fstarcode}[title={Contracts in F*}]
module BrrrSemantics.Contracts

(* Refinement type in F* is native *)
type nat = x:int{x >= 0}
type pos = x:int{x > 0}

(* Non-empty list *)
type non_empty_list (a:Type) = l:list a{Cons? l}

(* Function with contract *)
let divide (x:int) (y:pos) : int =
  x / y
(* Precondition y > 0 is enforced by type *)
(* Division by zero is impossible! *)

(* Postcondition via refinement *)
let abs (x:int) : y:nat{y >= 0 /\ (x >= 0 ==> y = x) /\ (x < 0 ==> y = -x)} =
  if x >= 0 then x else -x

(* Loop invariant *)
let rec sum_to (n:nat) : Tot (r:nat{r = n * (n + 1) / 2}) (decreases n) =
  if n = 0 then 0
  else n + sum_to (n - 1)

(* Hoare triple representation *)
noeq type hoare_triple (pre:Type0) (post:'a -> Type0) =
  | HT : (unit -> Pure 'a (requires pre) (ensures post)) -> hoare_triple pre post

(* Sequential composition *)
let seq_hoare (#a #b:Type) (#p #q #r:Type0)
              (h1:hoare_triple p (fun _ -> q))
              (h2:hoare_triple q (fun _ -> r))
    : hoare_triple p (fun _ -> r) =
  HT (fun () ->
    let HT f1 = h1 in
    let HT f2 = h2 in
    let _ = f1 () in
    f2 ())

(* Array bounds checking via refinement *)
type bounded_index (len:nat) = i:nat{i < len}

let safe_array_access (#a:Type) (arr:list a) (i:bounded_index (List.length arr)) : a =
  List.nth arr i
(* Index out of bounds is impossible! *)

(* Sorted list invariant *)
let rec sorted (l:list int) : bool =
  match l with
  | [] -> true
  | [_] -> true
  | x :: y :: rest -> x <= y && sorted (y :: rest)

type sorted_list = l:list int{sorted l}

(* Insert maintaining sortedness *)
let rec insert (x:int) (l:sorted_list) : sorted_list =
  match l with
  | [] -> [x]
  | h :: t ->
      if x <= h then x :: l
      else h :: insert x t

(* Verification condition generation *)
type vc = | VCTrue | VCImpl : vc -> vc -> vc | VCAnd : vc -> vc -> vc

let rec check_vc (v:vc) : bool =
  match v with
  | VCTrue -> true
  | VCImpl p q -> not (check_vc p) || check_vc q
  | VCAnd p q -> check_vc p && check_vc q
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Separation Logic Integration}

\section{Heap Assertions}

\begin{definition}[Separation Logic Assertions]
\begin{align*}
  P, Q &::= \mathsf{emp} & \text{(empty heap)} \\
    &\mid e \mapsto v & \text{(points-to)} \\
    &\mid P * Q & \text{(separating conjunction)} \\
    &\mid P \mathbin{-\!*} Q & \text{(magic wand)} \\
    &\mid \forall x.\, P \mid \exists x.\, P & \text{(quantifiers)}
\end{align*}
\end{definition}

\begin{definition}[Separating Conjunction Semantics]
$P * Q$ holds on heap $h$ iff $h = h_1 \uplus h_2$ where $P$ holds on $h_1$ and $Q$ holds on $h_2$ (disjoint heaps).
\end{definition}

\section{Frame Rule}

\begin{theorem}[Frame Rule]
\begin{mathpar}
  \inferrule*[right=Frame]
    {\{P\}\, c\, \{Q\} \\ \mathsf{mod}(c) \cap \mathsf{fv}(R) = \emptyset}
    {\{P * R\}\, c\, \{Q * R\}}
\end{mathpar}
Local reasoning: if $c$ only touches heap described by $P$, then $R$ is preserved.
\end{theorem}

\section{Ownership Integration}

\begin{definition}[Ownership as Separation]
Brrr-Lang ownership maps to separation logic:
\begin{align*}
  \own\, x &\cong x \mapsto v * \mathsf{Freeable}(x) \\
  \rref\, x &\cong x \mapsto^{1/n} v \\
  \rrefmut\, x &\cong x \mapsto v
\end{align*}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Separation Logic in F*}]
module BrrrSemantics.SeparationLogic

(* Heap location *)
type loc = nat

(* Heap: partial map from locations to values *)
type heap = loc -> option value

(* Empty heap *)
let emp : heap = fun _ -> None

(* Singleton heap *)
let singleton (l:loc) (v:value) : heap =
  fun l' -> if l = l' then Some v else None

(* Heap disjointness *)
let disjoint (h1 h2:heap) : bool =
  forall l. not (Some? (h1 l) && Some? (h2 l))

(* Heap union (requires disjoint) *)
let heap_union (h1 h2:heap) : heap =
  fun l -> match h1 l with Some v -> Some v | None -> h2 l

(* Separation logic assertion *)
noeq type sl_assertion =
  | SLEmp     : sl_assertion
  | SLPointsTo: loc -> value -> sl_assertion
  | SLStar    : sl_assertion -> sl_assertion -> sl_assertion
  | SLWand    : sl_assertion -> sl_assertion -> sl_assertion
  | SLForall  : (value -> sl_assertion) -> sl_assertion
  | SLExists  : (value -> sl_assertion) -> sl_assertion
  | SLPure    : bool -> sl_assertion

(* Assertion satisfaction *)
let rec satisfies (h:heap) (p:sl_assertion) : bool =
  match p with
  | SLEmp -> h = emp
  | SLPointsTo l v -> h = singleton l v
  | SLStar p1 p2 ->
      exists h1 h2. disjoint h1 h2 &&
                    heap_union h1 h2 = h &&
                    satisfies h1 p1 &&
                    satisfies h2 p2
  | SLWand p1 p2 ->
      forall h'. disjoint h h' && satisfies h' p1 ==>
                 satisfies (heap_union h h') p2
  | SLPure b -> b && h = emp
  | _ -> admit()

(* Separation logic Hoare triple *)
noeq type sl_triple = {
  pre  : sl_assertion;
  cmd  : expr;
  post : sl_assertion
}

(* Frame rule *)
let frame_rule (t:sl_triple) (frame:sl_assertion) : sl_triple =
  { pre = SLStar t.pre frame;
    cmd = t.cmd;
    post = SLStar t.post frame }

(* Allocation rule *)
(* {emp} x := alloc(v) {x ↦ v} *)
let alloc_rule (v:value) : sl_triple =
  { pre = SLEmp;
    cmd = (* alloc *) ELit VUnit;
    post = SLExists (fun l -> SLPointsTo l v) }

(* Deallocation rule *)
(* {x ↦ v} free(x) {emp} *)
let free_rule (l:loc) (v:value) : sl_triple =
  { pre = SLPointsTo l v;
    cmd = (* free *) ELit VUnit;
    post = SLEmp }

(* Read rule *)
(* {x ↦ v} y := *x {x ↦ v ∧ y = v} *)
let read_rule (l:loc) (v:value) : sl_triple =
  { pre = SLPointsTo l v;
    cmd = (* read *) ELit VUnit;
    post = SLStar (SLPointsTo l v) (SLPure true) }

(* Write rule *)
(* {x ↦ _} *x := v {x ↦ v} *)
let write_rule (l:loc) (v:value) : sl_triple =
  { pre = SLExists (fun _ -> SLPointsTo l (VBase VUnit));
    cmd = (* write *) ELit VUnit;
    post = SLPointsTo l v }

(* Ownership transfer via frame *)
let transfer_ownership (src dst:loc) (v:value) : sl_triple =
  (* {src ↦ v * dst ↦ _} move {src ↦ ⊥ * dst ↦ v} *)
  { pre = SLStar (SLPointsTo src v) (SLExists (fun _ -> SLPointsTo dst (VBase VUnit)));
    cmd = ELit VUnit;
    post = SLStar SLEmp (SLPointsTo dst v) }
\end{fstarcode}


%=============================================================================
% PART X: FFI & INTEROP
%=============================================================================
\part{FFI \& Interop}

\chapter{Foreign Function Interface}

The FFI enables Brrr-Lang to interface with code written in other languages while maintaining type safety.

\section{Foreign Type Declarations}

\begin{definition}[Foreign Type]
A foreign type represents an opaque type from another language:
\[
  \mathsf{foreign}\; \mathsf{type}\; T
\]
The type $T$ has no Brrr-Lang representation; it exists only at FFI boundaries.
\end{definition}

\begin{definition}[Foreign Function Declaration]
\begin{align*}
  &\mathsf{extern}\; \mathsf{``C''}\; \{ \\
  &\quad \mathsf{fn}\; f(x_1 : \tau_1, \ldots, x_n : \tau_n) \to \sigma; \\
  &\}
\end{align*}
The calling convention (``C'', ``Rust'', ``System'') determines ABI.
\end{definition}

\begin{definition}[FFI Typing]
\begin{mathpar}
  \inferrule*[right=T-Extern]
    {\forall i.\; \tau_i \in \mathsf{FFISafe} \\ \sigma \in \mathsf{FFISafe}}
    {\env \types \mathsf{extern}\; f : (\tau_1, \ldots, \tau_n) \to \sigma \; [\mathsf{FFI}]}
\end{mathpar}
where $\mathsf{FFISafe}$ is the set of types with defined ABI representation.
\end{definition}

\section{FFI-Safe Types}

\begin{definition}[FFI-Safe Type Set]
\begin{align*}
  \mathsf{FFISafe} ::=\; &\TInt[w, s] \text{ for } w \in \{8, 16, 32, 64\} \\
    \mid\; &\TFloat[p] \text{ for } p \in \{32, 64\} \\
    \mid\; &\mathsf{Ptr}[\tau] \text{ for } \tau \in \mathsf{FFISafe} \\
    \mid\; &\mathsf{FnPtr}[\tau_1, \ldots, \tau_n \to \sigma] \\
    \mid\; &\mathsf{CStr} \\
    \mid\; &\mathsf{Struct}[f_1 : \tau_1, \ldots, f_n : \tau_n] \text{ with } \#[\mathsf{repr}(\mathsf{C})]
\end{align*}
\end{definition}

\begin{definition}[Type Representation Attribute]
\begin{align*}
  \#[\mathsf{repr}(\mathsf{C})] &\quad \text{C-compatible layout} \\
  \#[\mathsf{repr}(\mathsf{transparent})] &\quad \text{Same as inner type} \\
  \#[\mathsf{repr}(\mathsf{packed})] &\quad \text{No padding} \\
  \#[\mathsf{repr}(\mathsf{align}(n))] &\quad \text{Alignment to $n$ bytes}
\end{align*}
\end{definition}

\section{Safety and Unsafety}

\begin{definition}[Unsafe Block]
FFI calls require unsafe context:
\[
  \mathsf{unsafe}\; \{ \ldots \}
\]
Inside unsafe, the programmer asserts memory safety invariants.
\end{definition}

\begin{definition}[Unsafe Typing]
\begin{mathpar}
  \inferrule*[right=T-Unsafe]
    {\env \types e : \tau \; [\rowext{\mathsf{Unsafe}}{\varepsilon}]}
    {\env \types \mathsf{unsafe}\; \{e\} : \tau \; [\varepsilon]}
\end{mathpar}
Unsafe blocks discharge the $\mathsf{Unsafe}$ effect.
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={FFI in F*}]
module BrrrSemantics.FFI

(* Calling convention *)
type calling_convention =
  | CC_C         : calling_convention
  | CC_Rust      : calling_convention
  | CC_System    : calling_convention
  | CC_Fastcall  : calling_convention

(* FFI-safe types *)
noeq type ffi_safe_type =
  | FFIInt    : int_width -> signedness -> ffi_safe_type
  | FFIFloat  : float_prec -> ffi_safe_type
  | FFIPtr    : ffi_safe_type -> ffi_safe_type
  | FFIFnPtr  : list ffi_safe_type -> ffi_safe_type -> ffi_safe_type
  | FFICStr   : ffi_safe_type
  | FFIVoid   : ffi_safe_type
  | FFIStruct : list (string & ffi_safe_type) -> ffi_safe_type

(* Check if type is FFI-safe *)
let rec is_ffi_safe (t:brrr_type) : option ffi_safe_type =
  match t with
  | TInt {width; sign} ->
      (match width with
       | I8 | I16 | I32 | I64 -> Some (FFIInt width sign)
       | _ -> None)  (* I128, IBig not FFI-safe *)
  | TFloat p ->
      (match p with
       | F32 | F64 -> Some (FFIFloat p)
       | F16 -> None)
  | TUnit -> Some FFIVoid
  | _ -> None  (* Would need more cases *)

(* Foreign function declaration *)
noeq type extern_fn = {
  name        : string;
  convention  : calling_convention;
  params      : list (string & ffi_safe_type);
  return_type : ffi_safe_type;
  is_variadic : bool
}

(* Type representation *)
type repr_attr =
  | ReprC           : repr_attr
  | ReprTransparent : repr_attr
  | ReprPacked      : repr_attr
  | ReprAlign       : nat -> repr_attr

(* Struct with repr *)
noeq type ffi_struct = {
  name   : string;
  repr   : repr_attr;
  fields : list (string & ffi_safe_type)
}

(* Compute struct layout for repr(C) *)
let rec compute_c_layout (fields:list (string & ffi_safe_type))
    : list (string & nat (* offset *) & nat (* size *)) =
  let rec go fields offset acc =
    match fields with
    | [] -> List.rev acc
    | (name, ty) :: rest ->
        let size = ffi_type_size ty in
        let align = ffi_type_align ty in
        let padded_offset = align_up offset align in
        go rest (padded_offset + size) ((name, padded_offset, size) :: acc)
  in go fields 0 []

and ffi_type_size (t:ffi_safe_type) : nat =
  match t with
  | FFIInt I8 _ -> 1
  | FFIInt I16 _ -> 2
  | FFIInt I32 _ -> 4
  | FFIInt I64 _ -> 8
  | FFIFloat F32 -> 4
  | FFIFloat F64 -> 8
  | FFIPtr _ -> 8  (* Assuming 64-bit *)
  | FFIFnPtr _ _ -> 8
  | FFICStr -> 8  (* Pointer *)
  | FFIVoid -> 0
  | FFIStruct fields -> admit()  (* Sum of field sizes + padding *)
  | _ -> 0

and ffi_type_align (t:ffi_safe_type) : nat =
  ffi_type_size t  (* Simplified: align = size *)

and align_up (n align:nat) : nat =
  if align = 0 then n
  else ((n + align - 1) / align) * align

(* Unsafe effect *)
type unsafe_effect = | UnsafeFFI | UnsafePtr | UnsafeTransmute

(* Unsafe context tracking *)
let in_unsafe_block : ref bool = ref false

(* Check if we can call FFI *)
let check_ffi_call (fn:extern_fn) : bool =
  !in_unsafe_block

(* Unsafe block execution *)
let with_unsafe (#a:Type) (body:unit -> a) : a =
  in_unsafe_block := true;
  let result = body () in
  in_unsafe_block := false;
  result
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Memory Layout}

\section{Data Layout Specification}

\begin{definition}[Layout]
A layout specifies size, alignment, and field positions:
\[
  \mathsf{Layout} = \{
    \mathsf{size} : \mathbb{N},
    \mathsf{align} : \mathbb{N},
    \mathsf{fields} : \mathsf{List}[(\mathsf{Name}, \mathsf{Offset}, \mathsf{Layout})]
  \}
\]
\end{definition}

\begin{definition}[Primitive Layouts]
\begin{center}
\begin{tabular}{lcc}
\toprule
Type & Size (bytes) & Alignment \\
\midrule
$\TInt[8, \_]$ & 1 & 1 \\
$\TInt[16, \_]$ & 2 & 2 \\
$\TInt[32, \_]$ & 4 & 4 \\
$\TInt[64, \_]$ & 8 & 8 \\
$\TFloat[32]$ & 4 & 4 \\
$\TFloat[64]$ & 8 & 8 \\
$\mathsf{Ptr}[\_]$ & 8 & 8 \\
\bottomrule
\end{tabular}
\end{center}
\end{definition}

\section{Struct Layout Rules}

\begin{definition}[C Layout Algorithm]
For $\#[\mathsf{repr}(\mathsf{C})]$ structs:
\begin{enumerate}
  \item Start at offset 0
  \item For each field in declaration order:
    \begin{enumerate}
      \item Pad to field's alignment
      \item Place field at current offset
      \item Advance offset by field size
    \end{enumerate}
  \item Final size is padded to struct alignment
  \item Struct alignment is max of field alignments
\end{enumerate}
\end{definition}

\begin{definition}[Rust Layout]
Without $\mathsf{repr}$ attribute, the compiler may:
\begin{itemize}
  \item Reorder fields to minimize padding
  \item Use niche optimization for enums
  \item Apply other optimizations
\end{itemize}
\end{definition}

\section{Pointer Operations}

\begin{definition}[Pointer Arithmetic]
\begin{align*}
  \mathsf{offset} &: \mathsf{Ptr}[\tau] \times \TInt \to \mathsf{Ptr}[\tau] \\
  \mathsf{offset}(p, n) &= p + n \cdot \mathsf{sizeof}(\tau)
\end{align*}
\end{definition}

\begin{definition}[Pointer Cast]
\begin{mathpar}
  \inferrule*[right=T-PtrCast]
    {\env \types p : \mathsf{Ptr}[\tau_1] \; [\varepsilon]}
    {\env \types p \;\mathsf{as}\; \mathsf{Ptr}[\tau_2] : \mathsf{Ptr}[\tau_2] \; [\rowext{\mathsf{Unsafe}}{\varepsilon}]}
\end{mathpar}
Pointer casts require unsafe and may violate aliasing rules.
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Memory Layout in F*}]
module BrrrSemantics.Layout

(* Layout descriptor *)
noeq type layout = {
  size  : nat;
  align : nat
}

(* Field layout *)
noeq type field_layout = {
  name   : string;
  offset : nat;
  layout : layout
}

(* Struct layout *)
noeq type struct_layout = {
  total_size  : nat;
  total_align : nat;
  fields      : list field_layout
}

(* Primitive layouts *)
let layout_i8  : layout = { size = 1; align = 1 }
let layout_i16 : layout = { size = 2; align = 2 }
let layout_i32 : layout = { size = 4; align = 4 }
let layout_i64 : layout = { size = 8; align = 8 }
let layout_f32 : layout = { size = 4; align = 4 }
let layout_f64 : layout = { size = 8; align = 8 }
let layout_ptr : layout = { size = 8; align = 8 }

(* Get layout for FFI type *)
let ffi_layout (t:ffi_safe_type) : layout =
  match t with
  | FFIInt I8 _ -> layout_i8
  | FFIInt I16 _ -> layout_i16
  | FFIInt I32 _ -> layout_i32
  | FFIInt I64 _ -> layout_i64
  | FFIFloat F32 -> layout_f32
  | FFIFloat F64 -> layout_f64
  | FFIPtr _ -> layout_ptr
  | FFIFnPtr _ _ -> layout_ptr
  | FFICStr -> layout_ptr
  | FFIVoid -> { size = 0; align = 1 }
  | FFIStruct _ -> admit()  (* Recursive *)
  | _ -> { size = 0; align = 1 }

(* Align offset *)
let align_offset (offset align:nat) : nat =
  if align = 0 then offset
  else
    let rem = offset % align in
    if rem = 0 then offset else offset + (align - rem)

(* Compute C struct layout *)
let compute_struct_layout (fields:list (string & ffi_safe_type)) : struct_layout =
  let rec go fields offset max_align acc =
    match fields with
    | [] ->
        let final_size = align_offset offset max_align in
        { total_size = final_size; total_align = max_align; fields = List.rev acc }
    | (name, ty) :: rest ->
        let ly = ffi_layout ty in
        let aligned_offset = align_offset offset ly.align in
        let field_ly = { name = name; offset = aligned_offset; layout = ly } in
        go rest (aligned_offset + ly.size) (max max_align ly.align) (field_ly :: acc)
  in go fields 0 1 []

(* Pointer type *)
noeq type ptr (a:Type) = {
  addr : nat;
  phantom : a -> unit  (* Type witness *)
}

(* Null pointer *)
let null (#a:Type) : ptr a = { addr = 0; phantom = fun _ -> () }

(* Pointer arithmetic *)
let ptr_offset (#a:Type) (p:ptr a) (n:int) (elem_size:nat) : ptr a =
  { p with addr = p.addr + n * elem_size }

(* Check pointer validity *)
let is_valid_ptr (#a:Type) (p:ptr a) (heap_size:nat) (elem_size:nat) : bool =
  p.addr > 0 &&
  p.addr + elem_size <= heap_size &&
  p.addr % elem_size = 0  (* Aligned *)

(* Pointer cast (unsafe) *)
let ptr_cast (#a #b:Type) (p:ptr a) : ptr b =
  { addr = p.addr; phantom = fun _ -> () }

(* Read through pointer *)
let ptr_read (#a:Type) (p:ptr a) (heap:nat -> option a) : option a =
  if p.addr = 0 then None
  else heap p.addr

(* Write through pointer *)
let ptr_write (#a:Type) (p:ptr a) (v:a) (heap:nat -> option a) : nat -> option a =
  if p.addr = 0 then heap
  else fun addr -> if addr = p.addr then Some v else heap addr
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Cross-Language Semantics}

\section{Translation Functors}

\begin{definition}[Translation Functor]
A translation from source language $L$ to Brrr-Lang is a functor:
\[
  \mathcal{T}_L : \mathsf{Prog}_L \to \mathsf{Prog}_{\mathsf{Brrr}}
\]
preserving typing: if $\env \types_L e : \tau$, then $\mathcal{T}_L(\env) \types_{\mathsf{Brrr}} \mathcal{T}_L(e) : \mathcal{T}_L(\tau)$.
\end{definition}

\begin{definition}[Soundness]
Translation $\mathcal{T}_L$ is sound iff:
\[
  \sem{e}_L = \sem{\mathcal{T}_L(e)}_{\mathsf{Brrr}}
\]
The Brrr-Lang program has the same behavior as the source.
\end{definition}

\section{Language Mode Configuration}

\begin{definition}[Language Mode]
Each source language is characterized by a 5-tuple of modes:
\[
  \mathsf{Mode}_L = (\mathsf{Memory}, \mathsf{Types}, \mathsf{Null}, \mathsf{Effects}, \mathsf{Concurrency})
\]
\end{definition}

\begin{definition}[Mode Axes]
\begin{center}
\begin{tabular}{lp{8cm}}
\toprule
Axis & Values \\
\midrule
Memory & $\{\mathsf{GC}, \mathsf{RC}, \mathsf{Manual}, \mathsf{Ownership}\}$ \\
Types & $\{\mathsf{Static}, \mathsf{Gradual}, \mathsf{Dynamic}\}$ \\
Null & $\{\mathsf{Nullable}, \mathsf{Optional}, \mathsf{NonNull}\}$ \\
Effects & $\{\mathsf{Pure}, \mathsf{Tracked}, \mathsf{Untracked}\}$ \\
Concurrency & $\{\mathsf{None}, \mathsf{Threads}, \mathsf{Async}, \mathsf{Actors}\}$ \\
\bottomrule
\end{tabular}
\end{center}
\end{definition}

\begin{example}[Language Configurations]
\begin{center}
\begin{tabular}{lccccc}
\toprule
Language & Memory & Types & Null & Effects & Concurrency \\
\midrule
Rust & Ownership & Static & Optional & Tracked & Async \\
Python & GC & Dynamic & Nullable & Untracked & Async \\
TypeScript & GC & Gradual & Nullable & Untracked & Async \\
Go & GC & Static & Nullable & Untracked & Async \\
Swift & RC & Static & Optional & Untracked & Async \\
Java & GC & Static & Nullable & Untracked & Threads \\
\bottomrule
\end{tabular}
\end{center}
\end{example}

\section{Boundary Guards}

\begin{definition}[Boundary]
A language boundary $L_1 \leftrightarrow L_2$ is where code from $L_1$ calls into $L_2$.
\end{definition}

\begin{definition}[Guard]
A guard ensures properties hold at boundaries:
\begin{align*}
  \mathsf{guard}^{L_1 \to L_2}_\tau &: \mathcal{T}_{L_1}(\tau) \to \mathcal{T}_{L_2}(\tau) \\
  \mathsf{guard}^{\mathsf{Py} \to \mathsf{Rust}}_{\TInt} &= \lambda x.\, \mathsf{if}\; \mathsf{is\_int}(x) \;\mathsf{then}\; x \;\mathsf{else}\; \mathsf{panic}
\end{align*}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Cross-Language Semantics in F*}]
module BrrrSemantics.CrossLanguage

(* Memory mode *)
type memory_mode = | MemGC | MemRC | MemManual | MemOwnership

(* Type mode *)
type type_mode = | TypeStatic | TypeGradual | TypeDynamic

(* Null mode *)
type null_mode = | NullNullable | NullOptional | NullNonNull

(* Effect mode *)
type effect_mode = | EffPure | EffTracked | EffUntracked

(* Concurrency mode *)
type conc_mode = | ConcNone | ConcThreads | ConcAsync | ConcActors

(* Language mode configuration *)
noeq type lang_mode = {
  memory      : memory_mode;
  types       : type_mode;
  null_safety : null_mode;
  effects     : effect_mode;
  concurrency : conc_mode
}

(* Standard language configurations *)
let rust_mode : lang_mode = {
  memory = MemOwnership;
  types = TypeStatic;
  null_safety = NullOptional;
  effects = EffTracked;
  concurrency = ConcAsync
}

let python_mode : lang_mode = {
  memory = MemGC;
  types = TypeDynamic;
  null_safety = NullNullable;
  effects = EffUntracked;
  concurrency = ConcAsync
}

let typescript_mode : lang_mode = {
  memory = MemGC;
  types = TypeGradual;
  null_safety = NullNullable;
  effects = EffUntracked;
  concurrency = ConcAsync
}

let go_mode : lang_mode = {
  memory = MemGC;
  types = TypeStatic;
  null_safety = NullNullable;
  effects = EffUntracked;
  concurrency = ConcAsync
}

(* Translation context *)
noeq type trans_ctx = {
  source_mode : lang_mode;
  target_mode : lang_mode  (* Always Brrr *)
}

(* Type translation *)
let rec translate_type (ctx:trans_ctx) (t:brrr_type) : brrr_type =
  match ctx.source_mode.null_safety, t with
  | NullNullable, t -> TOption t  (* Lift nullable to Option *)
  | NullOptional, t -> t          (* Already Option *)
  | NullNonNull, t -> t           (* No wrapping *)

(* Guard generation *)
type guard_result (a:Type) =
  | GuardOk  : a -> guard_result a
  | GuardErr : string -> guard_result a

let generate_guard (from_mode to_mode:lang_mode) (t:brrr_type)
    : value -> guard_result value =
  match from_mode.types, to_mode.types with
  | TypeDynamic, TypeStatic ->
      (* Need runtime type check *)
      fun v -> match runtime_typecheck v t with
        | true -> GuardOk v
        | false -> GuardErr "Type mismatch at boundary"
  | TypeStatic, TypeDynamic ->
      (* Can always widen to dynamic *)
      fun v -> GuardOk v
  | _, _ ->
      fun v -> GuardOk v

and runtime_typecheck (v:value) (t:brrr_type) : bool =
  match v, t with
  | VBase (VInt _), TInt _ -> true
  | VBase (VBool _), TBool -> true
  | VBase (VString _), TString -> true
  | _, _ -> false

(* Memory mode translation *)
let translate_ownership (from_mode:lang_mode) (t:brrr_type) : moded_type =
  match from_mode.memory with
  | MemOwnership -> { ty = t; mode = MOne }       (* Linear *)
  | MemRC -> { ty = t; mode = MOmega }            (* Shared via RC *)
  | MemGC -> { ty = t; mode = MOmega }            (* Shared via GC *)
  | MemManual -> { ty = t; mode = MOne }          (* Must track *)

(* Effect translation *)
let translate_effects (from_mode:lang_mode) (eff:effect_row) : effect_row =
  match from_mode.effects with
  | EffPure -> eff                    (* Keep precise effects *)
  | EffTracked -> eff                 (* Keep precise effects *)
  | EffUntracked -> Var "ε"          (* Abstract over effects *)

(* Full translation *)
let translate_expr (ctx:trans_ctx) (e:expr) : expr =
  (* Would traverse and apply translations *)
  e
\end{fstarcode}


%=============================================================================
% PART XI: PHYSICAL REPRESENTATION
%=============================================================================
\part{Physical Representation}

\chapter{Content-Addressed Nodes}

This chapter specifies how Brrr-Lang IR is stored for efficient analysis.

\section{Merkle Hashing}

\begin{definition}[Content Address]
Every IR node has a content address (hash):
\[
  \mathsf{hash} : \mathsf{Node} \to \mathsf{Hash}_{256}
\]
where $\mathsf{Hash}_{256}$ is a 256-bit BLAKE3 hash.
\end{definition}

\begin{definition}[Node Hash Computation]
\begin{align*}
  \mathsf{hash}(\mathsf{Leaf}(v)) &= \mathsf{BLAKE3}(\mathsf{tag} \| \mathsf{encode}(v)) \\
  \mathsf{hash}(\mathsf{Node}(k, c_1, \ldots, c_n)) &= \mathsf{BLAKE3}(\mathsf{tag} \| k \| \mathsf{hash}(c_1) \| \cdots \| \mathsf{hash}(c_n))
\end{align*}
where $\mathsf{tag}$ distinguishes node types.
\end{definition}

\begin{theorem}[Structural Sharing]
If $\mathsf{hash}(n_1) = \mathsf{hash}(n_2)$, then $n_1 = n_2$ (with overwhelming probability).

This enables:
\begin{itemize}
  \item Deduplication of identical subtrees
  \item O(1) equality checking
  \item Efficient caching and memoization
\end{itemize}
\end{theorem}

\section{Node Index}

\begin{definition}[Node ID]
A node ID is a 32-bit index into the node array:
\[
  \mathsf{NodeId} = \mathbb{N}_{32}
\]
\end{definition}

\begin{definition}[DFS Ordering]
Nodes are stored in depth-first order:
\begin{itemize}
  \item Parent before children
  \item Left-to-right child ordering
  \item Enables subtree as contiguous range
\end{itemize}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Content Addressing in F*}]
module BrrrSemantics.ContentAddressing

(* 256-bit hash *)
type hash256 = {
  bytes : list nat (* 32 bytes *)
}

(* Node ID *)
type node_id = nat

(* Node kind tag *)
type node_tag =
  | TagExpr    : nat -> node_tag  (* Expression kind *)
  | TagStmt    : nat -> node_tag  (* Statement kind *)
  | TagType    : nat -> node_tag  (* Type kind *)
  | TagPattern : nat -> node_tag  (* Pattern kind *)

(* IR Node *)
noeq type ir_node =
  | IRLeaf : node_tag -> list nat (* encoded data *) -> ir_node
  | IRNode : node_tag -> list node_id (* children *) -> ir_node

(* BLAKE3 hash (simplified) *)
let blake3 (data:list nat) : hash256 =
  (* Real impl would use BLAKE3 algorithm *)
  { bytes = List.take 32 (data @ List.init 32 (fun _ -> 0)) }

(* Encode value to bytes *)
let encode_value (v:value) : list nat =
  match v with
  | VBase (VInt n) -> [0; n % 256; (n / 256) % 256; (n / 65536) % 256; n / 16777216]
  | VBase (VBool b) -> [1; if b then 1 else 0]
  | VBase (VString s) -> [2] @ List.map Char.code (String.to_list s)
  | _ -> [255]

(* Hash computation *)
let rec compute_hash (node:ir_node) (get_hash:node_id -> hash256) : hash256 =
  match node with
  | IRLeaf tag data ->
      let tag_bytes = match tag with
        | TagExpr n -> [0; n]
        | TagStmt n -> [1; n]
        | TagType n -> [2; n]
        | TagPattern n -> [3; n]
      in
      blake3 (tag_bytes @ data)

  | IRNode tag children ->
      let tag_bytes = match tag with
        | TagExpr n -> [0; n]
        | TagStmt n -> [1; n]
        | TagType n -> [2; n]
        | TagPattern n -> [3; n]
      in
      let child_hashes = List.concat_map (fun cid ->
        (get_hash cid).bytes) children in
      blake3 (tag_bytes @ child_hashes)

(* Hash table for deduplication *)
type hash_table = list (hash256 & node_id)

let lookup_hash (h:hash256) (table:hash_table) : option node_id =
  match List.find (fun (h', _) -> h.bytes = h'.bytes) table with
  | Some (_, id) -> Some id
  | None -> None

(* Insert with deduplication *)
let insert_node (node:ir_node) (nodes:list ir_node) (table:hash_table)
    : node_id & list ir_node & hash_table =
  let h = compute_hash node (fun id ->
    compute_hash (List.nth nodes id) (fun _ -> { bytes = [] })) in
  match lookup_hash h table with
  | Some existing_id -> (existing_id, nodes, table)  (* Deduplicated! *)
  | None ->
      let new_id = List.length nodes in
      (new_id, nodes @ [node], (h, new_id) :: table)

(* DFS traversal order *)
let rec dfs_order (root:ir_node) (get_children:ir_node -> list ir_node) : list ir_node =
  root :: List.concat_map (fun c -> dfs_order c get_children) (get_children root)

(* Check if range is contiguous subtree *)
let is_subtree_range (start_id end_id:node_id) (nodes:list ir_node) : bool =
  (* In DFS order, subtree is always contiguous *)
  start_id <= end_id && end_id < List.length nodes
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Columnar Storage}

\section{Structure of Arrays}

\begin{definition}[SoA Layout]
Instead of array of structs (AoS), use structure of arrays (SoA):
\begin{align*}
  \text{AoS:} &\quad [(\mathsf{kind}_1, \mathsf{span}_1), (\mathsf{kind}_2, \mathsf{span}_2), \ldots] \\
  \text{SoA:} &\quad ([\mathsf{kind}_1, \mathsf{kind}_2, \ldots], [\mathsf{span}_1, \mathsf{span}_2, \ldots])
\end{align*}
\end{definition}

\begin{theorem}[SoA Benefits]
\begin{itemize}
  \item Cache efficiency: accessing one field hits sequential memory
  \item SIMD: can process 8/16/32 elements per instruction
  \item Compression: similar values cluster together
\end{itemize}
\end{theorem}

\section{Column Types}

\begin{definition}[Node Columns]
\begin{align*}
  \mathsf{kinds} &: \mathsf{Array}[\mathsf{NodeKind}] & \text{(1 byte each)} \\
  \mathsf{spans} &: \mathsf{Array}[\mathsf{Span}] & \text{(8 bytes each)} \\
  \mathsf{types} &: \mathsf{Array}[\mathsf{TypeId}] & \text{(4 bytes each)} \\
  \mathsf{parents} &: \mathsf{Array}[\mathsf{NodeId}] & \text{(4 bytes each)} \\
  \mathsf{first\_child} &: \mathsf{Array}[\mathsf{NodeId}] & \text{(4 bytes each)} \\
  \mathsf{next\_sibling} &: \mathsf{Array}[\mathsf{NodeId}] & \text{(4 bytes each)}
\end{align*}
\end{definition}

\section{Edge Storage (CSR)}

\begin{definition}[Compressed Sparse Row]
Edges stored in CSR format:
\begin{align*}
  \mathsf{row\_ptr} &: \mathsf{Array}[\mathsf{EdgeIdx}] & \text{(start of edges for node $i$)} \\
  \mathsf{col\_idx} &: \mathsf{Array}[\mathsf{NodeId}] & \text{(target nodes)} \\
  \mathsf{edge\_data} &: \mathsf{Array}[\mathsf{EdgeKind}] & \text{(optional edge labels)}
\end{align*}

Edges from node $i$ are at indices $[\mathsf{row\_ptr}[i], \mathsf{row\_ptr}[i+1])$ in $\mathsf{col\_idx}$.
\end{definition}

\begin{theorem}[CSR Complexity]
\begin{itemize}
  \item Space: $O(V + E)$ instead of $O(V^2)$ for adjacency matrix
  \item Iteration over successors: $O(\text{out-degree})$
  \item SIMD-friendly for sparse operations
\end{itemize}
\end{theorem}

\section{F* Mechanization}

\begin{fstarcode}[title={Columnar Storage in F*}]
module BrrrSemantics.ColumnarStorage

(* Node kind enum (fits in 1 byte) *)
type node_kind = nat (* 0-255 *)

(* Source span *)
noeq type span = {
  file_id : nat;
  start   : nat;
  end_    : nat
}

(* Type ID (index into type table) *)
type type_id = nat

(* Columnar node storage *)
noeq type node_columns = {
  kinds       : list node_kind;    (* Node kinds *)
  spans       : list span;         (* Source locations *)
  types       : list type_id;      (* Type annotations *)
  parents     : list node_id;      (* Parent pointers *)
  first_child : list node_id;      (* First child (0 = none) *)
  next_sibling: list node_id       (* Next sibling (0 = none) *)
}

(* Create empty columns *)
let empty_columns : node_columns = {
  kinds = [];
  spans = [];
  types = [];
  parents = [];
  first_child = [];
  next_sibling = []
}

(* Add node to columns *)
let add_node (cols:node_columns) (kind:node_kind) (sp:span) (ty:type_id)
             (parent:node_id) : node_columns & node_id =
  let id = List.length cols.kinds in
  let cols' = {
    kinds = cols.kinds @ [kind];
    spans = cols.spans @ [sp];
    types = cols.types @ [ty];
    parents = cols.parents @ [parent];
    first_child = cols.first_child @ [0];  (* No children yet *)
    next_sibling = cols.next_sibling @ [0]
  } in
  (cols', id)

(* Get node kind *)
let get_kind (cols:node_columns) (id:node_id) : option node_kind =
  if id < List.length cols.kinds then Some (List.nth cols.kinds id)
  else None

(* CSR edge storage *)
noeq type csr_edges = {
  row_ptr   : list nat;       (* Start index for each node's edges *)
  col_idx   : list node_id;   (* Target nodes *)
  edge_kind : list nat        (* Edge labels *)
}

(* Create CSR from edge list *)
let build_csr (num_nodes:nat) (edges:list (node_id & node_id & nat)) : csr_edges =
  (* Sort edges by source *)
  let sorted = List.sortBy (fun (s, _, _) -> s) edges in

  (* Build row pointers *)
  let rec build_row_ptr (node:nat) (edges:list (node_id & node_id & nat)) (idx:nat) (acc:list nat) =
    if node > num_nodes then List.rev acc
    else
      (* Count edges from this node *)
      let from_node = List.filter (fun (s, _, _) -> s = node) edges in
      build_row_ptr (node + 1) edges (idx + List.length from_node) (idx :: acc)
  in

  let row_ptr = build_row_ptr 0 sorted 0 [] in
  let col_idx = List.map (fun (_, t, _) -> t) sorted in
  let edge_kind = List.map (fun (_, _, k) -> k) sorted in

  { row_ptr = row_ptr; col_idx = col_idx; edge_kind = edge_kind }

(* Get successors of node *)
let get_successors (csr:csr_edges) (node:node_id) : list node_id =
  if node + 1 >= List.length csr.row_ptr then []
  else
    let start = List.nth csr.row_ptr node in
    let end_ = List.nth csr.row_ptr (node + 1) in
    List.slice csr.col_idx start end_

(* Iterate over edges (SIMD-friendly) *)
let fold_edges (#a:Type) (csr:csr_edges) (f:node_id -> node_id -> nat -> a -> a) (init:a) : a =
  let rec go (i:nat) (acc:a) =
    if i >= List.length csr.col_idx then acc
    else
      (* Find source node *)
      let src = List.find_index (fun p -> p > i) csr.row_ptr in
      match src with
      | Some s -> go (i + 1) (f (s - 1) (List.nth csr.col_idx i) (List.nth csr.edge_kind i) acc)
      | None -> acc
  in go 0 init

(* Memory layout statistics *)
let column_memory_usage (cols:node_columns) : nat =
  let n = List.length cols.kinds in
  n * 1 +      (* kinds: 1 byte *)
  n * 12 +     (* spans: 12 bytes *)
  n * 4 +      (* types: 4 bytes *)
  n * 4 +      (* parents: 4 bytes *)
  n * 4 +      (* first_child: 4 bytes *)
  n * 4        (* next_sibling: 4 bytes *)
  (* Total: 33 bytes per node *)
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{String Interning}

\section{String Table}

\begin{definition}[Interned String]
All strings are stored once in a global table:
\[
  \mathsf{StringId} = \mathbb{N}_{32}
\]
\[
  \mathsf{StringTable} : \mathsf{StringId} \rightharpoonup \mathsf{String}
\]
\end{definition}

\begin{definition}[Interning Operation]
\begin{align*}
  \mathsf{intern} &: \mathsf{String} \to \mathsf{StringId} \\
  \mathsf{intern}(s) &= \begin{cases}
    \mathsf{id} & \text{if } s \in \mathsf{table} \\
    \mathsf{fresh}() & \text{otherwise, adding } s \text{ to table}
  \end{cases}
\end{align*}
\end{definition}

\begin{theorem}[Interning Benefits]
\begin{itemize}
  \item O(1) string equality via ID comparison
  \item Reduced memory for repeated identifiers
  \item Better cache locality (IDs are 4 bytes)
\end{itemize}
\end{theorem}

\section{Type Hash-Consing}

\begin{definition}[Type Table]
Types are hash-consed similarly:
\[
  \mathsf{TypeId} = \mathbb{N}_{32}
\]
\[
  \mathsf{TypeTable} : \mathsf{TypeId} \rightharpoonup \mathsf{Type}
\]
\end{definition}

\begin{definition}[Type Hash-Consing]
\begin{align*}
  \mathsf{mk\_func}(\tau_1, \tau_2, \varepsilon) &= \mathsf{intern\_type}(\mathsf{Func}(\tau_1, \tau_2, \varepsilon)) \\
  \mathsf{mk\_array}(\tau) &= \mathsf{intern\_type}(\mathsf{Array}(\tau))
\end{align*}
Structurally equal types have equal IDs.
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={String Interning in F*}]
module BrrrSemantics.Interning

(* String ID *)
type string_id = nat

(* String table *)
noeq type string_table = {
  strings    : list string;           (* ID -> String *)
  lookup_map : list (string & string_id)  (* String -> ID *)
}

(* Empty table with builtin strings *)
let empty_string_table : string_table = {
  strings = [""];  (* ID 0 = empty string *)
  lookup_map = [("", 0)]
}

(* Intern a string *)
let intern_string (table:string_table) (s:string) : string_table & string_id =
  match List.assoc s table.lookup_map with
  | Some id -> (table, id)
  | None ->
      let id = List.length table.strings in
      let table' = {
        strings = table.strings @ [s];
        lookup_map = (s, id) :: table.lookup_map
      } in
      (table', id)

(* Get string by ID *)
let get_string (table:string_table) (id:string_id) : option string =
  if id < List.length table.strings then Some (List.nth table.strings id)
  else None

(* String equality via ID *)
let string_eq (id1 id2:string_id) : bool = id1 = id2

(* Type ID *)
type type_id = nat

(* Type representation for hashing *)
noeq type type_repr =
  | TRPrim   : nat -> type_repr                          (* Primitive type code *)
  | TRFunc   : type_id -> type_id -> effect_id -> type_repr
  | TRArray  : type_id -> type_repr
  | TROption : type_id -> type_repr
  | TRTuple  : list type_id -> type_repr
  | TRNamed  : string_id -> list type_id -> type_repr    (* Named type with args *)

and effect_id = nat

(* Type table *)
noeq type type_table = {
  types      : list type_repr;
  lookup_map : list (type_repr & type_id)
}

(* Empty type table with primitives *)
let empty_type_table : type_table = {
  types = [
    TRPrim 0;  (* Unit *)
    TRPrim 1;  (* Bool *)
    TRPrim 2;  (* Int32 *)
    TRPrim 3;  (* Int64 *)
    TRPrim 4;  (* Float32 *)
    TRPrim 5;  (* Float64 *)
    TRPrim 6;  (* String *)
    TRPrim 7   (* Never *)
  ];
  lookup_map = []  (* Primitives found by code *)
}

(* Type ID constants *)
let type_unit   : type_id = 0
let type_bool   : type_id = 1
let type_i32    : type_id = 2
let type_i64    : type_id = 3
let type_f32    : type_id = 4
let type_f64    : type_id = 5
let type_string : type_id = 6
let type_never  : type_id = 7

(* Hash-cons a type *)
let intern_type (table:type_table) (t:type_repr) : type_table & type_id =
  match List.assoc t table.lookup_map with
  | Some id -> (table, id)
  | None ->
      let id = List.length table.types in
      let table' = {
        types = table.types @ [t];
        lookup_map = (t, id) :: table.lookup_map
      } in
      (table', id)

(* Make function type *)
let mk_func_type (table:type_table) (arg ret:type_id) (eff:effect_id)
    : type_table & type_id =
  intern_type table (TRFunc arg ret eff)

(* Make array type *)
let mk_array_type (table:type_table) (elem:type_id) : type_table & type_id =
  intern_type table (TRArray elem)

(* Type equality via ID *)
let type_eq (id1 id2:type_id) : bool = id1 = id2

(* Get type by ID *)
let get_type (table:type_table) (id:type_id) : option type_repr =
  if id < List.length table.types then Some (List.nth table.types id)
  else None
\end{fstarcode}


%=============================================================================
% PART XII: COMPUTE ARCHITECTURE
%=============================================================================
\part{Compute Architecture}

\chapter{Parallelization Strategy}

\section{Parallelism Levels}

\begin{definition}[Four-Level Parallelism]
\begin{enumerate}
  \item \textbf{File-level}: Different files analyzed in parallel
  \item \textbf{Function-level}: Independent functions analyzed in parallel
  \item \textbf{Worklist-level}: Multiple worklist items processed in parallel
  \item \textbf{SIMD-level}: Data-parallel operations on vectors
\end{enumerate}
\end{definition}

\begin{definition}[Dependency Graph]
\[
  G_{\mathsf{dep}} = (V, E) \quad \text{where } (u, v) \in E \iff \text{analysis of } v \text{ requires } u
\]
\end{definition}

\begin{theorem}[Parallelization Theorem]
Tasks $t_1, \ldots, t_n$ can execute in parallel iff there is no path between any $t_i$ and $t_j$ in $G_{\mathsf{dep}}$.
\end{theorem}

\section{Work Stealing}

\begin{definition}[Work-Stealing Queue]
Each worker has a deque of tasks:
\begin{itemize}
  \item Push/pop from bottom (local operations)
  \item Steal from top (remote operations)
\end{itemize}
\end{definition}

\begin{definition}[Work-Stealing Algorithm]
\begin{enumerate}
  \item Worker attempts to pop from own deque
  \item If empty, randomly select victim and steal
  \item If all empty, worker goes idle
  \item New work wakes idle workers
\end{enumerate}
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Parallelization in F*}]
module BrrrSemantics.Parallel

(* Task ID *)
type task_id = nat

(* Task state *)
type task_state = | Pending | Running | Completed

(* Task with dependencies *)
noeq type task = {
  id           : task_id;
  dependencies : list task_id;
  state        : ref task_state;
  work         : unit -> unit
}

(* Check if task is ready *)
let is_ready (t:task) (completed:list task_id) : bool =
  List.for_all (fun dep -> List.mem dep completed) t.dependencies

(* Work-stealing deque *)
noeq type ws_deque (a:Type) = {
  items : ref (list a);
  lock  : ref bool  (* Simplified mutex *)
}

let new_deque (#a:Type) () : ws_deque a =
  { items = ref []; lock = ref false }

(* Push to bottom (local) *)
let push_bottom (#a:Type) (d:ws_deque a) (x:a) : unit =
  d.items := x :: !(d.items)

(* Pop from bottom (local) *)
let pop_bottom (#a:Type) (d:ws_deque a) : option a =
  match !(d.items) with
  | [] -> None
  | x :: rest -> d.items := rest; Some x

(* Steal from top (remote, needs sync) *)
let steal_top (#a:Type) (d:ws_deque a) : option a =
  (* Acquire lock *)
  if !(d.lock) then None
  else begin
    d.lock := true;
    let result = match List.rev !(d.items) with
      | [] -> None
      | x :: rest -> d.items := List.rev rest; Some x
    in
    d.lock := false;
    result
  end

(* Worker *)
noeq type worker = {
  id    : nat;
  deque : ws_deque task
}

(* Scheduler *)
noeq type scheduler = {
  workers   : list worker;
  completed : ref (list task_id)
}

(* Run worker *)
let rec worker_loop (w:worker) (all_workers:list worker) (completed:ref (list task_id)) : unit =
  (* Try own deque *)
  match pop_bottom w.deque with
  | Some t ->
      if is_ready t !completed then begin
        t.state := Running;
        t.work ();
        t.state := Completed;
        completed := t.id :: !completed;
        worker_loop w all_workers completed
      end else begin
        (* Put back if not ready *)
        push_bottom w.deque t;
        worker_loop w all_workers completed
      end
  | None ->
      (* Try stealing *)
      let victims = List.filter (fun w' -> w'.id <> w.id) all_workers in
      match try_steal victims with
      | Some t -> push_bottom w.deque t; worker_loop w all_workers completed
      | None -> ()  (* Done or waiting *)

and try_steal (victims:list worker) : option task =
  match victims with
  | [] -> None
  | v :: rest ->
      match steal_top v.deque with
      | Some t -> Some t
      | None -> try_steal rest

(* Dependency graph analysis *)
let topological_levels (tasks:list task) : list (list task_id) =
  (* Group tasks by dependency depth *)
  let rec depth (t:task) (memo:list (task_id & nat)) : nat =
    match List.assoc t.id memo with
    | Some d -> d
    | None ->
        if t.dependencies = [] then 0
        else 1 + List.fold_left max 0
          (List.map (fun dep ->
            match List.find (fun t' -> t'.id = dep) tasks with
            | Some t' -> depth t' memo
            | None -> 0) t.dependencies)
  in
  let depths = List.map (fun t -> (t.id, depth t [])) tasks in
  let max_depth = List.fold_left (fun m (_, d) -> max m d) 0 depths in
  List.init (max_depth + 1) (fun level ->
    List.filter_map (fun (id, d) -> if d = level then Some id else None) depths)

(* Parallel for each level *)
let parallel_execute (tasks:list task) : unit =
  let levels = topological_levels tasks in
  List.iter (fun level ->
    (* Tasks in same level can run in parallel *)
    List.iter (fun id ->
      match List.find (fun t -> t.id = id) tasks with
      | Some t -> t.work ()
      | None -> ()
    ) level
  ) levels
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{SIMD Optimization}

\section{Vector Operations}

\begin{definition}[SIMD Width]
\begin{align*}
  \mathsf{SSE} &: 128 \text{ bits} = 4 \times \TFloat[32] = 2 \times \TFloat[64] \\
  \mathsf{AVX2} &: 256 \text{ bits} = 8 \times \TFloat[32] = 4 \times \TFloat[64] \\
  \mathsf{AVX512} &: 512 \text{ bits} = 16 \times \TFloat[32] = 8 \times \TFloat[64]
\end{align*}
\end{definition}

\begin{definition}[Vector Type]
\[
  \mathsf{Vec}[n, \tau] \quad \text{where } n \cdot \mathsf{sizeof}(\tau) \leq \mathsf{SIMD\_WIDTH}
\]
\end{definition}

\section{Bitset Operations}

\begin{definition}[SIMD Bitset]
For dataflow facts represented as bitsets:
\[
  \mathsf{facts} : \mathsf{Vec}[512, \TBool] \cong \mathbb{Z}_{2^{512}}
\]
\end{definition}

\begin{definition}[Vectorized Set Operations]
\begin{align*}
  \mathsf{union}(a, b) &= a \lor b & \text{(bitwise OR)} \\
  \mathsf{intersect}(a, b) &= a \land b & \text{(bitwise AND)} \\
  \mathsf{diff}(a, b) &= a \land \lnot b & \text{(bitwise ANDNOT)} \\
  \mathsf{is\_subset}(a, b) &= (a \land \lnot b) = 0
\end{align*}
Single instruction per 512 bits with AVX-512.
\end{definition}

\begin{theorem}[Dataflow Speedup]
For bitvector dataflow with $n$ facts:
\begin{itemize}
  \item Scalar: $O(n)$ operations per join
  \item SIMD (512-bit): $O(n/512)$ operations per join
  \item Speedup: up to $512\times$ for large fact sets
\end{itemize}
\end{theorem}

\section{F* Mechanization}

\begin{fstarcode}[title={SIMD Optimization in F*}]
module BrrrSemantics.SIMD

(* SIMD width in bits *)
type simd_width = | SSE128 | AVX256 | AVX512

let width_bits (w:simd_width) : nat =
  match w with
  | SSE128 -> 128
  | AVX256 -> 256
  | AVX512 -> 512

(* Vector type *)
noeq type vec (n:nat) (a:Type) = {
  elements : l:list a{List.length l = n}
}

(* SIMD vector types *)
type vec4f32  = vec 4 float   (* SSE *)
type vec8f32  = vec 8 float   (* AVX2 *)
type vec16f32 = vec 16 float  (* AVX-512 *)

type vec2f64  = vec 2 float
type vec4f64  = vec 4 float
type vec8f64  = vec 8 float

(* Bitset as vector of 64-bit words *)
type bitset512 = vec 8 nat  (* 8 x 64 bits = 512 bits *)

(* Create empty bitset *)
let empty_bitset : bitset512 = { elements = [0;0;0;0;0;0;0;0] }

(* Create full bitset *)
let full_bitset : bitset512 = {
  elements = [0xFFFFFFFFFFFFFFFF; 0xFFFFFFFFFFFFFFFF;
              0xFFFFFFFFFFFFFFFF; 0xFFFFFFFFFFFFFFFF;
              0xFFFFFFFFFFFFFFFF; 0xFFFFFFFFFFFFFFFF;
              0xFFFFFFFFFFFFFFFF; 0xFFFFFFFFFFFFFFFF]
}

(* SIMD bitwise OR (union) *)
let simd_or (a b:bitset512) : bitset512 =
  { elements = List.map2 (fun x y -> x lor y) a.elements b.elements }

(* SIMD bitwise AND (intersect) *)
let simd_and (a b:bitset512) : bitset512 =
  { elements = List.map2 (fun x y -> x land y) a.elements b.elements }

(* SIMD bitwise ANDNOT (diff) *)
let simd_andnot (a b:bitset512) : bitset512 =
  { elements = List.map2 (fun x y -> x land (lnot y)) a.elements b.elements }

(* SIMD bitwise XOR *)
let simd_xor (a b:bitset512) : bitset512 =
  { elements = List.map2 (fun x y -> x lxor y) a.elements b.elements }

(* Check if zero (all bits unset) *)
let simd_is_zero (a:bitset512) : bool =
  List.for_all ((=) 0) a.elements

(* Check subset: a ⊆ b iff (a AND NOT b) = 0 *)
let simd_is_subset (a b:bitset512) : bool =
  simd_is_zero (simd_andnot a b)

(* Check equality *)
let simd_eq (a b:bitset512) : bool =
  simd_is_zero (simd_xor a b)

(* Count set bits (popcount) *)
let popcount64 (x:nat) : nat =
  (* Simplified - real impl uses hardware popcount *)
  let rec count x acc =
    if x = 0 then acc
    else count (x / 2) (acc + x mod 2)
  in count x 0

let simd_popcount (a:bitset512) : nat =
  List.fold_left (+) 0 (List.map popcount64 a.elements)

(* Set bit at position *)
let set_bit (a:bitset512) (pos:nat) : bitset512 =
  if pos >= 512 then a
  else
    let word_idx = pos / 64 in
    let bit_idx = pos mod 64 in
    { elements = List.mapi (fun i w ->
        if i = word_idx then w lor (1 lsl bit_idx) else w) a.elements }

(* Test bit at position *)
let test_bit (a:bitset512) (pos:nat) : bool =
  if pos >= 512 then false
  else
    let word_idx = pos / 64 in
    let bit_idx = pos mod 64 in
    (List.nth a.elements word_idx land (1 lsl bit_idx)) <> 0

(* Vectorized dataflow iteration *)
let dataflow_step (in_facts:list bitset512) (gen kill:bitset512) : bitset512 =
  (* out = gen ∪ (in - kill) *)
  let combined_in = List.fold_left simd_or empty_bitset in_facts in
  simd_or gen (simd_andnot combined_in kill)
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Worklist Algorithms}

\section{RPO Worklist}

\begin{definition}[Reverse Postorder (RPO)]
Nodes in reverse postorder of the CFG. Processing in RPO ensures:
\begin{itemize}
  \item Predecessors processed before successors (mostly)
  \item Faster convergence for forward analyses
\end{itemize}
\end{definition}

\begin{definition}[Worklist Algorithm]
\begin{enumerate}
  \item Initialize: worklist $\gets$ all nodes in RPO
  \item While worklist non-empty:
    \begin{enumerate}
      \item Remove node $n$ with smallest RPO number
      \item Compute new facts for $n$
      \item If facts changed, add successors to worklist
    \end{enumerate}
  \item Return fixpoint
\end{enumerate}
\end{definition}

\section{Lock-Free Fact Propagation}

\begin{definition}[Atomic Fact Update]
For concurrent worklist processing:
\[
  \mathsf{update}(\mathsf{facts}[n], \mathsf{new}) = \mathsf{CAS}(\mathsf{facts}[n], \mathsf{old}, \mathsf{old} \sqcup \mathsf{new})
\]
where CAS is atomic compare-and-swap.
\end{definition}

\begin{theorem}[Monotonicity Ensures Correctness]
If the transfer function is monotonic and the lattice has finite height, lock-free propagation converges to the same fixpoint as sequential.
\end{theorem}

\section{F* Mechanization}

\begin{fstarcode}[title={Worklist Algorithms in F*}]
module BrrrSemantics.Worklist

(* Priority queue based on RPO number *)
noeq type worklist = {
  items    : list (nat (* rpo *) & node_id);
  in_queue : node_id -> bool
}

let empty_worklist : worklist = {
  items = [];
  in_queue = fun _ -> false
}

(* Add node to worklist *)
let add_to_worklist (wl:worklist) (rpo:nat) (node:node_id) : worklist =
  if wl.in_queue node then wl
  else {
    items = insert_sorted (rpo, node) wl.items;
    in_queue = fun n -> n = node || wl.in_queue n
  }

and insert_sorted (item:nat & node_id) (items:list (nat & node_id))
    : list (nat & node_id) =
  match items with
  | [] -> [item]
  | (r, n) :: rest ->
      if fst item <= r then item :: items
      else (r, n) :: insert_sorted item rest

(* Remove minimum from worklist *)
let pop_worklist (wl:worklist) : option (node_id & worklist) =
  match wl.items with
  | [] -> None
  | (_, node) :: rest ->
      Some (node, {
        items = rest;
        in_queue = fun n -> n <> node && wl.in_queue n
      })

(* Dataflow lattice *)
type lattice (a:Type) = {
  bottom : a;
  join   : a -> a -> a;
  leq    : a -> a -> bool
}

(* Transfer function *)
type transfer (a:Type) = node_id -> a -> a

(* Dataflow analysis *)
let analyze (#a:Type) (lat:lattice a) (transfer:transfer a)
            (cfg:csr_edges) (rpo_order:list node_id) : node_id -> a =
  let n_nodes = List.length rpo_order in
  let facts : ref (node_id -> a) = ref (fun _ -> lat.bottom) in
  let rpo_num = List.mapi (fun i n -> (n, i)) rpo_order in

  (* Initialize worklist with all nodes *)
  let init_wl = List.fold_left (fun wl (node, rpo) ->
    add_to_worklist wl rpo node) empty_worklist rpo_num in

  (* Main loop *)
  let rec iterate (wl:worklist) : unit =
    match pop_worklist wl with
    | None -> ()  (* Converged *)
    | Some (node, wl') ->
        let old_fact = !facts node in
        (* Gather input from predecessors *)
        let pred_facts = List.map (fun p -> !facts p) (get_predecessors cfg node) in
        let in_fact = List.fold_left lat.join lat.bottom pred_facts in
        let new_fact = transfer node in_fact in

        if lat.leq new_fact old_fact then
          (* No change, continue *)
          iterate wl'
        else begin
          (* Update and propagate *)
          facts := (fun n -> if n = node then lat.join old_fact new_fact else !facts n);
          let succs = get_successors cfg node in
          let wl'' = List.fold_left (fun w s ->
            let rpo = match List.assoc s rpo_num with Some r -> r | None -> n_nodes in
            add_to_worklist w rpo s) wl' succs in
          iterate wl''
        end
  in

  iterate init_wl;
  !facts

and get_predecessors (cfg:csr_edges) (node:node_id) : list node_id =
  (* Would need reverse edges *)
  []

(* Lock-free fact update *)
type atomic_facts (a:Type) = {
  data : ref (node_id -> a);
  (* In real impl: array of atomic cells *)
}

let atomic_update (#a:Type) (lat:lattice a) (facts:atomic_facts a)
                  (node:node_id) (new_fact:a) : bool (* changed *) =
  let old = !facts.data node in
  let joined = lat.join old new_fact in
  if lat.leq joined old then false
  else begin
    (* CAS: compare-and-swap *)
    facts.data := (fun n -> if n = node then joined else !facts.data n);
    true
  end

(* Parallel worklist with lock-free facts *)
let parallel_analyze (#a:Type) (lat:lattice a) (transfer:transfer a)
                     (cfg:csr_edges) (rpo_order:list node_id) (n_workers:nat)
                     : node_id -> a =
  let facts : atomic_facts a = { data = ref (fun _ -> lat.bottom) } in

  (* Each worker processes nodes from shared worklist *)
  (* Simplified: actual impl would use concurrent data structures *)

  !facts.data
\end{fstarcode}

%-----------------------------------------------------------------------------
\chapter{Memory Hierarchy Optimization}

\section{Cache-Aware Layout}

\begin{definition}[Cache Line]
Modern CPUs fetch 64-byte cache lines. Data layout should:
\begin{itemize}
  \item Align hot data to cache line boundaries
  \item Group frequently co-accessed data
  \item Separate read-only from read-write data
\end{itemize}
\end{definition}

\begin{definition}[Hot/Warm/Cold Separation]
\begin{align*}
  \mathsf{Hot} &: \text{Accessed in inner loops (node kinds, parents)} \\
  \mathsf{Warm} &: \text{Accessed occasionally (types, spans)} \\
  \mathsf{Cold} &: \text{Rarely accessed (debug info, comments)}
\end{align*}
\end{definition}

\section{Memory Budget}

\begin{definition}[Per-Node Memory]
Target: fit working set in L3 cache.
\begin{center}
\begin{tabular}{lr}
\toprule
Component & Bytes per node \\
\midrule
Node kind & 1 \\
Parent pointer & 4 \\
First child & 4 \\
Next sibling & 4 \\
Type ID & 4 \\
Span & 12 \\
Flags & 1 \\
\midrule
\textbf{Hot total} & \textbf{30} \\
\midrule
Source text offset & 4 \\
Hash (cached) & 4 \\
\midrule
\textbf{Warm total} & \textbf{8} \\
\bottomrule
\end{tabular}
\end{center}
\end{definition}

\begin{theorem}[L3 Capacity]
With 30 bytes/node hot data and 32 MB L3 cache:
\[
  \text{Max hot nodes} = \frac{32 \times 10^6}{30} \approx 1{,}066{,}666 \text{ nodes}
\]
Sufficient for most single-file analyses.
\end{theorem}

\section{Prefetching}

\begin{definition}[Software Prefetch]
For predictable access patterns:
\[
  \mathsf{prefetch}(\mathsf{addr} + k \cdot \mathsf{stride})
\]
Fetch data $k$ iterations ahead.
\end{definition}

\section{F* Mechanization}

\begin{fstarcode}[title={Memory Hierarchy in F*}]
module BrrrSemantics.MemoryHierarchy

(* Cache line size *)
let cache_line_bytes : nat = 64

(* L1/L2/L3 cache sizes (typical) *)
let l1_cache_bytes : nat = 32 * 1024      (* 32 KB *)
let l2_cache_bytes : nat = 256 * 1024     (* 256 KB *)
let l3_cache_bytes : nat = 32 * 1024 * 1024  (* 32 MB *)

(* Temperature classification *)
type temperature = | Hot | Warm | Cold

(* Hot node data (fits in 32 bytes, aligned to 32) *)
noeq type hot_node = {
  kind        : nat;      (* 1 byte, padded *)
  flags       : nat;      (* 1 byte *)
  _pad1       : nat;      (* 2 bytes padding *)
  parent      : node_id;  (* 4 bytes *)
  first_child : node_id;  (* 4 bytes *)
  next_sibling: node_id;  (* 4 bytes *)
  type_id     : type_id;  (* 4 bytes *)
  span_start  : nat;      (* 4 bytes *)
  span_end    : nat;      (* 4 bytes *)
  span_file   : nat       (* 4 bytes *)
  (* Total: 32 bytes *)
}

(* Warm node data *)
noeq type warm_node = {
  source_offset : nat;    (* 4 bytes *)
  hash_cache    : nat     (* 4 bytes *)
  (* Total: 8 bytes *)
}

(* Cold node data *)
noeq type cold_node = {
  debug_name    : string_id;
  comment       : string_id;
  original_span : span
}

(* Separated storage *)
noeq type node_storage = {
  hot_nodes  : list hot_node;    (* Contiguous, cache-friendly *)
  warm_nodes : list warm_node;
  cold_nodes : list cold_node
}

(* Memory usage calculation *)
let hot_bytes_per_node : nat = 32
let warm_bytes_per_node : nat = 8
let cold_bytes_per_node : nat = 20  (* Approximate *)

let calculate_memory (n_nodes:nat) : nat & nat & nat =
  (n_nodes * hot_bytes_per_node,
   n_nodes * warm_bytes_per_node,
   n_nodes * cold_bytes_per_node)

(* Can fit in L3? *)
let fits_in_l3 (n_nodes:nat) : bool =
  n_nodes * hot_bytes_per_node <= l3_cache_bytes

(* Max nodes for L3 *)
let max_l3_nodes : nat = l3_cache_bytes / hot_bytes_per_node

(* Prefetch hint *)
type prefetch_hint = | PrefetchRead | PrefetchWrite | PrefetchNTA

let prefetch_distance : nat = 8  (* Prefetch 8 iterations ahead *)

(* Prefetch in traversal *)
let traverse_with_prefetch (nodes:list hot_node) (f:hot_node -> unit) : unit =
  let arr = nodes in  (* Assume array-like access *)
  let len = List.length arr in
  List.iteri (fun i node ->
    (* Prefetch ahead *)
    if i + prefetch_distance < len then
      let _ = List.nth arr (i + prefetch_distance) in ()  (* Touch to prefetch *)
    else ();
    f node
  ) arr

(* Cache line alignment *)
let align_to_cache_line (addr:nat) : nat =
  let rem = addr mod cache_line_bytes in
  if rem = 0 then addr else addr + (cache_line_bytes - rem)

(* Pack multiple small items into cache line *)
let items_per_cache_line (item_size:nat) : nat =
  cache_line_bytes / item_size

(* For 32-byte hot nodes: 2 per cache line *)
let hot_nodes_per_cache_line : nat = items_per_cache_line hot_bytes_per_node
\end{fstarcode}


%=============================================================================
% APPENDICES
%=============================================================================
\appendix

\chapter{Notation Summary}

\begin{center}
\begin{tabular}{lll}
\toprule
Symbol & Meaning & Definition \\
\midrule
$\sem{e}$ & Denotation of $e$ & Chapter 1 \\
$\tau \at m$ & Type with mode & Chapter 7 \\
$\effjoin$ & Effect join & Chapter 4 \\
$\effsub$ & Effect subtyping & Chapter 4 \\
$\rowext{E}{\varepsilon}$ & Effect row extension & Chapter 4 \\
$\Pure$ & Pure effect (bottom) & Chapter 4 \\
$\tensor$ & Tensor product (pair) & Chapter 10 \\
$\lolli$ & Linear function & Chapter 10 \\
$\bang\tau$ & Exponential (unrestricted) & Chapter 8 \\
$\Box\tau$ & Box (shared borrow) & Chapter 9 \\
$\Diamond\tau$ & Diamond (exclusive) & Chapter 9 \\
$\rho$ & Region/lifetime & Chapter 10 \\
\bottomrule
\end{tabular}
\end{center}

\chapter{Complete Typing Rules}

This appendix collects all typing rules for reference.

\section{Core Rules}

\begin{mathpar}
  \inferrule*[right=T-Var]
    {(x : \tau \at m) \in \env \\ m > \mzero}
    {\env \types x : \tau \; [\Pure]}
  \and
  \inferrule*[right=T-Abs]
    {\env, x : \tau_1 \at m \types e : \tau_2 \; [\varepsilon]}
    {\env \types \lambda x.\, e : (\tau_1 \at m) \xrightarrow{\varepsilon} \tau_2 \; [\Pure]}
  \and
  \inferrule*[right=T-App]
    {\env_1 \types e_1 : (\tau_1 \at m) \xrightarrow{\varepsilon_f} \tau_2 \; [\varepsilon_1] \\
     \env_2 \types e_2 : \tau_1 \; [\varepsilon_2]}
    {\env_1 + \env_2 \types e_1 \; e_2 : \tau_2 \; [\varepsilon_1 \effjoin \varepsilon_2 \effjoin \varepsilon_f]}
  \and
  \inferrule*[right=T-Let]
    {\env_1 \types e_1 : \tau_1 \; [\varepsilon_1] \\
     \env_2, x : \tau_1 \at m \types e_2 : \tau_2 \; [\varepsilon_2]}
    {\env_1 + \env_2 \types \mathsf{let}\, x = e_1 \;\mathsf{in}\; e_2 : \tau_2 \; [\varepsilon_1 \effjoin \varepsilon_2]}
  \and
  \inferrule*[right=T-If]
    {\env_0 \types e_c : \TBool \; [\varepsilon_0] \\
     \env_1 \types e_1 : \tau \; [\varepsilon_1] \\
     \env_2 \types e_2 : \tau \; [\varepsilon_2]}
    {\env_0 + \env_1 + \env_2 \types \mathsf{if}\, e_c \,\mathsf{then}\, e_1 \,\mathsf{else}\, e_2 : \tau \; [\varepsilon_0 \effjoin \varepsilon_1 \effjoin \varepsilon_2]}
\end{mathpar}

\section{Subtyping Rules}

\begin{mathpar}
  \inferrule*[right=T-Sub]
    {\env \types e : \tau_1 \; [\varepsilon_1] \\ \tau_1 \subtype \tau_2 \\ \varepsilon_1 \effsub \varepsilon_2}
    {\env \types e : \tau_2 \; [\varepsilon_2]}
\end{mathpar}

\section{Effect Rules}

\begin{mathpar}
  \inferrule*[right=T-Handle]
    {\env \types e : \tau \; [\rowext{E}{\varepsilon}] \\
     \env, x : \tau \types e_r : \sigma \; [\varepsilon'] \\
     \forall i.\; \env, x_i : \tau_i, k : \sigma_i \to \sigma\; [\varepsilon'] \types e_i : \sigma \; [\varepsilon']}
    {\env \types \mathsf{handle}\, e \,\mathsf{with}\, H : \sigma \; [\varepsilon \effjoin \varepsilon']}
\end{mathpar}

\section{Ownership Rules}

\begin{mathpar}
  \inferrule*[right=T-Move]
    {\env, x : \tau \at \mone \types e : \sigma \; [\varepsilon]}
    {\env \types \mathsf{move}(x) : \tau \; [\varepsilon]}
  \and
  \inferrule*[right=T-Borrow]
    {\env \types e : \tau \at \mone \; [\varepsilon]}
    {\env \types \&e : \Box\tau \; [\varepsilon]}
  \and
  \inferrule*[right=T-BorrowMut]
    {\env \types e : \tau \at \mone \; [\varepsilon] \\ \text{no active borrows}}
    {\env \types \&\mathsf{mut}\, e : \Diamond\tau \; [\varepsilon]}
\end{mathpar}

%=============================================================================
% PART XIII: INCREMENTAL ANALYSIS
%=============================================================================
\part{Incremental Analysis}

\chapter{Merkle-Based Change Detection}

Incremental analysis requires efficient detection of what has changed. We use
content-addressed hashing to create Merkle trees over the program structure.

\section{Content Hashing}

\begin{definition}[Node Hash]
For any AST node $n$, the \textbf{content hash} is:
\[
  \mathsf{hash}(n) = H(\mathsf{kind}(n) \mathbin{\|} \mathsf{hash}(\mathsf{children}(n)) \mathbin{\|} \mathsf{content}(n))
\]
where $H$ is BLAKE3 and $\|$ denotes concatenation.
\end{definition}

\begin{definition}[Merkle Root]
The \textbf{Merkle root} of a module $M$ is:
\[
  \mathsf{root}(M) = H\left(\bigoplus_{n \in \mathsf{toplevel}(M)} \mathsf{hash}(n)\right)
\]
\end{definition}

\begin{theorem}[Change Detection]
For modules $M_1, M_2$:
\[
  \mathsf{root}(M_1) = \mathsf{root}(M_2) \iff M_1 \equiv_{\alpha} M_2
\]
where $\equiv_{\alpha}$ is $\alpha$-equivalence (up to variable renaming).
\end{theorem}

\begin{fstarcode}[title=Merkle Tree Implementation]
module Merkle

open FStar.Bytes
open FStar.Seq

type hash = bytes_32

val hash_node : node_kind -> seq hash -> bytes -> hash
let hash_node kind children content =
  let kind_bytes = encode_kind kind in
  let children_hash = fold_left xor_hash zero_hash children in
  blake3 (kind_bytes @| children_hash @| content)

type merkle_tree = {
  root: hash;
  nodes: map hash node;
  children: map hash (seq hash);
}

val diff : merkle_tree -> merkle_tree -> set hash
let diff old_tree new_tree =
  let rec find_changed h =
    if not (Map.contains old_tree.nodes h) then
      singleton h
    else if Map.find old_tree.nodes h <> Map.find new_tree.nodes h then
      singleton h
    else
      fold_union find_changed (Map.find new_tree.children h)
  in
  find_changed new_tree.root

lemma diff_sound (t1 t2 : merkle_tree) (h : hash) :
  Lemma (requires h `Set.mem` diff t1 t2)
        (ensures node_changed t1 t2 h)
\end{fstarcode}

\section{Differential Algorithm}

\begin{definition}[Minimal Edit Script]
Given trees $T_1, T_2$, the \textbf{minimal edit script} is:
\[
  \mathsf{edit}(T_1, T_2) = \argmin_{s \in \mathsf{Scripts}} |\{e \in s \mid e = \mathsf{Modify}(\cdot)\}|
\]
subject to $\mathsf{apply}(s, T_1) = T_2$.
\end{definition}

\begin{theorem}[Edit Distance Bound]
For trees with $n_1, n_2$ nodes:
\[
  |\mathsf{edit}(T_1, T_2)| \leq \min(n_1, n_2) + |n_1 - n_2|
\]
\end{theorem}

The algorithm proceeds top-down:

\begin{enumerate}
  \item Compare roots: if hashes match, subtrees are identical
  \item If hashes differ, recursively compare children
  \item Use Hungarian algorithm for optimal child matching
  \item Generate Insert/Delete/Modify operations
\end{enumerate}

\begin{fstarcode}[title=Tree Diff Algorithm]
type edit_op =
  | Insert of hash * node
  | Delete of hash
  | Modify of hash * node * node
  | Move of hash * hash * hash  (* node, old_parent, new_parent *)

val tree_diff : merkle_tree -> merkle_tree -> list edit_op
let rec tree_diff t1 t2 =
  if t1.root = t2.root then []
  else
    let c1 = Map.find t1.children t1.root in
    let c2 = Map.find t2.children t2.root in
    let matching = hungarian_match c1 c2 hash_similarity in
    let ops = concat_map (fun (h1, h2) ->
      if h1 = h2 then []
      else if is_none h1 then [Insert (h2, Map.find t2.nodes h2)]
      else if is_none h2 then [Delete h1]
      else tree_diff (subtree t1 h1) (subtree t2 h2)
    ) matching in
    ops
\end{fstarcode}


\chapter{Dependency Tracking}

Analysis results depend on program fragments. We track these dependencies to
enable precise invalidation.

\section{Dependency Graph}

\begin{definition}[Dependency Relation]
The \textbf{dependency relation} $\depends$ is:
\[
  f \depends g \iff \text{analysis of } f \text{ reads result of } g
\]
\end{definition}

\begin{definition}[Transitive Closure]
The \textbf{affected set} for change $\Delta$ is:
\[
  \mathsf{affected}(\Delta) = \{f \mid \exists g \in \Delta.\; f \depends^* g\}
\]
\end{definition}

\begin{theorem}[Soundness of Invalidation]
If $\mathsf{invalidate}(\Delta) \supseteq \mathsf{affected}(\Delta)$, then
recomputing invalidated results produces correct analysis.
\end{theorem}

\begin{fstarcode}[title=Dependency Tracking]
module Dependencies

type dep_kind =
  | TypeDep      (* Type of symbol *)
  | CallDep      (* Function called *)
  | FieldDep     (* Field accessed *)
  | ImportDep    (* Module imported *)
  | InheritDep   (* Class inherited *)

type dependency = {
  source: symbol_id;
  target: symbol_id;
  kind: dep_kind;
  strength: float;  (* For prioritization *)
}

type dep_graph = {
  forward: map symbol_id (set dependency);
  backward: map symbol_id (set dependency);
}

val add_dependency : dep_graph -> dependency -> dep_graph
let add_dependency g d =
  { forward = Map.update g.forward d.source (Set.add d);
    backward = Map.update g.backward d.target (Set.add d) }

val affected_by : dep_graph -> set symbol_id -> set symbol_id
let rec affected_by g changed =
  let direct = fold_union (fun s ->
    Set.map (fun d -> d.source) (Map.find_default g.backward s Set.empty)
  ) changed in
  if Set.is_empty direct then changed
  else Set.union changed (affected_by g direct)

lemma affected_complete (g : dep_graph) (c : set symbol_id) (s : symbol_id) :
  Lemma (requires depends_transitively g s c)
        (ensures s `Set.mem` affected_by g c)
\end{fstarcode}

\section{Fine-Grained Dependencies}

We track dependencies at multiple granularities:

\begin{definition}[Granularity Levels]
\begin{align*}
  \mathsf{Module} &: \text{Entire module changed} \\
  \mathsf{Symbol} &: \text{Specific function/class changed} \\
  \mathsf{Signature} &: \text{Only type signature changed} \\
  \mathsf{Body} &: \text{Only implementation changed}
\end{align*}
\end{definition}

\begin{theorem}[Signature Stability]
If only the body of $f$ changes (not its signature), then:
\[
  \forall g.\; g \depends_{\mathsf{Signature}} f \implies g \text{ need not be reanalyzed}
\]
\end{theorem}

\begin{fstarcode}[title=Fine-Grained Invalidation]
type change_kind =
  | SignatureChange of symbol_id * typ * typ
  | BodyChange of symbol_id
  | AddSymbol of symbol_id
  | RemoveSymbol of symbol_id

val minimal_invalidation : dep_graph -> change_kind -> set symbol_id
let minimal_invalidation g change =
  match change with
  | SignatureChange (s, old_ty, new_ty) ->
      (* All dependents must be reanalyzed *)
      affected_by g (singleton s)
  | BodyChange s ->
      (* Only callers with body-level deps *)
      let deps = Map.find_default g.backward s Set.empty in
      Set.filter (fun d -> d.kind = CallDep && is_inlined d) deps
      |> Set.map (fun d -> d.source)
  | AddSymbol s ->
      (* New symbol, check for shadowing *)
      potential_shadowees g s
  | RemoveSymbol s ->
      (* All references now invalid *)
      affected_by g (singleton s)
\end{fstarcode}


\chapter{Memoization and Caching}

Analysis results are cached and reused when inputs haven't changed.

\section{Content-Addressed Cache}

\begin{definition}[Cache Key]
For analysis $A$ on input $x$:
\[
  \mathsf{key}(A, x) = H(A.\mathsf{version} \mathbin{\|} \mathsf{hash}(x) \mathbin{\|} \mathsf{hash}(\mathsf{deps}(A, x)))
\]
\end{definition}

\begin{definition}[Cache Validity]
Cache entry $(k, v)$ is \textbf{valid} iff:
\[
  \forall x.\; \mathsf{key}(A, x) = k \implies A(x) = v
\]
\end{definition}

\begin{theorem}[Cache Soundness]
If the cache is content-addressed and the hash function is collision-resistant,
then cache lookups always return correct results.
\end{theorem}

\begin{fstarcode}[title=Memoization Cache]
module Cache

type cache_entry (a : Type) = {
  key: hash;
  value: a;
  deps: set hash;
  created: timestamp;
  access_count: nat;
}

type cache (a : Type) = {
  entries: map hash (cache_entry a);
  max_size: nat;
  eviction_policy: eviction_policy;
}

val lookup : cache a -> hash -> option a
let lookup c k =
  match Map.find c.entries k with
  | Some e ->
      (* Validate deps still match *)
      if all_deps_valid e.deps then Some e.value
      else None
  | None -> None

val insert : cache a -> hash -> a -> set hash -> cache a
let insert c k v deps =
  let entry = { key = k; value = v; deps = deps;
                created = now(); access_count = 0 } in
  let c' = maybe_evict c in
  { c' with entries = Map.add c'.entries k entry }

val invalidate : cache a -> set hash -> cache a
let invalidate c changed =
  let dominated = find_dominated c.entries changed in
  { c with entries = Map.remove_all c.entries dominated }

(* LRU eviction with dependency awareness *)
val maybe_evict : cache a -> cache a
let maybe_evict c =
  if Map.size c.entries < c.max_size then c
  else
    let victim = find_lru_no_dependents c in
    { c with entries = Map.remove c.entries victim.key }
\end{fstarcode}

\section{Incremental Fixpoint}

For analyses that compute fixpoints (e.g., dataflow), we support incremental
recomputation.

\begin{definition}[Incremental Worklist]
Given change set $\Delta$, the initial worklist is:
\[
  W_0 = \mathsf{affected}(\Delta)
\]
\end{definition}

\begin{theorem}[Incremental Correctness]
Let $F$ be a monotone analysis. If:
\begin{enumerate}
  \item $W_0 \supseteq \mathsf{affected}(\Delta)$
  \item Each iteration adds newly-affected nodes to worklist
\end{enumerate}
Then the incremental fixpoint equals the from-scratch fixpoint.
\end{theorem}

\begin{fstarcode}[title=Incremental Fixpoint]
val incremental_fixpoint :
  analysis_fn -> dep_graph -> cache result -> set symbol_id ->
  (cache result * map symbol_id result)
let incremental_fixpoint analyze deps cache changed =
  let worklist = ref (affected_by deps changed) in
  let results = ref (cache_to_map cache) in

  while not (Set.is_empty !worklist) do
    let node = Set.choose !worklist in
    worklist := Set.remove !worklist node;

    let old_result = Map.find_default !results node bottom in
    let new_result = analyze node !results in

    if new_result <> old_result then begin
      results := Map.add !results node new_result;
      (* Add dependents to worklist *)
      let dependents = Map.find_default deps.backward node Set.empty in
      worklist := Set.union !worklist (Set.map (fun d -> d.source) dependents)
    end
  done;

  (map_to_cache !results, !results)

lemma incremental_correct (f : analysis_fn) (d : dep_graph) (c : cache) (ch : set symbol_id) :
  Lemma (let (_, r) = incremental_fixpoint f d c ch in
         r = from_scratch_fixpoint f)
\end{fstarcode}


%=============================================================================
% PART XIV: SOURCE LANGUAGE MAPPING
%=============================================================================
\part{Source Language Mapping}

This part defines translation functors from source languages to Brrr-Lang,
with soundness guarantees.

\chapter{Translation Functor Framework}

\section{Categorical Foundation}

Each source language $L$ forms a category:

\begin{definition}[Language Category]
\[
  \mathbf{Cat}_L = (\mathsf{Obj}_L, \mathsf{Mor}_L, \mathsf{id}, \circ)
\]
where:
\begin{itemize}
  \item $\mathsf{Obj}_L$ = types in $L$
  \item $\mathsf{Mor}_L$ = functions $f : A \to B$ in $L$
  \item $\mathsf{id}_A$ = identity function
  \item $\circ$ = function composition
\end{itemize}
\end{definition}

\begin{definition}[Translation Functor]
A \textbf{translation functor} $T : \mathbf{Cat}_L \to \mathbf{Cat}_{\mathsf{Brrr}}$ consists of:
\begin{itemize}
  \item Object mapping: $T(\tau) \in \mathsf{Types}_{\mathsf{Brrr}}$
  \item Morphism mapping: $T(f : A \to B) : T(A) \to T(B)$
\end{itemize}
satisfying:
\begin{align*}
  T(\mathsf{id}_A) &= \mathsf{id}_{T(A)} \tag{Identity} \\
  T(g \circ f) &= T(g) \circ T(f) \tag{Composition}
\end{align*}
\end{definition}

\begin{theorem}[Soundness]
A translation $T$ is \textbf{sound} iff:
\[
  \forall e, \rho.\; \sem{e}_L(\rho) = v \implies \sem{T(e)}_{\mathsf{Brrr}}(T(\rho)) = T(v)
\]
\end{theorem}

\begin{fstarcode}[title=Translation Functor Interface]
module TranslationFunctor

type functor (l : language) = {
  (* Object mapping *)
  translate_type : l.typ -> brrr_typ;

  (* Morphism mapping *)
  translate_expr : l.expr -> brrr_expr;
  translate_stmt : l.stmt -> brrr_stmt;

  (* Environment mapping *)
  translate_env : l.env -> brrr_env;

  (* Value mapping *)
  translate_value : l.value -> brrr_value;
}

val functor_laws : functor l -> prop
let functor_laws f =
  (* Identity preservation *)
  (forall a. f.translate_expr (l.id a) = brrr.id (f.translate_type a)) /\
  (* Composition preservation *)
  (forall g h. f.translate_expr (l.compose g h) =
               brrr.compose (f.translate_expr g) (f.translate_expr h))

val soundness : functor l -> prop
let soundness f =
  forall e rho v.
    l.eval e rho = v ==>
    brrr.eval (f.translate_expr e) (f.translate_env rho) = f.translate_value v
\end{fstarcode}


\chapter{Python Translation}

\section{Type Mapping}

\begin{definition}[Python Type Translation]
\begin{align*}
  T_{\mathsf{Py}}(\mathtt{None}) &= \TUnit \\
  T_{\mathsf{Py}}(\mathtt{bool}) &= \TBool \\
  T_{\mathsf{Py}}(\mathtt{int}) &= \TInt[\mathsf{BigInt}, \mathsf{Signed}] \\
  T_{\mathsf{Py}}(\mathtt{float}) &= \TFloat[\mathsf{F64}] \\
  T_{\mathsf{Py}}(\mathtt{str}) &= \TString \\
  T_{\mathsf{Py}}(\mathtt{list}[A]) &= \gc\, \TArray[T_{\mathsf{Py}}(A)] \\
  T_{\mathsf{Py}}(\mathtt{dict}[K, V]) &= \gc\, \TDict[T_{\mathsf{Py}}(K), T_{\mathsf{Py}}(V)] \\
  T_{\mathsf{Py}}(\mathtt{Callable}[[A_1, \ldots, A_n], R]) &= (T_{\mathsf{Py}}(A_1), \ldots) \xrightarrow{\varepsilon_{\mathsf{Py}}} T_{\mathsf{Py}}(R) \\
  T_{\mathsf{Py}}(\mathtt{Any}) &= \TAny
\end{align*}
where $\varepsilon_{\mathsf{Py}} = \rowext{\Throw}{\rowext{\IO}{\rowvar}}$ (Python's default effects).
\end{definition}

\section{Expression Translation}

\begin{definition}[Python Expression Translation]
\begin{align*}
  T_{\mathsf{Py}}(x) &= x \\
  T_{\mathsf{Py}}(\mathtt{lambda}\, x: e) &= \lambda x.\, T_{\mathsf{Py}}(e) \\
  T_{\mathsf{Py}}(e_1(e_2)) &= T_{\mathsf{Py}}(e_1)\, T_{\mathsf{Py}}(e_2) \\
  T_{\mathsf{Py}}(e_1 + e_2) &= T_{\mathsf{Py}}(e_1) + T_{\mathsf{Py}}(e_2) \\
  T_{\mathsf{Py}}([e_1, \ldots, e_n]) &= \mathsf{gc\_alloc}([T_{\mathsf{Py}}(e_1), \ldots, T_{\mathsf{Py}}(e_n)]) \\
  T_{\mathsf{Py}}(e.\mathit{attr}) &= \mathsf{attr\_get}(T_{\mathsf{Py}}(e), \mathit{attr}) \\
  T_{\mathsf{Py}}(\mathtt{raise}\, e) &= \throw(T_{\mathsf{Py}}(e))
\end{align*}
\end{definition}

\begin{fstarcode}[title=Python Translation]
module Python

let translate_type (t : py_type) : brrr_type =
  match t with
  | PyNone -> TUnit
  | PyBool -> TBool
  | PyInt -> TInt BigInt Signed
  | PyFloat -> TFloat F64
  | PyStr -> TString
  | PyList a -> TArray (translate_type a) GC
  | PyDict (k, v) -> TDict (translate_type k) (translate_type v) GC
  | PyCallable (args, ret) ->
      TFunc (List.map translate_type args) (translate_type ret) py_effects
  | PyAny -> TAny
  | PyClass name -> TClass name GC

let py_effects = RowExtend Throw (RowExtend IO RowVar)

let rec translate_expr (e : py_expr) : brrr_expr =
  match e with
  | PyVar x -> EVar x
  | PyLambda (x, body) -> ELambda (x, translate_expr body)
  | PyCall (f, args) -> EApp (translate_expr f) (List.map translate_expr args)
  | PyBinOp (op, l, r) -> EBinOp (translate_op op) (translate_expr l) (translate_expr r)
  | PyList elems -> EAlloc GC (EArray (List.map translate_expr elems))
  | PyDict pairs -> EAlloc GC (EDict (List.map (fun (k,v) ->
      (translate_expr k, translate_expr v)) pairs))
  | PyAttr (obj, attr) -> EFieldGet (translate_expr obj) attr
  | PyRaise exc -> EThrow (translate_expr exc)
  | PyTry (body, handlers, finally_) ->
      let brrr_body = translate_expr body in
      let brrr_handlers = List.map (fun (exc_ty, var, handler) ->
        (translate_type exc_ty, var, translate_expr handler)
      ) handlers in
      let brrr_finally = Option.map translate_expr finally_ in
      ETryCatch brrr_body brrr_handlers brrr_finally

lemma python_translation_sound (e : py_expr) (env : py_env) :
  Lemma (ensures
    forall v. py_eval e env = v ==>
    brrr_eval (translate_expr e) (translate_env env) = translate_value v)
\end{fstarcode}


\chapter{TypeScript Translation}

\section{Type Mapping}

\begin{definition}[TypeScript Type Translation]
\begin{align*}
  T_{\mathsf{TS}}(\mathtt{undefined}) &= \TUnit \\
  T_{\mathsf{TS}}(\mathtt{null}) &= \TOption[\TAny] \\
  T_{\mathsf{TS}}(\mathtt{boolean}) &= \TBool \\
  T_{\mathsf{TS}}(\mathtt{number}) &= \TFloat[\mathsf{F64}] \\
  T_{\mathsf{TS}}(\mathtt{bigint}) &= \TInt[\mathsf{BigInt}, \mathsf{Signed}] \\
  T_{\mathsf{TS}}(\mathtt{string}) &= \TString \\
  T_{\mathsf{TS}}(A[]) &= \gc\, \TArray[T_{\mathsf{TS}}(A)] \\
  T_{\mathsf{TS}}(\mathtt{Promise}\langle A \rangle) &= \TFuture[T_{\mathsf{TS}}(A), \mathsf{Hot}] \\
  T_{\mathsf{TS}}(A \mid B) &= T_{\mathsf{TS}}(A) \sqcup T_{\mathsf{TS}}(B) \\
  T_{\mathsf{TS}}(A \mathrel{\&} B) &= T_{\mathsf{TS}}(A) \sqcap T_{\mathsf{TS}}(B)
\end{align*}
\end{definition}

\section{Async/Await Translation}

\begin{definition}[Async Translation]
\begin{align*}
  T_{\mathsf{TS}}(\mathtt{async}\, f) &= f : \tau \xrightarrow{\Async} \TFuture[\sigma] \\
  T_{\mathsf{TS}}(\mathtt{await}\, e) &= \mathsf{await}(T_{\mathsf{TS}}(e))
\end{align*}
\end{definition}

\begin{fstarcode}[title=TypeScript Translation]
module TypeScript

let rec translate_type (t : ts_type) : brrr_type =
  match t with
  | TSUndefined -> TUnit
  | TSNull -> TOption TAny
  | TSBoolean -> TBool
  | TSNumber -> TFloat F64
  | TSBigInt -> TInt BigInt Signed
  | TSString -> TString
  | TSArray a -> TArray (translate_type a) GC
  | TSPromise a -> TFuture (translate_type a) Hot
  | TSUnion (a, b) -> TUnion (translate_type a) (translate_type b)
  | TSIntersection (a, b) -> TIntersection (translate_type a) (translate_type b)
  | TSObject fields -> TStruct (List.map (fun (n, t) -> (n, translate_type t)) fields) GC
  | TSFunction (params, ret) ->
      TFunc (List.map translate_type params) (translate_type ret) ts_effects

let ts_effects = RowExtend Throw (RowExtend Async RowVar)

let rec translate_expr (e : ts_expr) : brrr_expr =
  match e with
  | TSVar x -> EVar x
  | TSArrow (params, body) ->
      ELambda (List.map fst params) (translate_expr body)
  | TSCall (f, args) ->
      EApp (translate_expr f) (List.map translate_expr args)
  | TSAwait e -> EAwait (translate_expr e)
  | TSAsync body ->
      EAsync (translate_expr body)
  | TSOptionalChain (obj, prop) ->
      EMatch (translate_expr obj) [
        (PNone, EConst CUnit);
        (PSome "v", EFieldGet (EVar "v") prop)
      ]
  | TSNullishCoalesce (l, r) ->
      EMatch (translate_expr l) [
        (PNone, translate_expr r);
        (PSome "v", EVar "v")
      ]
  | TSTypeAssertion (e, ty) ->
      ECast (translate_expr e) (translate_type ty)
\end{fstarcode}


\chapter{Rust Translation}

\section{Ownership Mapping}

\begin{definition}[Rust Ownership Translation]
\begin{align*}
  T_{\mathsf{Rs}}(T) &= \own\, T_{\mathsf{Rs}}^{\mathsf{base}}(T) \\
  T_{\mathsf{Rs}}(\&'a T) &= \refm\, T_{\mathsf{Rs}}^{\mathsf{base}}(T)\, ['a] \\
  T_{\mathsf{Rs}}(\&'a \mathtt{mut}\, T) &= \refmut\, T_{\mathsf{Rs}}^{\mathsf{base}}(T)\, ['a] \\
  T_{\mathsf{Rs}}(\mathtt{Box}\langle T \rangle) &= \own\, \TBox[T_{\mathsf{Rs}}^{\mathsf{base}}(T)] \\
  T_{\mathsf{Rs}}(\mathtt{Rc}\langle T \rangle) &= \rc\, T_{\mathsf{Rs}}^{\mathsf{base}}(T) \\
  T_{\mathsf{Rs}}(\mathtt{Arc}\langle T \rangle) &= \arc\, T_{\mathsf{Rs}}^{\mathsf{base}}(T)
\end{align*}
\end{definition}

\section{Move Semantics}

\begin{definition}[Move Translation]
\begin{align*}
  T_{\mathsf{Rs}}(\mathtt{let}\, y = x) &= \mathtt{let}\, y = \mathsf{move}(x) \quad\text{(if $x : T$, $T$ not Copy)} \\
  T_{\mathsf{Rs}}(f(x)) &= f(\mathsf{move}(x)) \quad\text{(by value)} \\
  T_{\mathsf{Rs}}(f(\&x)) &= f(\&x) \quad\text{(shared borrow)} \\
  T_{\mathsf{Rs}}(f(\&\mathtt{mut}\, x)) &= f(\&\mathtt{mut}\, x) \quad\text{(exclusive borrow)}
\end{align*}
\end{definition}

\begin{theorem}[Ownership Preservation]
If Rust program $P$ is ownership-safe, then $T_{\mathsf{Rs}}(P)$ is ownership-safe in Brrr.
\end{theorem}

\begin{fstarcode}[title=Rust Translation]
module Rust

type ownership_mode = Own | Ref of lifetime | RefMut of lifetime | Rc | Arc

let rec translate_type (t : rust_type) : brrr_type * ownership_mode =
  match t with
  | RsOwned base -> (translate_base base, Own)
  | RsRef (lt, base) -> (translate_base base, Ref lt)
  | RsRefMut (lt, base) -> (translate_base base, RefMut lt)
  | RsBox base -> (TBox (translate_base base), Own)
  | RsRc base -> (translate_base base, Rc)
  | RsArc base -> (translate_base base, Arc)
  | RsOption t ->
      let (bt, mode) = translate_type t in
      (TOption bt, mode)
  | RsResult (t, e) ->
      let (bt, _) = translate_type t in
      let (be, _) = translate_type e in
      (TResult bt be, Own)

and translate_base (b : rust_base_type) : brrr_type =
  match b with
  | RsBool -> TBool
  | RsI8 -> TInt I8 Signed
  | RsI16 -> TInt I16 Signed
  | RsI32 -> TInt I32 Signed
  | RsI64 -> TInt I64 Signed
  | RsU8 -> TInt I8 Unsigned
  | RsU64 -> TInt I64 Unsigned
  | RsF32 -> TFloat F32
  | RsF64 -> TFloat F64
  | RsStr -> TString
  | RsVec t -> TArray (fst (translate_type t))
  | RsStruct (name, fields) ->
      TStruct (List.map (fun (n, t) -> (n, fst (translate_type t))) fields)

let rec translate_expr (e : rust_expr) (ctx : borrow_context) : brrr_expr =
  match e with
  | RsVar x ->
      if is_copy ctx x then EVar x
      else if is_moved ctx x then error "use after move"
      else EMove (EVar x)
  | RsBorrow x -> EBorrow (EVar x) Shared
  | RsBorrowMut x -> EBorrow (EVar x) Exclusive
  | RsDeref e -> EDeref (translate_expr e ctx)
  | RsMatch (scrut, arms) ->
      EMatch (translate_expr scrut ctx)
        (List.map (fun (pat, body) ->
          (translate_pattern pat, translate_expr body (extend_ctx ctx pat))
        ) arms)
  | RsBlock stmts ->
      let (ctx', brrr_stmts) = translate_stmts stmts ctx in
      EBlock brrr_stmts
  | RsDrop x ->
      ESeq (ECall (EVar "drop") [EMove (EVar x)]) (EConst CUnit)

lemma rust_ownership_preserved (e : rust_expr) :
  Lemma (requires rust_borrow_check e)
        (ensures brrr_ownership_safe (translate_expr e empty_ctx))
\end{fstarcode}


\chapter{Go Translation}

\section{Type Mapping}

\begin{definition}[Go Type Translation]
\begin{align*}
  T_{\mathsf{Go}}(\mathtt{bool}) &= \TBool \\
  T_{\mathsf{Go}}(\mathtt{int}) &= \TInt[\mathsf{I64}, \mathsf{Signed}] \\
  T_{\mathsf{Go}}(\mathtt{int32}) &= \TInt[\mathsf{I32}, \mathsf{Signed}] \\
  T_{\mathsf{Go}}(\mathtt{float64}) &= \TFloat[\mathsf{F64}] \\
  T_{\mathsf{Go}}(\mathtt{string}) &= \TString \\
  T_{\mathsf{Go}}([]A) &= \gc\, \TSlice[T_{\mathsf{Go}}(A)] \\
  T_{\mathsf{Go}}(\mathtt{map}[K]V) &= \gc\, \TDict[T_{\mathsf{Go}}(K), T_{\mathsf{Go}}(V)] \\
  T_{\mathsf{Go}}(\mathtt{chan}\, A) &= \TChannel[T_{\mathsf{Go}}(A)] \\
  T_{\mathsf{Go}}(*A) &= \gc\, \TPtr[T_{\mathsf{Go}}(A)] \\
  T_{\mathsf{Go}}(\mathtt{interface}\{\ldots\}) &= \TDyn[\mathsf{methods}]
\end{align*}
\end{definition}

\section{Goroutine Translation}

\begin{definition}[Concurrency Translation]
\begin{align*}
  T_{\mathsf{Go}}(\mathtt{go}\, f(x)) &= \mathsf{spawn}(T_{\mathsf{Go}}(f)(T_{\mathsf{Go}}(x))) \\
  T_{\mathsf{Go}}(ch \mathbin{\texttt{<-}} v) &= \mathsf{chan\_send}(ch, T_{\mathsf{Go}}(v)) \\
  T_{\mathsf{Go}}(\mathbin{\texttt{<-}}ch) &= \mathsf{chan\_recv}(ch)
\end{align*}
\end{definition}

\begin{fstarcode}[title=Go Translation]
module Go

let rec translate_type (t : go_type) : brrr_type =
  match t with
  | GoBool -> TBool
  | GoInt -> TInt I64 Signed
  | GoInt32 -> TInt I32 Signed
  | GoInt64 -> TInt I64 Signed
  | GoUint64 -> TInt I64 Unsigned
  | GoFloat64 -> TFloat F64
  | GoString -> TString
  | GoSlice a -> TSlice (translate_type a) GC
  | GoMap (k, v) -> TDict (translate_type k) (translate_type v) GC
  | GoChan a -> TChannel (translate_type a)
  | GoPtr a -> TPtr (translate_type a) GC
  | GoInterface methods -> TDyn (translate_methods methods)
  | GoStruct fields -> TStruct (translate_fields fields) GC
  | GoFunc (params, results) ->
      TFunc (List.map translate_type params)
            (tuple_or_single (List.map translate_type results))
            go_effects

let go_effects = RowExtend Panic (RowExtend Spawn RowVar)

let rec translate_expr (e : go_expr) : brrr_expr =
  match e with
  | GoVar x -> EVar x
  | GoGo f args -> ESpawn (EApp (translate_expr f) (List.map translate_expr args))
  | GoChanSend (ch, v) -> EChanSend (translate_expr ch) (translate_expr v)
  | GoChanRecv ch -> EChanRecv (translate_expr ch)
  | GoSelect cases ->
      ESelect (List.map (fun (ch, dir, body) ->
        match dir with
        | Send v -> (SelectSend (translate_expr ch) (translate_expr v), translate_expr body)
        | Recv x -> (SelectRecv (translate_expr ch) x, translate_expr body)
      ) cases)
  | GoDefer body -> EDefer (translate_expr body)
  | GoPanic v -> EPanic (translate_expr v)
  | GoRecover -> ERecover
\end{fstarcode}


\chapter{Swift Translation}

\section{Type Mapping}

\begin{definition}[Swift Type Translation]
\begin{align*}
  T_{\mathsf{Sw}}(\mathtt{Bool}) &= \TBool \\
  T_{\mathsf{Sw}}(\mathtt{Int}) &= \TInt[\mathsf{I64}, \mathsf{Signed}] \\
  T_{\mathsf{Sw}}(\mathtt{Double}) &= \TFloat[\mathsf{F64}] \\
  T_{\mathsf{Sw}}(\mathtt{String}) &= \TString \\
  T_{\mathsf{Sw}}([A]) &= \TArray[T_{\mathsf{Sw}}(A)] \quad\text{(CoW)} \\
  T_{\mathsf{Sw}}(A?) &= \TOption[T_{\mathsf{Sw}}(A)] \\
  T_{\mathsf{Sw}}(\mathtt{class}\, C) &= \arc\, T_{\mathsf{Sw}}^{\mathsf{fields}}(C) \\
  T_{\mathsf{Sw}}(\mathtt{struct}\, S) &= \own\, T_{\mathsf{Sw}}^{\mathsf{fields}}(S) \\
  T_{\mathsf{Sw}}(\mathtt{actor}\, A) &= \TActor[T_{\mathsf{Sw}}^{\mathsf{fields}}(A)]
\end{align*}
\end{definition}

\section{Value vs Reference Semantics}

\begin{definition}[Swift Semantics Translation]
Swift structs have value semantics with copy-on-write:
\begin{align*}
  T_{\mathsf{Sw}}(\mathtt{var}\, x = s) &= \mathtt{let}\, x = \mathsf{cow\_copy}(T_{\mathsf{Sw}}(s)) \\
  T_{\mathsf{Sw}}(x.\mathit{field} = v) &= \mathsf{cow\_write}(x, \mathit{field}, T_{\mathsf{Sw}}(v))
\end{align*}
\end{definition}

\begin{fstarcode}[title=Swift Translation]
module Swift

type swift_semantics = Value | Reference | Actor

let rec translate_type (t : swift_type) : brrr_type * swift_semantics =
  match t with
  | SwBool -> (TBool, Value)
  | SwInt -> (TInt I64 Signed, Value)
  | SwDouble -> (TFloat F64, Value)
  | SwString -> (TString, Value)  (* CoW optimized *)
  | SwArray a ->
      let (bt, _) = translate_type a in
      (TArray bt CoW, Value)
  | SwOptional a ->
      let (bt, sem) = translate_type a in
      (TOption bt, sem)
  | SwClass (name, fields) ->
      (TStruct (translate_fields fields) Arc, Reference)
  | SwStruct (name, fields) ->
      (TStruct (translate_fields fields) Own, Value)
  | SwActor (name, fields) ->
      (TActor (TStruct (translate_fields fields)), Actor)
  | SwProtocol methods ->
      (TDyn (translate_protocol methods), Reference)

let rec translate_expr (e : swift_expr) : brrr_expr =
  match e with
  | SwVar x -> EVar x
  | SwOptionalChain (base, prop) ->
      EMatch (translate_expr base) [
        (PNone, ENone);
        (PSome "v", ESome (EFieldGet (EVar "v") prop))
      ]
  | SwForceUnwrap e ->
      EMatch (translate_expr e) [
        (PNone, EPanic (EString "force unwrap of nil"));
        (PSome "v", EVar "v")
      ]
  | SwAsync body -> EAsync (translate_expr body)
  | SwAwait e -> EAwait (translate_expr e)
  | SwActorIsolated (actor, method, args) ->
      EActorCall (translate_expr actor) method (List.map translate_expr args)
\end{fstarcode}


\chapter{Java Translation}

\section{Type Mapping}

\begin{definition}[Java Type Translation]
\begin{align*}
  T_{\mathsf{Jv}}(\mathtt{boolean}) &= \TBool \\
  T_{\mathsf{Jv}}(\mathtt{int}) &= \TInt[\mathsf{I32}, \mathsf{Signed}] \\
  T_{\mathsf{Jv}}(\mathtt{long}) &= \TInt[\mathsf{I64}, \mathsf{Signed}] \\
  T_{\mathsf{Jv}}(\mathtt{double}) &= \TFloat[\mathsf{F64}] \\
  T_{\mathsf{Jv}}(\mathtt{String}) &= \TString \\
  T_{\mathsf{Jv}}(A[]) &= \gc\, \TArray[T_{\mathsf{Jv}}(A)] \\
  T_{\mathsf{Jv}}(\mathtt{List}\langle A \rangle) &= \gc\, \TList[T_{\mathsf{Jv}}(A)] \\
  T_{\mathsf{Jv}}(\mathtt{Map}\langle K, V \rangle) &= \gc\, \TDict[T_{\mathsf{Jv}}(K), T_{\mathsf{Jv}}(V)] \\
  T_{\mathsf{Jv}}(C) &= \gc\, T_{\mathsf{Jv}}^{\mathsf{class}}(C) \quad\text{(reference type)}
\end{align*}
\end{definition}

\section{Null Safety}

\begin{definition}[Nullable Translation]
\begin{align*}
  T_{\mathsf{Jv}}(T) &= \TOption[T_{\mathsf{Jv}}^{\mathsf{base}}(T)] \quad\text{(for reference $T$)} \\
  T_{\mathsf{Jv}}(@\mathtt{NonNull}\, T) &= T_{\mathsf{Jv}}^{\mathsf{base}}(T)
\end{align*}
\end{definition}

\begin{fstarcode}[title=Java Translation]
module Java

let rec translate_type (t : java_type) (nullability : nullable_annot) : brrr_type =
  match t with
  | JvPrimitive p -> translate_primitive p
  | JvArray elem ->
      let bt = translate_type elem Nullable in
      wrap_nullable (TArray bt GC) nullability
  | JvClass name ->
      wrap_nullable (TClass name GC) nullability
  | JvGeneric (name, args) ->
      let bargs = List.map (fun a -> translate_type a Nullable) args in
      wrap_nullable (TGeneric name bargs GC) nullability
  | JvWildcard (bound, variance) ->
      TExistential variance (translate_type bound Nullable)

and translate_primitive (p : java_primitive) : brrr_type =
  match p with
  | JvBoolean -> TBool
  | JvByte -> TInt I8 Signed
  | JvShort -> TInt I16 Signed
  | JvInt -> TInt I32 Signed
  | JvLong -> TInt I64 Signed
  | JvFloat -> TFloat F32
  | JvDouble -> TFloat F64
  | JvChar -> TChar

and wrap_nullable (t : brrr_type) (n : nullable_annot) : brrr_type =
  match n with
  | Nullable -> TOption t
  | NonNull -> t

let rec translate_expr (e : java_expr) : brrr_expr =
  match e with
  | JvVar x -> EVar x
  | JvNull -> ENone
  | JvNew (cls, args) ->
      EAlloc GC (EConstruct cls (List.map translate_expr args))
  | JvMethodCall (obj, method, args) ->
      (* Insert null check for nullable receiver *)
      let bobj = translate_expr obj in
      EMatch bobj [
        (PNone, EThrow (ENullPointerException));
        (PSome "recv", EMethodCall (EVar "recv") method (List.map translate_expr args))
      ]
  | JvFieldAccess (obj, field) ->
      let bobj = translate_expr obj in
      EMatch bobj [
        (PNone, EThrow (ENullPointerException));
        (PSome "recv", EFieldGet (EVar "recv") field)
      ]
  | JvInstanceOf (e, ty) ->
      ETypeTest (translate_expr e) (translate_type ty NonNull)
  | JvCast (e, ty) ->
      ECast (translate_expr e) (translate_type ty NonNull)
  | JvTryCatch (body, catches, finally_) ->
      ETryCatch (translate_expr body)
        (List.map (fun (exc_ty, var, handler) ->
          (translate_type exc_ty NonNull, var, translate_expr handler)
        ) catches)
        (Option.map translate_expr finally_)
  | JvSynchronized (lock, body) ->
      ESynchronized (translate_expr lock) (translate_expr body)
\end{fstarcode}


\chapter{Cross-Language Boundaries}

\section{Axiom Lattice}

Different languages provide different guarantees. We model this as a lattice:

\begin{definition}[Axiom Lattice]
\begin{center}
\begin{tikzcd}
  & \mathsf{AxAll} \arrow[dl] \arrow[d] \arrow[dr] & \\
  \mathsf{AxMemSafe} \arrow[dr] & \mathsf{AxTypeSafe} \arrow[d] & \mathsf{AxNullSafe} \arrow[dl] \\
  & \mathsf{AxPartial} \arrow[dl] \arrow[d] \arrow[dr] & \\
  \mathsf{AxLeakFree} & \mathsf{AxRaceFree} & \mathsf{AxDetDrop} \\
  & \mathsf{AxNone} \arrow[ul] \arrow[u] \arrow[ur] &
\end{tikzcd}
\end{center}
\end{definition}

\begin{definition}[Language Axioms]
\begin{align*}
  \mathsf{axioms}(\mathsf{Python}) &= \{\mathsf{AxMemSafe}, \mathsf{AxLeakFree}\} \\
  \mathsf{axioms}(\mathsf{TypeScript}) &= \{\mathsf{AxMemSafe}, \mathsf{AxTypeSafe}\} \\
  \mathsf{axioms}(\mathsf{Rust}) &= \{\mathsf{AxMemSafe}, \mathsf{AxTypeSafe}, \mathsf{AxRaceFree}, \mathsf{AxLeakFree}\} \\
  \mathsf{axioms}(\mathsf{Go}) &= \{\mathsf{AxMemSafe}, \mathsf{AxTypeSafe}, \mathsf{AxLeakFree}\} \\
  \mathsf{axioms}(\mathsf{Swift}) &= \{\mathsf{AxMemSafe}, \mathsf{AxTypeSafe}, \mathsf{AxNullSafe}\} \\
  \mathsf{axioms}(\mathsf{Java}) &= \{\mathsf{AxMemSafe}, \mathsf{AxTypeSafe}, \mathsf{AxLeakFree}\}
\end{align*}
\end{definition}

\section{Boundary Guards}

\begin{definition}[Guard Generation]
When crossing from $L_1$ to $L_2$:
\[
  \mathsf{guard}(L_1, L_2, v : \tau) =
  \begin{cases}
    \mathsf{type\_check}(v, \tau) & \text{if } \mathsf{AxTypeSafe} \in \mathsf{axioms}(L_2) \setminus \mathsf{axioms}(L_1) \\
    \mathsf{null\_check}(v) & \text{if } \mathsf{AxNullSafe} \in \mathsf{axioms}(L_2) \setminus \mathsf{axioms}(L_1) \\
    \mathsf{pin}(v) & \text{if } \mathsf{AxMemSafe} \in \mathsf{axioms}(L_1) \setminus \mathsf{axioms}(L_2) \\
    v & \text{otherwise}
  \end{cases}
\]
\end{definition}

\begin{theorem}[Boundary Soundness]
If $P$ is safe under $L_1$'s axioms and $\mathsf{boundary}(L_1, L_2)$ inserts
appropriate guards, then cross-language calls preserve safety.
\end{theorem}

\begin{fstarcode}[title=Boundary Guards]
module Boundary

type axiom =
  | AxMemSafe | AxTypeSafe | AxNullSafe
  | AxLeakFree | AxRaceFree | AxDetDrop

let language_axioms (l : language) : set axiom =
  match l with
  | Python -> set_of_list [AxMemSafe; AxLeakFree]
  | TypeScript -> set_of_list [AxMemSafe; AxTypeSafe]
  | Rust -> set_of_list [AxMemSafe; AxTypeSafe; AxRaceFree; AxLeakFree]
  | Go -> set_of_list [AxMemSafe; AxTypeSafe; AxLeakFree]
  | Swift -> set_of_list [AxMemSafe; AxTypeSafe; AxNullSafe]
  | Java -> set_of_list [AxMemSafe; AxTypeSafe; AxLeakFree]

let boundary_risks (from_lang : language) (to_lang : language) : set axiom =
  Set.diff (language_axioms from_lang) (language_axioms to_lang)

let generate_guard (from_lang : language) (to_lang : language)
                   (value : brrr_value) (ty : brrr_type) : brrr_expr =
  let risks = boundary_risks from_lang to_lang in
  let guarded = value in

  (* Insert type check if crossing into typed language *)
  let guarded =
    if Set.mem AxTypeSafe risks && not (Set.mem AxTypeSafe (language_axioms from_lang))
    then ETypeCheck guarded ty
    else guarded in

  (* Insert null check if crossing into null-safe language *)
  let guarded =
    if Set.mem AxNullSafe risks
    then EMatch guarded [
      (PNone, EThrow ENullPointerException);
      (PSome "v", EVar "v")
    ]
    else guarded in

  (* Pin GC objects if crossing into unsafe language *)
  let guarded =
    if not (Set.mem AxMemSafe (language_axioms to_lang)) &&
       Set.mem AxMemSafe (language_axioms from_lang)
    then EGCPin guarded
    else guarded in

  guarded

val boundary_call : language -> language -> brrr_expr -> list brrr_expr -> brrr_expr
let boundary_call from_lang to_lang callee args =
  (* Guard arguments (contravariant - from caller to callee) *)
  let guarded_args = List.map (fun (arg, ty) ->
    generate_guard from_lang to_lang arg ty
  ) args in

  (* Make the call *)
  let result = EApp callee guarded_args in

  (* Guard result (covariant - from callee to caller) *)
  generate_guard to_lang from_lang result (return_type callee)

lemma boundary_soundness (l1 l2 : language) (f : brrr_expr) (args : list brrr_expr) :
  Lemma (requires safe_in_language l1 f)
        (ensures safe_in_language l2 (boundary_call l1 l2 f args) \/
                 raises_boundary_exception (boundary_call l1 l2 f args))
\end{fstarcode}


%=============================================================================
% APPENDIX C: COMPLETE GRAMMAR
%=============================================================================
\appendix
\chapter{Complete Formal Grammar}

\section{Lexical Structure}

\begin{verbatim}
ident       ::= [a-zA-Z_][a-zA-Z0-9_]*
int_lit     ::= [0-9]+ | '0x' [0-9a-fA-F]+ | '0b' [01]+
float_lit   ::= [0-9]+ '.' [0-9]+ ([eE] [+-]? [0-9]+)?
string_lit  ::= '"' (escape | [^"\])* '"'
escape      ::= '\' [nrt\"\\] | '\x' [0-9a-fA-F]{2} | '\u{' [0-9a-fA-F]+ '}'
\end{verbatim}

\section{Type Grammar}

\begin{verbatim}
type        ::= base_type ('[' effect_row ']')?
base_type   ::= 'Bool' | 'Int' | 'Float' | 'String' | 'Unit'
              | 'Option' '[' type ']'
              | 'Result' '[' type ',' type ']'
              | 'Array' '[' type ']'
              | 'Dict' '[' type ',' type ']'
              | 'Future' '[' type ']'
              | 'Channel' '[' type ']'
              | '(' type (',' type)* ')' '->' type
              | '{' (ident ':' type ';')* '}'
              | ident ('[' type (',' type)* ']')?
              | refine_type

refine_type ::= '{' ident ':' type '|' formula '}'

effect_row  ::= effect ('|' effect)* ('|' row_var)?
effect      ::= 'Pure' | 'Throw' | 'IO' | 'Async' | 'Alloc' | 'Panic'
              | ident '[' type (',' type)* ']'
row_var     ::= ident
\end{verbatim}

\section{Expression Grammar}

\begin{verbatim}
expr        ::= literal
              | ident
              | expr '.' ident
              | expr '(' (expr (',' expr)*)? ')'
              | 'fn' '(' params ')' '->' type '{' expr '}'
              | 'if' expr 'then' expr 'else' expr
              | 'match' expr '{' (pattern '=>' expr ';')* '}'
              | 'let' ident (':' type)? '=' expr 'in' expr
              | expr binop expr
              | unop expr
              | 'throw' expr
              | 'try' expr 'catch' '{' handlers '}' ('finally' expr)?
              | 'async' expr
              | 'await' expr
              | 'spawn' expr
              | 'handle' expr 'with' '{' handlers '}'
              | 'perform' ident '(' expr ')'
              | '&' expr | '&mut' expr
              | 'move' '(' expr ')'
              | 'reset' '<' ident '>' expr
              | 'shift' '<' ident '>' expr

literal     ::= int_lit | float_lit | string_lit | 'true' | 'false' | '()'
pattern     ::= ident | literal | '_' | '(' pattern (',' pattern)* ')'
              | ident '(' pattern (',' pattern)* ')'
binop       ::= '+' | '-' | '*' | '/' | '%' | '==' | '!=' | '<' | '>'
              | '<=' | '>=' | '&&' | '||' | '|>' | '>>'
unop        ::= '-' | '!' | '*'
\end{verbatim}

\section{Declaration Grammar}

\begin{verbatim}
decl        ::= fn_decl | type_decl | effect_decl | module_decl

fn_decl     ::= 'fn' ident type_params? '(' params ')' '->' type
                ('[' effect_row ']')? '{' expr '}'

type_decl   ::= 'type' ident type_params? '=' type
              | 'struct' ident type_params? '{' fields '}'
              | 'enum' ident type_params? '{' variants '}'

effect_decl ::= 'effect' ident type_params? '{' operations '}'

module_decl ::= 'module' ident '{' decl* '}'
              | 'signature' ident '=' sig_body
              | 'functor' ident '(' ident ':' sig_body ')' '=' module_expr

type_params ::= '[' ident (':' kind)? (',' ident (':' kind)?)* ']'
params      ::= (ident ':' type ('at' mode)?) (',' ...)*
fields      ::= (ident ':' type ';')*
variants    ::= ident ('(' type (',' type)* ')')? ('|' ...)*
operations  ::= (ident ':' type ';')*
\end{verbatim}


\chapter{Node Kind Enumeration}

\begin{verbatim}
enum NodeKind {
    // Literals
    NLitBool, NLitInt, NLitFloat, NLitString, NLitUnit,

    // Expressions
    NVar, NApp, NLambda, NLet, NIf, NMatch, NBlock,
    NBinOp, NUnOp, NFieldGet, NFieldSet, NIndex,
    NThrow, NTryCatch, NAsync, NAwait, NSpawn,
    NHandle, NPerform, NResume,
    NBorrow, NBorrowMut, NMove, NDeref,
    NReset, NShift,

    // Patterns
    PWild, PVar, PLit, PTuple, PConstruct, POr, PGuard,

    // Types
    TBool, TInt, TFloat, TString, TUnit,
    TOption, TResult, TArray, TDict, TFuture, TChannel,
    TFunc, TStruct, TEnum, TRef, TBox,
    TForall, TExists, TRefinement,

    // Effects
    EPure, EThrow, EIO, EAsync, EAlloc, EPanic,
    ERowEmpty, ERowExtend, ERowVar,

    // Declarations
    DFn, DType, DStruct, DEnum, DEffect, DModule,
    DSignature, DFunctor,

    // Modules
    MStruct, MFunctorApp, MSeal, MPath,
}
\end{verbatim}


\chapter{Effect Kind Enumeration}

\begin{verbatim}
enum EffectKind {
    // Core effects
    Pure,           // No effects
    Diverge,        // Non-termination

    // Exception effects
    Throw(Type),    // May throw exception of type
    Panic,          // May panic (unrecoverable)

    // I/O effects
    Read,           // File/network read
    Write,          // File/network write
    IO,             // General I/O (Read | Write)

    // Concurrency effects
    Async,          // Asynchronous computation
    Spawn,          // Thread/task spawning
    Sync,           // Synchronization primitives

    // Memory effects
    Alloc,          // Heap allocation
    Free,           // Deallocation

    // State effects
    State(Type),    // Stateful computation
    STRef,          // Mutable reference

    // Control effects
    Shift(Label),   // Delimited continuation capture
    Abort(Type),    // Early exit with value

    // Resource effects
    Resource(Name), // Named resource usage

    // Security effects
    DynamicCode,    // eval/exec
    FFI,            // Foreign function call
}
\end{verbatim}


\chapter{Memory Budget Calculations}

\begin{definition}[Node Size Formula]
For a node with $c$ children and $s$ bytes of content:
\[
  \mathsf{size}(n) = 16 + 8c + s + \mathsf{padding}(s)
\]
where 16 bytes is the header (kind + hash prefix).
\end{definition}

\begin{definition}[Total Memory Budget]
\[
  M_{\mathsf{total}} = M_{\mathsf{nodes}} + M_{\mathsf{edges}} + M_{\mathsf{strings}} + M_{\mathsf{cache}}
\]
with typical ratios:
\begin{align*}
  M_{\mathsf{nodes}} &\approx 0.4 \cdot M_{\mathsf{total}} \\
  M_{\mathsf{edges}} &\approx 0.2 \cdot M_{\mathsf{total}} \\
  M_{\mathsf{strings}} &\approx 0.2 \cdot M_{\mathsf{total}} \\
  M_{\mathsf{cache}} &\approx 0.2 \cdot M_{\mathsf{total}}
\end{align*}
\end{definition}

\begin{definition}[Tokens per Node]
For LLM context efficiency:
\[
  \mathsf{tokens}(n) \approx \frac{\mathsf{size}(n)}{4} \cdot \mathsf{compression}
\]
where $\mathsf{compression} \approx 0.3$ for typical Brrr output.
\end{definition}


\chapter{Benchmark Reference}

\begin{center}
\begin{tabular}{lrrrrr}
\toprule
\textbf{Metric} & \textbf{Small} & \textbf{Medium} & \textbf{Large} & \textbf{XLarge} & \textbf{Unit} \\
\midrule
Lines of Code & 10K & 100K & 1M & 10M & lines \\
Nodes & 50K & 500K & 5M & 50M & nodes \\
Edges & 100K & 1M & 10M & 100M & edges \\
Parse Time & 50 & 500 & 5K & 50K & ms \\
Type Check & 100 & 1K & 10K & 100K & ms \\
Callgraph & 20 & 200 & 2K & 20K & ms \\
Taint Analysis & 50 & 500 & 5K & 50K & ms \\
Memory (Peak) & 100 & 1G & 10G & 100G & MB \\
\bottomrule
\end{tabular}
\end{center}

\begin{definition}[Complexity Classes]
\begin{align*}
  \text{Parsing:} &\quad O(n) \\
  \text{Type Checking:} &\quad O(n \log n) \text{ typical}, O(n^2) \text{ worst} \\
  \text{Callgraph:} &\quad O(n + e) \text{ flow-insensitive} \\
  \text{Points-to:} &\quad O(n^3) \text{ Andersen}, O(n) \text{ Steensgaard} \\
  \text{Taint:} &\quad O(n \cdot k) \text{ where } k = |\text{taint kinds}|
\end{align*}
\end{definition}


\end{document}
