% Part VII: Ownership and Resources - LaTeX Fragment
% This is a fragment file - no preamble, no \begin{document}

\part{Ownership and Resources}
\label{part:ownership}

\begin{pillarbox}[title={Historical Foundations: Ownership and Typestate Origins}]
\textbf{Strom \& Yemini 1986 --- Original Typestate:}
The foundational paper introducing typestate as ``a refinement of type.''
While \emph{type} determines operations ever permitted on an object, \emph{typestate}
determines the subset permitted in a particular context.

Key insights that persist to modern systems:
\begin{itemize}
    \item State machine semantics: Objects have typestates forming lower semilattice
    \item Transitions via operations: Each op has pre and post typestate conditions
    \item Compile-time tracking: Typestate as static invariant at each point
    \item Greatest lower bound at merge: Conservative approximation at branches
    \item Finalization guarantee: All objects returned to bottom state at exit
\end{itemize}

\textbf{Citation chain:} Strom 1986 $\rightarrow$ DeLine/Fahndrich Vault 2004 $\rightarrow$ Bierhoff 2007 $\rightarrow$ Prusti pledges (Astrauskas 2022) $\rightarrow$ Modern Rust unsafe

\medskip
\textbf{Boyapati, Lee, Rinard 2003 --- Ownership Types for Safe Programming:}
Introduced \emph{owner-as-dominator} discipline: ``All paths in the heap from root to object $x$ must pass through $x$'s owner.''

Key contributions:
\begin{itemize}
    \item Ownership types for data race and deadlock prevention
    \item Parameterized classes by owners (precursor to Rust generics + lifetime)
    \item Lock level partial ordering for deadlock freedom
    \item Tree-based lock ordering for nested data structures
    \item Unique pointers combined with ownership (first system to do so)
\end{itemize}

\textbf{Citation chain:} Boyapati 2003 $\rightarrow$ Cyclone (Grossman 2006) $\rightarrow$ Rust ownership $\rightarrow$ RustBelt (Jung 2018) $\rightarrow$ RefinedRust (Gaher 2024)

\medskip
\textbf{Modern Synthesis:}
Rust's ownership = Boyapati's owner discipline + Girard's linearity.
Prusti pledges = Strom's typestate + separation logic permissions.
Iris cameras = Semantic model for Boyapati's ownership hierarchy.
\end{pillarbox}

\begin{pillarbox}[title={Two Ownership Models: Cameras vs Access Permissions}]
\textbf{Cameras (Section~\ref{sec:resource-algebras}) --- From Iris/RustBelt:}
\begin{itemize}
    \item Use for: Rust-like ownership, move semantics, borrow checking
    \item Strengths: Expressive, handles complex aliasing patterns
    \item Complexity: Step-indexed, requires frame preservation proofs
    \item Best for: Systems languages (Rust, C++ with ownership annotations)
\end{itemize}

\textbf{Access Permissions (Section~\ref{sec:access-permissions}) --- From Bierhoff:}
\begin{itemize}
    \item Use for: Java-like typestate, resource protocols, API contracts
    \item Strengths: Decidable, practical for static analysis tools
    \item Complexity: 5 fixed permission kinds, simpler composition rules
    \item Best for: Managed languages (Java, C\#, Go), protocol verification
\end{itemize}

\textbf{Guidance:} Start with Access Permissions for decidability.
Upgrade to Cameras only when permission splitting is insufficient.
\end{pillarbox}

\begin{pillarbox}[title={Ownership as Coeffects (Petricek 2014 Connection)}]
Ownership and linear types connect to usage coeffects (Section~\ref{sec:coeffects}):

\begin{center}
\begin{tabular}{lll}
\toprule
\textbf{Ownership Style} & \textbf{Usage Coeffect} & \textbf{Constraint} \\
\midrule
Rust move semantics & $\mathsf{UBounded}~1$ (affine) & usage $\leq 1$ \\
Rust borrow (\texttt{\&T}) & $\mathsf{UMany}$ (unrestricted) & unlimited reads \\
Rust mut borrow (\texttt{\&mut}) & $\mathsf{UOne}$ (linear) & usage $= 1$ exactly \\
Linear \textbf{[Girard87]} & $\mathsf{UOne}$ & must use exactly once \\
Relevant & $\mathsf{UAtLeast}~1$ & must use at least once \\
\bottomrule
\end{tabular}
\end{center}

\textbf{Composition via Semiring:}
\begin{itemize}
    \item $x$ moved $+$ $x$ moved $=$ error ($\mathsf{UBounded}~1 + \mathsf{UBounded}~1 = \mathsf{UBounded}~2 > 1$)
    \item $x$ borrowed $+$ $x$ borrowed $=$ ok ($\mathsf{UMany} + \mathsf{UMany} = \mathsf{UMany}$)
\end{itemize}

Coeffects provide compositional reasoning; Cameras provide semantic model.
\end{pillarbox}

\begin{pillarbox}[title={Substructural Type Systems: Linear, Affine, and Relevant Types}]
\textbf{Source:} Girard 1987 (Linear Logic), Walker 2005 (Substructural Type Systems)

Substructural type systems restrict the \emph{structural rules} of the lambda calculus:
\begin{itemize}
    \item \textbf{Contraction:} Can a variable be used more than once?
    \item \textbf{Weakening:} Can a variable be ignored (not used)?
\end{itemize}

\textbf{The Substructural Hierarchy:}
\begin{center}
\begin{tabular}{lccp{6cm}}
\toprule
\textbf{Type System} & \textbf{Contraction} & \textbf{Weakening} & \textbf{Property} \\
\midrule
Unrestricted & Yes & Yes & Normal types (can copy/discard) \\
Affine & No & Yes & Use \emph{at most once} (Rust ownership) \\
Linear & No & No & Use \emph{exactly once} (Girard) \\
Relevant & Yes & No & Use \emph{at least once} \\
\bottomrule
\end{tabular}
\end{center}

\textbf{Why This Matters for Resource Management:}
\begin{itemize}
    \item \textbf{Linear types} guarantee resources are neither leaked nor double-used. A file handle with linear type \emph{must} be closed exactly once.
    \item \textbf{Affine types} allow discarding but prevent double-use. Rust's ownership is affine: values can be dropped implicitly but cannot be used after move.
    \item \textbf{Relevant types} ensure resources are used at least once, preventing ``acquire but never use'' patterns.
\end{itemize}

\textbf{Rust's Borrow Checker as Affine + Borrowing:}
\begin{enumerate}
    \item Owned values are \textbf{affine}: use at most once (move semantics)
    \item Shared borrows (\texttt{\&T}) are \textbf{unrestricted}: can copy freely
    \item Mutable borrows (\texttt{\&mut T}) are \textbf{linear during lifetime}: exactly one active mutable borrow
    \item The borrow checker enforces these constraints statically via lifetime analysis
\end{enumerate}

\textbf{Connection to Separation Logic:}
Linear types and separation logic share the ``resources cannot be duplicated'' principle:
\begin{itemize}
    \item Linear $A \tensor B$ (tensor) $\sim$ Separation $A * B$ (separating conjunction)
    \item Linear $A \lolli B$ (lollipop) $\sim$ ``consume $A$ to produce $B$''
    \item Both enforce disjointness of resource usage
\end{itemize}

\textbf{Critical Invariant: Linear Exclusivity}

When a context $\Gamma$ is split for parallel composition (e.g., function application
$\Gamma_1 + \Gamma_2 \vdash e_1\;e_2$), the split must ensure \emph{linear exclusivity}:
\begin{definition}[Linear Exclusivity]
For contexts $\Gamma_1, \Gamma_2$ resulting from splitting $\Gamma$:
\[
  \forall x.\; \mathsf{linear}(x) \implies
  (\Gamma_1(x) = 1 \implies \Gamma_2(x) = 0) \land
  (\Gamma_2(x) = 1 \implies \Gamma_1(x) = 0)
\]
\end{definition}

This invariant ensures that when contexts are joined (added) after branches,
the mode addition $1 + 1 = \omega$ cannot occur for linear resources:
\begin{itemize}
    \item $0 + 0 = 0$ (neither branch used it)
    \item $0 + 1 = 1$ (only right branch has it)
    \item $1 + 0 = 1$ (only left branch has it)
    \item $1 + 1 = \omega$ \textbf{(impossible due to linear exclusivity)}
\end{itemize}

Without this invariant, joining contexts after branches could produce $\omega$ (unrestricted)
for a linear resource, violating the linear type discipline.
\end{pillarbox}

\begin{pillarbox}[title={Tension Resolution: Separation Logic vs GC Languages}]
\textbf{Reynolds' Warning \textbf{[Reynolds02]}:} ``GC interaction is problematic'' for separation logic.
\begin{itemize}
    \item Separation logic assumes explicit deallocation
    \item GC may collect memory mid-analysis (unpredictable timing)
    \item Cannot model ``disconnected garbage'' in standard separation logic
\end{itemize}

\textbf{Resolution by Language Class:}

\emph{GC Languages (Python, Go, Java, JavaScript):}
\begin{itemize}
    \item Use separation logic for \emph{resources only} (files, connections, locks)
    \item Not for memory---grant MemSafe axiom from runtime
    \item Track ownership for API resources, not heap cells
    \item Frame Rule still applies to resource footprints
\end{itemize}

\emph{Manual Memory (C, C++, unsafe Rust):}
\begin{itemize}
    \item Full separation logic applies
    \item Frame rule essential for scalability
    \item Shape Analysis uses separating conjunction
\end{itemize}
\end{pillarbox}


%==================================================
\chapter{Resource Algebras from Iris}
\label{sec:resource-algebras}
%==================================================

\textbf{Papers:} \textbf{[Girard87]}, \textbf{[Reynolds02]}, \textbf{[Boyapati03]}, \textbf{[Jung18]}

\begin{pillarbox}[title={Historical Note: From Boyapati 2003 to Iris}]
Boyapati, Lee, Rinard (OOPSLA 2002) introduced ownership types for safe concurrent programming in Java. Their key insight: ownership encapsulation enables modular reasoning about locking.

\textbf{Owner-as-Dominator:} All heap paths to object $x$ pass through $x$'s owner.
\begin{itemize}
    \item Owner's lock protects all transitively owned objects
    \item Parameterized classes: different instances can have different owners
    \item \texttt{thisThread} owner: thread-local objects need no synchronization
    \item \texttt{self} owner: objects protected by their own lock
\end{itemize}

\textbf{Evolution to modern systems:}
\begin{center}
\begin{tabular}{lcl}
Boyapati 2003: & \texttt{Owner<T>} & $\rightarrow$ explicit owner parameter \\
Cyclone 2006: & \texttt{region<T>} & $\rightarrow$ region-based memory management \\
Rust 2015: & \texttt{T}, \texttt{\&'a T}, \texttt{\&'a mut T} & $\rightarrow$ lifetime-annotated borrows \\
RustBelt 2018: & $\mathsf{own}(t,v)$, $\mathsf{shr}(\kappa,t,l)$ & $\rightarrow$ semantic model via Iris cameras \\
\end{tabular}
\end{center}

Iris cameras provide the semantic foundation for ownership:
\begin{itemize}
    \item Exclusive camera $\mathsf{Ex}(T)$ $\sim$ Boyapati's \texttt{thisThread}/\texttt{self} owner
    \item Fractional camera $\mathsf{Frac}$ $\sim$ Boyapati's shared read access
    \item Agreement camera $\mathsf{Ag}(T)$ $\sim$ Boyapati's readonly owner
    \item Authoritative camera $\mathsf{Auth}$ $\sim$ Boyapati's ownership transfer
\end{itemize}
\end{pillarbox}

The brrr-machine uses resource algebras (cameras) from Iris to track ownership.
This provides a unified framework for reasoning about:
\begin{itemize}
    \item Memory ownership (Rust-style)
    \item Reference counting
    \item Shared state with synchronization
    \item File handles and connections
\end{itemize}

\section{The Camera Abstraction}
\label{sec:camera-abstraction}

\begin{definition}[Camera (from Iris)]
A \emph{camera} is a step-indexed partial commutative monoid (PCM):
\[
\text{Camera } M = (M, V : M \to \mathrm{Prop}, |\cdot| : M \to M?, (\cdot) : M \times M \to M)
\]
where:
\begin{itemize}
    \item $M$ is the carrier set (possible ownership states)
    \item $V$ is the validity predicate (which states are coherent)
    \item $|\cdot|$ is the core (shareable part)
    \item $(\cdot)$ is composition (combining ownerships)
\end{itemize}

\textbf{Axioms:}
\begin{align*}
\textsc{Assoc:} & \quad (a \cdot b) \cdot c = a \cdot (b \cdot c) \\
\textsc{Comm:} & \quad a \cdot b = b \cdot a \\
\textsc{Core-Id:} & \quad |a| \text{ defined} \implies |a| \cdot a = a \\
\textsc{Valid-Op:} & \quad V(a \cdot b) \implies V(a)
\end{align*}
\end{definition}

\textbf{Cameras capture different ownership disciplines:}

\begin{description}
    \item[Exclusive Camera $\mathsf{Ex}(T)$:] Elements are $T$ or ``invalid''. Composition always invalid (cannot share exclusive). Use: unique ownership, like \texttt{Box<T>} in Rust.

    \item[Agreement Camera $\mathsf{Ag}(T)$:] Elements are sets of $T$ values. Composition is union (must agree on values). Valid if all elements in set are equal. Use: read-only shared state.

    \item[Fractional Camera $\mathsf{Frac}$:] Elements are rationals in $(0, 1]$. Composition is addition (must sum to $\leq 1$). Use: fractional permissions, shared borrows.

    \item[Authoritative Camera $\mathsf{Auth}(M)$:] Elements are (full?, fragment) pairs. Full owns the ``truth'', fragments are views. Use: ghost state, invariants.
\end{description}

\textbf{Connection to Girard 1987 Exponentials:}
Cameras implement Girard's exponential modality ($\bang A$, $\whynot A$) via resource structure:
\begin{itemize}
    \item Exclusive $\mathsf{Ex}(T)$ $\sim$ bare $A$ (linear: exactly-once use, can free)
    \item Fractional $\mathsf{Frac}$ $\sim$ $\bang A$ (of-course: shareable, copyable borrows)
    \item Agreement $\mathsf{Ag}(T)$ $\sim$ $\bang A$ readonly (unlimited read-only copies)
\end{itemize}

The exponential $\bang A$ in linear logic makes $A$ freely copyable and discardable.
Cameras achieve this via the ``core'' operation: $|a|$ extracts the shareable part.
\begin{itemize}
    \item $|\mathsf{Ex}(v)| = \bot$ (exclusive has no shareable part)
    \item $|\mathsf{Frac}(q)| = \mathsf{Frac}(q)$ (fractions are their own core---duplicable)
    \item $|\mathsf{Ag}(s)| = \mathsf{Ag}(s)$ (agreement is duplicable)
\end{itemize}

\subsection{Ghost State and Invariants}

Ghost state enables strong specifications for concurrent programs without runtime cost:

\textbf{Ghost State Rules:}
\begin{align*}
\textsc{Allocation:} & \quad \vdash \pvs \exists \gamma.\, \mathsf{own}(\gamma, a) \\
\textsc{Interaction:} & \quad \mathsf{own}(\gamma, a) * \mathsf{own}(\gamma, b) \vdash \mathsf{valid}(a \cdot b) \\
\textsc{Update:} & \quad \mathsf{own}(\gamma, a) \vdash \pvs \mathsf{own}(\gamma, b) \quad \text{[frame-preserving]}
\end{align*}

\textbf{Invariant Protocol:}
$\mathsf{inv}~N~P$ is duplicable---multiple threads can hold reference.
But can only be opened during atomic operations.
Must close before atomic operation completes.
This enables safe sharing of logical resources.

\subsection{View Shifts and Step-Indexing}

\begin{definition}[View Shift]
The update modality $\pvs P$ asserts ownership of resources that can be updated to satisfy $P$. Key primitive for ghost state manipulation.

\textbf{Rules:}
\begin{align*}
& \pvs \pvs P \Leftrightarrow \pvs P \quad \text{(idempotent)} \\
& P \vdash \pvs P \quad \text{(identity)} \\
& (\pvs P) * Q \vdash \pvs (P * Q) \quad \text{(frame preserving)} \\
& \mathsf{own}(\gamma, a) \vdash \pvs \mathsf{own}(\gamma, b) \quad \text{(when $a \rightsquigarrow b$ frame-preserving)}
\end{align*}
\end{definition}

\textbf{Step-Indexing (why cameras are step-indexed):}
\begin{itemize}
    \item \textbf{Problem:} Higher-order ghost state creates circularity. Propositions can contain ghost state, ghost state validates propositions.
    \item \textbf{Solution:} Stratify by ``steps remaining'' (approximation index $n$).
    \begin{itemize}
        \item At step 0: all propositions equivalent (base case)
        \item At step $n+1$: can distinguish based on $n$-step behavior
        \item Cameras are step-indexed: $\mathsf{valid}_n(a)$ means valid for $n$ more steps
    \end{itemize}
    \item \textbf{Enables:} Impredicative invariants, recursive protocols, later modality ($\later$) for guarded recursion
\end{itemize}


\section{Separation Logic for Memory}
\label{sec:separation-logic}

\textbf{Paper:} \textbf{[Reynolds02]}

\begin{definition}[Separating Conjunction]
$P * Q$ means: $P$ and $Q$ hold on \emph{disjoint} portions of memory.
\end{definition}

\begin{theorem}[Frame Rule]
\[
\frac{\{P\}\; C\; \{Q\}}{\{P * R\}\; C\; \{Q * R\}}
\]
If $C$ only needs $P$, then $R$ is preserved. This enables local reasoning.
\end{theorem}

\begin{definition}[Points-To Assertion]
$x \mapsto v$ means: $x$ points to location containing $v$, and we have \emph{exclusive} access.
\end{definition}

\textbf{Example (swap):}
\begin{align*}
& \{x \mapsto a * y \mapsto b\} \\
& t := *x; \\
& *x := *y; \\
& *y := t \\
& \{x \mapsto b * y \mapsto a\}
\end{align*}
The frame rule lets us add any $R$ that does not mention $x$, $y$.

\textbf{Why this matters for brrr-machine:}
We can express memory safety as separation logic formulas:
\begin{itemize}
    \item No use-after-free: freed locations removed from valid heap
    \item No races: concurrent accesses require disjoint permissions
    \item Ownership transfer: moving $x \mapsto v$ from one context to another
\end{itemize}

\textbf{GC Language Caveat:}
For GC languages (Python, Java, Go, JS), use separation logic for \emph{resources} (files, connections) only---not for memory. Memory safety is granted axiomatically by the runtime.


\section{F* Specification: Ownership System}
\label{sec:fstar-ownership}

The following F* specifications formalize the ownership concepts from Iris cameras
in a form suitable for static analysis implementation. These type definitions
provide the foundation for tracking resource ownership, permissions, and state
transitions throughout the analysis.

\textbf{Note:} F* code using numeric multiplication requires \texttt{open FStar.Mul}
at the module level. All code blocks assume a module preamble with appropriate imports.

\subsection{Resource Algebra Typeclass}

The \texttt{resource\_algebra} typeclass captures the essential structure of Iris cameras:
a partial commutative monoid with a validity predicate and a core operation for extracting
shareable components. The four axioms ensure compositional reasoning about resource ownership.

\begin{fstarcode}[title={Resource Algebra (Simplified Camera)}]
(* Option bind for composing optional values *)
let option_bind #a #b (x : option a) (f : a -> option b) : option b =
  match x with
  | Some v -> f v
  | None -> None

(* Resource algebra operations as a record type *)
noeq type resource_algebra_ops (a : Type) = {
  (* Composition -- partial, may fail *)
  compose : a -> a -> option a;
  (* Validity predicate *)
  valid : a -> bool;
  (* Core -- the shareable/duplicable part *)
  core : a -> option a;
}

(* Axiom predicates -- instances must satisfy these *)
let ra_compose_comm #a (ops : resource_algebra_ops a) =
  forall (x y : a). ops.compose x y == ops.compose y x

let ra_compose_assoc #a (ops : resource_algebra_ops a) =
  forall (x y z : a).
    option_bind (ops.compose x y) (fun xy -> ops.compose xy z) ==
    option_bind (ops.compose y z) (fun yz -> ops.compose x yz)

let ra_valid_compose #a (ops : resource_algebra_ops a) =
  forall (x y r : a). ops.compose x y == Some r ==> ops.valid r ==> ops.valid x

let ra_core_id #a (ops : resource_algebra_ops a) =
  forall (x : a) (c : a). ops.core x == Some c ==> ops.compose c x == Some x

(* A valid resource algebra satisfies all axioms *)
type resource_algebra (a : Type) =
  ops:(resource_algebra_ops a){
    ra_compose_comm ops /\ ra_compose_assoc ops /\
    ra_valid_compose ops /\ ra_core_id ops
  }
\end{fstarcode}

The \texttt{exclusive} type models unique ownership---the ``Box'' pattern from Rust.
When you own something exclusively, composition with any other claim invalidates both.
This captures Rust's fundamental rule: a \texttt{Box<T>} cannot be aliased.
The \texttt{core} returns \texttt{None} because exclusive resources have no shareable fragment.

\begin{fstarcode}[title={Exclusive Ownership --- Like Rust's \texttt{Box<T>}}]
type exclusive (a : Type) =
  | ExOwned : value:a -> exclusive a
  | ExInvalid : exclusive a

(* Operations for exclusive resources *)
let exclusive_ops (#a : Type) : resource_algebra_ops (exclusive a) = {
  compose = (fun x y ->
    (* Exclusive resources cannot be composed *)
    Some ExInvalid);
  valid = (fun x ->
    match x with
    | ExOwned _ -> true
    | ExInvalid -> false);
  core = (fun x -> None);  (* No shareable part *)
}

(* NOTE: To form a valid resource_algebra, one must prove the axioms hold *)
\end{fstarcode}

Fractional permissions enable shared borrows---Rust's \texttt{\&T} references.
Instead of binary ownership, we track fractions: a full ownership is $1$,
and multiple shared references each hold a fraction summing to at most $1$.
Key properties:
\begin{itemize}
    \item Fractions can be \emph{composed} (combined) as long as the sum stays $\leq 1$
    \item Unlike exclusive, fractions have a \texttt{core}---they are duplicable (within limits)
    \item When all fractions reassemble to $1$, we can recover full ownership
\end{itemize}
This directly models Rust's rule: multiple \texttt{\&T} or one \texttt{\&mut T}, never both.

\begin{fstarcode}[title={Fractional Permissions --- For Shared Borrows}]
type fraction = { num : nat; denom : pos }  (* num/denom in (0,1] *)

let frac_add (f1 f2 : fraction) : option fraction =
  let num = f1.num * f2.denom + f2.num * f1.denom in
  let denom = f1.denom * f2.denom in
  if num <= denom then Some { num; denom }
  else None  (* Sum > 1, invalid *)

type fractional (a : Type) =
  | FracOwn : frac:fraction -> value:a -> fractional a
  | FracInvalid : fractional a

(* Operations for fractional resources *)
let fractional_ops (#a : Type) : resource_algebra_ops (fractional a) = {
  compose = (fun x y ->
    match x, y with
    | FracOwn f1 v1, FracOwn f2 v2 ->
        if v1 = v2 then
          match frac_add f1 f2 with
          | Some f -> Some (FracOwn f v1)
          | None -> Some FracInvalid
        else Some FracInvalid  (* Disagreement on value *)
    | _, _ -> Some FracInvalid);
  valid = (fun x ->
    match x with
    | FracOwn f v -> f.num > 0 && f.num <= f.denom
    | FracInvalid -> false);
  core = (fun x ->
    match x with
    | FracOwn f v -> Some (FracOwn f v)  (* Fractions are duplicable *)
    | _ -> None);
}

(* NOTE: To form a valid resource_algebra, one must prove the axioms hold *)
\end{fstarcode}

The \texttt{ownership\_state} type below models the lifecycle of a memory location through
the lens of Rust-style ownership semantics. Each location transitions through states from
allocation to deallocation, with borrowing as intermediate states. The \texttt{valid\_transition}
function encodes which state changes are legal, directly corresponding to Rust's borrow checker rules.

Key type signatures:
\begin{itemize}
    \item \texttt{OsOwned owner}: Location owned by scope \texttt{owner}, can be moved or freed
    \item \texttt{OsBorrowedShared borrowers}: Shared borrows active, read-only access by multiple scopes
    \item \texttt{OsBorrowedMut borrower}: Exclusive mutable borrow, single scope has write access
    \item \texttt{OsMoved}: Value moved out, location is ``poisoned'' (use-after-move error if accessed)
\end{itemize}

\begin{fstarcode}[title={Ownership State Machine --- Per-Location Tracking}]
type ownership_state =
  | OsUnallocated : ownership_state
  | OsOwned : owner:scope_id -> ownership_state
  | OsBorrowedShared : borrowers:set scope_id -> ownership_state
  | OsBorrowedMut : borrower:scope_id -> ownership_state
  | OsMoved : ownership_state
  | OsFreed : ownership_state

(* Valid transitions *)
let valid_transition (from to_ : ownership_state) : bool =
  match from, to_ with
  | OsUnallocated, OsOwned _ -> true      (* Allocation *)
  | OsOwned _, OsOwned _ -> true          (* Transfer *)
  | OsOwned o, OsBorrowedShared bs ->
      Set.for_all (fun b -> b <> o) bs    (* Borrow *)
  | OsOwned o, OsBorrowedMut b ->
      b <> o                               (* Mut borrow *)
  | OsBorrowedShared bs, OsOwned _ ->
      Set.is_empty bs                      (* Borrows ended *)
  | OsBorrowedMut _, OsOwned _ -> true    (* Mut borrow ended *)
  | OsOwned _, OsMoved -> true            (* Move *)
  | OsOwned _, OsFreed -> true            (* Deallocation *)
  | _, _ -> false
\end{fstarcode}


\section{Capability Multiplicities}
\label{sec:capability-multiplicities}

\textbf{Paper:} Crary, Walker, Morrisett 1999 (Typed Memory Management)

\begin{pillarbox}[title={Critical Distinction: Lifecycle vs Aliasing}]
The \texttt{ownership\_state} type above tracks \textbf{lifecycle}:
\[
\text{Unallocated} \rightarrow \text{Owned} \rightarrow \text{Borrowed} \rightarrow \text{Moved} \rightarrow \text{Freed}
\]

But this misses \textbf{aliasing information}:
``Is this pointer unique, or might other pointers exist?''

\textbf{Crary's insight:} Only \emph{unique} capabilities can safely free memory.
An ``owned'' but aliased pointer \emph{cannot} safely free---dangling refs remain.
\end{pillarbox}

\begin{definition}[Multiplicity (from Crary 1999)]
\begin{align*}
\mathsf{MUnique}~(\{r^1\}) & \quad \text{Provably no aliases exist. Can free.} \\
\mathsf{MDup}~(\{r^+\}) & \quad \text{May have aliases. Can only access, not free.}
\end{align*}

This is \textbf{stronger} than ``owned'':
\begin{itemize}
    \item Owned + Aliased $\Rightarrow$ Cannot free safely
    \item Unique $\Rightarrow$ Can free (no dangling pointers possible)
\end{itemize}
\end{definition}

\textbf{Capability Algebra:}
\begin{align*}
\text{Join rules:} \quad & \{r^1\} + \{r^1\} = \text{Invalid} \quad \text{(can't have two uniques!)} \\
& \{r^1\} + \{r^+\} = \{r^+\} \quad \text{(unique + dup = dup)} \\
& \{r^+\} + \{r^+\} = \{r^+\} \quad \text{(dup + dup = dup)} \\[1ex]
\text{Strip (lending):} \quad & \mathsf{strip}(\{r^1\}) = \{r^+\} \quad \text{(lend as duplicatable)} \\
& \mathsf{strip}(\{r^+\}) = \{r^+\} \quad \text{(already dup)}
\end{align*}

\textbf{Bounded Quantification for Capability Recovery:}
\begin{itemize}
    \item \textbf{Problem:} How to get uniqueness back after lending?
    \item \textbf{Solution:} $\forall[\varepsilon \leq \{r^+\}].\ (\varepsilon, \ldots, (\varepsilon, \ldots) \to 0) \to 0$
    \item Caller instantiates $\varepsilon = \{r^1\}$ (passes unique)
    \item Callee sees only $\varepsilon \leq \{r^+\}$ (can't free, can only access)
    \item Continuation gets $\{r^1\}$ back!
    \item This models Rust's borrow-and-return pattern.
\end{itemize}

\begin{theorem}[Complete Collection (Crary 1999)]
Well-typed terminating programs return all memory to the system.
\[
\text{If } \vdash (M, e) \text{ well-typed, then either:}
\begin{cases}
(M, e) \text{ diverges}, & \text{or} \\
(M, e) \to^* (\emptyset, \mathsf{halt}~i) & \text{heap is empty at termination}
\end{cases}
\]

\textbf{Proof sketch:}
\begin{enumerate}
    \item Typing rule for \textsf{halt} requires capability $= \emptyset$ (empty)
    \item Empty capability means no regions owned
    \item Subject reduction preserves typing
    \item Progress ensures termination reaches \textsf{halt}
    \item Therefore: terminating programs have empty heap
\end{enumerate}

This is \textbf{leak-freedom by construction}.
\end{theorem}


%==================================================
\chapter{Access Permissions and Typestate}
\label{ch:access-permissions}
%==================================================

\section{Access Permissions (Bierhoff)}
\label{sec:access-permissions}

\textbf{Paper:} Bierhoff 2007 (Modular Typestate Checking)

\textbf{Historical Foundation:} Strom \& Yemini 1986 (Original Typestate)

\begin{pillarbox}[title={Historical Note: From Strom 1986 to Modern Typestate}]
\textbf{Strom \& Yemini 1986 --- Original Typestate Concept:}
``Typestate is a refinement of the concept of type. Whereas the type of a data object determines the set of operations ever permitted on the object, typestate determines the subset of these operations which is permitted in a particular context.''

\textbf{Core Principles (still valid today):}
\begin{enumerate}
    \item State machine semantics: Each type has associated typestate lattice
    \item Preconditions: Each operation requires specific typestate
    \item Postconditions: Operations produce new typestate (possibly per outcome)
    \item Static tracking: Typestate is compile-time invariant at each point
    \item Merge rule: At branches, take greatest lower bound of typestates
    \item Finalization: All objects must reach bottom typestate at exit
\end{enumerate}

\textbf{Key Evolution:}
\begin{center}
\begin{tabular}{ll}
Strom 1986: & Typestate as static invariant, no aliasing handling \\
Vault 2004: & Adoption (permanent) and Focus (temporary) for aliasing \\
Bierhoff 2007: & 5 permission kinds integrate aliasing with typestate \\
\end{tabular}
\end{center}

Modern typestate = Strom's state machines + Bierhoff's permission aliasing
\end{pillarbox}

\begin{pillarbox}[title={Access Permissions: Decidable Alternative to Iris Cameras}]
Iris cameras (Section~\ref{sec:resource-algebras}) are \textbf{general} but \textbf{undecidable}.
Bierhoff's 5 permission kinds are \textbf{specific} but \textbf{decidable}.

\textbf{Five Permission Kinds:}
\begin{center}
\begin{tabular}{lp{9cm}}
\toprule
\textbf{Permission} & \textbf{Description} \\
\midrule
$\mathsf{unique}(r,n,g)$ & Full ownership, can free, no aliases exist \\
$\mathsf{full}(r,n,g)$ & Full access, may have pure aliases \\
$\mathsf{share}(r,n,g,k)$ & Shared mutable, fraction $k$ \\
$\mathsf{immutable}(r,n,g)$ & Read-only, unlimited copies \\
$\mathsf{pure}(r,n,g)$ & Read-only, guarantees no modification \\
\bottomrule
\end{tabular}
\end{center}

\textbf{Key Insight:} Permissions bound to state guarantees via root nodes.
A permission can be confined to a state subtree, guaranteeing the object stays in that region of the typestate.
\end{pillarbox}

\begin{fstarcode}[title={The Five Permission Kinds}]
type access_permission =
  | APUnique    : root:root_node -> node:state_node -> guarantee:state_node
                  -> access_permission
      (* Full ownership, can free, guaranteed no aliases *)
  | APFull      : root:root_node -> node:state_node -> guarantee:state_node
                  -> access_permission
      (* Full access, may have pure aliases observing *)
  | APShare     : root:root_node -> node:state_node -> guarantee:state_node
                  -> frac:fraction -> access_permission
      (* Shared mutable access with fraction *)
  | APImmutable : root:root_node -> node:state_node -> guarantee:state_node
                  -> access_permission
      (* Read-only, can duplicate freely *)
  | APPure      : root:root_node -> node:state_node -> guarantee:state_node
                  -> access_permission
      (* Read-only, guarantees object won't be modified *)
\end{fstarcode}

Permission splitting and joining form the core algebra of access control. These operations
implement Rust's borrow semantics at the permission level:
\begin{itemize}
    \item \texttt{split\_unique}: Creates a mutable reference from an owned value (like \texttt{\&mut} from \texttt{Box})
    \item \texttt{split\_full}: Creates multiple shared references from full access
    \item \texttt{join\_shares}: Recombines all shared references back to full access
    \item \texttt{join\_full\_pure}: Restores unique ownership when all borrows end
\end{itemize}
These operations are \emph{linear}---permissions cannot be duplicated or discarded, only split and rejoined.

\begin{fstarcode}[title={Permission Splitting and Joining}]
(* Split unique into full + pure *)
val split_unique :
  APUnique r n g -> (APFull r n g * APPure r n g)

(* Split full into share + share *)
val split_full :
  APFull r n g -> (APShare r n g (half_frac) * APShare r n g (half_frac))

(* Join shares back to full *)
val join_shares :
  APShare r n g f1 -> APShare r n g f2 ->
  requires (add_fracs f1 f2 = full_frac) ->
  APFull r n g

(* Join full + pure back to unique *)
val join_full_pure :
  APFull r n g -> APPure r n g -> APUnique r n g
\end{fstarcode}


\subsection{Per-Node Fraction Functions (Bierhoff 2007 Extended)}

Fraction functions generalize simple fractions to complex objects with heterogeneous
access patterns. Consider a database connection object: you might have full access
to the metadata but only partial (shared) access to the result cursor. The fraction
function maps each state node to its permission fraction, enabling fine-grained
access control over object substructure. This extends Bierhoff's typestate checking
to handle partially-locked composite objects.

\begin{fstarcode}[title={Fraction Functions}]
(* Complex objects may have different access levels at different states.
   A "partially open" file has full access to metadata, partial to content. *)

type fraction_function = state_node -> fraction

val frac_fn_split : fraction_function -> (fraction_function * fraction_function)
let frac_fn_split ff =
  (fun n -> half_of (ff n), fun n -> half_of (ff n))

val frac_fn_join : fraction_function -> fraction_function -> option fraction_function
let frac_fn_join ff1 ff2 =
  (* Sum must not exceed 1 at any node *)
  let can_join = forall (fun n -> can_add (ff1 n) (ff2 n)) in
  if can_join then Some (fun n -> add_frac (ff1 n) (ff2 n))
  else None  (* Sum exceeds 1 at some node *)
\end{fstarcode}


\subsection{Temporary State in Weak Permissions}

When strong permission (unique/full) splits into weak (pure/immutable), the weak permission carries \textbf{temporary state}---the state observed at split. This is \textbf{forgotten} when permissions rejoin, ensuring:
\begin{itemize}
    \item Observers saw consistent state at observation time
    \item State may have changed by rejoin time (that's OK)
\end{itemize}

\begin{fstarcode}[title={Temporary State Capture and Forget}]
(* Split unique into full + pure WITH state capture *)
val split_unique_with_state :
  p:access_permission_v2{APUnique_v2? p} ->
  (access_permission_v2 * access_permission_v2)
let split_unique_with_state (APUnique_v2 r n g) =
  let current_state = n in  (* Capture state at split time *)
  (APFull_v2 r n g,
   APPure_v2 r n g (Some current_state))  (* Pure carries observed state *)

(* When rejoining, temporary state is FORGOTTEN *)
val join_full_pure_forget :
  full:access_permission_v2{APFull_v2? full} ->
  pure:access_permission_v2{APPure_v2? pure} ->
  option access_permission_v2
let join_full_pure_forget (APFull_v2 r n g) (APPure_v2 r' n' g' obs) =
  if r = r' && g = g' then
    (* Observed state (obs) is DISCARDED *)
    Some (APUnique_v2 r n g)  (* Back to unique, no memory of observation *)
  else None
\end{fstarcode}


\section{MALL Specifications for Method Contracts}
\label{sec:mall-specs}

\textbf{Source:} \textbf{[Girard87]} (Linear Logic), Bierhoff 2007 (Modular Typestate)

\begin{pillarbox}[title={MALL: Linear Logic for Permission Contracts}]
Multiplicative-Additive Linear Logic (\textbf{[Girard87]}) provides precise permission contracts. MALL is the fragment without Par ($\parr$) or exponentials.

\textbf{Girard's Two Conjunctions (multiplicative vs additive):}
\begin{align*}
P \tensor Q &= \text{``have both $P$ and $Q$''} \quad \text{(tensor/times) --- both consumed} \\
P \with Q &= \text{``can use as $P$ or as $Q$''} \quad \text{(with) --- choice by consumer}
\end{align*}

\textbf{Girard's Two Disjunctions:}
\begin{align*}
P \plus Q &= \text{``provides $P$ or provides $Q$''} \quad \text{(plus) --- choice by provider} \\
P \parr Q &= \text{Par (excluded from MALL)}
\end{align*}

\textbf{Linear Implication:}
\[
P \lolli Q = \text{``consume $P$ to produce $Q$''}
\]

\textbf{Effect Composition Mapping (\textbf{[Girard87]} Section 1.1.4):}
\begin{itemize}
    \item Sequential composition $(e_1; e_2)$ maps to tensor $(E_1 \tensor E_2)$
    \item Choice (if-then-else) maps to plus $(E_1 \plus E_2)$
\end{itemize}
\end{pillarbox}

The \texttt{mall\_formula} type encodes MALL (Multiplicative-Additive Linear Logic) formulas
for specifying method contracts. Each constructor corresponds to a linear logic connective:

\begin{itemize}
    \item \texttt{MAtom}: A single permission (the atomic propositions of our logic)
    \item \texttt{MTensor} ($\tensor$): ``Have both''---consumes both resources
    \item \texttt{MLolli} ($\lolli$): ``Consume to produce''---linear implication
    \item \texttt{MWith} ($\with$): ``Choose one''---internal choice by consumer
    \item \texttt{MPlus} ($\oplus$): ``Provides one''---external choice by provider
\end{itemize}

\begin{fstarcode}[title={MALL Formula Type}]
type mall_formula =
  | MAtom : perm:access_permission_v2 -> mall_formula
  | MTensor : mall_formula -> mall_formula -> mall_formula    (* P tensor Q: have both *)
  | MLolli : mall_formula -> mall_formula -> mall_formula     (* P -o Q: consume to produce *)
  | MWith : mall_formula -> mall_formula -> mall_formula      (* P & Q: choose one *)
  | MPlus : mall_formula -> mall_formula -> mall_formula      (* P + Q: provides one *)
  | MOne : mall_formula   (* Unit for tensor *)
  | MTop : mall_formula   (* Unit for with *)
  | MZero : mall_formula  (* Unit for plus *)
  | MBot : mall_formula   (* Unit for par *)
\end{fstarcode}

Method contracts specify resource protocols using MALL. A contract has:
\begin{itemize}
    \item \textbf{Precondition}: Permissions the caller must provide (these are \emph{consumed})
    \item \textbf{Postcondition}: Permissions the method returns (these are \emph{produced})
\end{itemize}
The contract itself is a linear implication: $\mathsf{pre} \lolli \mathsf{post}$.
Calling a method \emph{consumes} the precondition and \emph{produces} the postcondition---this
is the essence of substructural reasoning for APIs. The examples below show file operations
where state transitions are tracked through permission transformations.

\begin{fstarcode}[title={Method Contracts in MALL}]
type method_contract = {
  method_name : string;
  precondition : mall_formula;   (* Required permissions - CONSUMED *)
  postcondition : mall_formula;  (* Produced permissions - RETURNED *)
}

(* File.open(): unique(closed) -o unique(open) *)
let file_open_contract : method_contract = {
  method_name = "open";
  precondition = MAtom (APUnique_v2 "file" "closed" "closed");
  postcondition = MAtom (APUnique_v2 "file" "open" "open");
}

(* File.read(): can use full OR immutable - caller chooses *)
let file_read_contract : method_contract = {
  method_name = "read";
  precondition = MWith
    (MAtom (APFull_v2 "file" "open" "open"))
    (MAtom (APImmutable_v2 "file" "open" "open"));
  postcondition = MWith
    (MAtom (APFull_v2 "file" "open" "open"))
    (MAtom (APImmutable_v2 "file" "open" "open"));
}
\end{fstarcode}


\section{Vault Adoption and Focus Mechanisms}
\label{sec:vault}

\textbf{Papers:} DeLine \& Fahndrich 2001, 2002, 2004 (Vault, Fugue)

\begin{pillarbox}[title={Vault: Adoption and Focus for Aliasing Management}]
Bierhoff (Section~\ref{sec:access-permissions}) provides 5 permission kinds for typestate.
Vault \textbf{complements} this with two critical operations for aliasing:

\textbf{Adoption:} Permanently transition from unique to shared-frozen state.
\[
\mathsf{unique}(\mathsf{obj}) \xrightarrow{\mathsf{adopt}} \mathsf{pure}(\mathsf{obj}) \quad \text{[Permanent, typestate frozen]}
\]
Use case: Publishing object to shared memory, \texttt{builder.build()}

\textbf{Focus:} Temporarily upgrade shared to unique within a scope.
\[
\mathsf{pure}(\mathsf{obj}) \xrightarrow{\mathsf{focus}} \{\mathsf{unique}(\mathsf{obj})\} \xrightarrow{\mathsf{unfocus}} \mathsf{pure}(\mathsf{obj}) \quad \text{[Temporary]}
\]
Use case: Critical section, exclusive state change on shared object

\textbf{Key Difference from Rust:}
\begin{itemize}
    \item Rust borrows are \textbf{temporary} and return ownership
    \item Vault adoption is \textbf{permanent}---once adopted, never unique again
    \item Use adoption for ``publish once'' patterns (builders, caches)
    \item Use Rust-style borrowing (Section~\ref{sec:resource-algebras}) for temporary access
\end{itemize}
\end{pillarbox}

The \texttt{adopt} function below demonstrates the key operation that transitions from
unique ownership to permanent sharing. Once an object is adopted, its typestate becomes
frozen---it cannot be modified further. This is useful for ``publish once'' patterns
like builders that produce immutable results.

\begin{fstarcode}[title={Adoption Operation}]
(* Adopt operation: unique -> pure (frozen) *)
val adopt :
  perm:access_permission_v2{APUnique_v2? perm} ->
  adoption_result
let adopt (APUnique_v2 r n g) =
  (* Typestate at adoption time becomes the permanent frozen state *)
  AdoptionSuccess (APPure_v2 r n g (Some n))

(* Adoption is idempotent on already-adopted (pure) permissions *)
val adopt_idempotent :
  perm:access_permission_v2 ->
  Lemma (APPure_v2? perm ==> adopt_safe perm = perm)
\end{fstarcode}

The \texttt{focus} operation provides the inverse capability: temporarily upgrading
a shared (pure) permission back to unique within a protected scope. This requires
lock acquisition to ensure no concurrent access occurs during the focus period.
The key insight is that focus is \emph{scoped}---upon exiting the focus block,
the permission reverts to pure with the updated typestate visible to all aliases.

\begin{fstarcode}[title={Focus Operation}]
(* Enter focus: pure -> unique (temporarily) *)
val enter_focus :
  perm:access_permission_v2{APPure_v2? perm} ->
  acquired_lock:bool ->
  focus_result
let enter_focus (APPure_v2 r n g obs) acquired_lock =
  let token = {
    target_root = r; target_node = n; target_guarantee = g;
    original_mode = AMMayBeAliased;
    scope_id = fresh_scope_id ();
    requires_lock = true;  (* Concurrent access requires lock *)
  } in
  if acquired_lock || not token.requires_lock then
    FocusSuccess token (APUnique_v2 r n g)
  else
    FocusFailure "Focus requires lock acquisition for concurrent access"

(* Exit focus: unique -> pure (restore aliased state) *)
val exit_focus :
  token:focus_token ->
  current_perm:access_permission_v2{APUnique_v2? current_perm} ->
  access_permission_v2
let exit_focus token (APUnique_v2 r n g) =
  (* New typestate (n) becomes the frozen state for all aliases *)
  APPure_v2 r n g (Some n)
\end{fstarcode}


\section{Frame-Based OOP Inheritance}
\label{sec:frame-based-oop}

\textbf{Source:} DeLine \& Fahndrich 2004 (Vault, Fugue)

\begin{pillarbox}[title={Frame Typestate for Object-Oriented Inheritance}]
When typestate meets inheritance, a challenge arises: subclasses may have their own
state machines, and virtual method calls must handle all possible subclass states.

\textbf{Key Insight:} Decompose object typestate into \emph{per-class frames}.
Each class in the inheritance hierarchy maintains its own frame typestate.
Virtual calls use ``sliding'' signatures that abstract over unknown subclass frames.

\textbf{Frame Typestate Structure:}
\begin{itemize}
    \item Each class has a frame with its own state machine
    \item Object typestate = composition of all frame typestates
    \item Abstract references include a ``rest'' component for unknown subclasses
    \item Virtual dispatch slides all frames including rest
\end{itemize}
\end{pillarbox}

The following F* code defines the frame typestate structure. The \texttt{frame\_typestate}
type captures per-class state, while \texttt{object\_typestate} composes frames for
the full inheritance chain. The distinction between \texttt{OTSConcrete} and \texttt{OTSAbstract}
is critical: concrete typestates know all frames (no virtual dispatch needed), while
abstract typestates include a ``rest'' state for unknown subclass behavior.

\begin{fstarcode}[title={Frame Typestate for OOP}]
(* Per-class frame typestate *)
type frame_typestate = {
  class_name : string;
  state_name : state_node;
  fields : option (list (string * symbolic_name));  (* None = packed *)
}

(* Object typestate: collection of frame typestates *)
type object_typestate =
  | OTSConcrete : frames:list frame_typestate -> object_typestate
      (* Known concrete type - all frames specified *)
  | OTSAbstract : frames:list frame_typestate -> rest:state_node -> object_typestate
      (* Abstract reference - rest represents unknown subclass frames *)

(* Get frame for a specific class *)
val get_frame : object_typestate -> string -> option frame_typestate
let get_frame ots cls =
  let frames = match ots with
    | OTSConcrete fs -> fs
    | OTSAbstract fs _ -> fs
  in
  List.find (fun f -> f.class_name = cls) frames

(* Upcast: convert concrete to abstract (lose subclass info) *)
val upcast : object_typestate -> string -> object_typestate
let upcast ots target_class =
  match ots with
  | OTSConcrete frames ->
      let (above, below) = List.partition (fun f ->
        is_superclass_or_equal f.class_name target_class
      ) frames in
      let rest_state = match below with
        | [] -> "Unknown"
        | f :: _ -> f.state_name
      in
      OTSAbstract above rest_state
  | OTSAbstract _ _ -> ots  (* Already abstract *)
\end{fstarcode}

Virtual methods that change typestate require two signatures: an \emph{implementation signature}
(implSig) that specifies what the implementing class does, and a \emph{virtual signature}
(virtSig) that specifies behavior for all possible dynamic types. The key difference is
that virtSig changes the ``rest'' state, affecting all unknown subclass frames.

\begin{fstarcode}[title={Sliding Method Signatures}]
type method_signature = {
  method_name : string;
  declaring_class : string;
  this_pre : object_typestate;
  this_post : object_typestate;
}

(* Implementation signature: changes frames up to implementing class *)
val impl_sig : string -> string -> state_node -> state_node -> method_signature
let impl_sig decl impl pre_s post_s =
  let pre_ts = OTSAbstract
    [{ class_name = decl; state_name = pre_s; fields = None }]
    pre_s  (* rest unchanged *)
  in
  let post_ts = OTSAbstract
    [{ class_name = decl; state_name = post_s; fields = None };
     { class_name = impl; state_name = post_s; fields = None }]
    pre_s  (* rest UNCHANGED in impl sig *)
  in
  { method_name = ""; declaring_class = decl;
    this_pre = pre_ts; this_post = post_ts }

(* Virtual signature: changes all frames INCLUDING rest *)
val virt_sig : string -> state_node -> state_node -> method_signature
let virt_sig decl pre_s post_s =
  let pre_ts = OTSAbstract
    [{ class_name = decl; state_name = pre_s; fields = None }]
    pre_s
  in
  let post_ts = OTSAbstract
    [{ class_name = decl; state_name = post_s; fields = None }]
    post_s  (* rest = post_state - ALL frames change! *)
  in
  { method_name = ""; declaring_class = decl;
    this_pre = pre_ts; this_post = post_ts }
\end{fstarcode}


\subsection{API Pattern Examples with Adoption and Focus}

The following examples demonstrate how Vault's adoption and focus mechanisms
apply to common design patterns. These patterns show the practical application
of typestate and permission tracking.

\begin{fstarcode}[title={Builder Pattern with Adoption}]
(* Builder Pattern: unique -> unique -> ... -> adopt -> pure + result
   Builder starts unique, accumulates state, adopts at build(). *)

type builder_state = | BEmpty | BHasName | BHasAge | BComplete

(* Builder.new() -> unique(Empty) *)
let builder_new_post = APUnique_v2 "builder" "Empty" "alive"

(* Builder.withName() : unique(Empty) -> unique(HasName) *)
let builder_withName_contract : method_contract = {
  method_name = "withName";
  precondition = MAtom (APUnique_v2 "builder" "Empty" "alive");
  postcondition = MAtom (APUnique_v2 "builder" "HasName" "alive");
}

(* Builder.build() : unique(HasAge) -> ADOPT -> pure(Complete) + unique(Person) *)
let builder_build_contract : method_contract = {
  method_name = "build";
  precondition = MAtom (APUnique_v2 "builder" "HasAge" "alive");
  postcondition = MTensor
    (MAtom (APPure_v2 "builder" "Complete" "Complete" (Some "Complete")))
    (MAtom (APUnique_v2 "person" "Valid" "alive"));
  (* Builder is ADOPTED - frozen at Complete, cannot be reused *)
}
\end{fstarcode}

\begin{fstarcode}[title={Socket State Machine with Focus}]
(* Socket lifecycle demonstrates state transitions with focus for closing
   a shared socket. Multiple readers can share, but close requires focus. *)

type socket_state = | SRaw | SBound | SConnected | SClosed

let socket_bind_contract : method_contract = {
  method_name = "bind";
  precondition = MAtom (APUnique_v2 "socket" "Raw" "alive");
  postcondition = MAtom (APUnique_v2 "socket" "Bound" "alive");
}

(* receive() : pure(Connected) -> pure(Connected) - read-only, aliased OK *)
let socket_receive_contract : method_contract = {
  method_name = "receive";
  precondition = MAtom (APPure_v2 "socket" "Connected" "alive" None);
  postcondition = MAtom (APPure_v2 "socket" "Connected" "alive" None);
}

(* close() requires focus if socket was shared:
   focus socket with lock {    -- temporarily unique(Connected)
     socket.close();           -- unique(Closed)
   }                           -- back to pure(Closed) *)
\end{fstarcode}

\begin{pillarbox}[title={Vault-Bierhoff Permission Integration Summary}]
\textbf{Bierhoff Provides (Section~\ref{sec:access-permissions}):}
\begin{itemize}
    \item 5 permission kinds: unique, full, share, immutable, pure
    \item Permission splitting and joining
    \item State guarantees via root nodes
    \item Per-node fraction functions
\end{itemize}

\textbf{Vault Adds (This Section):}
\begin{itemize}
    \item Adoption: permanent sharing with frozen typestate
    \item Focus: temporary unique upgrade for aliased objects
    \item Frame typestate decomposition for OOP
    \item Sliding methods for virtual dispatch
\end{itemize}

\textbf{Relationship:}
\begin{center}
\begin{tabular}{lcl}
Vault NotAliased & $=$ & Bierhoff unique \\
Vault MayBeAliased & $=$ & Bierhoff pure with frozen state \\
Adoption & $:$ & unique $\to$ pure (permanent) \\
Focus & $:$ & pure $\to$ unique $\to$ pure (temporary, scoped) \\
\end{tabular}
\end{center}

\textbf{vs Rust Borrowing:}
\begin{itemize}
    \item Rust borrow: temporary, lifetime-tracked, ownership returns
    \item Vault adoption: permanent, no restoration
    \item Vault focus: temporary exclusive access with explicit lock
\end{itemize}

Use Rust-style borrowing (Section~\ref{sec:resource-algebras}) for most cases.
Use Vault adoption for ``publish once'' patterns (builders, caches).
\end{pillarbox}


\section{Rust Verification: RefinedRust and Prusti}
\label{sec:rust-verification}

\textbf{Papers:} \textbf{[Gaher24]} (RefinedRust); Astrauskas, Poli, Mueller, Summers, Leymann 2022 (Prusti)

\begin{pillarbox}[title={Rust Verification: Beyond Basic Ownership}]
The \texttt{ownership\_state} in Section~\ref{sec:fstar-ownership} tracks lifecycle (owned/borrowed/moved) but lacks:
\begin{enumerate}
    \item \textbf{Functional correctness} (\texttt{Vec::push} adds element correctly)
    \item \textbf{Place structure} (nested field access \texttt{x.f.g.h})
    \item \textbf{Unsafe code verification} (preconditions for raw pointers)
    \item \textbf{Temporal reasoning} (what holds when a borrow expires)
\end{enumerate}

\textbf{RefinedRust (Foundational, Coq-verified):}
\begin{itemize}
    \item Refinement types: $T~@~\mathit{spec}$ where spec is mathematical
    \item Place types: $\mathsf{place}(T)$, $\mathsf{blocked}_{'\!a}(T)$ for borrow tracking
    \item Unsafe verification with explicit preconditions
    \item Layout-generic (correct for any valid layout algorithm)
\end{itemize}

\textbf{Prusti (Practical, automated via Viper):}
\begin{itemize}
    \item Pledges: \texttt{assert\_on\_expiry} for reborrowing contracts
    \item Automatic core proof from type information
    \item Pure functions for specification use
    \item Type-conditional specifications (\texttt{refine\_spec})
\end{itemize}

\textbf{Selection Guidance:}
\begin{center}
\begin{tabular}{ll}
Safe Rust, simple lifetimes & $\rightarrow$ Prusti (faster, less annotation) \\
Unsafe Rust, libraries & $\rightarrow$ RefinedRust (foundational proofs) \\
Functional correctness & $\rightarrow$ Either (both support refinements) \\
Machine-checked proofs & $\rightarrow$ RefinedRust (Coq output) \\
\end{tabular}
\end{center}
\end{pillarbox}

\subsection{Place Types and Blocked Types (RefinedRust)}

RefinedRust introduces \emph{place types} to make Rust's lvalue structure first-class in the type system.
The key insight is that a ``place'' (an lvalue like \texttt{x.field.subfield}) has two components:
\begin{enumerate}
    \item The \textbf{refinement}: the mathematical/specification value for verification
    \item The \textbf{place type}: the ownership structure (owned, blocked, uninitialized, dead)
\end{enumerate}

The \texttt{PlaceBlocked} constructor is critical: when a place is borrowed, it becomes ``blocked''
until the lifetime ends. The inner type records what will be \emph{restored} when the borrow expires.
This enables precise tracking of what ownership state returns after borrowing.

\begin{fstarcode}[title={Place Types for Rust Borrow Reasoning}]
type place_type =
  | PlaceOwned : inner:rust_type -> place_type
      (* place(T) - full ownership of a place containing value of type T *)
  | PlaceBlocked : lifetime:lifetime_id -> inner:rust_type -> place_type
      (* blocked_'a(T) - place is borrowed until lifetime 'a ends
         The inner type T records what will be restored when borrow ends *)
  | PlaceUninit : size:nat -> place_type
      (* Uninitialized memory of given size in bytes *)
  | PlaceDead : place_type
      (* Place has been moved out of - cannot access *)

(* Refined type = refinement paired with place type *)
type refined_type = {
  ref_val : refinement;       (* Mathematical/specification value *)
  place_ty : place_type;      (* Ownership structure *)
}
\end{fstarcode}

\subsection{Pledge Specifications for Reborrowing (Prusti)}

Prusti introduces \emph{pledges} to handle a challenging verification problem: when a function
returns a mutable reference (reborrowing), what happens when that reference expires?
The key insight is that reborrowing creates a \emph{temporal contract}:

\begin{itemize}
    \item \textbf{Caller obligation:} ensure certain conditions hold \emph{before} the reference expires
    \item \textbf{Callee guarantee:} certain conditions will hold \emph{after} the reference expires
\end{itemize}

This is expressed via \texttt{assert\_on\_expiry} annotations that specify both the pre-expiry
constraint and the post-expiry guarantee. The pledge below demonstrates this for a BST's
\texttt{get\_root\_value} method, which returns a mutable reference to the root value.

\begin{fstarcode}[title={Pledges for Reborrowing Contracts}]
(* MOTIVATION: When a function returns a mutable reference (reborrowing),
   we need to specify:
   1. What the CALLER must ensure before the reference expires
   2. What the CALLEE guarantees after the reference expires *)

type pledge = {
  (* The reborrowed reference this pledge applies to *)
  reborrowed_ref : string;

  (* Constraint that MUST hold before expiry (caller obligation) *)
  pre_expiry_constraint : temporal_expr -> prop;

  (* Guarantee that WILL hold after expiry (callee guarantee) *)
  post_expiry_guarantee : temporal_expr -> temporal_expr -> prop;
}

(* Example: BST get_root_value specification *)
let bst_get_root_pledge : pledge = {
  reborrowed_ref = "result";
  pre_expiry_constraint = fun te ->
    (* All elements in left subtree less than result *)
    forall_in_tree (fun elem -> elem < eval_at_before_expiry te) left_subtree;
  post_expiry_guarantee = fun old_self before_result ->
    (* The root value equals what was returned *)
    match old_self with
    | Node (root_val, _, _) -> root_val = before_result
    | _ -> false;
}
\end{fstarcode}


%==================================================
\chapter{Linearizability for Concurrent Objects}
\label{ch:linearizability}
%==================================================

\textbf{Paper:} Herlihy \& Wing 1990

\begin{pillarbox}[title={What Linearizability Provides}]
The synthesis has: race detection, ownership, happens-before.
The synthesis \textbf{lacks}: concurrent data structure \emph{correctness}.

Linearizability answers: ``Does this concurrent queue behave like a queue?''
(Not just ``are there races?'' but ``is the behavior correct?'')

\textbf{Key Theorem (Locality):} $H$ is linearizable $\Longleftrightarrow$ $\forall x.\, H|_x$ is linearizable.

This enables \textbf{modular verification}---verify each object independently.
\end{pillarbox}

\begin{definition}[Linearizability]
$H$ is linearizable w.r.t.\ spec $S$ iff:
\begin{enumerate}
    \item $H$ can be extended to $H'$ (completing pending operations)
    \item $\mathsf{complete}(H')$ is equivalent to some legal sequential history $S$
    \item Precedence in $H$ is preserved in $S$
\end{enumerate}
\end{definition}

The formalization below captures concurrent execution histories as sequences of events.
Each event is either an \texttt{Invocation} (a process starting an operation) or a
\texttt{Response} (the operation completing). The \texttt{sequential} predicate checks
if a history represents serial execution (invocations immediately followed by responses),
while \texttt{precedes} captures the real-time ordering that linearizability must preserve.

\begin{fstarcode}[title={Histories and Events}]
type event =
  | Invocation : obj:string -> op:string -> args:list value -> proc:nat -> event
  | Response : obj:string -> result:value -> proc:nat -> event

type history = list event

(* A history is sequential if invocations immediately followed by responses *)
let rec sequential (h : history) : bool =
  match h with
  | [] -> true
  | Invocation _ _ _ _ :: Response _ _ _ :: rest -> sequential rest
  | _ -> false

(* Precedence: response r precedes invocation i if r appears before i *)
let precedes (e1 e2 : event) (h : history) : bool =
  match e1, e2 with
  | Response _ _ _, Invocation _ _ _ _ -> index_of e1 h < index_of e2 h
  | _ -> false
\end{fstarcode}

\begin{pillarbox}[title={Why Set Abstraction for Concurrent Objects}]
\textbf{Sequential Objects:} $\alpha : \mathsf{rep} \to \mathsf{abs}$ (Single abstract value)

\textbf{Concurrent Objects:} $\alpha : \mathsf{rep} \to \mathcal{P}(\mathsf{abs})$ (Set of abstract values)

\textbf{Why a set?}
Concurrent execution introduces nondeterminism. Multiple threads may interleave operations, and multiple linearizations of the same history may all be valid. Each linearization produces a (potentially different) abstract state.

\textbf{Example:} Concurrent queue with \texttt{enqueue(1)}, \texttt{enqueue(2)} overlapping:
\begin{itemize}
    \item Linearization 1: \texttt{enqueue(1)} then \texttt{enqueue(2)} $\rightarrow$ $[1, 2]$
    \item Linearization 2: \texttt{enqueue(2)} then \texttt{enqueue(1)} $\rightarrow$ $[2, 1]$
    \item $\alpha(\mathsf{rep}) = \{[1,2], [2,1]\}$ --- both are valid abstract states
\end{itemize}
\end{pillarbox}


\section{Progress Properties for Concurrent Objects}
\label{sec:progress-properties}

\textbf{Source:} Herlihy \& Shavit 2008 --- ``The Art of Multiprocessor Programming''

Linearizability is a \emph{safety} property (``nothing bad happens'').
Progress properties ensure \emph{liveness} (``something good eventually happens'').

\begin{definition}[Progress Guarantees (Hierarchy from strongest to weakest)]
\begin{description}
    \item[Wait-Free:] Every operation completes in bounded steps, regardless of other threads. No thread can be starved.
    \item[Lock-Free:] System-wide progress: some operation completes in finite time. Individual threads may starve, but system as a whole progresses.
    \item[Obstruction-Free:] Progress guaranteed if thread runs in isolation (no contention). May livelock under contention.
    \item[Blocking:] May use locks; susceptible to deadlock, priority inversion, and indefinite blocking if lock holder fails.
\end{description}
\end{definition}

\begin{fstarcode}[title={Progress Guarantee Types}]
type progress_guarantee =
  | WaitFree : bound:nat -> progress_guarantee
  | LockFree : progress_guarantee
  | ObstructionFree : progress_guarantee
  | Blocking : progress_guarantee

(* Well-known classifications *)
let michael_scott_queue : progress_guarantee = LockFree
let harris_linked_list : progress_guarantee = LockFree
let herlihy_snapshot : progress_guarantee = WaitFree 2  (* 2-scan algorithm *)
let treiber_stack : progress_guarantee = LockFree
let mutex_protected : progress_guarantee = Blocking
\end{fstarcode}


\section{Temporal Logic for Liveness}
\label{sec:temporal-logic}

\textbf{Source:} Pnueli 1977 --- ``The Temporal Logic of Programs''

\begin{pillarbox}[title={Temporal Logic for Program Verification}]
Progress properties describe \emph{what} guarantees a concurrent object provides.
Temporal logic provides the formal \emph{language} to specify and verify these properties.

\textbf{Key Insight (Pnueli):} Program properties split into two classes:
\begin{itemize}
    \item \textbf{Safety:} ``Nothing bad ever happens'' (invariance)
    \item \textbf{Liveness:} ``Something good eventually happens'' (eventuality)
\end{itemize}

The temporal operators $\Box$ (always) and $\Diamond$ (eventually) provide:
\begin{itemize}
    \item Precise specification of concurrent behavior
    \item Proof principles for verification (P1 for safety, P2 for liveness)
    \item Foundation for fairness assumptions in concurrent systems
\end{itemize}
\end{pillarbox}

\begin{fstarcode}[title={Temporal Operators}]
type temporal_formula =
  (* State formula lifted to path *)
  | TFState : state_formula -> temporal_formula

  (* Next: holds in the next state *)
  | TFNext : temporal_formula -> temporal_formula           (* X phi *)

  (* Globally/Always: holds in all future states *)
  | TFAlways : temporal_formula -> temporal_formula         (* G phi or Box phi *)

  (* Finally/Eventually: holds in some future state *)
  | TFEventually : temporal_formula -> temporal_formula     (* F phi or Diamond phi *)

  (* Until: phi holds until psi becomes true *)
  | TFUntil : temporal_formula -> temporal_formula -> temporal_formula  (* phi U psi *)

  (* Leads-to: if phi holds, psi eventually holds *)
  | TFLeadsTo : temporal_formula -> temporal_formula -> temporal_formula  (* phi ~> psi *)
\end{fstarcode}

\begin{theorem}[Invariance Principle (P1) --- Pnueli 1977]
To prove $\Box P$ ($P$ always holds):
\begin{enumerate}
    \item Show $P$ holds initially
    \item Show every transition preserves $P$
\end{enumerate}
This is the foundation for verifying \textbf{safety} properties.
\end{theorem}

\begin{theorem}[Eventuality Principle (P2) --- Pnueli 1977]
To prove $P \leadsto Q$ (if $P$ holds, $Q$ eventually holds):
Find a ranking function $r : \mathsf{state} \to \mathbb{N}$ such that:
\begin{itemize}
    \item $r$ decreases on each step while $Q$ does not hold
    \item When $r$ reaches 0, $Q$ must hold
\end{itemize}
This is the foundation for verifying \textbf{liveness} properties.
\end{theorem}


\section{CTL Model Checking}
\label{sec:ctl}

\textbf{Source:} Clarke, Emerson, Sistla 1986 --- ``Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic''

\begin{pillarbox}[title={CTL Model Checking: Branching-Time Temporal Logic}]
Pnueli's LTL (Section~\ref{sec:temporal-logic}) uses \textbf{linear time}---formulas describe properties of single execution paths. CTL uses \textbf{branching time}---formulas can distinguish between ``all paths'' and ``some path''.

\textbf{Key Distinction:}
\begin{itemize}
    \item LTL: $\Box(\mathit{request} \Rightarrow \Diamond \mathit{response})$ --- on this path, responses follow requests
    \item CTL: $\mathsf{AG}(\mathit{request} \Rightarrow \mathsf{AF}\ \mathit{response})$ --- on all paths from all states
    \item CTL: $\mathsf{AG}(\mathit{request} \Rightarrow \mathsf{EF}\ \mathit{response})$ --- on some path from all states
\end{itemize}

\textbf{Why CTL Matters for Security:}
\begin{itemize}
    \item Use-after-free: $\mathsf{AG}(\mathit{freed}(p) \Rightarrow \mathsf{AX}\ \mathsf{AG}(\neg \mathit{deref}(p)))$
    \item Resource leak: $\mathsf{AG}(\mathit{acquire}(r) \Rightarrow \mathsf{AF}\ \mathit{release}(r))$
    \item Deadlock-free: $\mathsf{AG}(\mathsf{EF}\ \mathit{progress})$
\end{itemize}

\textbf{Complexity:} $O(|f| \cdot (|S| + |R|))$ --- \textbf{linear} in formula and state graph.
This is much better than LTL model checking (PSPACE-complete)!
\end{pillarbox}

\begin{fstarcode}[title={CTL Formula Type}]
type ctl_formula =
  | CTLAtom : pred:(node_id -> bool) -> ctl_formula
  | CTLNot : ctl_formula -> ctl_formula
  | CTLAnd : ctl_formula -> ctl_formula -> ctl_formula

  (* Path quantifier + Next *)
  | CTLAX : ctl_formula -> ctl_formula  (* On ALL paths, phi holds NEXT *)
  | CTLEX : ctl_formula -> ctl_formula  (* On SOME path, phi holds NEXT *)

  (* Path quantifier + Until *)
  | CTLAU : ctl_formula -> ctl_formula -> ctl_formula  (* A[phi U psi] *)
  | CTLEU : ctl_formula -> ctl_formula -> ctl_formula  (* E[phi U psi] *)

(* Derived operators *)
let ctl_af phi = CTLAU ctl_true phi        (* AF: inevitable *)
let ctl_ef phi = CTLEU ctl_true phi        (* EF: reachable *)
let ctl_ag phi = CTLNot (ctl_ef (CTLNot phi))  (* AG: invariant *)
let ctl_eg phi = CTLNot (ctl_af (CTLNot phi))  (* EG: persistent *)
\end{fstarcode}

\begin{fstarcode}[title={Security Properties as CTL Formulas}]
(* Use-after-free prevention:
   AG(freed(p) -> AX AG(not deref(p))) *)
val use_after_free_safe : (node_id -> bool) -> (node_id -> bool) -> ctl_formula
let use_after_free_safe is_free is_deref =
  let freed = CTLAtom is_free in
  let deref = CTLAtom is_deref in
  ctl_ag (CTLImplies freed (CTLAX (ctl_ag (CTLNot deref))))

(* Resource leak detection:
   AG(acquire(r) -> AF release(r)) *)
val resource_must_release : (node_id -> bool) -> (node_id -> bool) -> ctl_formula
let resource_must_release is_acquire is_release =
  let acquired = CTLAtom is_acquire in
  let released = CTLAtom is_release in
  ctl_ag (CTLImplies acquired (ctl_af released))

(* Deadlock freedom:
   AG(EF progress) *)
val deadlock_free : (node_id -> bool) -> ctl_formula
let deadlock_free is_progress =
  ctl_ag (ctl_ef (CTLAtom is_progress))
\end{fstarcode}


%==================================================
\chapter{Frame Rule and Footprint Computation}
\label{ch:frame-rule}
%==================================================

\textbf{Source:} \textbf{[Reynolds02]} --- ``Separation Logic: A Logic for Shared Mutable Data Structures''

\section{The Frame Rule}
\label{sec:frame-rule}

\begin{theorem}[Frame Rule --- The Most Important Theorem for Compositional Analysis]
\[
\frac{\{P\}\; C\; \{Q\}}{\{P * R\}\; C\; \{Q * R\}}
\]

\textbf{Provided:}
\begin{itemize}
    \item $R$ shares no modified variables with $C$
    \item $R$ does not mention locations freed by $C$
\end{itemize}

\textbf{Meaning:}
If $C$ is correct with precondition $P$ and postcondition $Q$,
then $C$ is \textbf{also} correct when extra resources $R$ exist.

\textbf{Why This Matters:}
\begin{itemize}
    \item Analyze functions in \textbf{isolation}
    \item Caller's resources automatically preserved
    \item Enables true \textbf{compositional} verification
\end{itemize}
\end{theorem}


\section{Footprint Computation}
\label{sec:footprint}

\begin{fstarcode}[title={Memory Footprint Definition}]
type footprint = {
  reads : set loc;      (* Locations read *)
  writes : set loc;     (* Locations written *)
  allocates : set loc;  (* Locations allocated *)
  frees : set loc;      (* Locations freed *)
}

val compute_footprint : ir_stmt -> footprint
let rec compute_footprint stmt = match stmt with
  | SRead dst ptr ->
      { empty_footprint with reads = singleton (resolve_loc ptr) }
  | SWrite ptr val_ ->
      { empty_footprint with writes = singleton (resolve_loc ptr) }
  | SAlloc dst size ->
      { empty_footprint with allocates = fresh_abstract_loc () }
  | SFree ptr ->
      { empty_footprint with frees = singleton (resolve_loc ptr) }
  | SSeq s1 s2 ->
      merge_footprint (compute_footprint s1) (compute_footprint s2)
  | SIf cond s1 s2 ->
      merge_footprint (compute_footprint s1) (compute_footprint s2)
  | SWhile cond body ->
      compute_footprint body
  | SCall dst func args ->
      lookup_footprint_summary func
  | SPure _ -> empty_footprint
\end{fstarcode}


\section{Compositional Analysis Algorithm}
\label{sec:compositional-algorithm}

\textbf{Algorithm: Analyze function with frame rule}
\begin{enumerate}
    \item \textbf{Compute Footprint:} $\mathsf{footprint}(f) = \bigcup \{ \mathsf{footprint}(\mathit{stmt}) \mid \mathit{stmt} \in f.\mathit{body} \}$
    \item \textbf{Generate Specification:}
    \begin{itemize}
        \item Pre: resources needed by footprint
        \item Post: resources produced/modified
    \end{itemize}
    \item \textbf{At Call Sites:}
    \begin{itemize}
        \item Caller has resources: $P_{\mathit{caller}}$
        \item Callee needs: $P_{\mathit{callee}}$ (from spec)
        \item Frame: $R = P_{\mathit{caller}} - P_{\mathit{callee}}$ (what's left over)
        \item Apply frame rule: $\{P_{\mathit{callee}} * R\}\; \mathit{call}\; \{Q_{\mathit{callee}} * R\}$
    \end{itemize}
    \item \textbf{Verify Disjointness:}
    \begin{itemize}
        \item Callee footprint $\cap$ $R = \emptyset$
        \item No aliasing between callee access and frame
    \end{itemize}
\end{enumerate}

\textbf{Benefit:} Analyze callee \textbf{once}, reuse at all call sites!


\section{Magic Wands for Partial Data Structures}
\label{sec:magic-wands}

\textbf{Source:} Muller et al.\ 2016 (Viper), \textbf{[Reynolds02]}

\begin{definition}[Magic Wand (Separating Implication)]
Magic wand $A \wand B$ means: ``providing $A$ yields $B$''

\textbf{Semantics:} $(A \wand B)$ holds in state $s$ if:
\[
\forall s'.\, s' \text{ disjoint from } s \implies A \text{ holds in } s' \implies B \text{ holds in } (s * s')
\]

\textbf{Use Cases:}
\begin{itemize}
    \item Partial data structure traversal: $\mathsf{lseg}(\mathit{ptr}, \mathit{null}) \wand \mathsf{lseg}(\mathit{hd}, \mathit{null})$
    \item Reborrowing specifications (Prusti)
    \item Modular verification of iterative algorithms
\end{itemize}
\end{definition}

\textbf{Viper Syntax:}
\begin{verbatim}
  acc(lseg(ptr, null)) --* acc(lseg(hd, null))

Operations:
  package (A --* B)   -- Create wand
  apply (A --* B)     -- Use wand: exchange A for B
\end{verbatim}

\textbf{Complexity Warning:}
Full magic wand reasoning is PSPACE-complete (Reynolds).
Use for \emph{specification} only. Prefer frame rule for implementation.


\section{Quantified Permissions for Arrays}
\label{sec:quantified-permissions}

\textbf{Source:} Muller et al.\ 2016 (Viper)

\begin{fstarcode}[title={Quantified Permissions}]
(* Enables pointwise permission specification for arrays and graphs:
   forall i: Int :: 0 <= i && i < len ==> acc(loc(arr, i).val) *)

type quantified_permission = {
  index_var : string;
  index_type : ir_type;
  range_constraint : ir_expr;      (* e.g., 0 <= i && i < len *)
  permission_body : sl_assertion;  (* e.g., acc(loc(arr, i).val) *)
}

(* Array permission: all elements accessible *)
val array_perm : arr:var_id -> len:nat -> quantified_permission
let array_perm arr len = {
  index_var = "i";
  index_type = TInt;
  range_constraint = EBinOp OpAnd
    (EBinOp OpLeq (EInt 0) (EVar "i"))
    (EBinOp OpLt (EVar "i") (EInt len));
  permission_body = SLPointsTo (EArrayAccess (EVar arr) (EVar "i")) PermFull;
}
\end{fstarcode}

\textbf{Advantages over Recursive Predicates:}
\begin{itemize}
    \item Direct random access (no fold/unfold chains)
    \item Works for cyclic structures
    \item Efficient SMT encoding
\end{itemize}


\section{Automated Proof Search for Separation Logic}
\label{sec:diaframe}

\textbf{Source:} Mulder et al.\ 2022 (Diaframe), Calcagno et al.\ 2009 (Bi-Abduction)

\begin{pillarbox}[title={Diaframe: Goal-Directed Separation Logic Proof Search}]
\textbf{Key Insight:} Treat separation logic connectives as proof search instructions.
Inspired by linear logic programming (Hodas \& Miller).

\textbf{Automation Strategy:}
\begin{enumerate}
    \item Interpret connectives as search instructions:
    \begin{itemize}
        \item $*$ (star) $\rightarrow$ ISplit: split goal into two
        \item $\wand$ (wand) $\rightarrow$ IIntro: introduce hypothesis
        \item $\exists x$ $\rightarrow$ IExists: postpone instantiation
        \item $\pvs$ (update) $\rightarrow$ IUpdate: perform ghost state update
    \end{itemize}
    \item Use bi-abduction for resource matching
    \item Apply domain-specific hints when stuck
\end{enumerate}

\textbf{Diaframe Achieves:}
\begin{itemize}
    \item Foundational soundness (proofs checked by Coq kernel)
    \item Practical automation (10x less manual proof than raw Iris)
    \item Extensibility via user-defined hints
\end{itemize}
\end{pillarbox}


%==================================================
\chapter{Representation Predicates}
\label{ch:representation-predicates}
%==================================================

\textbf{Source:} VeriFFI (Wang et al.\ 2025) --- ``A Verified Foreign Function Interface between Coq and C''

\begin{pillarbox}[title={Representation Predicates --- VeriFFI}]
Representation predicates connect \textbf{high-level types} to \textbf{low-level memory}.
This is critical for:
\begin{itemize}
    \item FFI boundary verification
    \item Data structure correctness
    \item Garbage collection safety
\end{itemize}

\textbf{Key Insight:} Without representation predicates, we cannot prove that foreign function calls preserve type invariants across language boundaries.
\end{pillarbox}

\begin{definition}[Representation Predicate (InGraph)]
$\mathsf{InGraph}(g, x, p, t)$ means:
\begin{itemize}
    \item $x$ is a value of type $t$
    \item $p$ points to $x$'s representation in memory graph $g$
    \item The representation is \textbf{valid} according to $t$'s layout
\end{itemize}
\end{definition}

\begin{fstarcode}[title={Representation Predicate Type Class}]
class rep_predicate (t : Type) = {
  (* The predicate itself: graph -> value -> address -> proposition *)
  in_graph : memory_graph -> t -> address -> bool;

  (* MONOTONICITY: Adding nodes doesn't invalidate existing predicates.
     Critical for GC correctness. *)
  monotone : squash (forall g g' x p.
    extends g g' ->
    in_graph g x p ->
    in_graph g' x p);

  (* INJECTIVITY: Same address, same type => same value.
     A representation is deterministic. *)
  injective : squash (forall g x y p.
    in_graph g x p ->
    in_graph g y p ->
    x == y);
}
\end{fstarcode}

\begin{theorem}[GC Preservation (VeriFFI Lemma 3.2)]
Representation predicates are preserved under GC isomorphism.
If $x$ is represented at $p$ in $\mathit{old\_graph}$, and GC maps $p$ to $p'$,
then $x$ is represented at $p'$ in $\mathit{new\_graph}$.
\end{theorem}


%==================================================
\chapter{GC-Aware Ownership Analysis}
\label{ch:gc-aware}
%==================================================

\textbf{Papers:} VeriFFI (Wang et al.\ 2025), RustBelt (\textbf{[Jung18]})

\begin{pillarbox}[title={GC-Isomorphism --- VeriFFI}]
For languages with garbage collection (Java, Python, Go, OCaml), ownership analysis must account for:
\begin{itemize}
    \item GC can \textbf{move} objects (address changes)
    \item GC can \textbf{collect} unreachable objects (lifetime shorter than scope)
    \item GC provides \textbf{implicit} memory safety
\end{itemize}

The key property: \textbf{representation preserved under GC}.
\end{pillarbox}

\section{GC-Isomorphism Definition}

\begin{fstarcode}[title={GC State and Isomorphism}]
type gc_state = {
  heap : memory_graph;
  roots : set address;
  generation : nat;  (* GC generation/epoch *)
}

type gc_isomorphism = {
  source : gc_state;
  target : gc_state;
  address_map : map address address;  (* Old addr -> new addr *)
}

(* Validity: bijection on reachable, preserves structure and values *)
val is_valid_gc_iso : gc_isomorphism -> bool
let is_valid_gc_iso iso =
  is_bijection iso.address_map (reachable iso.source) (reachable iso.target) &&
  (* Preserves pointer structure *)
  (forall a b. points_to iso.source.heap a b ==>
               points_to iso.target.heap (Map.find a iso.address_map)
                                         (Map.find b iso.address_map)) &&
  (* Preserves values *)
  (forall a. iso.source.heap.values a =
             iso.target.heap.values (Map.find a iso.address_map))
\end{fstarcode}


\section{Ownership in GC Languages}

\begin{fstarcode}[title={GC-Aware Ownership States}]
(* For GC languages, we DON'T track deallocation (GC handles it).
   Instead, we track reachability, mutation, and finalization. *)

type gc_ownership_state =
  | GCRooted           (* Definitely reachable from a GC root *)
  | GCReachable        (* Reachable from some rooted object *)
  | GCMaybeCollected   (* May have been collected *)
  | GCFinalized        (* Finalizer has run - object is "dead" *)
\end{fstarcode}


\section{GC at Language Boundaries}

\begin{fstarcode}[title={GC Requirements at FFI Boundaries}]
(* CRITICAL: When GC and non-GC languages interact via FFI,
   we must ensure GC doesn't collect objects still referenced
   by the non-GC side. *)

type boundary_gc_requirement =
  | PinDuringCall       (* Object must not move during FFI call *)
  | RegisterAsRoot      (* Register pointer as GC root *)
  | CopyOut             (* Copy data out of GC heap *)
  | Opaque              (* Non-GC side cannot access GC heap *)

val determine_gc_requirement :
  source_lang : language_id{has_gc source_lang} ->
  target_lang : language_id ->
  value_type : ir_type ->
  boundary_gc_requirement
let determine_gc_requirement src tgt ty =
  if has_gc tgt then
    if same_gc_runtime src tgt then Opaque
    else RegisterAsRoot
  else
    if is_primitive ty then CopyOut
    else if is_small_struct ty then CopyOut
    else PinDuringCall
\end{fstarcode}


%==================================================
\chapter{WebAssembly Memory Safety Analysis}
\label{ch:wasm}
%==================================================

\textbf{Papers:} MS-Wasm (Disselkoen et al.\ 2019), WASM Security Survey (Perrone \& Romano 2024)

\begin{pillarbox}[title={WebAssembly Memory Model and Safety Extensions}]
WebAssembly provides \textbf{isolation} from host (sandbox) but \textbf{not} memory safety \emph{within} the sandbox. C/C++ vulnerabilities carry over when compiled to Wasm.

\textbf{MS-Wasm} extends Wasm with explicit memory safety semantics:
\begin{itemize}
    \item \textbf{Segments:} bounded memory regions with lifetime tracking
    \item \textbf{Handles:} typed pointers that encapsulate bounds information
    \item \textbf{Progressive enforcement:} backends choose safety/performance tradeoff
\end{itemize}

\textbf{Key insight:} Capture C/C++ pointer semantics at \emph{compile time} so backends can leverage \emph{hardware features} (ARM MTE, PAC, CHERI) at runtime.
\end{pillarbox}


\section{WebAssembly Linear Memory Model}

WebAssembly uses \textbf{linear memory}: a contiguous, mutable array of raw bytes.
\begin{itemize}
    \item Loads and stores operate on untyped byte addresses (i32)
    \item No bounds metadata preserved from source language
    \item Stack-smashing mitigated (separate stack), but in-sandbox exploits remain
\end{itemize}

\textbf{Attack primitives that still work in WebAssembly:}
\begin{itemize}
    \item Stack-based buffer overflow (into Wasm's linear memory stack area)
    \item Heap metadata corruption
    \item Overwriting ``constant'' data in linear memory
    \item Redirecting indirect calls via corrupted function table indices
\end{itemize}


\section{MS-Wasm Segment Memory Model}

\begin{fstarcode}[title={MS-Wasm Handle}]
(* HANDLE: A typed pointer with bounds information
   4-tuple: (base, offset, bound, isCorrupted) *)

type ms_wasm_handle = {
  base : address;       (* Start of segment in segment memory *)
  offset : int;         (* Current offset within segment *)
  bound : nat;          (* Size of accessible region *)
  is_corrupted : bool;  (* Set if handle integrity violated *)
}

(* Spatial safety check *)
val is_spatially_safe : ms_wasm_handle -> bool
let is_spatially_safe h =
  not (h = handle_null) &&
  h.offset >= 0 &&
  h.offset < h.bound &&
  not h.is_corrupted

(* Handle slicing for intra-object safety *)
val segment_slice :
  parent:ms_wasm_handle ->
  new_base:nat ->
  new_bound:nat{new_base + new_bound <= parent.bound} ->
  ms_wasm_handle
let segment_slice parent new_base new_bound =
  { base = parent.base + new_base;
    offset = 0;
    bound = new_bound;
    is_corrupted = parent.is_corrupted }
\end{fstarcode}


\section{MS-Wasm Memory Safety Properties}

\textbf{Three Memory Safety Properties} (de Amorim et al.\ 2017):
\begin{enumerate}
    \item \textbf{Spatial Safety:} no out-of-bounds reads/writes
    \item \textbf{Temporal Safety:} no use-after-free
    \item \textbf{Pointer Integrity:} no pointer forgery or corruption
\end{enumerate}


\section{Hardware-Accelerated Memory Safety}

\begin{fstarcode}[title={Hardware Mechanisms for MS-Wasm Backends}]
type hw_memory_safety_mechanism =
  | HWSoftwareOnly        (* Pure software checks, ~2x overhead *)
  | HWMemoryTagging       (* ARM MTE, ~0% overhead, probabilistic *)
  | HWPointerAuth         (* ARM PAC, ~20% overhead for all pointers *)
  | HWCapabilities        (* CHERI, <5% overhead, full spatial safety *)

type safety_enforcement_level =
  | EnforceFull           (* All three properties enforced *)
  | EnforceSpatialOnly    (* Bounds checking only *)
  | EnforceProbabilistic  (* MTE-style detection *)
  | EnforceNone           (* Performance mode, equivalent to plain Wasm *)
\end{fstarcode}


\section{WebAssembly Analysis Landscape (2024 Survey)}

\textbf{Source:} Perrone \& Romano 2024 (121 papers surveyed)

\textbf{Analysis Categories:}
\begin{itemize}
    \item \textbf{Static Analysis:} CFG analysis, context-sensitive data flow, CPG, symbolic semantic graphs
    \item \textbf{Dynamic Analysis:} Fuzzing, symbolic execution (EUNOMIA), concolic execution (SWAM), runtime instrumentation (Wasabi)
\end{itemize}

\textbf{Vulnerability Types Detected:}
\begin{itemize}
    \item Smart Contracts: Fake transfer, reentrancy, rollback, missing auth
    \item Memory Safety: Buffer overflow, UAF, double-free, format string
    \item Side Channels: Cache timing, port contention, transient execution
\end{itemize}

\textbf{Security Enhancements:}
\begin{itemize}
    \item CT-Wasm (Watt 2019): Type-driven constant-time for crypto
    \item MS-Wasm (Michael 2023): Memory safety via segment memory
    \item Formal verification: WasmCert-Isabelle, WasmCert-Coq
    \item Software Fault Isolation (SFI): VeriWasm verifier
\end{itemize}


\section{Integration with Brrr-Machine Analysis}

\textbf{Integration Points:}
\begin{enumerate}
    \item \textbf{Part V (Pointer Analysis):}
    \begin{itemize}
        \item Wasm linear memory as single abstract object
        \item Function table indices as pointer-like values
        \item MS-Wasm handles map directly to ownership analysis
    \end{itemize}

    \item \textbf{Part VIII (Security Analysis):}
    \begin{itemize}
        \item Taint analysis for Wasm imports (JS inputs are taint sources)
        \item XSS/injection via Wasm-to-JS string passing
        \item Cryptojacking detection (characteristic Wasm patterns)
    \end{itemize}

    \item \textbf{Section~\ref{ch:gc-aware} (GC-Aware Analysis):}
    \begin{itemize}
        \item JS-Wasm boundary: JS side is GC'd, Wasm side is manual
        \item ArrayBuffer references must survive GC cycles
        \item Similar to VeriFFI constraints
    \end{itemize}

    \item \textbf{Part IX (Multi-Language):}
    \begin{itemize}
        \item Wasm-JS boundary follows Matthews-Findler semantics
        \item Type coercions at boundary (JS dynamic $\to$ Wasm static)
        \item Gradual typing applicable to Wasm-JS interface
    \end{itemize}
\end{enumerate}

\textbf{Cross-References:}
\begin{itemize}
    \item See Section~\ref{ch:gc-aware} for GC-aware ownership when Wasm interoperates with JS/Python
    \item See Part VIII for taint analysis applicable to Wasm imports
    \item See Part IX for boundary semantics (JS-Wasm follows Matthews-Findler)
\end{itemize}
